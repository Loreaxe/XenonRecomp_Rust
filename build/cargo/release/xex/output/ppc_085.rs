pub fn sub_828A2098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2098 size=512
    let mut pc: u32 = 0x828A2098;
    'dispatch: loop {
        match pc {
            0x828A2098 => {
    //   block [0x828A2098..0x828A2298)
	// 828A2098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A209C: 48407361  bl 0x82ca93fc
	ctx.lr = 0x828A20A0;
	sub_82CA93D0(ctx, base);
	// 828A20A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A20A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A20A8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A20AC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A20B0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828A20B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A20B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A20BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828A20C0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A20C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A20C8: 419A0008  beq cr6, 0x828a20d0
	if ctx.cr[6].eq {
	pc = 0x828A20D0; continue 'dispatch;
	}
	// 828A20CC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A20D0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A20D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A20D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A20DC: 4BB2C4E5  bl 0x823ce5c0
	ctx.lr = 0x828A20E0;
	sub_823CE5C0(ctx, base);
	// 828A20E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A20E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A20E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A20EC: 4BB2C025  bl 0x823ce110
	ctx.lr = 0x828A20F0;
	sub_823CE110(ctx, base);
	// 828A20F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A20F4: 4B915A25  bl 0x821b7b18
	ctx.lr = 0x828A20F8;
	sub_821B7B18(ctx, base);
	// 828A20F8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A20FC: 4B97D15D  bl 0x8221f258
	ctx.lr = 0x828A2100;
	sub_8221F258(ctx, base);
	// 828A2100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2104: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A2108: 419A005C  beq cr6, 0x828a2164
	if ctx.cr[6].eq {
	pc = 0x828A2164; continue 'dispatch;
	}
	// 828A210C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A2110: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A2114: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2118: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A211C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A2120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2124: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A2128: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A212C: 4B94E115  bl 0x821f0240
	ctx.lr = 0x828A2130;
	sub_821F0240(ctx, base);
	// 828A2130: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A2134: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A2138: 4B97D121  bl 0x8221f258
	ctx.lr = 0x828A213C;
	sub_8221F258(ctx, base);
	// 828A213C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2140: 419A0028  beq cr6, 0x828a2168
	if ctx.cr[6].eq {
	pc = 0x828A2168; continue 'dispatch;
	}
	// 828A2144: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A2148: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A214C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2150: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A2154: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A2158: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A215C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A2160: 4800000C  b 0x828a216c
	pc = 0x828A216C; continue 'dispatch;
	// 828A2164: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A2168: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A216C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2170: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A2174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2178: 419A0008  beq cr6, 0x828a2180
	if ctx.cr[6].eq {
	pc = 0x828A2180; continue 'dispatch;
	}
	// 828A217C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2180: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A2184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2188: 419A0078  beq cr6, 0x828a2200
	if ctx.cr[6].eq {
	pc = 0x828A2200; continue 'dispatch;
	}
	// 828A218C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2190: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A2194: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2198: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A219C: 4B986F6D  bl 0x82229108
	ctx.lr = 0x828A21A0;
	sub_82229108(ctx, base);
	// 828A21A0: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A21A4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A21A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A21AC: 3BCB28E8  addi r30, r11, 0x28e8
	ctx.r[30].s64 = ctx.r[11].s64 + 10472;
	// 828A21B0: 4B9856D1  bl 0x82227880
	ctx.lr = 0x828A21B4;
	sub_82227880(ctx, base);
	// 828A21B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A21B8: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 828A21BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A21C0: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 828A21C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A21C8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A21CC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A21D0: 4B8F88B1  bl 0x8219aa80
	ctx.lr = 0x828A21D4;
	sub_8219AA80(ctx, base);
	// 828A21D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A21D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A21DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A21E0: 4BB2C241  bl 0x823ce420
	ctx.lr = 0x828A21E4;
	sub_823CE420(ctx, base);
	// 828A21E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A21E8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A21EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A21F0: 481824D9  bl 0x82a246c8
	ctx.lr = 0x828A21F4;
	sub_82A246C8(ctx, base);
	// 828A21F4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A21F8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A21FC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A2200: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A2204: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2208: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A220C: 419A0020  beq cr6, 0x828a222c
	if ctx.cr[6].eq {
	pc = 0x828A222C; continue 'dispatch;
	}
	// 828A2210: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2218: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A221C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A2220: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2224: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2228: 4082FFE8  bne 0x828a2210
	if !ctx.cr[0].eq {
	pc = 0x828A2210; continue 'dispatch;
	}
	// 828A222C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2234: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A2238: 4BA53711  bl 0x822f5948
	ctx.lr = 0x828A223C;
	sub_822F5948(ctx, base);
	// 828A223C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2240: 4B9158D9  bl 0x821b7b18
	ctx.lr = 0x828A2244;
	sub_821B7B18(ctx, base);
	// 828A2244: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2248: 419A0040  beq cr6, 0x828a2288
	if ctx.cr[6].eq {
	pc = 0x828A2288; continue 'dispatch;
	}
	// 828A224C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2250: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2254: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2258: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A225C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2260: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2264: 4082FFE8  bne 0x828a224c
	if !ctx.cr[0].eq {
	pc = 0x828A224C; continue 'dispatch;
	}
	// 828A2268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A226C: 409A001C  bne cr6, 0x828a2288
	if !ctx.cr[6].eq {
	pc = 0x828A2288; continue 'dispatch;
	}
	// 828A2270: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2274: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A227C: 4E800421  bctrl
	ctx.lr = 0x828A2280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2280: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A2284: 4B979AB5  bl 0x8221bd38
	ctx.lr = 0x828A2288;
	sub_8221BD38(ctx, base);
	// 828A2288: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A228C: 4B91588D  bl 0x821b7b18
	ctx.lr = 0x828A2290;
	sub_821B7B18(ctx, base);
	// 828A2290: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A2294: 484071B8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2298 size=516
    let mut pc: u32 = 0x828A2298;
    'dispatch: loop {
        match pc {
            0x828A2298 => {
    //   block [0x828A2298..0x828A249C)
	// 828A2298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A229C: 48407161  bl 0x82ca93fc
	ctx.lr = 0x828A22A0;
	sub_82CA93D0(ctx, base);
	// 828A22A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A22A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A22A8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A22AC: 3D408217  lis r10, -0x7de9
	ctx.r[10].s64 = -2112421888;
	// 828A22B0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828A22B4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A22B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A22BC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A22C0: 3BAA2680  addi r29, r10, 0x2680
	ctx.r[29].s64 = ctx.r[10].s64 + 9856;
	// 828A22C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A22C8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A22CC: 419A0008  beq cr6, 0x828a22d4
	if ctx.cr[6].eq {
	pc = 0x828A22D4; continue 'dispatch;
	}
	// 828A22D0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A22D4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A22D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A22DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A22E0: 4BB2C2E1  bl 0x823ce5c0
	ctx.lr = 0x828A22E4;
	sub_823CE5C0(ctx, base);
	// 828A22E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A22E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A22EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A22F0: 4BB2BE21  bl 0x823ce110
	ctx.lr = 0x828A22F4;
	sub_823CE110(ctx, base);
	// 828A22F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A22F8: 4B915821  bl 0x821b7b18
	ctx.lr = 0x828A22FC;
	sub_821B7B18(ctx, base);
	// 828A22FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A2300: 4B97CF59  bl 0x8221f258
	ctx.lr = 0x828A2304;
	sub_8221F258(ctx, base);
	// 828A2304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2308: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A230C: 419A005C  beq cr6, 0x828a2368
	if ctx.cr[6].eq {
	pc = 0x828A2368; continue 'dispatch;
	}
	// 828A2310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A2314: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A2318: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A231C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A2320: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A2324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2328: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A232C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A2330: 4B94DF11  bl 0x821f0240
	ctx.lr = 0x828A2334;
	sub_821F0240(ctx, base);
	// 828A2334: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A2338: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A233C: 4B97CF1D  bl 0x8221f258
	ctx.lr = 0x828A2340;
	sub_8221F258(ctx, base);
	// 828A2340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2344: 419A0028  beq cr6, 0x828a236c
	if ctx.cr[6].eq {
	pc = 0x828A236C; continue 'dispatch;
	}
	// 828A2348: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A234C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A2350: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2354: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A2358: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A235C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2360: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A2364: 4800000C  b 0x828a2370
	pc = 0x828A2370; continue 'dispatch;
	// 828A2368: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A236C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A2370: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2374: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A2378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A237C: 419A0008  beq cr6, 0x828a2384
	if ctx.cr[6].eq {
	pc = 0x828A2384; continue 'dispatch;
	}
	// 828A2380: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2384: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A2388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A238C: 419A0078  beq cr6, 0x828a2404
	if ctx.cr[6].eq {
	pc = 0x828A2404; continue 'dispatch;
	}
	// 828A2390: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2394: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A2398: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A239C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A23A0: 4B986D69  bl 0x82229108
	ctx.lr = 0x828A23A4;
	sub_82229108(ctx, base);
	// 828A23A4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A23A8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A23AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A23B0: 3BCB2AB8  addi r30, r11, 0x2ab8
	ctx.r[30].s64 = ctx.r[11].s64 + 10936;
	// 828A23B4: 4B9854CD  bl 0x82227880
	ctx.lr = 0x828A23B8;
	sub_82227880(ctx, base);
	// 828A23B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A23BC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828A23C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A23C4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828A23C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A23CC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A23D0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A23D4: 4B8F86AD  bl 0x8219aa80
	ctx.lr = 0x828A23D8;
	sub_8219AA80(ctx, base);
	// 828A23D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A23DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A23E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A23E4: 4BB2C03D  bl 0x823ce420
	ctx.lr = 0x828A23E8;
	sub_823CE420(ctx, base);
	// 828A23E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A23EC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A23F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A23F4: 481822D5  bl 0x82a246c8
	ctx.lr = 0x828A23F8;
	sub_82A246C8(ctx, base);
	// 828A23F8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A23FC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A2400: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A2404: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A2408: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A240C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A2410: 419A0020  beq cr6, 0x828a2430
	if ctx.cr[6].eq {
	pc = 0x828A2430; continue 'dispatch;
	}
	// 828A2414: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2418: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A241C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2420: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A2424: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2428: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A242C: 4082FFE8  bne 0x828a2414
	if !ctx.cr[0].eq {
	pc = 0x828A2414; continue 'dispatch;
	}
	// 828A2430: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2434: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2438: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A243C: 4BA5350D  bl 0x822f5948
	ctx.lr = 0x828A2440;
	sub_822F5948(ctx, base);
	// 828A2440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2444: 4B9156D5  bl 0x821b7b18
	ctx.lr = 0x828A2448;
	sub_821B7B18(ctx, base);
	// 828A2448: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A244C: 419A0040  beq cr6, 0x828a248c
	if ctx.cr[6].eq {
	pc = 0x828A248C; continue 'dispatch;
	}
	// 828A2450: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2454: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2458: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A245C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2460: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2464: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2468: 4082FFE8  bne 0x828a2450
	if !ctx.cr[0].eq {
	pc = 0x828A2450; continue 'dispatch;
	}
	// 828A246C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2470: 409A001C  bne cr6, 0x828a248c
	if !ctx.cr[6].eq {
	pc = 0x828A248C; continue 'dispatch;
	}
	// 828A2474: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2478: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A247C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2480: 4E800421  bctrl
	ctx.lr = 0x828A2484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A2488: 4B9798B1  bl 0x8221bd38
	ctx.lr = 0x828A248C;
	sub_8221BD38(ctx, base);
	// 828A248C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2490: 4B915689  bl 0x821b7b18
	ctx.lr = 0x828A2494;
	sub_821B7B18(ctx, base);
	// 828A2494: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A2498: 48406FB4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A24A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A24A0 size=512
    let mut pc: u32 = 0x828A24A0;
    'dispatch: loop {
        match pc {
            0x828A24A0 => {
    //   block [0x828A24A0..0x828A26A0)
	// 828A24A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A24A4: 48406F59  bl 0x82ca93fc
	ctx.lr = 0x828A24A8;
	sub_82CA93D0(ctx, base);
	// 828A24A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A24AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A24B0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A24B4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A24B8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828A24BC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A24C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A24C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828A24C8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A24CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A24D0: 419A0008  beq cr6, 0x828a24d8
	if ctx.cr[6].eq {
	pc = 0x828A24D8; continue 'dispatch;
	}
	// 828A24D4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A24D8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A24DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A24E0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A24E4: 4BB2C0DD  bl 0x823ce5c0
	ctx.lr = 0x828A24E8;
	sub_823CE5C0(ctx, base);
	// 828A24E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A24EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A24F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A24F4: 4BB2BC1D  bl 0x823ce110
	ctx.lr = 0x828A24F8;
	sub_823CE110(ctx, base);
	// 828A24F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A24FC: 4B91561D  bl 0x821b7b18
	ctx.lr = 0x828A2500;
	sub_821B7B18(ctx, base);
	// 828A2500: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A2504: 4B97CD55  bl 0x8221f258
	ctx.lr = 0x828A2508;
	sub_8221F258(ctx, base);
	// 828A2508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A250C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A2510: 419A005C  beq cr6, 0x828a256c
	if ctx.cr[6].eq {
	pc = 0x828A256C; continue 'dispatch;
	}
	// 828A2514: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A2518: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A251C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2520: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A2524: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A2528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A252C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A2530: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A2534: 4B94DD0D  bl 0x821f0240
	ctx.lr = 0x828A2538;
	sub_821F0240(ctx, base);
	// 828A2538: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A253C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A2540: 4B97CD19  bl 0x8221f258
	ctx.lr = 0x828A2544;
	sub_8221F258(ctx, base);
	// 828A2544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2548: 419A0028  beq cr6, 0x828a2570
	if ctx.cr[6].eq {
	pc = 0x828A2570; continue 'dispatch;
	}
	// 828A254C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A2550: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A2554: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2558: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A255C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A2560: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2564: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A2568: 4800000C  b 0x828a2574
	pc = 0x828A2574; continue 'dispatch;
	// 828A256C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A2570: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A2574: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2578: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A257C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2580: 419A0008  beq cr6, 0x828a2588
	if ctx.cr[6].eq {
	pc = 0x828A2588; continue 'dispatch;
	}
	// 828A2584: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2588: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A258C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2590: 419A0078  beq cr6, 0x828a2608
	if ctx.cr[6].eq {
	pc = 0x828A2608; continue 'dispatch;
	}
	// 828A2594: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2598: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A259C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A25A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A25A4: 4B986B65  bl 0x82229108
	ctx.lr = 0x828A25A8;
	sub_82229108(ctx, base);
	// 828A25A8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A25AC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A25B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A25B4: 3BCB2C30  addi r30, r11, 0x2c30
	ctx.r[30].s64 = ctx.r[11].s64 + 11312;
	// 828A25B8: 4B9852C9  bl 0x82227880
	ctx.lr = 0x828A25BC;
	sub_82227880(ctx, base);
	// 828A25BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A25C0: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 828A25C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A25C8: 388A39D8  addi r4, r10, 0x39d8
	ctx.r[4].s64 = ctx.r[10].s64 + 14808;
	// 828A25CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A25D0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A25D4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A25D8: 4B8F84A9  bl 0x8219aa80
	ctx.lr = 0x828A25DC;
	sub_8219AA80(ctx, base);
	// 828A25DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A25E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A25E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A25E8: 4BB2BE39  bl 0x823ce420
	ctx.lr = 0x828A25EC;
	sub_823CE420(ctx, base);
	// 828A25EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A25F0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A25F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A25F8: 481820D1  bl 0x82a246c8
	ctx.lr = 0x828A25FC;
	sub_82A246C8(ctx, base);
	// 828A25FC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2600: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A2604: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A2608: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A260C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2610: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A2614: 419A0020  beq cr6, 0x828a2634
	if ctx.cr[6].eq {
	pc = 0x828A2634; continue 'dispatch;
	}
	// 828A2618: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A261C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2620: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2624: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A2628: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A262C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2630: 4082FFE8  bne 0x828a2618
	if !ctx.cr[0].eq {
	pc = 0x828A2618; continue 'dispatch;
	}
	// 828A2634: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A263C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A2640: 4BA53309  bl 0x822f5948
	ctx.lr = 0x828A2644;
	sub_822F5948(ctx, base);
	// 828A2644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2648: 4B9154D1  bl 0x821b7b18
	ctx.lr = 0x828A264C;
	sub_821B7B18(ctx, base);
	// 828A264C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2650: 419A0040  beq cr6, 0x828a2690
	if ctx.cr[6].eq {
	pc = 0x828A2690; continue 'dispatch;
	}
	// 828A2654: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2658: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A265C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2660: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2664: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2668: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A266C: 4082FFE8  bne 0x828a2654
	if !ctx.cr[0].eq {
	pc = 0x828A2654; continue 'dispatch;
	}
	// 828A2670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2674: 409A001C  bne cr6, 0x828a2690
	if !ctx.cr[6].eq {
	pc = 0x828A2690; continue 'dispatch;
	}
	// 828A2678: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A267C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2684: 4E800421  bctrl
	ctx.lr = 0x828A2688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2688: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A268C: 4B9796AD  bl 0x8221bd38
	ctx.lr = 0x828A2690;
	sub_8221BD38(ctx, base);
	// 828A2690: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2694: 4B915485  bl 0x821b7b18
	ctx.lr = 0x828A2698;
	sub_821B7B18(ctx, base);
	// 828A2698: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A269C: 48406DB0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A26A0 size=516
    let mut pc: u32 = 0x828A26A0;
    'dispatch: loop {
        match pc {
            0x828A26A0 => {
    //   block [0x828A26A0..0x828A28A4)
	// 828A26A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A26A4: 48406D59  bl 0x82ca93fc
	ctx.lr = 0x828A26A8;
	sub_82CA93D0(ctx, base);
	// 828A26A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A26AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A26B0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A26B4: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A26B8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828A26BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A26C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A26C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A26C8: 3BAA0F98  addi r29, r10, 0xf98
	ctx.r[29].s64 = ctx.r[10].s64 + 3992;
	// 828A26CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A26D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A26D4: 419A0008  beq cr6, 0x828a26dc
	if ctx.cr[6].eq {
	pc = 0x828A26DC; continue 'dispatch;
	}
	// 828A26D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A26DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A26E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A26E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A26E8: 4BB2BED9  bl 0x823ce5c0
	ctx.lr = 0x828A26EC;
	sub_823CE5C0(ctx, base);
	// 828A26EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A26F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A26F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A26F8: 4BB2BA19  bl 0x823ce110
	ctx.lr = 0x828A26FC;
	sub_823CE110(ctx, base);
	// 828A26FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A2700: 4B915419  bl 0x821b7b18
	ctx.lr = 0x828A2704;
	sub_821B7B18(ctx, base);
	// 828A2704: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A2708: 4B97CB51  bl 0x8221f258
	ctx.lr = 0x828A270C;
	sub_8221F258(ctx, base);
	// 828A270C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2710: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A2714: 419A005C  beq cr6, 0x828a2770
	if ctx.cr[6].eq {
	pc = 0x828A2770; continue 'dispatch;
	}
	// 828A2718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A271C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A2720: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2724: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A2728: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A272C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2730: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A2734: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A2738: 4B94DB09  bl 0x821f0240
	ctx.lr = 0x828A273C;
	sub_821F0240(ctx, base);
	// 828A273C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A2740: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A2744: 4B97CB15  bl 0x8221f258
	ctx.lr = 0x828A2748;
	sub_8221F258(ctx, base);
	// 828A2748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A274C: 419A0028  beq cr6, 0x828a2774
	if ctx.cr[6].eq {
	pc = 0x828A2774; continue 'dispatch;
	}
	// 828A2750: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A2754: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A2758: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A275C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A2760: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A2764: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2768: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A276C: 4800000C  b 0x828a2778
	pc = 0x828A2778; continue 'dispatch;
	// 828A2770: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A2774: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A2778: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A277C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A2780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2784: 419A0008  beq cr6, 0x828a278c
	if ctx.cr[6].eq {
	pc = 0x828A278C; continue 'dispatch;
	}
	// 828A2788: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A278C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A2790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2794: 419A0078  beq cr6, 0x828a280c
	if ctx.cr[6].eq {
	pc = 0x828A280C; continue 'dispatch;
	}
	// 828A2798: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A279C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A27A0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A27A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A27A8: 4B986961  bl 0x82229108
	ctx.lr = 0x828A27AC;
	sub_82229108(ctx, base);
	// 828A27AC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A27B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A27B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A27B8: 3BCB2DB0  addi r30, r11, 0x2db0
	ctx.r[30].s64 = ctx.r[11].s64 + 11696;
	// 828A27BC: 4B9850C5  bl 0x82227880
	ctx.lr = 0x828A27C0;
	sub_82227880(ctx, base);
	// 828A27C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A27C4: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 828A27C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A27CC: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 828A27D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A27D4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A27D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A27DC: 4B8F82A5  bl 0x8219aa80
	ctx.lr = 0x828A27E0;
	sub_8219AA80(ctx, base);
	// 828A27E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A27E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A27E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A27EC: 4BB2BC35  bl 0x823ce420
	ctx.lr = 0x828A27F0;
	sub_823CE420(ctx, base);
	// 828A27F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A27F4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A27F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A27FC: 48181ECD  bl 0x82a246c8
	ctx.lr = 0x828A2800;
	sub_82A246C8(ctx, base);
	// 828A2800: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2804: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A2808: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A280C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A2810: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2814: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A2818: 419A0020  beq cr6, 0x828a2838
	if ctx.cr[6].eq {
	pc = 0x828A2838; continue 'dispatch;
	}
	// 828A281C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A2820: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2824: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2828: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A282C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A2830: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2834: 4082FFE8  bne 0x828a281c
	if !ctx.cr[0].eq {
	pc = 0x828A281C; continue 'dispatch;
	}
	// 828A2838: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A283C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2840: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A2844: 4BA53105  bl 0x822f5948
	ctx.lr = 0x828A2848;
	sub_822F5948(ctx, base);
	// 828A2848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A284C: 4B9152CD  bl 0x821b7b18
	ctx.lr = 0x828A2850;
	sub_821B7B18(ctx, base);
	// 828A2850: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A2854: 419A0040  beq cr6, 0x828a2894
	if ctx.cr[6].eq {
	pc = 0x828A2894; continue 'dispatch;
	}
	// 828A2858: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A285C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2860: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A2864: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2868: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A286C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2870: 4082FFE8  bne 0x828a2858
	if !ctx.cr[0].eq {
	pc = 0x828A2858; continue 'dispatch;
	}
	// 828A2874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2878: 409A001C  bne cr6, 0x828a2894
	if !ctx.cr[6].eq {
	pc = 0x828A2894; continue 'dispatch;
	}
	// 828A287C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2880: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2884: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2888: 4E800421  bctrl
	ctx.lr = 0x828A288C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A288C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A2890: 4B9794A9  bl 0x8221bd38
	ctx.lr = 0x828A2894;
	sub_8221BD38(ctx, base);
	// 828A2894: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2898: 4B915281  bl 0x821b7b18
	ctx.lr = 0x828A289C;
	sub_821B7B18(ctx, base);
	// 828A289C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A28A0: 48406BAC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A28A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A28A8 size=56
    let mut pc: u32 = 0x828A28A8;
    'dispatch: loop {
        match pc {
            0x828A28A8 => {
    //   block [0x828A28A8..0x828A28E0)
	// 828A28A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A28AC: 419A0018  beq cr6, 0x828a28c4
	if ctx.cr[6].eq {
	pc = 0x828A28C4; continue 'dispatch;
	}
	// 828A28B0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A28B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A28B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A28BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A28C0: 409A0008  bne cr6, 0x828a28c8
	if !ctx.cr[6].eq {
	pc = 0x828A28C8; continue 'dispatch;
	}
	// 828A28C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A28C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A28CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A28D0: 419A0010  beq cr6, 0x828a28e0
	if ctx.cr[6].eq {
		sub_828A28E0(ctx, base);
		return;
	}
	// 828A28D4: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A28D8: 55632FFE  rlwinm r3, r11, 5, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828A28DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A28E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A28E0 size=8
    let mut pc: u32 = 0x828A28E0;
    'dispatch: loop {
        match pc {
            0x828A28E0 => {
    //   block [0x828A28E0..0x828A28E8)
	// 828A28E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A28E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A28E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A28E8 size=464
    let mut pc: u32 = 0x828A28E8;
    'dispatch: loop {
        match pc {
            0x828A28E8 => {
    //   block [0x828A28E8..0x828A2AB8)
	// 828A28E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A28EC: 48406B21  bl 0x82ca940c
	ctx.lr = 0x828A28F0;
	sub_82CA93D0(ctx, base);
	// 828A28F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A28F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A28F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A28FC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2900: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A2904: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A2908: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828A290C: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 828A2910: 4198019C  blt cr6, 0x828a2aac
	if ctx.cr[6].lt {
	pc = 0x828A2AAC; continue 'dispatch;
	}
	// 828A2914: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A2918: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A291C: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 828A2920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2924: 4B9856A5  bl 0x82227fc8
	ctx.lr = 0x828A2928;
	sub_82227FC8(ctx, base);
	// 828A2928: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A292C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2930: 419A017C  beq cr6, 0x828a2aac
	if ctx.cr[6].eq {
	pc = 0x828A2AAC; continue 'dispatch;
	}
	// 828A2934: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A2938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A293C: 4B9857BD  bl 0x822280f8
	ctx.lr = 0x828A2940;
	sub_822280F8(ctx, base);
	// 828A2940: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2944: 4B984C1D  bl 0x82227560
	ctx.lr = 0x828A2948;
	sub_82227560(ctx, base);
	// 828A2948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A294C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A2950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2954: 4B93DA35  bl 0x821e0388
	ctx.lr = 0x828A2958;
	sub_821E0388(ctx, base);
	// 828A2958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A295C: 419A0018  beq cr6, 0x828a2974
	if ctx.cr[6].eq {
	pc = 0x828A2974; continue 'dispatch;
	}
	// 828A2960: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A2964: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A2968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A296C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2970: 409A0008  bne cr6, 0x828a2978
	if !ctx.cr[6].eq {
	pc = 0x828A2978; continue 'dispatch;
	}
	// 828A2974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2978: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A297C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2980: 419A012C  beq cr6, 0x828a2aac
	if ctx.cr[6].eq {
	pc = 0x828A2AAC; continue 'dispatch;
	}
	// 828A2984: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A2988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A298C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828A2990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A2994: 419A00EC  beq cr6, 0x828a2a80
	if ctx.cr[6].eq {
	pc = 0x828A2A80; continue 'dispatch;
	}
	// 828A2998: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A299C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A29A0: 419A0020  beq cr6, 0x828a29c0
	if ctx.cr[6].eq {
	pc = 0x828A29C0; continue 'dispatch;
	}
	// 828A29A4: 894B009B  lbz r10, 0x9b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 828A29A8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A29AC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A29B0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A29B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A29B8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A29BC: 480000C8  b 0x828a2a84
	pc = 0x828A2A84; continue 'dispatch;
	// 828A29C0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A29C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A29C8: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A29CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A29D0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A29D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A29D8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A29DC: 40810054  ble 0x828a2a30
	if !ctx.cr[0].gt {
	pc = 0x828A2A30; continue 'dispatch;
	}
	// 828A29E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A29E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A29E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A29EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A29F0: 2F07009B  cmpwi cr6, r7, 0x9b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 155, &mut ctx.xer);
	// 828A29F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A29F8: 41980008  blt cr6, 0x828a2a00
	if ctx.cr[6].lt {
	pc = 0x828A2A00; continue 'dispatch;
	}
	// 828A29FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A2A00: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A2A04: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A2A08: 419A0014  beq cr6, 0x828a2a1c
	if ctx.cr[6].eq {
	pc = 0x828A2A1C; continue 'dispatch;
	}
	// 828A2A0C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A2A10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A2A14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2A18: 4800000C  b 0x828a2a24
	pc = 0x828A2A24; continue 'dispatch;
	// 828A2A1C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A2A20: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A2A24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2A28: 4199FFB8  bgt cr6, 0x828a29e0
	if ctx.cr[6].gt {
	pc = 0x828A29E0; continue 'dispatch;
	}
	// 828A2A2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2A30: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A2A34: 419A003C  beq cr6, 0x828a2a70
	if ctx.cr[6].eq {
	pc = 0x828A2A70; continue 'dispatch;
	}
	// 828A2A38: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2A3C: 2F0B009B  cmpwi cr6, r11, 0x9b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 155, &mut ctx.xer);
	// 828A2A40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2A44: 41990008  bgt cr6, 0x828a2a4c
	if ctx.cr[6].gt {
	pc = 0x828A2A4C; continue 'dispatch;
	}
	// 828A2A48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2A4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2A54: 409A001C  bne cr6, 0x828a2a70
	if !ctx.cr[6].eq {
	pc = 0x828A2A70; continue 'dispatch;
	}
	// 828A2A58: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A2A5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2A60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A2A64: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A2A68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2A6C: 48000018  b 0x828a2a84
	pc = 0x828A2A84; continue 'dispatch;
	// 828A2A70: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A2A74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2A78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2A7C: 48000008  b 0x828a2a84
	pc = 0x828A2A84; continue 'dispatch;
	// 828A2A80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2A84: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A2A88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2A8C: 419A0020  beq cr6, 0x828a2aac
	if ctx.cr[6].eq {
	pc = 0x828A2AAC; continue 'dispatch;
	}
	// 828A2A90: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2A94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2A98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A2A9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A2AA0: 4E800421  bctrl
	ctx.lr = 0x828A2AA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2AA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A2AA8: 484069B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828A2AAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A2AB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A2AB4: 484069A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2AB8 size=372
    let mut pc: u32 = 0x828A2AB8;
    'dispatch: loop {
        match pc {
            0x828A2AB8 => {
    //   block [0x828A2AB8..0x828A2C2C)
	// 828A2AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2ABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2AC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2AC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A2AC8: 419A0018  beq cr6, 0x828a2ae0
	if ctx.cr[6].eq {
	pc = 0x828A2AE0; continue 'dispatch;
	}
	// 828A2ACC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A2AD0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A2AD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2ADC: 409A0008  bne cr6, 0x828a2ae4
	if !ctx.cr[6].eq {
	pc = 0x828A2AE4; continue 'dispatch;
	}
	// 828A2AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2AEC: 419A012C  beq cr6, 0x828a2c18
	if ctx.cr[6].eq {
	pc = 0x828A2C18; continue 'dispatch;
	}
	// 828A2AF0: 81440034  lwz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A2AF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2AF8: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828A2AFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A2B00: 419A00E8  beq cr6, 0x828a2be8
	if ctx.cr[6].eq {
	pc = 0x828A2BE8; continue 'dispatch;
	}
	// 828A2B04: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A2B08: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A2B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2B10: 419A001C  beq cr6, 0x828a2b2c
	if ctx.cr[6].eq {
	pc = 0x828A2B2C; continue 'dispatch;
	}
	// 828A2B14: 896B009B  lbz r11, 0x9b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 828A2B18: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A2B1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A2B20: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2B24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2B28: 480000C4  b 0x828a2bec
	pc = 0x828A2BEC; continue 'dispatch;
	// 828A2B2C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A2B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2B34: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2B38: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A2B3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A2B40: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2B44: 40810054  ble 0x828a2b98
	if !ctx.cr[0].gt {
	pc = 0x828A2B98; continue 'dispatch;
	}
	// 828A2B48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A2B4C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A2B50: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A2B54: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2B58: 2F07009B  cmpwi cr6, r7, 0x9b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 155, &mut ctx.xer);
	// 828A2B5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A2B60: 41980008  blt cr6, 0x828a2b68
	if ctx.cr[6].lt {
	pc = 0x828A2B68; continue 'dispatch;
	}
	// 828A2B64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A2B68: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A2B6C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A2B70: 419A0014  beq cr6, 0x828a2b84
	if ctx.cr[6].eq {
	pc = 0x828A2B84; continue 'dispatch;
	}
	// 828A2B74: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A2B78: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A2B7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2B80: 4800000C  b 0x828a2b8c
	pc = 0x828A2B8C; continue 'dispatch;
	// 828A2B84: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A2B88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A2B8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2B90: 4199FFB8  bgt cr6, 0x828a2b48
	if ctx.cr[6].gt {
	pc = 0x828A2B48; continue 'dispatch;
	}
	// 828A2B94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2B98: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A2B9C: 419A003C  beq cr6, 0x828a2bd8
	if ctx.cr[6].eq {
	pc = 0x828A2BD8; continue 'dispatch;
	}
	// 828A2BA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2BA4: 2F0B009B  cmpwi cr6, r11, 0x9b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 155, &mut ctx.xer);
	// 828A2BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2BAC: 41990008  bgt cr6, 0x828a2bb4
	if ctx.cr[6].gt {
	pc = 0x828A2BB4; continue 'dispatch;
	}
	// 828A2BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2BB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2BBC: 409A001C  bne cr6, 0x828a2bd8
	if !ctx.cr[6].eq {
	pc = 0x828A2BD8; continue 'dispatch;
	}
	// 828A2BC0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A2BC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2BC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A2BCC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A2BD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2BD4: 48000018  b 0x828a2bec
	pc = 0x828A2BEC; continue 'dispatch;
	// 828A2BD8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A2BDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2BE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2BE4: 48000008  b 0x828a2bec
	pc = 0x828A2BEC; continue 'dispatch;
	// 828A2BE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2BEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A2BF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2BF4: 419A0024  beq cr6, 0x828a2c18
	if ctx.cr[6].eq {
	pc = 0x828A2C18; continue 'dispatch;
	}
	// 828A2BF8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A2BFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A2C00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A2C04: 4E800421  bctrl
	ctx.lr = 0x828A2C08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2C08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A2C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2C14: 4E800020  blr
	return;
	// 828A2C18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A2C1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A2C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2C30 size=384
    let mut pc: u32 = 0x828A2C30;
    'dispatch: loop {
        match pc {
            0x828A2C30 => {
    //   block [0x828A2C30..0x828A2DB0)
	// 828A2C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2C34: 484067D9  bl 0x82ca940c
	ctx.lr = 0x828A2C38;
	sub_82CA93D0(ctx, base);
	// 828A2C38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2C3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2C40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A2C44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A2C48: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A2C4C: 419A0018  beq cr6, 0x828a2c64
	if ctx.cr[6].eq {
	pc = 0x828A2C64; continue 'dispatch;
	}
	// 828A2C50: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A2C54: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A2C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2C5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2C60: 409A0008  bne cr6, 0x828a2c68
	if !ctx.cr[6].eq {
	pc = 0x828A2C68; continue 'dispatch;
	}
	// 828A2C64: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A2C68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2C70: 419A0130  beq cr6, 0x828a2da0
	if ctx.cr[6].eq {
	pc = 0x828A2DA0; continue 'dispatch;
	}
	// 828A2C74: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A2C78: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828A2C7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2C80: 419A00F0  beq cr6, 0x828a2d70
	if ctx.cr[6].eq {
	pc = 0x828A2D70; continue 'dispatch;
	}
	// 828A2C84: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A2C88: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A2C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2C90: 419A0020  beq cr6, 0x828a2cb0
	if ctx.cr[6].eq {
	pc = 0x828A2CB0; continue 'dispatch;
	}
	// 828A2C94: 896B009B  lbz r11, 0x9b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 828A2C98: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A2C9C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A2CA0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2CA4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A2CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2CAC: 480000C8  b 0x828a2d74
	pc = 0x828A2D74; continue 'dispatch;
	// 828A2CB0: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A2CB4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A2CB8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A2CBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2CC0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2CC4: 40810054  ble 0x828a2d18
	if !ctx.cr[0].gt {
	pc = 0x828A2D18; continue 'dispatch;
	}
	// 828A2CC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A2CCC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A2CD0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A2CD4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2CD8: 2F07009B  cmpwi cr6, r7, 0x9b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 155, &mut ctx.xer);
	// 828A2CDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A2CE0: 41980008  blt cr6, 0x828a2ce8
	if ctx.cr[6].lt {
	pc = 0x828A2CE8; continue 'dispatch;
	}
	// 828A2CE4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828A2CE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A2CEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A2CF0: 419A0014  beq cr6, 0x828a2d04
	if ctx.cr[6].eq {
	pc = 0x828A2D04; continue 'dispatch;
	}
	// 828A2CF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A2CF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A2CFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2D00: 4800000C  b 0x828a2d0c
	pc = 0x828A2D0C; continue 'dispatch;
	// 828A2D04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A2D08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A2D0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2D10: 4199FFB8  bgt cr6, 0x828a2cc8
	if ctx.cr[6].gt {
	pc = 0x828A2CC8; continue 'dispatch;
	}
	// 828A2D14: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2D18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A2D1C: 419A0040  beq cr6, 0x828a2d5c
	if ctx.cr[6].eq {
	pc = 0x828A2D5C; continue 'dispatch;
	}
	// 828A2D20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2D24: 2F0B009B  cmpwi cr6, r11, 0x9b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 155, &mut ctx.xer);
	// 828A2D28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2D2C: 41990008  bgt cr6, 0x828a2d34
	if ctx.cr[6].gt {
	pc = 0x828A2D34; continue 'dispatch;
	}
	// 828A2D30: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A2D34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2D3C: 409A0020  bne cr6, 0x828a2d5c
	if !ctx.cr[6].eq {
	pc = 0x828A2D5C; continue 'dispatch;
	}
	// 828A2D40: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A2D44: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A2D48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A2D4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2D50: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A2D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2D58: 4800001C  b 0x828a2d74
	pc = 0x828A2D74; continue 'dispatch;
	// 828A2D5C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A2D60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2D64: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A2D68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2D6C: 48000008  b 0x828a2d74
	pc = 0x828A2D74; continue 'dispatch;
	// 828A2D70: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A2D74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2D7C: 419A0024  beq cr6, 0x828a2da0
	if ctx.cr[6].eq {
	pc = 0x828A2DA0; continue 'dispatch;
	}
	// 828A2D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D88: 4B94D4B9  bl 0x821f0240
	ctx.lr = 0x828A2D8C;
	sub_821F0240(ctx, base);
	// 828A2D8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2D90: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2D9C: 4E800421  bctrl
	ctx.lr = 0x828A2DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2DA4: 4B972035  bl 0x82214dd8
	ctx.lr = 0x828A2DA8;
	sub_82214DD8(ctx, base);
	// 828A2DA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A2DAC: 484066B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2DB0 size=376
    let mut pc: u32 = 0x828A2DB0;
    'dispatch: loop {
        match pc {
            0x828A2DB0 => {
    //   block [0x828A2DB0..0x828A2F28)
	// 828A2DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2DB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2DBC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828A2DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2DC4: 419A0018  beq cr6, 0x828a2ddc
	if ctx.cr[6].eq {
	pc = 0x828A2DDC; continue 'dispatch;
	}
	// 828A2DC8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A2DCC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828A2DD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A2DD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A2DD8: 409A0008  bne cr6, 0x828a2de0
	if !ctx.cr[6].eq {
	pc = 0x828A2DE0; continue 'dispatch;
	}
	// 828A2DDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2DE0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A2DE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2DE8: 419A0130  beq cr6, 0x828a2f18
	if ctx.cr[6].eq {
	pc = 0x828A2F18; continue 'dispatch;
	}
	// 828A2DEC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A2DF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A2DF4: 55282FFE  rlwinm r8, r9, 5, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x07FFFFFFu64;
	// 828A2DF8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828A2DFC: 419A00F8  beq cr6, 0x828a2ef4
	if ctx.cr[6].eq {
	pc = 0x828A2EF4; continue 'dispatch;
	}
	// 828A2E00: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A2E04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A2E08: 419A0024  beq cr6, 0x828a2e2c
	if ctx.cr[6].eq {
	pc = 0x828A2E2C; continue 'dispatch;
	}
	// 828A2E0C: 892A009B  lbz r9, 0x9b(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(155 as u32) ) } as u64;
	// 828A2E10: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A2E14: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828A2E18: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A2E1C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2E20: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A2E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2E28: 480000D0  b 0x828a2ef8
	pc = 0x828A2EF8; continue 'dispatch;
	// 828A2E2C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A2E30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828A2E34: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A2E38: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828A2E3C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A2E40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2E44: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2E48: 40810054  ble 0x828a2e9c
	if !ctx.cr[0].gt {
	pc = 0x828A2E9C; continue 'dispatch;
	}
	// 828A2E4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A2E50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A2E54: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A2E58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2E5C: 2F07009B  cmpwi cr6, r7, 0x9b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 155, &mut ctx.xer);
	// 828A2E60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A2E64: 41980008  blt cr6, 0x828a2e6c
	if ctx.cr[6].lt {
	pc = 0x828A2E6C; continue 'dispatch;
	}
	// 828A2E68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A2E6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A2E70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A2E74: 419A0014  beq cr6, 0x828a2e88
	if ctx.cr[6].eq {
	pc = 0x828A2E88; continue 'dispatch;
	}
	// 828A2E78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A2E7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A2E80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A2E84: 4800000C  b 0x828a2e90
	pc = 0x828A2E90; continue 'dispatch;
	// 828A2E88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A2E8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A2E90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A2E94: 4199FFB8  bgt cr6, 0x828a2e4c
	if ctx.cr[6].gt {
	pc = 0x828A2E4C; continue 'dispatch;
	}
	// 828A2E98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A2E9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A2EA0: 419A0040  beq cr6, 0x828a2ee0
	if ctx.cr[6].eq {
	pc = 0x828A2EE0; continue 'dispatch;
	}
	// 828A2EA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2EA8: 2F0B009B  cmpwi cr6, r11, 0x9b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 155, &mut ctx.xer);
	// 828A2EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2EB0: 41990008  bgt cr6, 0x828a2eb8
	if ctx.cr[6].gt {
	pc = 0x828A2EB8; continue 'dispatch;
	}
	// 828A2EB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2EB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2EC0: 409A0020  bne cr6, 0x828a2ee0
	if !ctx.cr[6].eq {
	pc = 0x828A2EE0; continue 'dispatch;
	}
	// 828A2EC4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A2EC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A2ECC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A2ED0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2ED4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A2ED8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2EDC: 4800001C  b 0x828a2ef8
	pc = 0x828A2EF8; continue 'dispatch;
	// 828A2EE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A2EE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2EE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A2EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2EF0: 48000008  b 0x828a2ef8
	pc = 0x828A2EF8; continue 'dispatch;
	// 828A2EF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A2EF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A2EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2F00: 419A0018  beq cr6, 0x828a2f18
	if ctx.cr[6].eq {
	pc = 0x828A2F18; continue 'dispatch;
	}
	// 828A2F04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A2F08: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828A2F0C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828A2F10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2F14: 4E800421  bctrl
	ctx.lr = 0x828A2F18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2F18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A2F1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2F20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2F24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A2F28 size=8
    let mut pc: u32 = 0x828A2F28;
    'dispatch: loop {
        match pc {
            0x828A2F28 => {
    //   block [0x828A2F28..0x828A2F30)
	// 828A2F28: 38600059  li r3, 0x59
	ctx.r[3].s64 = 89;
	// 828A2F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2F30 size=60
    let mut pc: u32 = 0x828A2F30;
    'dispatch: loop {
        match pc {
            0x828A2F30 => {
    //   block [0x828A2F30..0x828A2F6C)
	// 828A2F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2F3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2F40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A2F44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A2F48: 388B94B4  addi r4, r11, -0x6b4c
	ctx.r[4].s64 = ctx.r[11].s64 + -27468;
	// 828A2F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2F50: 4B989F81  bl 0x8222ced0
	ctx.lr = 0x828A2F54;
	sub_8222CED0(ctx, base);
	// 828A2F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A2F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2F70 size=112
    let mut pc: u32 = 0x828A2F70;
    'dispatch: loop {
        match pc {
            0x828A2F70 => {
    //   block [0x828A2F70..0x828A2FE0)
	// 828A2F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A2F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2F84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A2F88: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828A2F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2F90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2F94: 388B8E24  addi r4, r11, -0x71dc
	ctx.r[4].s64 = ctx.r[11].s64 + -29148;
	// 828A2F98: 4B8F3BE9  bl 0x82196b80
	ctx.lr = 0x828A2F9C;
	sub_82196B80(ctx, base);
	// 828A2F9C: D03F000C  stfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828A2FA0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828A2FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2FA8: 388AABAC  addi r4, r10, -0x5454
	ctx.r[4].s64 = ctx.r[10].s64 + -21588;
	// 828A2FAC: 4B8F3BD5  bl 0x82196b80
	ctx.lr = 0x828A2FB0;
	sub_82196B80(ctx, base);
	// 828A2FB0: D03F0010  stfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828A2FB4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828A2FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2FBC: 38894E24  addi r4, r9, 0x4e24
	ctx.r[4].s64 = ctx.r[9].s64 + 20004;
	// 828A2FC0: 4BA6D2D1  bl 0x82310290
	ctx.lr = 0x828A2FC4;
	sub_82310290(ctx, base);
	// 828A2FC4: 987F0014  stb r3, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u8 ) };
	// 828A2FC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A2FCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2FD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2FD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A2FD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2FDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2FE0 size=80
    let mut pc: u32 = 0x828A2FE0;
    'dispatch: loop {
        match pc {
            0x828A2FE0 => {
    //   block [0x828A2FE0..0x828A3030)
	// 828A2FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2FEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2FF0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A2FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2FF8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A2FFC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A3000: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 828A3004: 4B9557C5  bl 0x821f87c8
	ctx.lr = 0x828A3008;
	sub_821F87C8(ctx, base);
	// 828A3008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A300C: 419A0010  beq cr6, 0x828a301c
	if ctx.cr[6].eq {
	pc = 0x828A301C; continue 'dispatch;
	}
	// 828A3010: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3014: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3018: 4BBDEB51  bl 0x82481b68
	ctx.lr = 0x828A301C;
	sub_82481B68(ctx, base);
	// 828A301C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A3020: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3024: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3028: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A302C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3030 size=80
    let mut pc: u32 = 0x828A3030;
    'dispatch: loop {
        match pc {
            0x828A3030 => {
    //   block [0x828A3030..0x828A3080)
	// 828A3030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3038: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A303C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3040: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A3044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3048: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A304C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A3050: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 828A3054: 4B955775  bl 0x821f87c8
	ctx.lr = 0x828A3058;
	sub_821F87C8(ctx, base);
	// 828A3058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A305C: 419A0010  beq cr6, 0x828a306c
	if ctx.cr[6].eq {
	pc = 0x828A306C; continue 'dispatch;
	}
	// 828A3060: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3064: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3068: 4BBDEBE1  bl 0x82481c48
	ctx.lr = 0x828A306C;
	sub_82481C48(ctx, base);
	// 828A306C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A3070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A307C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A3080 size=152
    let mut pc: u32 = 0x828A3080;
    'dispatch: loop {
        match pc {
            0x828A3080 => {
    //   block [0x828A3080..0x828A3118)
	// 828A3080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3084: 48406389  bl 0x82ca940c
	ctx.lr = 0x828A3088;
	sub_82CA93D0(ctx, base);
	// 828A3088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A308C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A3090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3094: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A3098: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A309C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A30A0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A30A4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A30A8: 812A0078  lwz r9, 0x78(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A30AC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A30B0: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A30B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A30B8: 4B93EAF1  bl 0x821e1ba8
	ctx.lr = 0x828A30BC;
	sub_821E1BA8(ctx, base);
	// 828A30BC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 828A30C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A30C4: 38A7B278  addi r5, r7, -0x4d88
	ctx.r[5].s64 = ctx.r[7].s64 + -19848;
	// 828A30C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A30CC: 4BA16725  bl 0x822b97f0
	ctx.lr = 0x828A30D0;
	sub_822B97F0(ctx, base);
	// 828A30D0: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 828A30D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A30D8: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A30DC: 38868E24  addi r4, r6, -0x71dc
	ctx.r[4].s64 = ctx.r[6].s64 + -29148;
	// 828A30E0: 4BFA26D9  bl 0x828457b8
	ctx.lr = 0x828A30E4;
	sub_828457B8(ctx, base);
	// 828A30E4: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 828A30E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A30EC: C03E0010  lfs f1, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A30F0: 3885ABAC  addi r4, r5, -0x5454
	ctx.r[4].s64 = ctx.r[5].s64 + -21588;
	// 828A30F4: 4BFA26C5  bl 0x828457b8
	ctx.lr = 0x828A30F8;
	sub_828457B8(ctx, base);
	// 828A30F8: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 828A30FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3100: 88BE0014  lbz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A3104: 38844E24  addi r4, r4, 0x4e24
	ctx.r[4].s64 = ctx.r[4].s64 + 20004;
	// 828A3108: 4BBFBA89  bl 0x8249eb90
	ctx.lr = 0x828A310C;
	sub_8249EB90(ctx, base);
	// 828A310C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3114: 48406348  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A3118 size=8
    let mut pc: u32 = 0x828A3118;
    'dispatch: loop {
        match pc {
            0x828A3118 => {
    //   block [0x828A3118..0x828A3120)
	// 828A3118: D023000C  stfs f1, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828A311C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A3120 size=8
    let mut pc: u32 = 0x828A3120;
    'dispatch: loop {
        match pc {
            0x828A3120 => {
    //   block [0x828A3120..0x828A3128)
	// 828A3120: C0230010  lfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A3124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3128 size=156
    let mut pc: u32 = 0x828A3128;
    'dispatch: loop {
        match pc {
            0x828A3128 => {
    //   block [0x828A3128..0x828A31C4)
	// 828A3128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A312C: 484062E1  bl 0x82ca940c
	ctx.lr = 0x828A3130;
	sub_82CA93D0(ctx, base);
	// 828A3130: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3134: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828A3138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A313C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A3140: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3144: 388B8E24  addi r4, r11, -0x71dc
	ctx.r[4].s64 = ctx.r[11].s64 + -29148;
	// 828A3148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A314C: 4B989D85  bl 0x8222ced0
	ctx.lr = 0x828A3150;
	sub_8222CED0(ctx, base);
	// 828A3150: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3154: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828A3158: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A315C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A3160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3164: 419A0008  beq cr6, 0x828a316c
	if ctx.cr[6].eq {
	pc = 0x828A316C; continue 'dispatch;
	}
	// 828A3168: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A316C: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828A3170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3174: 4BBDD6DD  bl 0x82480850
	ctx.lr = 0x828A3178;
	sub_82480850(ctx, base);
	// 828A3178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A317C: 4B971C5D  bl 0x82214dd8
	ctx.lr = 0x828A3180;
	sub_82214DD8(ctx, base);
	// 828A3180: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828A3184: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3188: 388BABAC  addi r4, r11, -0x5454
	ctx.r[4].s64 = ctx.r[11].s64 + -21588;
	// 828A318C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3190: 4B989D41  bl 0x8222ced0
	ctx.lr = 0x828A3194;
	sub_8222CED0(ctx, base);
	// 828A3194: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A3198: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A319C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A31A0: 419A0008  beq cr6, 0x828a31a8
	if ctx.cr[6].eq {
	pc = 0x828A31A8; continue 'dispatch;
	}
	// 828A31A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A31A8: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828A31AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A31B0: 4BBDD6A1  bl 0x82480850
	ctx.lr = 0x828A31B4;
	sub_82480850(ctx, base);
	// 828A31B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A31B8: 4B971C21  bl 0x82214dd8
	ctx.lr = 0x828A31BC;
	sub_82214DD8(ctx, base);
	// 828A31BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A31C0: 4840629C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A31C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A31C8 size=396
    let mut pc: u32 = 0x828A31C8;
    'dispatch: loop {
        match pc {
            0x828A31C8 => {
    //   block [0x828A31C8..0x828A3354)
	// 828A31C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A31CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A31D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A31D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A31D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A31DC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828A31E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A31E4: 3BCB2330  addi r30, r11, 0x2330
	ctx.r[30].s64 = ctx.r[11].s64 + 9008;
	// 828A31E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A31EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A31F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A31F4: 4B989CDD  bl 0x8222ced0
	ctx.lr = 0x828A31F8;
	sub_8222CED0(ctx, base);
	// 828A31F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A31FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3200: 48000159  bl 0x828a3358
	ctx.lr = 0x828A3204;
	sub_828A3358(ctx, base);
	// 828A3204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3208: 4B971BD1  bl 0x82214dd8
	ctx.lr = 0x828A320C;
	sub_82214DD8(ctx, base);
	// 828A320C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A3210: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3214: 388A2340  addi r4, r10, 0x2340
	ctx.r[4].s64 = ctx.r[10].s64 + 9024;
	// 828A3218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A321C: 4B989CB5  bl 0x8222ced0
	ctx.lr = 0x828A3220;
	sub_8222CED0(ctx, base);
	// 828A3220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3224: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A322C: 4B989CA5  bl 0x8222ced0
	ctx.lr = 0x828A3230;
	sub_8222CED0(ctx, base);
	// 828A3230: 3D20828A  lis r9, -0x7d76
	ctx.r[9].s64 = -2104885248;
	// 828A3234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3238: 38C93080  addi r6, r9, 0x3080
	ctx.r[6].s64 = ctx.r[9].s64 + 12416;
	// 828A323C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828A3240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3244: 4800035D  bl 0x828a35a0
	ctx.lr = 0x828A3248;
	sub_828A35A0(ctx, base);
	// 828A3248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A324C: 4B971B8D  bl 0x82214dd8
	ctx.lr = 0x828A3250;
	sub_82214DD8(ctx, base);
	// 828A3250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A3254: 4B971B85  bl 0x82214dd8
	ctx.lr = 0x828A3258;
	sub_82214DD8(ctx, base);
	// 828A3258: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828A325C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3260: 38885AE0  addi r4, r8, 0x5ae0
	ctx.r[4].s64 = ctx.r[8].s64 + 23264;
	// 828A3264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3268: 4B989C69  bl 0x8222ced0
	ctx.lr = 0x828A326C;
	sub_8222CED0(ctx, base);
	// 828A326C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3270: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A3274: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A3278: 4B989C59  bl 0x8222ced0
	ctx.lr = 0x828A327C;
	sub_8222CED0(ctx, base);
	// 828A327C: 3CE0828A  lis r7, -0x7d76
	ctx.r[7].s64 = -2104885248;
	// 828A3280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3284: 38C73118  addi r6, r7, 0x3118
	ctx.r[6].s64 = ctx.r[7].s64 + 12568;
	// 828A3288: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A328C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A3290: 48000519  bl 0x828a37a8
	ctx.lr = 0x828A3294;
	sub_828A37A8(ctx, base);
	// 828A3294: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A3298: 4B971B41  bl 0x82214dd8
	ctx.lr = 0x828A329C;
	sub_82214DD8(ctx, base);
	// 828A329C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A32A0: 4B971B39  bl 0x82214dd8
	ctx.lr = 0x828A32A4;
	sub_82214DD8(ctx, base);
	// 828A32A4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A32A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A32AC: 38862354  addi r4, r6, 0x2354
	ctx.r[4].s64 = ctx.r[6].s64 + 9044;
	// 828A32B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A32B4: 4B989C1D  bl 0x8222ced0
	ctx.lr = 0x828A32B8;
	sub_8222CED0(ctx, base);
	// 828A32B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A32BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A32C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A32C4: 4B989C0D  bl 0x8222ced0
	ctx.lr = 0x828A32C8;
	sub_8222CED0(ctx, base);
	// 828A32C8: 3C808291  lis r4, -0x7d6f
	ctx.r[4].s64 = -2104426496;
	// 828A32CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A32D0: 38C4D6B0  addi r6, r4, -0x2950
	ctx.r[6].s64 = ctx.r[4].s64 + -10576;
	// 828A32D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A32D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A32DC: 480006D5  bl 0x828a39b0
	ctx.lr = 0x828A32E0;
	sub_828A39B0(ctx, base);
	// 828A32E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A32E4: 4B971AF5  bl 0x82214dd8
	ctx.lr = 0x828A32E8;
	sub_82214DD8(ctx, base);
	// 828A32E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A32EC: 4B971AED  bl 0x82214dd8
	ctx.lr = 0x828A32F0;
	sub_82214DD8(ctx, base);
	// 828A32F0: 3C60820C  lis r3, -0x7df4
	ctx.r[3].s64 = -2113142784;
	// 828A32F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A32F8: 3883708C  addi r4, r3, 0x708c
	ctx.r[4].s64 = ctx.r[3].s64 + 28812;
	// 828A32FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3300: 4B989BD1  bl 0x8222ced0
	ctx.lr = 0x828A3304;
	sub_8222CED0(ctx, base);
	// 828A3304: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3308: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A330C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A3310: 4B989BC1  bl 0x8222ced0
	ctx.lr = 0x828A3314;
	sub_8222CED0(ctx, base);
	// 828A3314: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A3318: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A331C: 38CB3120  addi r6, r11, 0x3120
	ctx.r[6].s64 = ctx.r[11].s64 + 12576;
	// 828A3320: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3328: 48000689  bl 0x828a39b0
	ctx.lr = 0x828A332C;
	sub_828A39B0(ctx, base);
	// 828A332C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A3330: 4B971AA9  bl 0x82214dd8
	ctx.lr = 0x828A3334;
	sub_82214DD8(ctx, base);
	// 828A3334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3338: 4B971AA1  bl 0x82214dd8
	ctx.lr = 0x828A333C;
	sub_82214DD8(ctx, base);
	// 828A333C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3348: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A334C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3358 size=584
    let mut pc: u32 = 0x828A3358;
    'dispatch: loop {
        match pc {
            0x828A3358 => {
    //   block [0x828A3358..0x828A35A0)
	// 828A3358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A335C: 484060A5  bl 0x82ca9400
	ctx.lr = 0x828A3360;
	sub_82CA93D0(ctx, base);
	// 828A3360: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3364: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3368: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A336C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3370: 409A0010  bne cr6, 0x828a3380
	if !ctx.cr[6].eq {
	pc = 0x828A3380; continue 'dispatch;
	}
	// 828A3374: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3378: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828A337C: 48000008  b 0x828a3384
	pc = 0x828A3384; continue 'dispatch;
	// 828A3380: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3384: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3388: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A338C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3390: 4BB2B231  bl 0x823ce5c0
	ctx.lr = 0x828A3394;
	sub_823CE5C0(ctx, base);
	// 828A3394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A3398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A339C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A33A0: 4BB2AE61  bl 0x823ce200
	ctx.lr = 0x828A33A4;
	sub_823CE200(ctx, base);
	// 828A33A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A33A8: 4B914771  bl 0x821b7b18
	ctx.lr = 0x828A33AC;
	sub_821B7B18(ctx, base);
	// 828A33AC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828A33B0: 4B97BEA9  bl 0x8221f258
	ctx.lr = 0x828A33B4;
	sub_8221F258(ctx, base);
	// 828A33B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A33B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A33BC: 419A0040  beq cr6, 0x828a33fc
	if ctx.cr[6].eq {
	pc = 0x828A33FC; continue 'dispatch;
	}
	// 828A33C0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828A33C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A33C8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828A33CC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A33D0: 4B97BE89  bl 0x8221f258
	ctx.lr = 0x828A33D4;
	sub_8221F258(ctx, base);
	// 828A33D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A33D8: 419A0028  beq cr6, 0x828a3400
	if ctx.cr[6].eq {
	pc = 0x828A3400; continue 'dispatch;
	}
	// 828A33DC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A33E0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A33E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A33E8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A33EC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A33F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A33F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A33F8: 4800000C  b 0x828a3404
	pc = 0x828A3404; continue 'dispatch;
	// 828A33FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A3400: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A3404: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A3408: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A340C: 419A00FC  beq cr6, 0x828a3508
	if ctx.cr[6].eq {
	pc = 0x828A3508; continue 'dispatch;
	}
	// 828A3410: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3414: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A3418: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A341C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A3420: 4B985CE9  bl 0x82229108
	ctx.lr = 0x828A3424;
	sub_82229108(ctx, base);
	// 828A3424: 3D608217  lis r11, -0x7de9
	ctx.r[11].s64 = -2112421888;
	// 828A3428: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A342C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A3430: 3BCB4510  addi r30, r11, 0x4510
	ctx.r[30].s64 = ctx.r[11].s64 + 17680;
	// 828A3434: 4B98444D  bl 0x82227880
	ctx.lr = 0x828A3438;
	sub_82227880(ctx, base);
	// 828A3438: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A343C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828A3440: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A3444: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828A3448: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A344C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A3450: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A3454: 4B8F762D  bl 0x8219aa80
	ctx.lr = 0x828A3458;
	sub_8219AA80(ctx, base);
	// 828A3458: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828A345C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A3460: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828A3464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3468: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A346C: 4BB2AFB5  bl 0x823ce420
	ctx.lr = 0x828A3470;
	sub_823CE420(ctx, base);
	// 828A3470: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A3474: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A3478: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A347C: 4818124D  bl 0x82a246c8
	ctx.lr = 0x828A3480;
	sub_82A246C8(ctx, base);
	// 828A3480: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3484: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A3488: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828A348C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828A3490: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3494: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A349C: 4B985C6D  bl 0x82229108
	ctx.lr = 0x828A34A0;
	sub_82229108(ctx, base);
	// 828A34A0: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A34A4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A34A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A34AC: 3BEB2F28  addi r31, r11, 0x2f28
	ctx.r[31].s64 = ctx.r[11].s64 + 12072;
	// 828A34B0: 4B9843D1  bl 0x82227880
	ctx.lr = 0x828A34B4;
	sub_82227880(ctx, base);
	// 828A34B4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828A34B8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828A34BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A34C0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828A34C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A34C8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A34CC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828A34D0: 4B8F75B1  bl 0x8219aa80
	ctx.lr = 0x828A34D4;
	sub_8219AA80(ctx, base);
	// 828A34D4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828A34D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A34DC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828A34E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A34E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A34E8: 4BB2AF39  bl 0x823ce420
	ctx.lr = 0x828A34EC;
	sub_823CE420(ctx, base);
	// 828A34EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A34F0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A34F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A34F8: 481811D1  bl 0x82a246c8
	ctx.lr = 0x828A34FC;
	sub_82A246C8(ctx, base);
	// 828A34FC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3500: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828A3504: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828A3508: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828A350C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A3510: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828A3514: 419A0020  beq cr6, 0x828a3534
	if ctx.cr[6].eq {
	pc = 0x828A3534; continue 'dispatch;
	}
	// 828A3518: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A351C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3520: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3524: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A3528: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A352C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3530: 4082FFE8  bne 0x828a3518
	if !ctx.cr[0].eq {
	pc = 0x828A3518; continue 'dispatch;
	}
	// 828A3534: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3538: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A353C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A3540: 4BA52409  bl 0x822f5948
	ctx.lr = 0x828A3544;
	sub_822F5948(ctx, base);
	// 828A3544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3548: 4B9145D1  bl 0x821b7b18
	ctx.lr = 0x828A354C;
	sub_821B7B18(ctx, base);
	// 828A354C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A3550: 419A0040  beq cr6, 0x828a3590
	if ctx.cr[6].eq {
	pc = 0x828A3590; continue 'dispatch;
	}
	// 828A3554: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3558: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A355C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3560: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3564: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3568: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A356C: 4082FFE8  bne 0x828a3554
	if !ctx.cr[0].eq {
	pc = 0x828A3554; continue 'dispatch;
	}
	// 828A3570: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3574: 409A001C  bne cr6, 0x828a3590
	if !ctx.cr[6].eq {
	pc = 0x828A3590; continue 'dispatch;
	}
	// 828A3578: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A357C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3580: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3584: 4E800421  bctrl
	ctx.lr = 0x828A3588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3588: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A358C: 4B9787AD  bl 0x8221bd38
	ctx.lr = 0x828A3590;
	sub_8221BD38(ctx, base);
	// 828A3590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3594: 4B914585  bl 0x821b7b18
	ctx.lr = 0x828A3598;
	sub_821B7B18(ctx, base);
	// 828A3598: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A359C: 48405EB4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A35A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A35A0 size=516
    let mut pc: u32 = 0x828A35A0;
    'dispatch: loop {
        match pc {
            0x828A35A0 => {
    //   block [0x828A35A0..0x828A37A4)
	// 828A35A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A35A4: 48405E59  bl 0x82ca93fc
	ctx.lr = 0x828A35A8;
	sub_82CA93D0(ctx, base);
	// 828A35A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A35AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A35B0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A35B4: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A35B8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828A35BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A35C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A35C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A35C8: 3BAA3080  addi r29, r10, 0x3080
	ctx.r[29].s64 = ctx.r[10].s64 + 12416;
	// 828A35CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A35D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A35D4: 419A0008  beq cr6, 0x828a35dc
	if ctx.cr[6].eq {
	pc = 0x828A35DC; continue 'dispatch;
	}
	// 828A35D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A35DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A35E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A35E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A35E8: 4BB2AFD9  bl 0x823ce5c0
	ctx.lr = 0x828A35EC;
	sub_823CE5C0(ctx, base);
	// 828A35EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A35F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A35F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A35F8: 4BB2AB19  bl 0x823ce110
	ctx.lr = 0x828A35FC;
	sub_823CE110(ctx, base);
	// 828A35FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A3600: 4B914519  bl 0x821b7b18
	ctx.lr = 0x828A3604;
	sub_821B7B18(ctx, base);
	// 828A3604: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3608: 4B97BC51  bl 0x8221f258
	ctx.lr = 0x828A360C;
	sub_8221F258(ctx, base);
	// 828A360C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3614: 419A005C  beq cr6, 0x828a3670
	if ctx.cr[6].eq {
	pc = 0x828A3670; continue 'dispatch;
	}
	// 828A3618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A361C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A3620: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A3624: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A3628: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A362C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3630: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3634: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A3638: 4B94CC09  bl 0x821f0240
	ctx.lr = 0x828A363C;
	sub_821F0240(ctx, base);
	// 828A363C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A3640: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A3644: 4B97BC15  bl 0x8221f258
	ctx.lr = 0x828A3648;
	sub_8221F258(ctx, base);
	// 828A3648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A364C: 419A0028  beq cr6, 0x828a3674
	if ctx.cr[6].eq {
	pc = 0x828A3674; continue 'dispatch;
	}
	// 828A3650: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A3654: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A3658: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A365C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A3660: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A3664: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3668: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A366C: 4800000C  b 0x828a3678
	pc = 0x828A3678; continue 'dispatch;
	// 828A3670: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A3674: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A3678: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A367C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A3680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3684: 419A0008  beq cr6, 0x828a368c
	if ctx.cr[6].eq {
	pc = 0x828A368C; continue 'dispatch;
	}
	// 828A3688: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A368C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A3690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3694: 419A0078  beq cr6, 0x828a370c
	if ctx.cr[6].eq {
	pc = 0x828A370C; continue 'dispatch;
	}
	// 828A3698: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A369C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A36A0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A36A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A36A8: 4B985A61  bl 0x82229108
	ctx.lr = 0x828A36AC;
	sub_82229108(ctx, base);
	// 828A36AC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A36B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A36B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A36B8: 3BCB3BB0  addi r30, r11, 0x3bb0
	ctx.r[30].s64 = ctx.r[11].s64 + 15280;
	// 828A36BC: 4B9841C5  bl 0x82227880
	ctx.lr = 0x828A36C0;
	sub_82227880(ctx, base);
	// 828A36C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A36C4: 3D408296  lis r10, -0x7d6a
	ctx.r[10].s64 = -2104098816;
	// 828A36C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A36CC: 388A7468  addi r4, r10, 0x7468
	ctx.r[4].s64 = ctx.r[10].s64 + 29800;
	// 828A36D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A36D4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A36D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A36DC: 4B8F73A5  bl 0x8219aa80
	ctx.lr = 0x828A36E0;
	sub_8219AA80(ctx, base);
	// 828A36E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A36E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A36E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A36EC: 4BB2AD35  bl 0x823ce420
	ctx.lr = 0x828A36F0;
	sub_823CE420(ctx, base);
	// 828A36F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A36F4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A36F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A36FC: 48180FCD  bl 0x82a246c8
	ctx.lr = 0x828A3700;
	sub_82A246C8(ctx, base);
	// 828A3700: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3704: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A3708: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A370C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A3710: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A3714: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A3718: 419A0020  beq cr6, 0x828a3738
	if ctx.cr[6].eq {
	pc = 0x828A3738; continue 'dispatch;
	}
	// 828A371C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3720: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3724: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3728: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A372C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3730: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3734: 4082FFE8  bne 0x828a371c
	if !ctx.cr[0].eq {
	pc = 0x828A371C; continue 'dispatch;
	}
	// 828A3738: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A373C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3740: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A3744: 4BA52205  bl 0x822f5948
	ctx.lr = 0x828A3748;
	sub_822F5948(ctx, base);
	// 828A3748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A374C: 4B9143CD  bl 0x821b7b18
	ctx.lr = 0x828A3750;
	sub_821B7B18(ctx, base);
	// 828A3750: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A3754: 419A0040  beq cr6, 0x828a3794
	if ctx.cr[6].eq {
	pc = 0x828A3794; continue 'dispatch;
	}
	// 828A3758: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A375C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3760: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3764: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3768: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A376C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3770: 4082FFE8  bne 0x828a3758
	if !ctx.cr[0].eq {
	pc = 0x828A3758; continue 'dispatch;
	}
	// 828A3774: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3778: 409A001C  bne cr6, 0x828a3794
	if !ctx.cr[6].eq {
	pc = 0x828A3794; continue 'dispatch;
	}
	// 828A377C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3780: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3788: 4E800421  bctrl
	ctx.lr = 0x828A378C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A378C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A3790: 4B9785A9  bl 0x8221bd38
	ctx.lr = 0x828A3794;
	sub_8221BD38(ctx, base);
	// 828A3794: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3798: 4B914381  bl 0x821b7b18
	ctx.lr = 0x828A379C;
	sub_821B7B18(ctx, base);
	// 828A379C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A37A0: 48405CAC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A37A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A37A8 size=516
    let mut pc: u32 = 0x828A37A8;
    'dispatch: loop {
        match pc {
            0x828A37A8 => {
    //   block [0x828A37A8..0x828A39AC)
	// 828A37A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A37AC: 48405C51  bl 0x82ca93fc
	ctx.lr = 0x828A37B0;
	sub_82CA93D0(ctx, base);
	// 828A37B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A37B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A37B8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A37BC: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A37C0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828A37C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A37C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A37CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A37D0: 3BAA3118  addi r29, r10, 0x3118
	ctx.r[29].s64 = ctx.r[10].s64 + 12568;
	// 828A37D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A37D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A37DC: 419A0008  beq cr6, 0x828a37e4
	if ctx.cr[6].eq {
	pc = 0x828A37E4; continue 'dispatch;
	}
	// 828A37E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A37E4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A37E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A37EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A37F0: 4BB2ADD1  bl 0x823ce5c0
	ctx.lr = 0x828A37F4;
	sub_823CE5C0(ctx, base);
	// 828A37F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A37F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A37FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A3800: 4BB2A911  bl 0x823ce110
	ctx.lr = 0x828A3804;
	sub_823CE110(ctx, base);
	// 828A3804: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A3808: 4B914311  bl 0x821b7b18
	ctx.lr = 0x828A380C;
	sub_821B7B18(ctx, base);
	// 828A380C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3810: 4B97BA49  bl 0x8221f258
	ctx.lr = 0x828A3814;
	sub_8221F258(ctx, base);
	// 828A3814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3818: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A381C: 419A005C  beq cr6, 0x828a3878
	if ctx.cr[6].eq {
	pc = 0x828A3878; continue 'dispatch;
	}
	// 828A3820: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A3824: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A3828: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A382C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A3830: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3838: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A383C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A3840: 4B94CA01  bl 0x821f0240
	ctx.lr = 0x828A3844;
	sub_821F0240(ctx, base);
	// 828A3844: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A3848: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A384C: 4B97BA0D  bl 0x8221f258
	ctx.lr = 0x828A3850;
	sub_8221F258(ctx, base);
	// 828A3850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A3854: 419A0028  beq cr6, 0x828a387c
	if ctx.cr[6].eq {
	pc = 0x828A387C; continue 'dispatch;
	}
	// 828A3858: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A385C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A3860: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3864: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A3868: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A386C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3870: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A3874: 4800000C  b 0x828a3880
	pc = 0x828A3880; continue 'dispatch;
	// 828A3878: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A387C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A3880: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3884: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A3888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A388C: 419A0008  beq cr6, 0x828a3894
	if ctx.cr[6].eq {
	pc = 0x828A3894; continue 'dispatch;
	}
	// 828A3890: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3894: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A3898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A389C: 419A0078  beq cr6, 0x828a3914
	if ctx.cr[6].eq {
	pc = 0x828A3914; continue 'dispatch;
	}
	// 828A38A0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A38A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A38A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A38AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A38B0: 4B985859  bl 0x82229108
	ctx.lr = 0x828A38B4;
	sub_82229108(ctx, base);
	// 828A38B4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A38B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A38BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A38C0: 3BCB3D78  addi r30, r11, 0x3d78
	ctx.r[30].s64 = ctx.r[11].s64 + 15736;
	// 828A38C4: 4B983FBD  bl 0x82227880
	ctx.lr = 0x828A38C8;
	sub_82227880(ctx, base);
	// 828A38C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A38CC: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828A38D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A38D4: 388A3B58  addi r4, r10, 0x3b58
	ctx.r[4].s64 = ctx.r[10].s64 + 15192;
	// 828A38D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A38DC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A38E0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A38E4: 4B8F719D  bl 0x8219aa80
	ctx.lr = 0x828A38E8;
	sub_8219AA80(ctx, base);
	// 828A38E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A38EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A38F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A38F4: 4BB2AB2D  bl 0x823ce420
	ctx.lr = 0x828A38F8;
	sub_823CE420(ctx, base);
	// 828A38F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A38FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A3900: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A3904: 48180DC5  bl 0x82a246c8
	ctx.lr = 0x828A3908;
	sub_82A246C8(ctx, base);
	// 828A3908: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A390C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A3910: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A3914: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A3918: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A391C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A3920: 419A0020  beq cr6, 0x828a3940
	if ctx.cr[6].eq {
	pc = 0x828A3940; continue 'dispatch;
	}
	// 828A3924: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3928: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A392C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3930: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A3934: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3938: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A393C: 4082FFE8  bne 0x828a3924
	if !ctx.cr[0].eq {
	pc = 0x828A3924; continue 'dispatch;
	}
	// 828A3940: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3948: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A394C: 4BA51FFD  bl 0x822f5948
	ctx.lr = 0x828A3950;
	sub_822F5948(ctx, base);
	// 828A3950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3954: 4B9141C5  bl 0x821b7b18
	ctx.lr = 0x828A3958;
	sub_821B7B18(ctx, base);
	// 828A3958: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A395C: 419A0040  beq cr6, 0x828a399c
	if ctx.cr[6].eq {
	pc = 0x828A399C; continue 'dispatch;
	}
	// 828A3960: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3964: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3968: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A396C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3970: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3974: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3978: 4082FFE8  bne 0x828a3960
	if !ctx.cr[0].eq {
	pc = 0x828A3960; continue 'dispatch;
	}
	// 828A397C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3980: 409A001C  bne cr6, 0x828a399c
	if !ctx.cr[6].eq {
	pc = 0x828A399C; continue 'dispatch;
	}
	// 828A3984: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3988: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A398C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3990: 4E800421  bctrl
	ctx.lr = 0x828A3994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A3998: 4B9783A1  bl 0x8221bd38
	ctx.lr = 0x828A399C;
	sub_8221BD38(ctx, base);
	// 828A399C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A39A0: 4B914179  bl 0x821b7b18
	ctx.lr = 0x828A39A4;
	sub_821B7B18(ctx, base);
	// 828A39A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A39A8: 48405AA4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A39B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A39B0 size=512
    let mut pc: u32 = 0x828A39B0;
    'dispatch: loop {
        match pc {
            0x828A39B0 => {
    //   block [0x828A39B0..0x828A3BB0)
	// 828A39B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A39B4: 48405A49  bl 0x82ca93fc
	ctx.lr = 0x828A39B8;
	sub_82CA93D0(ctx, base);
	// 828A39B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A39BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A39C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A39C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A39C8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828A39CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A39D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A39D4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828A39D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A39DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A39E0: 419A0008  beq cr6, 0x828a39e8
	if ctx.cr[6].eq {
	pc = 0x828A39E8; continue 'dispatch;
	}
	// 828A39E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A39E8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A39EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A39F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A39F4: 4BB2ABCD  bl 0x823ce5c0
	ctx.lr = 0x828A39F8;
	sub_823CE5C0(ctx, base);
	// 828A39F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A39FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3A00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A3A04: 4BB2A70D  bl 0x823ce110
	ctx.lr = 0x828A3A08;
	sub_823CE110(ctx, base);
	// 828A3A08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A3A0C: 4B91410D  bl 0x821b7b18
	ctx.lr = 0x828A3A10;
	sub_821B7B18(ctx, base);
	// 828A3A10: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3A14: 4B97B845  bl 0x8221f258
	ctx.lr = 0x828A3A18;
	sub_8221F258(ctx, base);
	// 828A3A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3A1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3A20: 419A005C  beq cr6, 0x828a3a7c
	if ctx.cr[6].eq {
	pc = 0x828A3A7C; continue 'dispatch;
	}
	// 828A3A24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A3A28: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A3A2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A3A30: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A3A34: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3A38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3A3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3A40: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A3A44: 4B94C7FD  bl 0x821f0240
	ctx.lr = 0x828A3A48;
	sub_821F0240(ctx, base);
	// 828A3A48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A3A4C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A3A50: 4B97B809  bl 0x8221f258
	ctx.lr = 0x828A3A54;
	sub_8221F258(ctx, base);
	// 828A3A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A3A58: 419A0028  beq cr6, 0x828a3a80
	if ctx.cr[6].eq {
	pc = 0x828A3A80; continue 'dispatch;
	}
	// 828A3A5C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A3A60: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A3A64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3A68: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A3A6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A3A70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3A74: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A3A78: 4800000C  b 0x828a3a84
	pc = 0x828A3A84; continue 'dispatch;
	// 828A3A7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A3A80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A3A84: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3A88: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A3A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3A90: 419A0008  beq cr6, 0x828a3a98
	if ctx.cr[6].eq {
	pc = 0x828A3A98; continue 'dispatch;
	}
	// 828A3A94: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3A98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A3A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3AA0: 419A0078  beq cr6, 0x828a3b18
	if ctx.cr[6].eq {
	pc = 0x828A3B18; continue 'dispatch;
	}
	// 828A3AA4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3AA8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A3AAC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3AB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A3AB4: 4B985655  bl 0x82229108
	ctx.lr = 0x828A3AB8;
	sub_82229108(ctx, base);
	// 828A3AB8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 828A3ABC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A3AC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A3AC4: 3BCBBBC0  addi r30, r11, -0x4440
	ctx.r[30].s64 = ctx.r[11].s64 + -17472;
	// 828A3AC8: 4B983DB9  bl 0x82227880
	ctx.lr = 0x828A3ACC;
	sub_82227880(ctx, base);
	// 828A3ACC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3AD0: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828A3AD4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A3AD8: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828A3ADC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A3AE0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A3AE4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A3AE8: 4B8F6F99  bl 0x8219aa80
	ctx.lr = 0x828A3AEC;
	sub_8219AA80(ctx, base);
	// 828A3AEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A3AF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A3AF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3AF8: 4BB2A929  bl 0x823ce420
	ctx.lr = 0x828A3AFC;
	sub_823CE420(ctx, base);
	// 828A3AFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A3B00: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A3B04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A3B08: 48180BC1  bl 0x82a246c8
	ctx.lr = 0x828A3B0C;
	sub_82A246C8(ctx, base);
	// 828A3B0C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3B10: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A3B14: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A3B18: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A3B1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A3B20: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A3B24: 419A0020  beq cr6, 0x828a3b44
	if ctx.cr[6].eq {
	pc = 0x828A3B44; continue 'dispatch;
	}
	// 828A3B28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3B2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3B30: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3B34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A3B38: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3B3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3B40: 4082FFE8  bne 0x828a3b28
	if !ctx.cr[0].eq {
	pc = 0x828A3B28; continue 'dispatch;
	}
	// 828A3B44: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3B48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3B4C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A3B50: 4BA51DF9  bl 0x822f5948
	ctx.lr = 0x828A3B54;
	sub_822F5948(ctx, base);
	// 828A3B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3B58: 4B913FC1  bl 0x821b7b18
	ctx.lr = 0x828A3B5C;
	sub_821B7B18(ctx, base);
	// 828A3B5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A3B60: 419A0040  beq cr6, 0x828a3ba0
	if ctx.cr[6].eq {
	pc = 0x828A3BA0; continue 'dispatch;
	}
	// 828A3B64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A3B68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3B6C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A3B70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3B74: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3B78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3B7C: 4082FFE8  bne 0x828a3b64
	if !ctx.cr[0].eq {
	pc = 0x828A3B64; continue 'dispatch;
	}
	// 828A3B80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3B84: 409A001C  bne cr6, 0x828a3ba0
	if !ctx.cr[6].eq {
	pc = 0x828A3BA0; continue 'dispatch;
	}
	// 828A3B88: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3B8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3B94: 4E800421  bctrl
	ctx.lr = 0x828A3B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3B98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A3B9C: 4B97819D  bl 0x8221bd38
	ctx.lr = 0x828A3BA0;
	sub_8221BD38(ctx, base);
	// 828A3BA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3BA4: 4B913F75  bl 0x821b7b18
	ctx.lr = 0x828A3BA8;
	sub_821B7B18(ctx, base);
	// 828A3BA8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A3BAC: 484058A0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3BB0 size=456
    let mut pc: u32 = 0x828A3BB0;
    'dispatch: loop {
        match pc {
            0x828A3BB0 => {
    //   block [0x828A3BB0..0x828A3D78)
	// 828A3BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3BC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3BC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A3BCC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828A3BD0: 419A0018  beq cr6, 0x828a3be8
	if ctx.cr[6].eq {
	pc = 0x828A3BE8; continue 'dispatch;
	}
	// 828A3BD4: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A3BD8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A3BDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A3BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A3BE4: 409A0008  bne cr6, 0x828a3bec
	if !ctx.cr[6].eq {
	pc = 0x828A3BEC; continue 'dispatch;
	}
	// 828A3BE8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A3BEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A3BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3BF4: 419A0160  beq cr6, 0x828a3d54
	if ctx.cr[6].eq {
	pc = 0x828A3D54; continue 'dispatch;
	}
	// 828A3BF8: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A3BFC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A3C00: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828A3C04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A3C08: 419A00E8  beq cr6, 0x828a3cf0
	if ctx.cr[6].eq {
	pc = 0x828A3CF0; continue 'dispatch;
	}
	// 828A3C0C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A3C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3C14: 419A0020  beq cr6, 0x828a3c34
	if ctx.cr[6].eq {
	pc = 0x828A3C34; continue 'dispatch;
	}
	// 828A3C18: 894B0059  lbz r10, 0x59(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 828A3C1C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A3C20: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A3C24: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A3C28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3C2C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3C30: 480000C4  b 0x828a3cf4
	pc = 0x828A3CF4; continue 'dispatch;
	// 828A3C34: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A3C38: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A3C3C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A3C40: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A3C44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A3C48: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3C4C: 40810054  ble 0x828a3ca0
	if !ctx.cr[0].gt {
	pc = 0x828A3CA0; continue 'dispatch;
	}
	// 828A3C50: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A3C54: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A3C58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A3C5C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3C60: 2F070059  cmpwi cr6, r7, 0x59
	ctx.cr[6].compare_i32(ctx.r[7].s32, 89, &mut ctx.xer);
	// 828A3C64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A3C68: 41980008  blt cr6, 0x828a3c70
	if ctx.cr[6].lt {
	pc = 0x828A3C70; continue 'dispatch;
	}
	// 828A3C6C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828A3C70: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A3C74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A3C78: 419A0014  beq cr6, 0x828a3c8c
	if ctx.cr[6].eq {
	pc = 0x828A3C8C; continue 'dispatch;
	}
	// 828A3C7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A3C80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A3C84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3C88: 4800000C  b 0x828a3c94
	pc = 0x828A3C94; continue 'dispatch;
	// 828A3C8C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A3C90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A3C94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3C98: 4199FFB8  bgt cr6, 0x828a3c50
	if ctx.cr[6].gt {
	pc = 0x828A3C50; continue 'dispatch;
	}
	// 828A3C9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A3CA0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A3CA4: 419A003C  beq cr6, 0x828a3ce0
	if ctx.cr[6].eq {
	pc = 0x828A3CE0; continue 'dispatch;
	}
	// 828A3CA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3CAC: 2F0B0059  cmpwi cr6, r11, 0x59
	ctx.cr[6].compare_i32(ctx.r[11].s32, 89, &mut ctx.xer);
	// 828A3CB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A3CB4: 41990008  bgt cr6, 0x828a3cbc
	if ctx.cr[6].gt {
	pc = 0x828A3CBC; continue 'dispatch;
	}
	// 828A3CB8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A3CBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A3CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3CC4: 409A001C  bne cr6, 0x828a3ce0
	if !ctx.cr[6].eq {
	pc = 0x828A3CE0; continue 'dispatch;
	}
	// 828A3CC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A3CCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3CD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A3CD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A3CD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3CDC: 48000018  b 0x828a3cf4
	pc = 0x828A3CF4; continue 'dispatch;
	// 828A3CE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A3CE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3CE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3CEC: 48000008  b 0x828a3cf4
	pc = 0x828A3CF4; continue 'dispatch;
	// 828A3CF0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828A3CF4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A3CF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A3CFC: 419A0058  beq cr6, 0x828a3d54
	if ctx.cr[6].eq {
	pc = 0x828A3D54; continue 'dispatch;
	}
	// 828A3D00: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A3D04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828A3D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3D0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A3D10: 4E800421  bctrl
	ctx.lr = 0x828A3D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3D14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3D18: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3D20: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828A3D24: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3D28: 419A0020  beq cr6, 0x828a3d48
	if ctx.cr[6].eq {
	pc = 0x828A3D48; continue 'dispatch;
	}
	// 828A3D2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A3D30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3D34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A3D38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A3D3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A3D40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A3D44: 4082FFE8  bne 0x828a3d2c
	if !ctx.cr[0].eq {
	pc = 0x828A3D2C; continue 'dispatch;
	}
	// 828A3D48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3D4C: 4B913DCD  bl 0x821b7b18
	ctx.lr = 0x828A3D50;
	sub_821B7B18(ctx, base);
	// 828A3D50: 4800000C  b 0x828a3d5c
	pc = 0x828A3D5C; continue 'dispatch;
	// 828A3D54: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A3D58: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828A3D5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3D60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3D6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3D70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3D78 size=352
    let mut pc: u32 = 0x828A3D78;
    'dispatch: loop {
        match pc {
            0x828A3D78 => {
    //   block [0x828A3D78..0x828A3ED8)
	// 828A3D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3D80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3D84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A3D88: 419A0018  beq cr6, 0x828a3da0
	if ctx.cr[6].eq {
	pc = 0x828A3DA0; continue 'dispatch;
	}
	// 828A3D8C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A3D90: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A3D94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A3D98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A3D9C: 409A0008  bne cr6, 0x828a3da4
	if !ctx.cr[6].eq {
	pc = 0x828A3DA4; continue 'dispatch;
	}
	// 828A3DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3DA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A3DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3DAC: 419A011C  beq cr6, 0x828a3ec8
	if ctx.cr[6].eq {
	pc = 0x828A3EC8; continue 'dispatch;
	}
	// 828A3DB0: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A3DB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3DB8: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 828A3DBC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A3DC0: 419A00E8  beq cr6, 0x828a3ea8
	if ctx.cr[6].eq {
	pc = 0x828A3EA8; continue 'dispatch;
	}
	// 828A3DC4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A3DC8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A3DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3DD0: 419A001C  beq cr6, 0x828a3dec
	if ctx.cr[6].eq {
	pc = 0x828A3DEC; continue 'dispatch;
	}
	// 828A3DD4: 896B0059  lbz r11, 0x59(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(89 as u32) ) } as u64;
	// 828A3DD8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A3DDC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A3DE0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3DE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3DE8: 480000C4  b 0x828a3eac
	pc = 0x828A3EAC; continue 'dispatch;
	// 828A3DEC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A3DF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3DF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A3DF8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A3DFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A3E00: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3E04: 40810054  ble 0x828a3e58
	if !ctx.cr[0].gt {
	pc = 0x828A3E58; continue 'dispatch;
	}
	// 828A3E08: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A3E0C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A3E10: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A3E14: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3E18: 2F070059  cmpwi cr6, r7, 0x59
	ctx.cr[6].compare_i32(ctx.r[7].s32, 89, &mut ctx.xer);
	// 828A3E1C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A3E20: 41980008  blt cr6, 0x828a3e28
	if ctx.cr[6].lt {
	pc = 0x828A3E28; continue 'dispatch;
	}
	// 828A3E24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A3E28: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A3E2C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A3E30: 419A0014  beq cr6, 0x828a3e44
	if ctx.cr[6].eq {
	pc = 0x828A3E44; continue 'dispatch;
	}
	// 828A3E34: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A3E38: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A3E3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A3E40: 4800000C  b 0x828a3e4c
	pc = 0x828A3E4C; continue 'dispatch;
	// 828A3E44: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A3E48: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A3E4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3E50: 4199FFB8  bgt cr6, 0x828a3e08
	if ctx.cr[6].gt {
	pc = 0x828A3E08; continue 'dispatch;
	}
	// 828A3E54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A3E58: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A3E5C: 419A003C  beq cr6, 0x828a3e98
	if ctx.cr[6].eq {
	pc = 0x828A3E98; continue 'dispatch;
	}
	// 828A3E60: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3E64: 2F0B0059  cmpwi cr6, r11, 0x59
	ctx.cr[6].compare_i32(ctx.r[11].s32, 89, &mut ctx.xer);
	// 828A3E68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A3E6C: 41990008  bgt cr6, 0x828a3e74
	if ctx.cr[6].gt {
	pc = 0x828A3E74; continue 'dispatch;
	}
	// 828A3E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3E74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A3E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3E7C: 409A001C  bne cr6, 0x828a3e98
	if !ctx.cr[6].eq {
	pc = 0x828A3E98; continue 'dispatch;
	}
	// 828A3E80: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A3E84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3E88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A3E8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A3E90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3E94: 48000018  b 0x828a3eac
	pc = 0x828A3EAC; continue 'dispatch;
	// 828A3E98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A3E9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3EA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3EA4: 48000008  b 0x828a3eac
	pc = 0x828A3EAC; continue 'dispatch;
	// 828A3EA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A3EAC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A3EB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A3EB4: 419A0014  beq cr6, 0x828a3ec8
	if ctx.cr[6].eq {
	pc = 0x828A3EC8; continue 'dispatch;
	}
	// 828A3EB8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3EBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A3EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A3EC4: 4E800421  bctrl
	ctx.lr = 0x828A3EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3EC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A3ECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3ED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A3ED8 size=444
    let mut pc: u32 = 0x828A3ED8;
    'dispatch: loop {
        match pc {
            0x828A3ED8 => {
    //   block [0x828A3ED8..0x828A4094)
	// 828A3ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3EDC: 4840551D  bl 0x82ca93f8
	ctx.lr = 0x828A3EE0;
	sub_82CA93D0(ctx, base);
	// 828A3EE0: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 828A3EE4: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828A3EE8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3EEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A3EF0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828A3EF4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A3EF8: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 828A3EFC: 419A0184  beq cr6, 0x828a4080
	if ctx.cr[6].eq {
	pc = 0x828A4080; continue 'dispatch;
	}
	// 828A3F00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3F04: 4815CA8D  bl 0x82a00990
	ctx.lr = 0x828A3F08;
	sub_82A00990(ctx, base);
	// 828A3F08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828A3F0C: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 828A3F10: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 828A3F14: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 828A3F18: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828A3F1C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 828A3F20: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A3F24: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828A3F28: 419A0144  beq cr6, 0x828a406c
	if ctx.cr[6].eq {
	pc = 0x828A406C; continue 'dispatch;
	}
	// 828A3F2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828A3F30: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A3F34: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828A3F38: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 828A3F3C: 3B8BA1D8  addi r28, r11, -0x5e28
	ctx.r[28].s64 = ctx.r[11].s64 + -24104;
	// 828A3F40: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828A3F44: 419A005C  beq cr6, 0x828a3fa0
	if ctx.cr[6].eq {
	pc = 0x828A3FA0; continue 'dispatch;
	}
	// 828A3F48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3F4C: 4815CF2D  bl 0x82a00e78
	ctx.lr = 0x828A3F50;
	sub_82A00E78(ctx, base);
	// 828A3F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3F54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3F58: 419A0040  beq cr6, 0x828a3f98
	if ctx.cr[6].eq {
	pc = 0x828A3F98; continue 'dispatch;
	}
	// 828A3F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A3F60: 807E6DA0  lwz r3, 0x6da0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828A3F64: 4B9402ED  bl 0x821e4250
	ctx.lr = 0x828A3F68;
	sub_821E4250(ctx, base);
	// 828A3F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A3F6C: 419A002C  beq cr6, 0x828a3f98
	if ctx.cr[6].eq {
	pc = 0x828A3F98; continue 'dispatch;
	}
	// 828A3F70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A3F74: 4B8F2C0D  bl 0x82196b80
	ctx.lr = 0x828A3F78;
	sub_82196B80(ctx, base);
	// 828A3F78: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 828A3F7C: 4099001C  ble cr6, 0x828a3f98
	if !ctx.cr[6].gt {
	pc = 0x828A3F98; continue 'dispatch;
	}
	// 828A3F80: D0210054  stfs f1, 0x54(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828A3F84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A3F88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3F8C: EFE1F82A  fadds f31, f1, f31
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 828A3F90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A3F94: 4B9F31F5  bl 0x82297188
	ctx.lr = 0x828A3F98;
	sub_82297188(ctx, base);
	// 828A3F98: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828A3F9C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828A3FA0: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828A3FA4: 4082FF9C  bne 0x828a3f40
	if !ctx.cr[0].eq {
	pc = 0x828A3F40; continue 'dispatch;
	}
	// 828A3FA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A3FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A3FB0: 419A00BC  beq cr6, 0x828a406c
	if ctx.cr[6].eq {
	pc = 0x828A406C; continue 'dispatch;
	}
	// 828A3FB4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A3FB8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828A3FBC: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3FC0: 418200A0  beq 0x828a4060
	if ctx.cr[0].eq {
	pc = 0x828A4060; continue 'dispatch;
	}
	// 828A3FC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A3FC8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A3FCC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A3FD0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A3FD4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A3FD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3FDC: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 828A3FE0: 4B94C9E9  bl 0x821f09c8
	ctx.lr = 0x828A3FE4;
	sub_821F09C8(ctx, base);
	// 828A3FE4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A3FE8: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A3FEC: FC00F090  fmr f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[30].f64;
	// 828A3FF0: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A3FF4: 40990008  ble cr6, 0x828a3ffc
	if !ctx.cr[6].gt {
	pc = 0x828A3FFC; continue 'dispatch;
	}
	// 828A3FF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A3FFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A4000: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4004: 40990008  ble cr6, 0x828a400c
	if !ctx.cr[6].gt {
	pc = 0x828A400C; continue 'dispatch;
	}
	// 828A4008: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A400C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4010: 419A0050  beq cr6, 0x828a4060
	if ctx.cr[6].eq {
	pc = 0x828A4060; continue 'dispatch;
	}
	// 828A4014: 41980008  blt cr6, 0x828a401c
	if ctx.cr[6].lt {
	pc = 0x828A401C; continue 'dispatch;
	}
	// 828A4018: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A401C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828A4020: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A4024: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828A4028: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A402C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828A4030: 4099000C  ble cr6, 0x828a403c
	if !ctx.cr[6].gt {
	pc = 0x828A403C; continue 'dispatch;
	}
	// 828A4034: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A4038: 40990018  ble cr6, 0x828a4050
	if !ctx.cr[6].gt {
	pc = 0x828A4050; continue 'dispatch;
	}
	// 828A403C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4040: 41980008  blt cr6, 0x828a4048
	if ctx.cr[6].lt {
	pc = 0x828A4048; continue 'dispatch;
	}
	// 828A4044: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A4048: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828A404C: 4BFFFFB4  b 0x828a4000
	pc = 0x828A4000; continue 'dispatch;
	// 828A4050: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A4054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4058: 419A0008  beq cr6, 0x828a4060
	if ctx.cr[6].eq {
	pc = 0x828A4060; continue 'dispatch;
	}
	// 828A405C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 828A4060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4064: 419A0008  beq cr6, 0x828a406c
	if ctx.cr[6].eq {
	pc = 0x828A406C; continue 'dispatch;
	}
	// 828A4068: 4B977CD1  bl 0x8221bd38
	ctx.lr = 0x828A406C;
	sub_8221BD38(ctx, base);
	// 828A406C: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 828A4070: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 828A4074: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 828A4078: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A407C: 4B977CBD  bl 0x8221bd38
	ctx.lr = 0x828A4080;
	sub_8221BD38(ctx, base);
	// 828A4080: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828A4084: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828A4088: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828A408C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828A4090: 484053B8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A4098 size=312
    let mut pc: u32 = 0x828A4098;
    'dispatch: loop {
        match pc {
            0x828A4098 => {
    //   block [0x828A4098..0x828A41D0)
	// 828A4098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A409C: 48405359  bl 0x82ca93f4
	ctx.lr = 0x828A40A0;
	sub_82CA93D0(ctx, base);
	// 828A40A0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 828A40A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A40A8: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828A40AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A40B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A40B4: 4815C8DD  bl 0x82a00990
	ctx.lr = 0x828A40B8;
	sub_82A00990(ctx, base);
	// 828A40B8: 83010064  lwz r24, 0x64(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A40BC: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A40C0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828A40C4: 419A00D8  beq cr6, 0x828a419c
	if ctx.cr[6].eq {
	pc = 0x828A419C; continue 'dispatch;
	}
	// 828A40C8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828A40CC: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A40D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828A40D4: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 828A40D8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 828A40DC: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 828A40E0: C3EA9484  lfs f31, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A40E4: 3B8BA1D8  addi r28, r11, -0x5e28
	ctx.r[28].s64 = ctx.r[11].s64 + -24104;
	// 828A40E8: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828A40EC: 419A00A8  beq cr6, 0x828a4194
	if ctx.cr[6].eq {
	pc = 0x828A4194; continue 'dispatch;
	}
	// 828A40F0: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A40F4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828A40F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A40FC: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828A4100: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 828A4104: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828A4108: 419A0020  beq cr6, 0x828a4128
	if ctx.cr[6].eq {
	pc = 0x828A4128; continue 'dispatch;
	}
	// 828A410C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828A4110: 409A00A0  bne cr6, 0x828a41b0
	if !ctx.cr[6].eq {
	pc = 0x828A41B0; continue 'dispatch;
	}
	// 828A4114: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A4118: 815AE454  lwz r10, -0x1bac(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828A411C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4120: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4124: 409A0094  bne cr6, 0x828a41b8
	if !ctx.cr[6].eq {
	pc = 0x828A41B8; continue 'dispatch;
	}
	// 828A4128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A412C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A4130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4134: 419A0058  beq cr6, 0x828a418c
	if ctx.cr[6].eq {
	pc = 0x828A418C; continue 'dispatch;
	}
	// 828A4138: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A413C: 4815CD3D  bl 0x82a00e78
	ctx.lr = 0x828A4140;
	sub_82A00E78(ctx, base);
	// 828A4140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4144: 807D6DA0  lwz r3, 0x6da0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828A4148: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A414C: 4B940105  bl 0x821e4250
	ctx.lr = 0x828A4150;
	sub_821E4250(ctx, base);
	// 828A4150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4154: 419A0038  beq cr6, 0x828a418c
	if ctx.cr[6].eq {
	pc = 0x828A418C; continue 'dispatch;
	}
	// 828A4158: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A415C: 4B8F2A25  bl 0x82196b80
	ctx.lr = 0x828A4160;
	sub_82196B80(ctx, base);
	// 828A4160: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828A4164: 40990028  ble cr6, 0x828a418c
	if !ctx.cr[6].gt {
	pc = 0x828A418C; continue 'dispatch;
	}
	// 828A4168: D0210054  stfs f1, 0x54(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828A416C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A4170: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4174: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A4178: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A417C: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828A4180: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A4184: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828A4188: 4BDDFA19  bl 0x82683ba0
	ctx.lr = 0x828A418C;
	sub_82683BA0(ctx, base);
	// 828A418C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828A4190: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828A4194: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 828A4198: 4082FF50  bne 0x828a40e8
	if !ctx.cr[0].eq {
	pc = 0x828A40E8; continue 'dispatch;
	}
	// 828A419C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A41A0: 4B977B99  bl 0x8221bd38
	ctx.lr = 0x828A41A4;
	sub_8221BD38(ctx, base);
	// 828A41A4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A41A8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828A41AC: 48405298  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828A41B0: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 828A41B4: 419A0010  beq cr6, 0x828a41c4
	if ctx.cr[6].eq {
	pc = 0x828A41C4; continue 'dispatch;
	}
	// 828A41B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A41BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A41C0: 4BFFFF6C  b 0x828a412c
	pc = 0x828A412C; continue 'dispatch;
	// 828A41C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A41C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A41CC: 4BFFFF60  b 0x828a412c
	pc = 0x828A412C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A41D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A41D0 size=172
    let mut pc: u32 = 0x828A41D0;
    'dispatch: loop {
        match pc {
            0x828A41D0 => {
    //   block [0x828A41D0..0x828A427C)
	// 828A41D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A41D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A41D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A41DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A41E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A41E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A41E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A41EC: 419A0078  beq cr6, 0x828a4264
	if ctx.cr[6].eq {
	pc = 0x828A4264; continue 'dispatch;
	}
	// 828A41F0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A41F4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A41F8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A41FC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A4200: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4204: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 828A4208: 4B94C7C1  bl 0x821f09c8
	ctx.lr = 0x828A420C;
	sub_821F09C8(ctx, base);
	// 828A420C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4210: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828A4214: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4218: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A421C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4220: 419A0044  beq cr6, 0x828a4264
	if ctx.cr[6].eq {
	pc = 0x828A4264; continue 'dispatch;
	}
	// 828A4224: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828A4228: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A422C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828A4230: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A4234: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828A4238: 4099000C  ble cr6, 0x828a4244
	if !ctx.cr[6].gt {
	pc = 0x828A4244; continue 'dispatch;
	}
	// 828A423C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A4240: 40990018  ble cr6, 0x828a4258
	if !ctx.cr[6].gt {
	pc = 0x828A4258; continue 'dispatch;
	}
	// 828A4244: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4248: 409A0008  bne cr6, 0x828a4250
	if !ctx.cr[6].eq {
	pc = 0x828A4250; continue 'dispatch;
	}
	// 828A424C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A4250: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4254: 4BFFFFC8  b 0x828a421c
	pc = 0x828A421C; continue 'dispatch;
	// 828A4258: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A425C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4260: 409A0008  bne cr6, 0x828a4268
	if !ctx.cr[6].eq {
	pc = 0x828A4268; continue 'dispatch;
	}
	// 828A4264: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A4268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A426C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A4280 size=24
    let mut pc: u32 = 0x828A4280;
    'dispatch: loop {
        match pc {
            0x828A4280 => {
    //   block [0x828A4280..0x828A4298)
	// 828A4280: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828A4284: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4288: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A428C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4290: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A4294: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A4298 size=52
    let mut pc: u32 = 0x828A4298;
    'dispatch: loop {
        match pc {
            0x828A4298 => {
    //   block [0x828A4298..0x828A42CC)
	// 828A4298: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A429C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A42A0: 409A0008  bne cr6, 0x828a42a8
	if !ctx.cr[6].eq {
	pc = 0x828A42A8; continue 'dispatch;
	}
	// 828A42A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A42A8: E90B0008  ld r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828A42AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A42B0: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828A42B4: C001FFF4  lfs f0, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A42B8: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 828A42BC: 409A0008  bne cr6, 0x828a42c4
	if !ctx.cr[6].eq {
	pc = 0x828A42C4; continue 'dispatch;
	}
	// 828A42C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A42C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A42C8: 4BFFFFC8  b 0x828a4290
	sub_828A4280(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A42CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A42CC size=4
    let mut pc: u32 = 0x828A42CC;
    'dispatch: loop {
        match pc {
            0x828A42CC => {
    //   block [0x828A42CC..0x828A42D0)
	// 828A42CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A42D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A42D0 size=140
    let mut pc: u32 = 0x828A42D0;
    'dispatch: loop {
        match pc {
            0x828A42D0 => {
    //   block [0x828A42D0..0x828A435C)
	// 828A42D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A42D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A42D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A42DC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A42E0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828A42E4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A42E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A42EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A42F0: 419A0058  beq cr6, 0x828a4348
	if ctx.cr[6].eq {
	pc = 0x828A4348; continue 'dispatch;
	}
	// 828A42F4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A42F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A42FC: 409A0008  bne cr6, 0x828a4304
	if !ctx.cr[6].eq {
	pc = 0x828A4304; continue 'dispatch;
	}
	// 828A4300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A4304: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A4308: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828A430C: 419A0018  beq cr6, 0x828a4324
	if ctx.cr[6].eq {
	pc = 0x828A4324; continue 'dispatch;
	}
	// 828A4310: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A4314: 409A0008  bne cr6, 0x828a431c
	if !ctx.cr[6].eq {
	pc = 0x828A431C; continue 'dispatch;
	}
	// 828A4318: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A431C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4320: 4BFFFFCC  b 0x828a42ec
	pc = 0x828A42EC; continue 'dispatch;
	// 828A4324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4328: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A432C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A4330: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A4334: 4B935BB5  bl 0x821d9ee8
	ctx.lr = 0x828A4338;
	sub_821D9EE8(ctx, base);
	// 828A4338: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A433C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4344: 4E800020  blr
	return;
	// 828A4348: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A434C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4360 size=60
    let mut pc: u32 = 0x828A4360;
    'dispatch: loop {
        match pc {
            0x828A4360 => {
    //   block [0x828A4360..0x828A439C)
	// 828A4360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4368: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A436C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4370: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A4374: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A4378: 388B9AC8  addi r4, r11, -0x6538
	ctx.r[4].s64 = ctx.r[11].s64 + -25912;
	// 828A437C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4380: 4B988B51  bl 0x8222ced0
	ctx.lr = 0x828A4384;
	sub_8222CED0(ctx, base);
	// 828A4384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4388: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A438C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4394: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A43A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A43A0 size=296
    let mut pc: u32 = 0x828A43A0;
    'dispatch: loop {
        match pc {
            0x828A43A0 => {
    //   block [0x828A43A0..0x828A44C8)
	// 828A43A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A43A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A43A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A43AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A43B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A43B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A43B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A43BC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A43C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A43C4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A43C8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A43CC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A43D0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A43D4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A43D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A43DC: 419A00E4  beq cr6, 0x828a44c0
	if ctx.cr[6].eq {
	pc = 0x828A44C0; continue 'dispatch;
	}
	// 828A43E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A43E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A43E8: 419A00D4  beq cr6, 0x828a44bc
	if ctx.cr[6].eq {
	pc = 0x828A44BC; continue 'dispatch;
	}
	// 828A43EC: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828A43F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A43F4: 419A0018  beq cr6, 0x828a440c
	if ctx.cr[6].eq {
	pc = 0x828A440C; continue 'dispatch;
	}
	// 828A43F8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A43FC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A4400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A4404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A4408: 409A0008  bne cr6, 0x828a4410
	if !ctx.cr[6].eq {
	pc = 0x828A4410; continue 'dispatch;
	}
	// 828A440C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4410: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A4414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4418: 419A0088  beq cr6, 0x828a44a0
	if ctx.cr[6].eq {
	pc = 0x828A44A0; continue 'dispatch;
	}
	// 828A441C: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A4420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4424: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4428: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A442C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A4430: 4E800421  bctrl
	ctx.lr = 0x828A4434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4438: 4B8CFA01  bl 0x82173e38
	ctx.lr = 0x828A443C;
	sub_82173E38(ctx, base);
	// 828A443C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828A4440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4444: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A4448: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A444C: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A4450: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828A4454: 4E800421  bctrl
	ctx.lr = 0x828A4458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4458: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A445C: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A4460: 4B951761  bl 0x821f5bc0
	ctx.lr = 0x828A4464;
	sub_821F5BC0(ctx, base);
	// 828A4464: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A4468: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A44C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A44C8 size=96
    let mut pc: u32 = 0x828A44C8;
    'dispatch: loop {
        match pc {
            0x828A44C8 => {
    //   block [0x828A44C8..0x828A4528)
	// 828A44C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A44CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A44D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A44D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A44D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A44DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A44E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A44E4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828A44E8: 48001539  bl 0x828a5a20
	ctx.lr = 0x828A44EC;
	sub_828A5A20(ctx, base);
	// 828A44EC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828A44F0: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828A44F4: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828A44F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A44FC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4504: 419A000C  beq cr6, 0x828a4510
	if ctx.cr[6].eq {
	pc = 0x828A4510; continue 'dispatch;
	}
	// 828A4508: 4B977831  bl 0x8221bd38
	ctx.lr = 0x828A450C;
	sub_8221BD38(ctx, base);
	// 828A450C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4510: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A451C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4528 size=1484
    let mut pc: u32 = 0x828A4528;
    'dispatch: loop {
        match pc {
            0x828A4528 => {
    //   block [0x828A4528..0x828A4AF4)
	// 828A4528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A452C: 48404EA9  bl 0x82ca93d4
	ctx.lr = 0x828A4530;
	sub_82CA93D0(ctx, base);
	// 828A4530: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4534: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 828A4538: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A453C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4540: 38EA2360  addi r7, r10, 0x2360
	ctx.r[7].s64 = ctx.r[10].s64 + 9056;
	// 828A4544: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4548: 80CB001C  lwz r6, 0x1c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828A454C: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A4550: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 828A4554: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 828A4558: 4B90DFA1  bl 0x821b24f8
	ctx.lr = 0x828A455C;
	sub_821B24F8(ctx, base);
	// 828A455C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828A4560: 4BA05489  bl 0x822a99e8
	ctx.lr = 0x828A4564;
	sub_822A99E8(ctx, base);
	// 828A4564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4568: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A456C: 419A0580  beq cr6, 0x828a4aec
	if ctx.cr[6].eq {
	pc = 0x828A4AEC; continue 'dispatch;
	}
	// 828A4570: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 828A4574: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828A4578: 617E9DC5  ori r30, r11, 0x9dc5
	ctx.r[30].u64 = ctx.r[11].u64 | 40389;
	// 828A457C: 386AABAC  addi r3, r10, -0x5454
	ctx.r[3].s64 = ctx.r[10].s64 + -21588;
	// 828A4580: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A4584: 4B94F7D5  bl 0x821f3d58
	ctx.lr = 0x828A4588;
	sub_821F3D58(ctx, base);
	// 828A4588: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 828A458C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A4590: 38692FB4  addi r3, r9, 0x2fb4
	ctx.r[3].s64 = ctx.r[9].s64 + 12212;
	// 828A4594: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A4598: 4B94F7C1  bl 0x821f3d58
	ctx.lr = 0x828A459C;
	sub_821F3D58(ctx, base);
	// 828A459C: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A45A0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828A45A4: 38682374  addi r3, r8, 0x2374
	ctx.r[3].s64 = ctx.r[8].s64 + 9076;
	// 828A45A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A45AC: 4B94F7AD  bl 0x821f3d58
	ctx.lr = 0x828A45B0;
	sub_821F3D58(ctx, base);
	// 828A45B0: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828A45B4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A45B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A45BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A45C0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A45C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A45C8: 4815BE51  bl 0x82a00418
	ctx.lr = 0x828A45CC;
	sub_82A00418(ctx, base);
	// 828A45CC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A45D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A45D4: 419A000C  beq cr6, 0x828a45e0
	if ctx.cr[6].eq {
	pc = 0x828A45E0; continue 'dispatch;
	}
	// 828A45D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A45DC: 916F000C  stw r11, 0xc(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828A45E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A45E4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A45E8: 4815C3A9  bl 0x82a00990
	ctx.lr = 0x828A45EC;
	sub_82A00990(ctx, base);
	// 828A45EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A45F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A45F4: 3A2B0B7C  addi r17, r11, 0xb7c
	ctx.r[17].s64 = ctx.r[11].s64 + 2940;
	// 828A45F8: 3A4A0B7C  addi r18, r10, 0xb7c
	ctx.r[18].s64 = ctx.r[10].s64 + 2940;
	// 828A45FC: 83210090  lwz r25, 0x90(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A4600: 8261008C  lwz r19, 0x8c(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A4604: 82010088  lwz r16, 0x88(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828A4608: 7F199840  cmplw cr6, r25, r19
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[19].u32, &mut ctx.xer);
	// 828A460C: 419A02B4  beq cr6, 0x828a48c0
	if ctx.cr[6].eq {
	pc = 0x828A48C0; continue 'dispatch;
	}
	// 828A4610: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828A4614: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828A4618: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 828A461C: 3EA0834A  lis r21, -0x7cb6
	ctx.r[21].s64 = -2092302336;
	// 828A4620: 3ACBE460  addi r22, r11, -0x1ba0
	ctx.r[22].s64 = ctx.r[11].s64 + -7072;
	// 828A4624: 572B083C  slwi r11, r25, 1
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A4628: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 828A462C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A4630: 7D6B8214  add r11, r11, r16
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[16].u64;
	// 828A4634: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4638: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828A463C: 409A0278  bne cr6, 0x828a48b4
	if !ctx.cr[6].eq {
	pc = 0x828A48B4; continue 'dispatch;
	}
	// 828A4640: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A4644: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4648: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828A464C: 419A0020  beq cr6, 0x828a466c
	if ctx.cr[6].eq {
	pc = 0x828A466C; continue 'dispatch;
	}
	// 828A4650: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828A4654: 409A0018  bne cr6, 0x828a466c
	if !ctx.cr[6].eq {
	pc = 0x828A466C; continue 'dispatch;
	}
	// 828A4658: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A465C: 8135E454  lwz r9, -0x1bac(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828A4660: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A4664: 409A0008  bne cr6, 0x828a466c
	if !ctx.cr[6].eq {
	pc = 0x828A466C; continue 'dispatch;
	}
	// 828A4668: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 828A466C: 80746DA0  lwz r3, 0x6da0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828A4670: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4674: 4B93FBDD  bl 0x821e4250
	ctx.lr = 0x828A4678;
	sub_821E4250(ctx, base);
	// 828A4678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A467C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A4680: 419A0234  beq cr6, 0x828a48b4
	if ctx.cr[6].eq {
	pc = 0x828A48B4; continue 'dispatch;
	}
	// 828A4684: 924100A0  stw r18, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[18].u32 ) };
	// 828A4688: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A468C: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A4690: 4B97ABC9  bl 0x8221f258
	ctx.lr = 0x828A4694;
	sub_8221F258(ctx, base);
	// 828A4694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4698: 419A0008  beq cr6, 0x828a46a0
	if ctx.cr[6].eq {
	pc = 0x828A46A0; continue 'dispatch;
	}
	// 828A469C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828A46A0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A46A4: 41820008  beq 0x828a46ac
	if ctx.cr[0].eq {
	pc = 0x828A46AC; continue 'dispatch;
	}
	// 828A46A8: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828A46AC: 906100AC  stw r3, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 828A46B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A46B4: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 828A46B8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828A46BC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A46C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A46C4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828A46C8: 4B9D7159  bl 0x8227b820
	ctx.lr = 0x828A46CC;
	sub_8227B820(ctx, base);
	// 828A46CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A46D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A46D4: 419A0090  beq cr6, 0x828a4764
	if ctx.cr[6].eq {
	pc = 0x828A4764; continue 'dispatch;
	}
	// 828A46D8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828A46DC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828A46E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A46E4: 4815BFE5  bl 0x82a006c8
	ctx.lr = 0x828A46E8;
	sub_82A006C8(ctx, base);
	// 828A46E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A46EC: 419A000C  beq cr6, 0x828a46f8
	if ctx.cr[6].eq {
	pc = 0x828A46F8; continue 'dispatch;
	}
	// 828A46F0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A46F4: 48000008  b 0x828a46fc
	pc = 0x828A46FC; continue 'dispatch;
	// 828A46F8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828A46FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A4700: 419A0064  beq cr6, 0x828a4764
	if ctx.cr[6].eq {
	pc = 0x828A4764; continue 'dispatch;
	}
	// 828A4704: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A4708: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A470C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828A4710: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 828A4714: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A4718: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A471C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4720: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4724: 4B9BFD65  bl 0x82264488
	ctx.lr = 0x828A4728;
	sub_82264488(ctx, base);
	// 828A4728: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A472C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A4730: 419A0034  beq cr6, 0x828a4764
	if ctx.cr[6].eq {
	pc = 0x828A4764; continue 'dispatch;
	}
	// 828A4734: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 828A4738: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A473C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828A4740: 4B970159  bl 0x82214898
	ctx.lr = 0x828A4744;
	sub_82214898(ctx, base);
	// 828A4744: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A4748: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A474C: 4BC2D77D  bl 0x824d1ec8
	ctx.lr = 0x828A4750;
	sub_824D1EC8(ctx, base);
	// 828A4750: 92210058  stw r17, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[17].u32 ) };
	// 828A4754: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A4758: 4B8EF6E1  bl 0x82193e38
	ctx.lr = 0x828A475C;
	sub_82193E38(ctx, base);
	// 828A475C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828A4760: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828A4764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4768: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A476C: 4815C225  bl 0x82a00990
	ctx.lr = 0x828A4770;
	sub_82A00990(ctx, base);
	// 828A4770: 83E10090  lwz r31, 0x90(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A4774: 8381008C  lwz r28, 0x8c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A4778: 83A10088  lwz r29, 0x88(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828A477C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828A4780: 419A00F8  beq cr6, 0x828a4878
	if ctx.cr[6].eq {
	pc = 0x828A4878; continue 'dispatch;
	}
	// 828A4784: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A4788: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828A478C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A4790: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828A4794: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4798: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828A479C: 409A00CC  bne cr6, 0x828a4868
	if !ctx.cr[6].eq {
	pc = 0x828A4868; continue 'dispatch;
	}
	// 828A47A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A47A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A47A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828A47AC: 419A0020  beq cr6, 0x828a47cc
	if ctx.cr[6].eq {
	pc = 0x828A47CC; continue 'dispatch;
	}
	// 828A47B0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828A47B4: 409A0018  bne cr6, 0x828a47cc
	if !ctx.cr[6].eq {
	pc = 0x828A47CC; continue 'dispatch;
	}
	// 828A47B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A47BC: 8135E454  lwz r9, -0x1bac(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828A47C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A47C4: 409A0008  bne cr6, 0x828a47cc
	if !ctx.cr[6].eq {
	pc = 0x828A47CC; continue 'dispatch;
	}
	// 828A47C8: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 828A47CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A47D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A47D4: 815A6AB8  lwz r10, 0x6ab8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A47D8: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828A47DC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A47E0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A47E4: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A47E8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A47EC: 80670000  lwz r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A47F0: 4B9BFC99  bl 0x82264488
	ctx.lr = 0x828A47F4;
	sub_82264488(ctx, base);
	// 828A47F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A47F8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A47FC: 419A006C  beq cr6, 0x828a4868
	if ctx.cr[6].eq {
	pc = 0x828A4868; continue 'dispatch;
	}
	// 828A4800: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 828A4804: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4808: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828A480C: 4B97008D  bl 0x82214898
	ctx.lr = 0x828A4810;
	sub_82214898(ctx, base);
	// 828A4810: 814100AC  lwz r10, 0xac(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828A4814: 396100A8  addi r11, r1, 0xa8
	ctx.r[11].s64 = ctx.r[1].s64 + 168;
	// 828A4818: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A481C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828A4820: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828A4824: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828A4828: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828A482C: 4BBB18ED  bl 0x82456118
	ctx.lr = 0x828A4830;
	sub_82456118(ctx, base);
	// 828A4830: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A4834: 92210060  stw r17, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[17].u32 ) };
	// 828A4838: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A483C: 419A0024  beq cr6, 0x828a4860
	if ctx.cr[6].eq {
	pc = 0x828A4860; continue 'dispatch;
	}
	// 828A4840: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4844: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4848: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828A484C: 40820014  bne 0x828a4860
	if !ctx.cr[0].eq {
	pc = 0x828A4860; continue 'dispatch;
	}
	// 828A4850: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4858: 409A0008  bne cr6, 0x828a4860
	if !ctx.cr[6].eq {
	pc = 0x828A4860; continue 'dispatch;
	}
	// 828A485C: 4B9774DD  bl 0x8221bd38
	ctx.lr = 0x828A4860;
	sub_8221BD38(ctx, base);
	// 828A4860: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828A4864: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828A4868: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828A486C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828A4870: 409AFF14  bne cr6, 0x828a4784
	if !ctx.cr[6].eq {
	pc = 0x828A4784; continue 'dispatch;
	}
	// 828A4874: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828A4878: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828A487C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4880: 419A0020  beq cr6, 0x828a48a0
	if ctx.cr[6].eq {
	pc = 0x828A48A0; continue 'dispatch;
	}
	// 828A4884: 816F0014  lwz r11, 0x14(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A4888: 386F0010  addi r3, r15, 0x10
	ctx.r[3].s64 = ctx.r[15].s64 + 16;
	// 828A488C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 828A4890: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828A4894: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828A4898: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A489C: 4800109D  bl 0x828a5938
	ctx.lr = 0x828A48A0;
	sub_828A5938(ctx, base);
	// 828A48A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A48A4: 4B977495  bl 0x8221bd38
	ctx.lr = 0x828A48A8;
	sub_8221BD38(ctx, base);
	// 828A48A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A48AC: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 828A48B0: 48000249  bl 0x828a4af8
	ctx.lr = 0x828A48B4;
	sub_828A4AF8(ctx, base);
	// 828A48B4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828A48B8: 7F199840  cmplw cr6, r25, r19
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[19].u32, &mut ctx.xer);
	// 828A48BC: 409AFD68  bne cr6, 0x828a4624
	if !ctx.cr[6].eq {
	pc = 0x828A4624; continue 'dispatch;
	}
	// 828A48C0: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A48C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A48C8: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A48CC: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828A48D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A48D4: 419A00D8  beq cr6, 0x828a49ac
	if ctx.cr[6].eq {
	pc = 0x828A49AC; continue 'dispatch;
	}
	// 828A48D8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A48DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A48E0: 419A001C  beq cr6, 0x828a48fc
	if ctx.cr[6].eq {
	pc = 0x828A48FC; continue 'dispatch;
	}
	// 828A48E4: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A48E8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A48EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A48F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A48F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A48F8: 480000B0  b 0x828a49a8
	pc = 0x828A49A8; continue 'dispatch;
	// 828A48FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A4900: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A4904: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828A4908: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A490C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828A4910: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4914: 40810054  ble 0x828a4968
	if !ctx.cr[0].gt {
	pc = 0x828A4968; continue 'dispatch;
	}
	// 828A4918: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A491C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A4920: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A4924: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4928: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 828A492C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A4930: 41980008  blt cr6, 0x828a4938
	if ctx.cr[6].lt {
	pc = 0x828A4938; continue 'dispatch;
	}
	// 828A4934: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A4938: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A493C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A4940: 419A0014  beq cr6, 0x828a4954
	if ctx.cr[6].eq {
	pc = 0x828A4954; continue 'dispatch;
	}
	// 828A4944: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A4948: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A494C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A4950: 4800000C  b 0x828a495c
	pc = 0x828A495C; continue 'dispatch;
	// 828A4954: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A4958: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A495C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4960: 4199FFB8  bgt cr6, 0x828a4918
	if ctx.cr[6].gt {
	pc = 0x828A4918; continue 'dispatch;
	}
	// 828A4964: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828A4968: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A496C: 419A0034  beq cr6, 0x828a49a0
	if ctx.cr[6].eq {
	pc = 0x828A49A0; continue 'dispatch;
	}
	// 828A4970: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4974: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 828A4978: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A497C: 41990008  bgt cr6, 0x828a4984
	if ctx.cr[6].gt {
	pc = 0x828A4984; continue 'dispatch;
	}
	// 828A4980: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A4984: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A4988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A498C: 409A0014  bne cr6, 0x828a49a0
	if !ctx.cr[6].eq {
	pc = 0x828A49A0; continue 'dispatch;
	}
	// 828A4990: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828A4994: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 828A4998: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828A499C: 48000008  b 0x828a49a4
	pc = 0x828A49A4; continue 'dispatch;
	// 828A49A0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A49A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A49A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A49AC: 4B9FA4CD  bl 0x8229ee78
	ctx.lr = 0x828A49B0;
	sub_8229EE78(ctx, base);
	// 828A49B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A49B4: 419A0130  beq cr6, 0x828a4ae4
	if ctx.cr[6].eq {
	pc = 0x828A4AE4; continue 'dispatch;
	}
	// 828A49B8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A49BC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A49C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A49C4: 419A0120  beq cr6, 0x828a4ae4
	if ctx.cr[6].eq {
	pc = 0x828A4AE4; continue 'dispatch;
	}
	// 828A49C8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A49CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A49D0: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828A49D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A49D8: 419A00D0  beq cr6, 0x828a4aa8
	if ctx.cr[6].eq {
	pc = 0x828A4AA8; continue 'dispatch;
	}
	// 828A49DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A49E0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A49E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A49E8: 419A0018  beq cr6, 0x828a4a00
	if ctx.cr[6].eq {
	pc = 0x828A4A00; continue 'dispatch;
	}
	// 828A49EC: 896B0041  lbz r11, 0x41(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 828A49F0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A49F4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A49F8: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A49FC: 480000AC  b 0x828a4aa8
	pc = 0x828A4AA8; continue 'dispatch;
	// 828A4A00: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A4A04: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828A4A08: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A4A0C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828A4A10: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4A14: 40810054  ble 0x828a4a68
	if !ctx.cr[0].gt {
	pc = 0x828A4A68; continue 'dispatch;
	}
	// 828A4A18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A4A1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A4A20: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A4A24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4A28: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 828A4A2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A4A30: 41980008  blt cr6, 0x828a4a38
	if ctx.cr[6].lt {
	pc = 0x828A4A38; continue 'dispatch;
	}
	// 828A4A34: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A4A38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A4A3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A4A40: 419A0014  beq cr6, 0x828a4a54
	if ctx.cr[6].eq {
	pc = 0x828A4A54; continue 'dispatch;
	}
	// 828A4A44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A4A48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A4A4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A4A50: 4800000C  b 0x828a4a5c
	pc = 0x828A4A5C; continue 'dispatch;
	// 828A4A54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A4A58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A4A5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4A60: 4199FFB8  bgt cr6, 0x828a4a18
	if ctx.cr[6].gt {
	pc = 0x828A4A18; continue 'dispatch;
	}
	// 828A4A64: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828A4A68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A4A6C: 419A0034  beq cr6, 0x828a4aa0
	if ctx.cr[6].eq {
	pc = 0x828A4AA0; continue 'dispatch;
	}
	// 828A4A70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4A74: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 828A4A78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A4A7C: 41990008  bgt cr6, 0x828a4a84
	if ctx.cr[6].gt {
	pc = 0x828A4A84; continue 'dispatch;
	}
	// 828A4A80: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A4A84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A4A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4A8C: 409A0014  bne cr6, 0x828a4aa0
	if !ctx.cr[6].eq {
	pc = 0x828A4AA0; continue 'dispatch;
	}
	// 828A4A90: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828A4A94: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 828A4A98: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828A4A9C: 48000008  b 0x828a4aa4
	pc = 0x828A4AA4; continue 'dispatch;
	// 828A4AA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A4AA4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4AA8: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 828A4AAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4AB0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828A4AB4: 808F0004  lwz r4, 4(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4AB8: 4B96FDE1  bl 0x82214898
	ctx.lr = 0x828A4ABC;
	sub_82214898(ctx, base);
	// 828A4ABC: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 828A4AC0: 387F0128  addi r3, r31, 0x128
	ctx.r[3].s64 = ctx.r[31].s64 + 296;
	// 828A4AC4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A4AC8: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828A4ACC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828A4AD0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A4AD4: 4BBB1645  bl 0x82456118
	ctx.lr = 0x828A4AD8;
	sub_82456118(ctx, base);
	// 828A4AD8: 92210060  stw r17, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[17].u32 ) };
	// 828A4ADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4AE0: 4B8EF359  bl 0x82193e38
	ctx.lr = 0x828A4AE4;
	sub_82193E38(ctx, base);
	// 828A4AE4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828A4AE8: 4B977251  bl 0x8221bd38
	ctx.lr = 0x828A4AEC;
	sub_8221BD38(ctx, base);
	// 828A4AEC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 828A4AF0: 48404934  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4AF8 size=96
    let mut pc: u32 = 0x828A4AF8;
    'dispatch: loop {
        match pc {
            0x828A4AF8 => {
    //   block [0x828A4AF8..0x828A4B58)
	// 828A4AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4B00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4B04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4B10: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828A4B14: 4BE88825  bl 0x8272d338
	ctx.lr = 0x828A4B18;
	sub_8272D338(ctx, base);
	// 828A4B18: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A4B1C: 4B97721D  bl 0x8221bd38
	ctx.lr = 0x828A4B20;
	sub_8221BD38(ctx, base);
	// 828A4B20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A4B24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A4B28: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828A4B2C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828A4B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4B34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A4B38: 4B8EF301  bl 0x82193e38
	ctx.lr = 0x828A4B3C;
	sub_82193E38(ctx, base);
	// 828A4B3C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A4B40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4B4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4B50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4B58 size=312
    let mut pc: u32 = 0x828A4B58;
    'dispatch: loop {
        match pc {
            0x828A4B58 => {
    //   block [0x828A4B58..0x828A4C90)
	// 828A4B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4B60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4B64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4B68: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A4B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4B70: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A4B74: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A4B78: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A4B7C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4B80: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4B84: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A4B88: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A4B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4B90: 419A00E0  beq cr6, 0x828a4c70
	if ctx.cr[6].eq {
	pc = 0x828A4C70; continue 'dispatch;
	}
	// 828A4B94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4B98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A4B9C: 419A00D0  beq cr6, 0x828a4c6c
	if ctx.cr[6].eq {
	pc = 0x828A4C6C; continue 'dispatch;
	}
	// 828A4BA0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A4BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4BA8: 419A0018  beq cr6, 0x828a4bc0
	if ctx.cr[6].eq {
	pc = 0x828A4BC0; continue 'dispatch;
	}
	// 828A4BAC: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A4BB0: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828A4BB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4BB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A4BBC: 409A0008  bne cr6, 0x828a4bc4
	if !ctx.cr[6].eq {
	pc = 0x828A4BC4; continue 'dispatch;
	}
	// 828A4BC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A4BC4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A4BC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A4BCC: 419A00AC  beq cr6, 0x828a4c78
	if ctx.cr[6].eq {
	pc = 0x828A4C78; continue 'dispatch;
	}
	// 828A4BD0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A4BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4BD8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4BDC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A4BE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A4BE4: 4E800421  bctrl
	ctx.lr = 0x828A4BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4BE8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4BEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4BF0: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A4BF4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4BF8: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A4BFC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828A4C00: 4E800421  bctrl
	ctx.lr = 0x828A4C04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4C04: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A4C08: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A4C0C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A4C10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A4C14: 7D6319D6  mullw r11, r3, r3
	ctx.r[11].s64 = (ctx.r[3].s32 as i64) * (ctx.r[3].s32 as i64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A4C90 size=968
    let mut pc: u32 = 0x828A4C90;
    'dispatch: loop {
        match pc {
            0x828A4C90 => {
    //   block [0x828A4C90..0x828A5058)
	// 828A4C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4C94: 48404771  bl 0x82ca9404
	ctx.lr = 0x828A4C98;
	sub_82CA93D0(ctx, base);
	// 828A4C98: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A5058 size=1112
    let mut pc: u32 = 0x828A5058;
    'dispatch: loop {
        match pc {
            0x828A5058 => {
    //   block [0x828A5058..0x828A54B0)
	// 828A5058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A505C: 484043A1  bl 0x82ca93fc
	ctx.lr = 0x828A5060;
	sub_82CA93D0(ctx, base);
	// 828A5060: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828A5064: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828A5068: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A54B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A54B0 size=1156
    let mut pc: u32 = 0x828A54B0;
    'dispatch: loop {
        match pc {
            0x828A54B0 => {
    //   block [0x828A54B0..0x828A5934)
	// 828A54B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A54B4: 48403F41  bl 0x82ca93f4
	ctx.lr = 0x828A54B8;
	sub_82CA93D0(ctx, base);
	// 828A54B8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A54BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A54C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A54C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A54C8: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 828A54CC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A54D0: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 828A54D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A54D8: 9381009C  stw r28, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[28].u32 ) };
	// 828A54DC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A54E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A54E4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828A54E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828A54EC: 4E800421  bctrl
	ctx.lr = 0x828A54F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A54F0: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 828A54F4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828A54F8: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A54FC: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 828A5500: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A5504: 3C608349  lis r3, -0x7cb7
	ctx.r[3].s64 = -2092367872;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5938 size=228
    let mut pc: u32 = 0x828A5938;
    'dispatch: loop {
        match pc {
            0x828A5938 => {
    //   block [0x828A5938..0x828A5A1C)
	// 828A5938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A593C: 48403AC5  bl 0x82ca9400
	ctx.lr = 0x828A5940;
	sub_82CA93D0(ctx, base);
	// 828A5940: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5944: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 828A5948: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A594C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828A5950: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828A5954: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A5958: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A595C: 4B9798FD  bl 0x8221f258
	ctx.lr = 0x828A5960;
	sub_8221F258(ctx, base);
	// 828A5960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5964: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A5968: 419A0008  beq cr6, 0x828a5970
	if ctx.cr[6].eq {
	pc = 0x828A5970; continue 'dispatch;
	}
	// 828A596C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828A5970: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 828A5974: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A5978: 419A0008  beq cr6, 0x828a5980
	if ctx.cr[6].eq {
	pc = 0x828A5980; continue 'dispatch;
	}
	// 828A597C: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828A5980: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A5984: 4182001C  beq 0x828a59a0
	if ctx.cr[0].eq {
	pc = 0x828A59A0; continue 'dispatch;
	}
	// 828A5988: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A598C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5990: 4B8F13E1  bl 0x82196d70
	ctx.lr = 0x828A5994;
	sub_82196D70(ctx, base);
	// 828A5994: 389A0008  addi r4, r26, 8
	ctx.r[4].s64 = ctx.r[26].s64 + 8;
	// 828A5998: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828A599C: 4BCB22ED  bl 0x82557c88
	ctx.lr = 0x828A59A0;
	sub_82557C88(ctx, base);
	// 828A59A0: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 828A59A4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A59A8: 6169CCCC  ori r9, r11, 0xcccc
	ctx.r[9].u64 = ctx.r[11].u64 | 52428;
	// 828A59AC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828A59B0: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 828A59B4: 40980048  bge cr6, 0x828a59fc
	if !ctx.cr[6].lt {
	pc = 0x828A59FC; continue 'dispatch;
	}
	// 828A59B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828A59BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A59C0: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 828A59C4: 4BA4C57D  bl 0x822f1f40
	ctx.lr = 0x828A59C8;
	sub_822F1F40(ctx, base);
	// 828A59C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A59CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A59D0: 4BA4C3E1  bl 0x822f1db0
	ctx.lr = 0x828A59D4;
	sub_822F1DB0(ctx, base);
	// 828A59D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828A59D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A59DC: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828A59E0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828A59E4: 4BA4C43D  bl 0x822f1e20
	ctx.lr = 0x828A59E8;
	sub_822F1E20(ctx, base);
	// 828A59E8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828A59EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A59F0: 4BDD5DF1  bl 0x8267b7e0
	ctx.lr = 0x828A59F4;
	sub_8267B7E0(ctx, base);
	// 828A59F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A59F8: 4B8CBE19  bl 0x82171810
	ctx.lr = 0x828A59FC;
	sub_82171810(ctx, base);
	// 828A59FC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5A00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A5A04: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828A5A08: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828A5A0C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5A10: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5A14: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A5A18: 48403A38  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5A20 size=204
    let mut pc: u32 = 0x828A5A20;
    'dispatch: loop {
        match pc {
            0x828A5A20 => {
    //   block [0x828A5A20..0x828A5AEC)
	// 828A5A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5A24: 484039DD  bl 0x82ca9400
	ctx.lr = 0x828A5A28;
	sub_82CA93D0(ctx, base);
	// 828A5A28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5A2C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A5A30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A5A34: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5A38: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5A3C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5A40: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5A44: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A5A48: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5A4C: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A5A50: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A5A54: 419A0084  beq cr6, 0x828a5ad8
	if ctx.cr[6].eq {
	pc = 0x828A5AD8; continue 'dispatch;
	}
	// 828A5A58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A5A5C: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	// 828A5A60: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 828A5A64: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5A68: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828A5A6C: 4BE878CD  bl 0x8272d338
	ctx.lr = 0x828A5A70;
	sub_8272D338(ctx, base);
	// 828A5A70: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A5A74: 4B9762C5  bl 0x8221bd38
	ctx.lr = 0x828A5A78;
	sub_8221BD38(ctx, base);
	// 828A5A78: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 828A5A7C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A5A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5A84: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 828A5A88: 419A0034  beq cr6, 0x828a5abc
	if ctx.cr[6].eq {
	pc = 0x828A5ABC; continue 'dispatch;
	}
	// 828A5A8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5A90: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828A5A94: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A5A98: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5A9C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5AA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A5AA4: 409A0014  bne cr6, 0x828a5ab8
	if !ctx.cr[6].eq {
	pc = 0x828A5AB8; continue 'dispatch;
	}
	// 828A5AA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5AAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5AB0: 409A0008  bne cr6, 0x828a5ab8
	if !ctx.cr[6].eq {
	pc = 0x828A5AB8; continue 'dispatch;
	}
	// 828A5AB4: 4B976285  bl 0x8221bd38
	ctx.lr = 0x828A5AB8;
	sub_8221BD38(ctx, base);
	// 828A5AB8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A5ABC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A5AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5AC4: 4B976275  bl 0x8221bd38
	ctx.lr = 0x828A5AC8;
	sub_8221BD38(ctx, base);
	// 828A5AC8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5ACC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828A5AD0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A5AD4: 409AFF8C  bne cr6, 0x828a5a60
	if !ctx.cr[6].eq {
	pc = 0x828A5A60; continue 'dispatch;
	}
	// 828A5AD8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5ADC: 4B97625D  bl 0x8221bd38
	ctx.lr = 0x828A5AE0;
	sub_8221BD38(ctx, base);
	// 828A5AE0: 93BB0004  stw r29, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A5AE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A5AE8: 48403968  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5AF0 size=220
    let mut pc: u32 = 0x828A5AF0;
    'dispatch: loop {
        match pc {
            0x828A5AF0 => {
    //   block [0x828A5AF0..0x828A5BCC)
	// 828A5AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5AF4: 4840390D  bl 0x82ca9400
	ctx.lr = 0x828A5AF8;
	sub_82CA93D0(ctx, base);
	// 828A5AF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5AFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5B00: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828A5B04: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828A5B08: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A5B0C: 3B8B0024  addi r28, r11, 0x24
	ctx.r[28].s64 = ctx.r[11].s64 + 36;
	// 828A5B10: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A5B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5B18: 419A0010  beq cr6, 0x828a5b28
	if ctx.cr[6].eq {
	pc = 0x828A5B28; continue 'dispatch;
	}
	// 828A5B1C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A5B20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A5B24: 4800000C  b 0x828a5b30
	pc = 0x828A5B30; continue 'dispatch;
	// 828A5B28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A5B2C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828A5B30: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828A5B34: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5B38: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828A5B3C: 409A0010  bne cr6, 0x828a5b4c
	if !ctx.cr[6].eq {
	pc = 0x828A5B4C; continue 'dispatch;
	}
	// 828A5B40: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A5B44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A5B48: 419A0008  beq cr6, 0x828a5b50
	if ctx.cr[6].eq {
	pc = 0x828A5B50; continue 'dispatch;
	}
	// 828A5B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A5B50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A5B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5B58: 409A006C  bne cr6, 0x828a5bc4
	if !ctx.cr[6].eq {
	pc = 0x828A5BC4; continue 'dispatch;
	}
	// 828A5B5C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5B60: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A5B64: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A5B68: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A5B6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A5B70: 419A0040  beq cr6, 0x828a5bb0
	if ctx.cr[6].eq {
	pc = 0x828A5BB0; continue 'dispatch;
	}
	// 828A5B74: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828A5B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5B7C: 4B95DA65  bl 0x822035e0
	ctx.lr = 0x828A5B80;
	sub_822035E0(ctx, base);
	// 828A5B80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A5B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5B88: 419A0028  beq cr6, 0x828a5bb0
	if ctx.cr[6].eq {
	pc = 0x828A5BB0; continue 'dispatch;
	}
	// 828A5B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5B90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A5B94: 4B95A555  bl 0x822000e8
	ctx.lr = 0x828A5B98;
	sub_822000E8(ctx, base);
	// 828A5B98: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A5B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5BA0: 419A0010  beq cr6, 0x828a5bb0
	if ctx.cr[6].eq {
	pc = 0x828A5BB0; continue 'dispatch;
	}
	// 828A5BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A5BA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A5BAC: 482A3BA5  bl 0x82b49750
	ctx.lr = 0x828A5BB0;
	sub_82B49750(ctx, base);
	// 828A5BB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5BB8: 419AFF74  beq cr6, 0x828a5b2c
	if ctx.cr[6].eq {
	pc = 0x828A5B2C; continue 'dispatch;
	}
	// 828A5BBC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A5BC0: 4BFFFF70  b 0x828a5b30
	pc = 0x828A5B30; continue 'dispatch;
	// 828A5BC4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A5BC8: 48403888  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5BD0 size=584
    let mut pc: u32 = 0x828A5BD0;
    'dispatch: loop {
        match pc {
            0x828A5BD0 => {
    //   block [0x828A5BD0..0x828A5E18)
	// 828A5BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5BD4: 4840382D  bl 0x82ca9400
	ctx.lr = 0x828A5BD8;
	sub_82CA93D0(ctx, base);
	// 828A5BD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5BDC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5BE0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A5BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5BE8: 409A0010  bne cr6, 0x828a5bf8
	if !ctx.cr[6].eq {
	pc = 0x828A5BF8; continue 'dispatch;
	}
	// 828A5BEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A5BF0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828A5BF4: 48000008  b 0x828a5bfc
	pc = 0x828A5BFC; continue 'dispatch;
	// 828A5BF8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5BFC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5C00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5C04: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5C08: 4BB289B9  bl 0x823ce5c0
	ctx.lr = 0x828A5C0C;
	sub_823CE5C0(ctx, base);
	// 828A5C0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5C10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5C14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5C18: 4BB285E9  bl 0x823ce200
	ctx.lr = 0x828A5C1C;
	sub_823CE200(ctx, base);
	// 828A5C1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5C20: 4B911EF9  bl 0x821b7b18
	ctx.lr = 0x828A5C24;
	sub_821B7B18(ctx, base);
	// 828A5C24: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828A5C28: 4B979631  bl 0x8221f258
	ctx.lr = 0x828A5C2C;
	sub_8221F258(ctx, base);
	// 828A5C2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5C30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A5C34: 419A0040  beq cr6, 0x828a5c74
	if ctx.cr[6].eq {
	pc = 0x828A5C74; continue 'dispatch;
	}
	// 828A5C38: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828A5C3C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A5C40: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828A5C44: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A5C48: 4B979611  bl 0x8221f258
	ctx.lr = 0x828A5C4C;
	sub_8221F258(ctx, base);
	// 828A5C4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A5C50: 419A0028  beq cr6, 0x828a5c78
	if ctx.cr[6].eq {
	pc = 0x828A5C78; continue 'dispatch;
	}
	// 828A5C54: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A5C58: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828A5C5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A5C60: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A5C64: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A5C68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A5C6C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A5C70: 4800000C  b 0x828a5c7c
	pc = 0x828A5C7C; continue 'dispatch;
	// 828A5C74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A5C78: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A5C7C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A5C80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A5C84: 419A00FC  beq cr6, 0x828a5d80
	if ctx.cr[6].eq {
	pc = 0x828A5D80; continue 'dispatch;
	}
	// 828A5C88: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5C8C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A5C90: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5C94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A5C98: 4B983471  bl 0x82229108
	ctx.lr = 0x828A5C9C;
	sub_82229108(ctx, base);
	// 828A5C9C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A5CA0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A5CA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A5CA8: 3BCB6020  addi r30, r11, 0x6020
	ctx.r[30].s64 = ctx.r[11].s64 + 24608;
	// 828A5CAC: 4B981BD5  bl 0x82227880
	ctx.lr = 0x828A5CB0;
	sub_82227880(ctx, base);
	// 828A5CB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A5CB4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828A5CB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A5CBC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828A5CC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A5CC4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A5CC8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A5CCC: 4B8F4DB5  bl 0x8219aa80
	ctx.lr = 0x828A5CD0;
	sub_8219AA80(ctx, base);
	// 828A5CD0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828A5CD4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A5CD8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828A5CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5CE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A5CE4: 4BB2873D  bl 0x823ce420
	ctx.lr = 0x828A5CE8;
	sub_823CE420(ctx, base);
	// 828A5CE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A5CEC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A5CF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A5CF4: 4817E9D5  bl 0x82a246c8
	ctx.lr = 0x828A5CF8;
	sub_82A246C8(ctx, base);
	// 828A5CF8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5CFC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A5D00: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828A5D04: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828A5D08: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5D0C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D14: 4B9833F5  bl 0x82229108
	ctx.lr = 0x828A5D18;
	sub_82229108(ctx, base);
	// 828A5D18: 3D608231  lis r11, -0x7dcf
	ctx.r[11].s64 = -2110717952;
	// 828A5D1C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A5D20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D24: 3BEBB078  addi r31, r11, -0x4f88
	ctx.r[31].s64 = ctx.r[11].s64 + -20360;
	// 828A5D28: 4B981B59  bl 0x82227880
	ctx.lr = 0x828A5D2C;
	sub_82227880(ctx, base);
	// 828A5D2C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828A5D30: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828A5D34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A5D38: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828A5D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D40: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A5D44: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828A5D48: 4B8F4D39  bl 0x8219aa80
	ctx.lr = 0x828A5D4C;
	sub_8219AA80(ctx, base);
	// 828A5D4C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828A5D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A5D54: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828A5D58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5D5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5D60: 4BB286C1  bl 0x823ce420
	ctx.lr = 0x828A5D64;
	sub_823CE420(ctx, base);
	// 828A5D64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5D68: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A5D6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D70: 4817E959  bl 0x82a246c8
	ctx.lr = 0x828A5D74;
	sub_82A246C8(ctx, base);
	// 828A5D74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5D78: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828A5D7C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828A5D80: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828A5D84: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A5D88: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828A5D8C: 419A0020  beq cr6, 0x828a5dac
	if ctx.cr[6].eq {
	pc = 0x828A5DAC; continue 'dispatch;
	}
	// 828A5D90: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A5D94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5D98: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A5D9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A5DA0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A5DA4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5DA8: 4082FFE8  bne 0x828a5d90
	if !ctx.cr[0].eq {
	pc = 0x828A5D90; continue 'dispatch;
	}
	// 828A5DAC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5DB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A5DB4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A5DB8: 4BA4FB91  bl 0x822f5948
	ctx.lr = 0x828A5DBC;
	sub_822F5948(ctx, base);
	// 828A5DBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A5DC0: 4B911D59  bl 0x821b7b18
	ctx.lr = 0x828A5DC4;
	sub_821B7B18(ctx, base);
	// 828A5DC4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A5DC8: 419A0040  beq cr6, 0x828a5e08
	if ctx.cr[6].eq {
	pc = 0x828A5E08; continue 'dispatch;
	}
	// 828A5DCC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A5DD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5DD4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A5DD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A5DDC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A5DE0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5DE4: 4082FFE8  bne 0x828a5dcc
	if !ctx.cr[0].eq {
	pc = 0x828A5DCC; continue 'dispatch;
	}
	// 828A5DE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A5DEC: 409A001C  bne cr6, 0x828a5e08
	if !ctx.cr[6].eq {
	pc = 0x828A5E08; continue 'dispatch;
	}
	// 828A5DF0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5DF4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5DF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A5DFC: 4E800421  bctrl
	ctx.lr = 0x828A5E00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A5E00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A5E04: 4B975F35  bl 0x8221bd38
	ctx.lr = 0x828A5E08;
	sub_8221BD38(ctx, base);
	// 828A5E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5E0C: 4B911D0D  bl 0x821b7b18
	ctx.lr = 0x828A5E10;
	sub_821B7B18(ctx, base);
	// 828A5E10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A5E14: 4840363C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5E18 size=516
    let mut pc: u32 = 0x828A5E18;
    'dispatch: loop {
        match pc {
            0x828A5E18 => {
    //   block [0x828A5E18..0x828A601C)
	// 828A5E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5E1C: 484035E1  bl 0x82ca93fc
	ctx.lr = 0x828A5E20;
	sub_82CA93D0(ctx, base);
	// 828A5E20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5E24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5E28: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A5E2C: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A5E30: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828A5E34: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A5E38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5E3C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A5E40: 3BAA54B0  addi r29, r10, 0x54b0
	ctx.r[29].s64 = ctx.r[10].s64 + 21680;
	// 828A5E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5E48: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A5E4C: 419A0008  beq cr6, 0x828a5e54
	if ctx.cr[6].eq {
	pc = 0x828A5E54; continue 'dispatch;
	}
	// 828A5E50: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5E54: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5E58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5E5C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5E60: 4BB28761  bl 0x823ce5c0
	ctx.lr = 0x828A5E64;
	sub_823CE5C0(ctx, base);
	// 828A5E64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5E68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A5E6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5E70: 4BB282A1  bl 0x823ce110
	ctx.lr = 0x828A5E74;
	sub_823CE110(ctx, base);
	// 828A5E74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5E78: 4B911CA1  bl 0x821b7b18
	ctx.lr = 0x828A5E7C;
	sub_821B7B18(ctx, base);
	// 828A5E7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A5E80: 4B9793D9  bl 0x8221f258
	ctx.lr = 0x828A5E84;
	sub_8221F258(ctx, base);
	// 828A5E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5E88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A5E8C: 419A005C  beq cr6, 0x828a5ee8
	if ctx.cr[6].eq {
	pc = 0x828A5EE8; continue 'dispatch;
	}
	// 828A5E90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A5E94: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828A5E98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A5E9C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828A5EA0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A5EA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A5EA8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A5EAC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828A5EB0: 4B94A391  bl 0x821f0240
	ctx.lr = 0x828A5EB4;
	sub_821F0240(ctx, base);
	// 828A5EB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A5EB8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828A5EBC: 4B97939D  bl 0x8221f258
	ctx.lr = 0x828A5EC0;
	sub_8221F258(ctx, base);
	// 828A5EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A5EC4: 419A0028  beq cr6, 0x828a5eec
	if ctx.cr[6].eq {
	pc = 0x828A5EEC; continue 'dispatch;
	}
	// 828A5EC8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828A5ECC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828A5ED0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A5ED4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828A5ED8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A5EDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5EE0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A5EE4: 4800000C  b 0x828a5ef0
	pc = 0x828A5EF0; continue 'dispatch;
	// 828A5EE8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A5EEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A5EF0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5EF4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A5EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5EFC: 419A0008  beq cr6, 0x828a5f04
	if ctx.cr[6].eq {
	pc = 0x828A5F04; continue 'dispatch;
	}
	// 828A5F00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5F04: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A5F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5F0C: 419A0078  beq cr6, 0x828a5f84
	if ctx.cr[6].eq {
	pc = 0x828A5F84; continue 'dispatch;
	}
	// 828A5F10: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5F14: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828A5F18: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5F1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A5F20: 4B9831E9  bl 0x82229108
	ctx.lr = 0x828A5F24;
	sub_82229108(ctx, base);
	// 828A5F24: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A5F28: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828A5F2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A5F30: 3BCB6060  addi r30, r11, 0x6060
	ctx.r[30].s64 = ctx.r[11].s64 + 24672;
	// 828A5F34: 4B98194D  bl 0x82227880
	ctx.lr = 0x828A5F38;
	sub_82227880(ctx, base);
	// 828A5F38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A5F3C: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 828A5F40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A5F44: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 828A5F48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A5F4C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A5F50: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A5F54: 4B8F4B2D  bl 0x8219aa80
	ctx.lr = 0x828A5F58;
	sub_8219AA80(ctx, base);
	// 828A5F58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5F5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A5F60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A5F64: 4BB284BD  bl 0x823ce420
	ctx.lr = 0x828A5F68;
	sub_823CE420(ctx, base);
	// 828A5F68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5F6C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828A5F70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A5F74: 4817E755  bl 0x82a246c8
	ctx.lr = 0x828A5F78;
	sub_82A246C8(ctx, base);
	// 828A5F78: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5F7C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828A5F80: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828A5F84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A5F88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A5F8C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A5F90: 419A0020  beq cr6, 0x828a5fb0
	if ctx.cr[6].eq {
	pc = 0x828A5FB0; continue 'dispatch;
	}
	// 828A5F94: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A5F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5F9C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A5FA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A5FA4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A5FA8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5FAC: 4082FFE8  bne 0x828a5f94
	if !ctx.cr[0].eq {
	pc = 0x828A5F94; continue 'dispatch;
	}
	// 828A5FB0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5FB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A5FB8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828A5FBC: 4BA4F98D  bl 0x822f5948
	ctx.lr = 0x828A5FC0;
	sub_822F5948(ctx, base);
	// 828A5FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5FC4: 4B911B55  bl 0x821b7b18
	ctx.lr = 0x828A5FC8;
	sub_821B7B18(ctx, base);
	// 828A5FC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A5FCC: 419A0040  beq cr6, 0x828a600c
	if ctx.cr[6].eq {
	pc = 0x828A600C; continue 'dispatch;
	}
	// 828A5FD0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828A5FD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5FD8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828A5FDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A5FE0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A5FE4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A5FE8: 4082FFE8  bne 0x828a5fd0
	if !ctx.cr[0].eq {
	pc = 0x828A5FD0; continue 'dispatch;
	}
	// 828A5FEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A5FF0: 409A001C  bne cr6, 0x828a600c
	if !ctx.cr[6].eq {
	pc = 0x828A600C; continue 'dispatch;
	}
	// 828A5FF4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A5FF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5FFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A6000: 4E800421  bctrl
	ctx.lr = 0x828A6004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A6004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6008: 4B975D31  bl 0x8221bd38
	ctx.lr = 0x828A600C;
	sub_8221BD38(ctx, base);
	// 828A600C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A6010: 4B911B09  bl 0x821b7b18
	ctx.lr = 0x828A6014;
	sub_821B7B18(ctx, base);
	// 828A6014: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A6018: 48403434  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A6020 size=56
    let mut pc: u32 = 0x828A6020;
    'dispatch: loop {
        match pc {
            0x828A6020 => {
    //   block [0x828A6020..0x828A6058)
	// 828A6020: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A6024: 419A0018  beq cr6, 0x828a603c
	if ctx.cr[6].eq {
	pc = 0x828A603C; continue 'dispatch;
	}
	// 828A6028: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A602C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A6030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6034: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6038: 409A0008  bne cr6, 0x828a6040
	if !ctx.cr[6].eq {
	pc = 0x828A6040; continue 'dispatch;
	}
	// 828A603C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A6040: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6048: 419A0010  beq cr6, 0x828a6058
	if ctx.cr[6].eq {
		sub_828A6058(ctx, base);
		return;
	}
	// 828A604C: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A6050: 556367FE  rlwinm r3, r11, 0xc, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828A6054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A6058 size=8
    let mut pc: u32 = 0x828A6058;
    'dispatch: loop {
        match pc {
            0x828A6058 => {
    //   block [0x828A6058..0x828A6060)
	// 828A6058: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A605C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6060 size=464
    let mut pc: u32 = 0x828A6060;
    'dispatch: loop {
        match pc {
            0x828A6060 => {
    //   block [0x828A6060..0x828A6230)
	// 828A6060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6064: 484033A9  bl 0x82ca940c
	ctx.lr = 0x828A6068;
	sub_82CA93D0(ctx, base);
	// 828A6068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A606C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A6070: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A6074: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A6078: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A607C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A6080: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828A6084: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 828A6088: 4198019C  blt cr6, 0x828a6224
	if ctx.cr[6].lt {
	pc = 0x828A6224; continue 'dispatch;
	}
	// 828A608C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A6090: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A6094: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 828A6098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A609C: 4B981F2D  bl 0x82227fc8
	ctx.lr = 0x828A60A0;
	sub_82227FC8(ctx, base);
	// 828A60A0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A60A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A60A8: 419A017C  beq cr6, 0x828a6224
	if ctx.cr[6].eq {
	pc = 0x828A6224; continue 'dispatch;
	}
	// 828A60AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A60B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A60B4: 4B982045  bl 0x822280f8
	ctx.lr = 0x828A60B8;
	sub_822280F8(ctx, base);
	// 828A60B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A60BC: 4B9814A5  bl 0x82227560
	ctx.lr = 0x828A60C0;
	sub_82227560(ctx, base);
	// 828A60C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A60C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A60C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A60CC: 4B93A2BD  bl 0x821e0388
	ctx.lr = 0x828A60D0;
	sub_821E0388(ctx, base);
	// 828A60D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A60D4: 419A0018  beq cr6, 0x828a60ec
	if ctx.cr[6].eq {
	pc = 0x828A60EC; continue 'dispatch;
	}
	// 828A60D8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A60DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A60E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A60E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A60E8: 409A0008  bne cr6, 0x828a60f0
	if !ctx.cr[6].eq {
	pc = 0x828A60F0; continue 'dispatch;
	}
	// 828A60EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A60F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A60F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A60F8: 419A012C  beq cr6, 0x828a6224
	if ctx.cr[6].eq {
	pc = 0x828A6224; continue 'dispatch;
	}
	// 828A60FC: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A6100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A6104: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828A6108: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A610C: 419A00EC  beq cr6, 0x828a61f8
	if ctx.cr[6].eq {
	pc = 0x828A61F8; continue 'dispatch;
	}
	// 828A6110: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6118: 419A0020  beq cr6, 0x828a6138
	if ctx.cr[6].eq {
	pc = 0x828A6138; continue 'dispatch;
	}
	// 828A611C: 894B00B4  lbz r10, 0xb4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 828A6120: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6124: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A6128: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A612C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A6130: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6134: 480000C8  b 0x828a61fc
	pc = 0x828A61FC; continue 'dispatch;
	// 828A6138: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A613C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A6140: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6144: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A6148: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A614C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6150: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6154: 40810054  ble 0x828a61a8
	if !ctx.cr[0].gt {
	pc = 0x828A61A8; continue 'dispatch;
	}
	// 828A6158: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A615C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6160: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A6164: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6168: 2F0700B4  cmpwi cr6, r7, 0xb4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 180, &mut ctx.xer);
	// 828A616C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6170: 41980008  blt cr6, 0x828a6178
	if ctx.cr[6].lt {
	pc = 0x828A6178; continue 'dispatch;
	}
	// 828A6174: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A6178: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A617C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6180: 419A0014  beq cr6, 0x828a6194
	if ctx.cr[6].eq {
	pc = 0x828A6194; continue 'dispatch;
	}
	// 828A6184: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6188: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A618C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6190: 4800000C  b 0x828a619c
	pc = 0x828A619C; continue 'dispatch;
	// 828A6194: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6198: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A619C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A61A0: 4199FFB8  bgt cr6, 0x828a6158
	if ctx.cr[6].gt {
	pc = 0x828A6158; continue 'dispatch;
	}
	// 828A61A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A61A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A61AC: 419A003C  beq cr6, 0x828a61e8
	if ctx.cr[6].eq {
	pc = 0x828A61E8; continue 'dispatch;
	}
	// 828A61B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A61B4: 2F0B00B4  cmpwi cr6, r11, 0xb4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 180, &mut ctx.xer);
	// 828A61B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A61BC: 41990008  bgt cr6, 0x828a61c4
	if ctx.cr[6].gt {
	pc = 0x828A61C4; continue 'dispatch;
	}
	// 828A61C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A61C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A61C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A61CC: 409A001C  bne cr6, 0x828a61e8
	if !ctx.cr[6].eq {
	pc = 0x828A61E8; continue 'dispatch;
	}
	// 828A61D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A61D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A61D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A61DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A61E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A61E4: 48000018  b 0x828a61fc
	pc = 0x828A61FC; continue 'dispatch;
	// 828A61E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A61EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A61F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A61F4: 48000008  b 0x828a61fc
	pc = 0x828A61FC; continue 'dispatch;
	// 828A61F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A61FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828A6200: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6204: 419A0020  beq cr6, 0x828a6224
	if ctx.cr[6].eq {
	pc = 0x828A6224; continue 'dispatch;
	}
	// 828A6208: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A620C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A6210: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A6214: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828A6218: 4E800421  bctrl
	ctx.lr = 0x828A621C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A621C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A6220: 4840323C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828A6224: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A6228: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A622C: 48403230  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6230 size=84
    let mut pc: u32 = 0x828A6230;
    'dispatch: loop {
        match pc {
            0x828A6230 => {
    //   block [0x828A6230..0x828A6284)
	// 828A6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A6238: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A623C: 38630020  addi r3, r3, 0x20
	ctx.r[3].s64 = ctx.r[3].s64 + 32;
	// 828A6240: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6248: 419A0028  beq cr6, 0x828a6270
	if ctx.cr[6].eq {
	pc = 0x828A6270; continue 'dispatch;
	}
	// 828A624C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6250: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6254: 419A0018  beq cr6, 0x828a626c
	if ctx.cr[6].eq {
	pc = 0x828A626C; continue 'dispatch;
	}
	// 828A6258: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828A625C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A6260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A6264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A6268: 4E800020  blr
	return;
	// 828A626C: 4B8EDBCD  bl 0x82193e38
	ctx.lr = 0x828A6270;
	sub_82193E38(ctx, base);
	// 828A6270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A6274: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A6278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A627C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A6280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A6288 size=8
    let mut pc: u32 = 0x828A6288;
    'dispatch: loop {
        match pc {
            0x828A6288 => {
    //   block [0x828A6288..0x828A6290)
	// 828A6288: 3860006A  li r3, 0x6a
	ctx.r[3].s64 = 106;
	// 828A628C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6290 size=60
    let mut pc: u32 = 0x828A6290;
    'dispatch: loop {
        match pc {
            0x828A6290 => {
    //   block [0x828A6290..0x828A62CC)
	// 828A6290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A6298: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A629C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A62A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A62A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A62A8: 388B95C0  addi r4, r11, -0x6a40
	ctx.r[4].s64 = ctx.r[11].s64 + -27200;
	// 828A62AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A62B0: 4B986C21  bl 0x8222ced0
	ctx.lr = 0x828A62B4;
	sub_8222CED0(ctx, base);
	// 828A62B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A62B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A62BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A62C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A62C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A62C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A62D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A62D0 size=12
    let mut pc: u32 = 0x828A62D0;
    'dispatch: loop {
        match pc {
            0x828A62D0 => {
    //   block [0x828A62D0..0x828A62DC)
	// 828A62D0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828A62D4: 986B6D4F  stb r3, 0x6d4f(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27983 as u32), ctx.r[3].u8 ) };
	// 828A62D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A62E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A62E0 size=108
    let mut pc: u32 = 0x828A62E0;
    'dispatch: loop {
        match pc {
            0x828A62E0 => {
    //   block [0x828A62E0..0x828A634C)
	// 828A62E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A62E4: 48403129  bl 0x82ca940c
	ctx.lr = 0x828A62E8;
	sub_82CA93D0(ctx, base);
	// 828A62E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A62EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A62F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A62F4: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 828A62F8: 4BA71B51  bl 0x82317e48
	ctx.lr = 0x828A62FC;
	sub_82317E48(ctx, base);
	// 828A62FC: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6300: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 828A6304: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6308: 419A0008  beq cr6, 0x828a6310
	if ctx.cr[6].eq {
	pc = 0x828A6310; continue 'dispatch;
	}
	// 828A630C: 4B975A2D  bl 0x8221bd38
	ctx.lr = 0x828A6310;
	sub_8221BD38(ctx, base);
	// 828A6310: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828A6314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A6318: 392A2850  addi r9, r10, 0x2850
	ctx.r[9].s64 = ctx.r[10].s64 + 10320;
	// 828A631C: 57A807FE  clrlwi r8, r29, 0x1f
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828A6320: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828A6324: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828A6328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A632C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828A6330: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828A6334: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A6338: 419A000C  beq cr6, 0x828a6344
	if ctx.cr[6].eq {
	pc = 0x828A6344; continue 'dispatch;
	}
	// 828A633C: 4B9759FD  bl 0x8221bd38
	ctx.lr = 0x828A6340;
	sub_8221BD38(ctx, base);
	// 828A6340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6348: 48403114  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6350 size=668
    let mut pc: u32 = 0x828A6350;
    'dispatch: loop {
        match pc {
            0x828A6350 => {
    //   block [0x828A6350..0x828A65EC)
	// 828A6350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6354: 484030A9  bl 0x82ca93fc
	ctx.lr = 0x828A6358;
	sub_82CA93D0(ctx, base);
	// 828A6358: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A635C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A6360: 89790030  lbz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A6364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6368: 409A027C  bne cr6, 0x828a65e4
	if !ctx.cr[6].eq {
	pc = 0x828A65E4; continue 'dispatch;
	}
	// 828A636C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A6370: 4BA7A819  bl 0x82320b88
	ctx.lr = 0x828A6374;
	sub_82320B88(ctx, base);
	// 828A6374: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6378: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A637C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 828A6380: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A6384: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A6388: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A638C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A6390: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828A6394: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828A6398: 481F0FD1  bl 0x82a97368
	ctx.lr = 0x828A639C;
	sub_82A97368(ctx, base);
	// 828A639C: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A63A0: 83E50000  lwz r31, 0(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A63A4: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A63A8: 419A002C  beq cr6, 0x828a63d4
	if ctx.cr[6].eq {
	pc = 0x828A63D4; continue 'dispatch;
	}
	// 828A63AC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A63B0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A63B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A63B8: 480029A1  bl 0x828a8d58
	ctx.lr = 0x828A63BC;
	sub_828A8D58(ctx, base);
	// 828A63BC: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A63C0: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A63C4: 409A0008  bne cr6, 0x828a63cc
	if !ctx.cr[6].eq {
	pc = 0x828A63CC; continue 'dispatch;
	}
	// 828A63C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A63CC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A63D0: 4BFFFFD4  b 0x828a63a4
	pc = 0x828A63A4; continue 'dispatch;
	// 828A63D4: 83450000  lwz r26, 0(r5)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A63D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A63DC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828A63E0: 7F1A2840  cmplw cr6, r26, r5
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A63E4: 419A01AC  beq cr6, 0x828a6590
	if ctx.cr[6].eq {
	pc = 0x828A6590; continue 'dispatch;
	}
	// 828A63E8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A63EC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828A63F0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A63F4: 5549AFFE  rlwinm r9, r10, 0x15, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000007FFu64;
	// 828A63F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A63FC: 419A00F4  beq cr6, 0x828a64f0
	if ctx.cr[6].eq {
	pc = 0x828A64F0; continue 'dispatch;
	}
	// 828A6400: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6408: 419A0024  beq cr6, 0x828a642c
	if ctx.cr[6].eq {
	pc = 0x828A642C; continue 'dispatch;
	}
	// 828A640C: 894A006B  lbz r10, 0x6b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A6410: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6414: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A6418: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A641C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6420: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A6424: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A6428: 480000CC  b 0x828a64f4
	pc = 0x828A64F4; continue 'dispatch;
	// 828A642C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6430: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6434: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6438: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A643C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6440: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6444: 40810054  ble 0x828a6498
	if !ctx.cr[0].gt {
	pc = 0x828A6498; continue 'dispatch;
	}
	// 828A6448: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A644C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6450: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A6454: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6458: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A645C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A6460: 41980008  blt cr6, 0x828a6468
	if ctx.cr[6].lt {
	pc = 0x828A6468; continue 'dispatch;
	}
	// 828A6464: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6468: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A646C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6470: 419A0014  beq cr6, 0x828a6484
	if ctx.cr[6].eq {
	pc = 0x828A6484; continue 'dispatch;
	}
	// 828A6474: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6478: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A647C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6480: 4800000C  b 0x828a648c
	pc = 0x828A648C; continue 'dispatch;
	// 828A6484: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6488: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A648C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6490: 4199FFB8  bgt cr6, 0x828a6448
	if ctx.cr[6].gt {
	pc = 0x828A6448; continue 'dispatch;
	}
	// 828A6494: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6498: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A649C: 419A0040  beq cr6, 0x828a64dc
	if ctx.cr[6].eq {
	pc = 0x828A64DC; continue 'dispatch;
	}
	// 828A64A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A64A4: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A64A8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A64AC: 41990008  bgt cr6, 0x828a64b4
	if ctx.cr[6].gt {
	pc = 0x828A64B4; continue 'dispatch;
	}
	// 828A64B0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A64B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A64B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A64BC: 409A0020  bne cr6, 0x828a64dc
	if !ctx.cr[6].eq {
	pc = 0x828A64DC; continue 'dispatch;
	}
	// 828A64C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A64C4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828A64C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A64CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A64D0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A64D4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A64D8: 4800001C  b 0x828a64f4
	pc = 0x828A64F4; continue 'dispatch;
	// 828A64DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A64E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A64E4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A64E8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A64EC: 48000008  b 0x828a64f4
	pc = 0x828A64F4; continue 'dispatch;
	// 828A64F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A64F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A64F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A64FC: 419A0080  beq cr6, 0x828a657c
	if ctx.cr[6].eq {
	pc = 0x828A657C; continue 'dispatch;
	}
	// 828A6500: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6504: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6508: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A650C: 419A0070  beq cr6, 0x828a657c
	if ctx.cr[6].eq {
	pc = 0x828A657C; continue 'dispatch;
	}
	// 828A6510: 3BD9001C  addi r30, r25, 0x1c
	ctx.r[30].s64 = ctx.r[25].s64 + 28;
	// 828A6514: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6518: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A651C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6520: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A6524: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828A6528: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828A652C: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 828A6530: 419A0020  beq cr6, 0x828a6550
	if ctx.cr[6].eq {
	pc = 0x828A6550; continue 'dispatch;
	}
	// 828A6534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A6538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A653C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A6540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A6544: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A6548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A654C: 4082FFE8  bne 0x828a6534
	if !ctx.cr[0].eq {
	pc = 0x828A6534; continue 'dispatch;
	}
	// 828A6550: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A6554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6558: 4B910109  bl 0x821b6660
	ctx.lr = 0x828A655C;
	sub_821B6660(ctx, base);
	// 828A655C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828A6560: 4B9115B9  bl 0x821b7b18
	ctx.lr = 0x828A6564;
	sub_821B7B18(ctx, base);
	// 828A6564: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A6568: 9B7E0011  stb r27, 0x11(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 828A656C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6570: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A6574: 409AFFA0  bne cr6, 0x828a6514
	if !ctx.cr[6].eq {
	pc = 0x828A6514; continue 'dispatch;
	}
	// 828A6578: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A657C: 7F1A2840  cmplw cr6, r26, r5
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A6580: 409A0008  bne cr6, 0x828a6588
	if !ctx.cr[6].eq {
	pc = 0x828A6588; continue 'dispatch;
	}
	// 828A6584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A6588: 835A0000  lwz r26, 0(r26)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A658C: 4BFFFE54  b 0x828a63e0
	pc = 0x828A63E0; continue 'dispatch;
	// 828A6590: 8979002D  lbz r11, 0x2d(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(45 as u32) ) } as u64;
	// 828A6594: 3BF9001C  addi r31, r25, 0x1c
	ctx.r[31].s64 = ctx.r[25].s64 + 28;
	// 828A6598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A659C: 419A003C  beq cr6, 0x828a65d8
	if ctx.cr[6].eq {
	pc = 0x828A65D8; continue 'dispatch;
	}
	// 828A65A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A65A4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 828A65A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A65AC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828A65B0: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A65B4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A65B8: 88DF0010  lbz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A65BC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828A65C0: 7CA84BD6  divw r5, r8, r9
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 828A65C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A65C8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A65CC: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828A65D0: 48007C81  bl 0x828ae250
	ctx.lr = 0x828A65D4;
	sub_828AE250(ctx, base);
	// 828A65D4: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828A65D8: 9B790030  stb r27, 0x30(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 828A65DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A65E0: 4BD940A9  bl 0x8263a688
	ctx.lr = 0x828A65E4;
	sub_8263A688(ctx, base);
	// 828A65E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828A65E8: 48402E64  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A65F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A65F0 size=1616
    let mut pc: u32 = 0x828A65F0;
    'dispatch: loop {
        match pc {
            0x828A65F0 => {
    //   block [0x828A65F0..0x828A6C40)
	// 828A65F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A65F4: 48402E01  bl 0x82ca93f4
	ctx.lr = 0x828A65F8;
	sub_82CA93D0(ctx, base);
	// 828A65F8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A65FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A6600: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828A6604: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828A6608: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828A660C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 828A6610: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 828A6614: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A6618: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A661C: 419A0018  beq cr6, 0x828a6634
	if ctx.cr[6].eq {
	pc = 0x828A6634; continue 'dispatch;
	}
	// 828A6620: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A6624: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A6628: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A662C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6630: 409A0008  bne cr6, 0x828a6638
	if !ctx.cr[6].eq {
	pc = 0x828A6638; continue 'dispatch;
	}
	// 828A6634: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6638: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A663C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6640: 419A05F8  beq cr6, 0x828a6c38
	if ctx.cr[6].eq {
	pc = 0x828A6C38; continue 'dispatch;
	}
	// 828A6644: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A6648: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828A664C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A6650: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A6654: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6658: 419A00F4  beq cr6, 0x828a674c
	if ctx.cr[6].eq {
	pc = 0x828A674C; continue 'dispatch;
	}
	// 828A665C: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6664: 419A0024  beq cr6, 0x828a6688
	if ctx.cr[6].eq {
	pc = 0x828A6688; continue 'dispatch;
	}
	// 828A6668: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A666C: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6670: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A6674: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A6678: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A667C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6680: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6684: 480000CC  b 0x828a6750
	pc = 0x828A6750; continue 'dispatch;
	// 828A6688: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A668C: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6690: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6694: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A6698: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A669C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A66A0: 40810054  ble 0x828a66f4
	if !ctx.cr[0].gt {
	pc = 0x828A66F4; continue 'dispatch;
	}
	// 828A66A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A66A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A66AC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A66B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A66B4: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A66B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A66BC: 41980008  blt cr6, 0x828a66c4
	if ctx.cr[6].lt {
	pc = 0x828A66C4; continue 'dispatch;
	}
	// 828A66C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A66C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A66C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A66CC: 419A0014  beq cr6, 0x828a66e0
	if ctx.cr[6].eq {
	pc = 0x828A66E0; continue 'dispatch;
	}
	// 828A66D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A66D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A66D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A66DC: 4800000C  b 0x828a66e8
	pc = 0x828A66E8; continue 'dispatch;
	// 828A66E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A66E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A66E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A66EC: 4199FFB8  bgt cr6, 0x828a66a4
	if ctx.cr[6].gt {
	pc = 0x828A66A4; continue 'dispatch;
	}
	// 828A66F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A66F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A66F8: 419A0040  beq cr6, 0x828a6738
	if ctx.cr[6].eq {
	pc = 0x828A6738; continue 'dispatch;
	}
	// 828A66FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6700: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A6704: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6708: 41990008  bgt cr6, 0x828a6710
	if ctx.cr[6].gt {
	pc = 0x828A6710; continue 'dispatch;
	}
	// 828A670C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6710: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6718: 409A0020  bne cr6, 0x828a6738
	if !ctx.cr[6].eq {
	pc = 0x828A6738; continue 'dispatch;
	}
	// 828A671C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6720: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A6724: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A672C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6734: 4800001C  b 0x828a6750
	pc = 0x828A6750; continue 'dispatch;
	// 828A6738: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A673C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6740: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6744: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6748: 48000008  b 0x828a6750
	pc = 0x828A6750; continue 'dispatch;
	// 828A674C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6750: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6758: 419A0360  beq cr6, 0x828a6ab8
	if ctx.cr[6].eq {
	pc = 0x828A6AB8; continue 'dispatch;
	}
	// 828A675C: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A6760: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828A6764: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6768: 419A0078  beq cr6, 0x828a67e0
	if ctx.cr[6].eq {
	pc = 0x828A67E0; continue 'dispatch;
	}
	// 828A676C: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6774: 409A0064  bne cr6, 0x828a67d8
	if !ctx.cr[6].eq {
	pc = 0x828A67D8; continue 'dispatch;
	}
	// 828A6778: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A677C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6780: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A6784: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6788: 40810050  ble 0x828a67d8
	if !ctx.cr[0].gt {
	pc = 0x828A67D8; continue 'dispatch;
	}
	// 828A678C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A6790: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6794: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6798: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A679C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828A67A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A67A4: 41980008  blt cr6, 0x828a67ac
	if ctx.cr[6].lt {
	pc = 0x828A67AC; continue 'dispatch;
	}
	// 828A67A8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A67AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A67B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A67B4: 419A0014  beq cr6, 0x828a67c8
	if ctx.cr[6].eq {
	pc = 0x828A67C8; continue 'dispatch;
	}
	// 828A67B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A67BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A67C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A67C4: 4800000C  b 0x828a67d0
	pc = 0x828A67D0; continue 'dispatch;
	// 828A67C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A67CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A67D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A67D4: 4199FFB8  bgt cr6, 0x828a678c
	if ctx.cr[6].gt {
	pc = 0x828A678C; continue 'dispatch;
	}
	// 828A67D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A67DC: 48000008  b 0x828a67e4
	pc = 0x828A67E4; continue 'dispatch;
	// 828A67E0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A67E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A67E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A67EC: 419A02CC  beq cr6, 0x828a6ab8
	if ctx.cr[6].eq {
	pc = 0x828A6AB8; continue 'dispatch;
	}
	// 828A67F0: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A67F4: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 828A67F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A67FC: 419A00F4  beq cr6, 0x828a68f0
	if ctx.cr[6].eq {
	pc = 0x828A68F0; continue 'dispatch;
	}
	// 828A6800: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6808: 419A0024  beq cr6, 0x828a682c
	if ctx.cr[6].eq {
	pc = 0x828A682C; continue 'dispatch;
	}
	// 828A680C: 894B004A  lbz r10, 0x4a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(74 as u32) ) } as u64;
	// 828A6810: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6814: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A6818: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A681C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6820: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A6824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6828: 480000CC  b 0x828a68f4
	pc = 0x828A68F4; continue 'dispatch;
	// 828A682C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6830: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6834: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6838: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A683C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6840: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6844: 40810054  ble 0x828a6898
	if !ctx.cr[0].gt {
	pc = 0x828A6898; continue 'dispatch;
	}
	// 828A6848: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A684C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6850: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6854: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6858: 2F07004A  cmpwi cr6, r7, 0x4a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 74, &mut ctx.xer);
	// 828A685C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6860: 41980008  blt cr6, 0x828a6868
	if ctx.cr[6].lt {
	pc = 0x828A6868; continue 'dispatch;
	}
	// 828A6864: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6868: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A686C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6870: 419A0014  beq cr6, 0x828a6884
	if ctx.cr[6].eq {
	pc = 0x828A6884; continue 'dispatch;
	}
	// 828A6874: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6878: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A687C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6880: 4800000C  b 0x828a688c
	pc = 0x828A688C; continue 'dispatch;
	// 828A6884: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6888: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A688C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6890: 4199FFB8  bgt cr6, 0x828a6848
	if ctx.cr[6].gt {
	pc = 0x828A6848; continue 'dispatch;
	}
	// 828A6894: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6898: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A689C: 419A0040  beq cr6, 0x828a68dc
	if ctx.cr[6].eq {
	pc = 0x828A68DC; continue 'dispatch;
	}
	// 828A68A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A68A4: 2F0B004A  cmpwi cr6, r11, 0x4a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 74, &mut ctx.xer);
	// 828A68A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A68AC: 41990008  bgt cr6, 0x828a68b4
	if ctx.cr[6].gt {
	pc = 0x828A68B4; continue 'dispatch;
	}
	// 828A68B0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A68B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A68B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A68BC: 409A0020  bne cr6, 0x828a68dc
	if !ctx.cr[6].eq {
	pc = 0x828A68DC; continue 'dispatch;
	}
	// 828A68C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A68C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A68C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A68CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A68D0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A68D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A68D8: 4800001C  b 0x828a68f4
	pc = 0x828A68F4; continue 'dispatch;
	// 828A68DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A68E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A68E4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A68E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A68EC: 48000008  b 0x828a68f4
	pc = 0x828A68F4; continue 'dispatch;
	// 828A68F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A68F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A68F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A68FC: 419A01BC  beq cr6, 0x828a6ab8
	if ctx.cr[6].eq {
	pc = 0x828A6AB8; continue 'dispatch;
	}
	// 828A6900: 81650018  lwz r11, 0x18(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A6904: 7D6AC038  and r10, r11, r24
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[24].u64;
	// 828A6908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A690C: 419A01AC  beq cr6, 0x828a6ab8
	if ctx.cr[6].eq {
	pc = 0x828A6AB8; continue 'dispatch;
	}
	// 828A6910: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828A6914: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 828A6918: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 828A691C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828A6920: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828A6924: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828A6928: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A692C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6930: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A6934: 419A0174  beq cr6, 0x828a6aa8
	if ctx.cr[6].eq {
	pc = 0x828A6AA8; continue 'dispatch;
	}
	// 828A6938: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A693C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A6940: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828A6944: 409A0010  bne cr6, 0x828a6954
	if !ctx.cr[6].eq {
	pc = 0x828A6954; continue 'dispatch;
	}
	// 828A6948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A694C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A6950: 4BD71D41  bl 0x82618690
	ctx.lr = 0x828A6954;
	sub_82618690(ctx, base);
	// 828A6954: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6958: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A695C: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828A6960: 409A0010  bne cr6, 0x828a6970
	if !ctx.cr[6].eq {
	pc = 0x828A6970; continue 'dispatch;
	}
	// 828A6964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6968: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A696C: 4BD71D25  bl 0x82618690
	ctx.lr = 0x828A6970;
	sub_82618690(ctx, base);
	// 828A6970: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6974: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A6978: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A697C: 409AFFBC  bne cr6, 0x828a6938
	if !ctx.cr[6].eq {
	pc = 0x828A6938; continue 'dispatch;
	}
	// 828A6980: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A6984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6988: 419A0120  beq cr6, 0x828a6aa8
	if ctx.cr[6].eq {
	pc = 0x828A6AA8; continue 'dispatch;
	}
	// 828A698C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A6990: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A6994: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6998: 41820110  beq 0x828a6aa8
	if ctx.cr[0].eq {
	pc = 0x828A6AA8; continue 'dispatch;
	}
	// 828A699C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A69A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A69A4: 419A0104  beq cr6, 0x828a6aa8
	if ctx.cr[6].eq {
	pc = 0x828A6AA8; continue 'dispatch;
	}
	// 828A69A8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A69AC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A69B0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A69B4: 418200F4  beq 0x828a6aa8
	if ctx.cr[0].eq {
	pc = 0x828A6AA8; continue 'dispatch;
	}
	// 828A69B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A69BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A69C0: 48003889  bl 0x828aa248
	ctx.lr = 0x828A69C4;
	sub_828AA248(ctx, base);
	// 828A69C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A69C8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A69CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A69D0: 48003879  bl 0x828aa248
	ctx.lr = 0x828A69D4;
	sub_828AA248(ctx, base);
	// 828A69D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A69D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A69DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A69E0: 48003869  bl 0x828aa248
	ctx.lr = 0x828A69E4;
	sub_828AA248(ctx, base);
	// 828A69E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A69E8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828A69EC: 4800385D  bl 0x828aa248
	ctx.lr = 0x828A69F0;
	sub_828AA248(ctx, base);
	// 828A69F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A69F4: 4BB35E35  bl 0x823dc828
	ctx.lr = 0x828A69F8;
	sub_823DC828(ctx, base);
	// 828A69F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A69FC: 4BB35E2D  bl 0x823dc828
	ctx.lr = 0x828A6A00;
	sub_823DC828(ctx, base);
	// 828A6A00: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6A08: 409A000C  bne cr6, 0x828a6a14
	if !ctx.cr[6].eq {
	pc = 0x828A6A14; continue 'dispatch;
	}
	// 828A6A0C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828A6A10: 48000010  b 0x828a6a20
	pc = 0x828A6A20; continue 'dispatch;
	// 828A6A14: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A6A18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A6A1C: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 828A6A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6A24: 419A0048  beq cr6, 0x828a6a6c
	if ctx.cr[6].eq {
	pc = 0x828A6A6C; continue 'dispatch;
	}
	// 828A6A28: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A6A2C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A6A30: 7D0A2E70  srawi r10, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 828A6A34: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A6A38: 40980034  bge cr6, 0x828a6a6c
	if !ctx.cr[6].lt {
	pc = 0x828A6A6C; continue 'dispatch;
	}
	// 828A6A3C: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A6A40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A6A44: 419A001C  beq cr6, 0x828a6a60
	if ctx.cr[6].eq {
	pc = 0x828A6A60; continue 'dispatch;
	}
	// 828A6A48: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828A6A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6A50: 480037F9  bl 0x828aa248
	ctx.lr = 0x828A6A54;
	sub_828AA248(ctx, base);
	// 828A6A54: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828A6A58: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828A6A5C: 480037ED  bl 0x828aa248
	ctx.lr = 0x828A6A60;
	sub_828AA248(ctx, base);
	// 828A6A60: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 828A6A64: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828A6A68: 48000030  b 0x828a6a98
	pc = 0x828A6A98; continue 'dispatch;
	// 828A6A6C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A6A70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A6A74: 40990008  ble cr6, 0x828a6a7c
	if !ctx.cr[6].gt {
	pc = 0x828A6A7C; continue 'dispatch;
	}
	// 828A6A78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A6A7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6A80: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828A6A84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A6A88: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A6A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A6A90: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6A94: 48003965  bl 0x828aa3f8
	ctx.lr = 0x828A6A98;
	sub_828AA3F8(ctx, base);
	// 828A6A98: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828A6A9C: 4BB35D8D  bl 0x823dc828
	ctx.lr = 0x828A6AA0;
	sub_823DC828(ctx, base);
	// 828A6AA0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A6AA4: 4BB35D85  bl 0x823dc828
	ctx.lr = 0x828A6AA8;
	sub_823DC828(ctx, base);
	// 828A6AA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A6AAC: 4BB35D7D  bl 0x823dc828
	ctx.lr = 0x828A6AB0;
	sub_823DC828(ctx, base);
	// 828A6AB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A6AB4: 4BB35D75  bl 0x823dc828
	ctx.lr = 0x828A6AB8;
	sub_823DC828(ctx, base);
	// 828A6AB8: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828A6ABC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828A6AC0: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A6AC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6AC8: 419A00F0  beq cr6, 0x828a6bb8
	if ctx.cr[6].eq {
	pc = 0x828A6BB8; continue 'dispatch;
	}
	// 828A6ACC: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6AD0: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6AD8: 419A0020  beq cr6, 0x828a6af8
	if ctx.cr[6].eq {
	pc = 0x828A6AF8; continue 'dispatch;
	}
	// 828A6ADC: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828A6AE0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A6AE4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A6AE8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6AEC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6AF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6AF4: 480000C8  b 0x828a6bbc
	pc = 0x828A6BBC; continue 'dispatch;
	// 828A6AF8: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6AFC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6B00: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A6B04: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6B08: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6B0C: 40810054  ble 0x828a6b60
	if !ctx.cr[0].gt {
	pc = 0x828A6B60; continue 'dispatch;
	}
	// 828A6B10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A6B14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6B18: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6B1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6B20: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828A6B24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6B28: 41980008  blt cr6, 0x828a6b30
	if ctx.cr[6].lt {
	pc = 0x828A6B30; continue 'dispatch;
	}
	// 828A6B2C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6B30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A6B34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6B38: 419A0014  beq cr6, 0x828a6b4c
	if ctx.cr[6].eq {
	pc = 0x828A6B4C; continue 'dispatch;
	}
	// 828A6B3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6B40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A6B44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6B48: 4800000C  b 0x828a6b54
	pc = 0x828A6B54; continue 'dispatch;
	// 828A6B4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6B50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A6B54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6B58: 4199FFB8  bgt cr6, 0x828a6b10
	if ctx.cr[6].gt {
	pc = 0x828A6B10; continue 'dispatch;
	}
	// 828A6B5C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6B60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A6B64: 419A0040  beq cr6, 0x828a6ba4
	if ctx.cr[6].eq {
	pc = 0x828A6BA4; continue 'dispatch;
	}
	// 828A6B68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6B6C: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828A6B70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6B74: 41990008  bgt cr6, 0x828a6b7c
	if ctx.cr[6].gt {
	pc = 0x828A6B7C; continue 'dispatch;
	}
	// 828A6B78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6B7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6B84: 409A0020  bne cr6, 0x828a6ba4
	if !ctx.cr[6].eq {
	pc = 0x828A6BA4; continue 'dispatch;
	}
	// 828A6B88: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6B8C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A6B90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6B94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6B98: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6B9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6BA0: 4800001C  b 0x828a6bbc
	pc = 0x828A6BBC; continue 'dispatch;
	// 828A6BA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A6BA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6BAC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6BB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6BB4: 48000008  b 0x828a6bbc
	pc = 0x828A6BBC; continue 'dispatch;
	// 828A6BB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6BBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6BC4: 419A0074  beq cr6, 0x828a6c38
	if ctx.cr[6].eq {
	pc = 0x828A6C38; continue 'dispatch;
	}
	// 828A6BC8: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6BCC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A6BD0: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828A6BD4: 41980064  blt cr6, 0x828a6c38
	if ctx.cr[6].lt {
	pc = 0x828A6C38; continue 'dispatch;
	}
	// 828A6BD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6BDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6BE0: 48041839  bl 0x828e8418
	ctx.lr = 0x828A6BE4;
	sub_828E8418(ctx, base);
	// 828A6BE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A6BE8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A6BEC: 419A0018  beq cr6, 0x828a6c04
	if ctx.cr[6].eq {
	pc = 0x828A6C04; continue 'dispatch;
	}
	// 828A6BF0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A6BF4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A6BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6BFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6C00: 409A0008  bne cr6, 0x828a6c08
	if !ctx.cr[6].eq {
	pc = 0x828A6C08; continue 'dispatch;
	}
	// 828A6C04: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6C08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6C10: 419A001C  beq cr6, 0x828a6c2c
	if ctx.cr[6].eq {
	pc = 0x828A6C2C; continue 'dispatch;
	}
	// 828A6C14: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 828A6C18: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828A6C1C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828A6C20: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A6C24: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828A6C28: 4BFFF9C9  bl 0x828a65f0
	ctx.lr = 0x828A6C2C;
	sub_828A65F0(ctx, base);
	// 828A6C2C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828A6C30: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828A6C34: 4099FFA4  ble cr6, 0x828a6bd8
	if !ctx.cr[6].gt {
	pc = 0x828A6BD8; continue 'dispatch;
	}
	// 828A6C38: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828A6C3C: 48402808  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6C40 size=1276
    let mut pc: u32 = 0x828A6C40;
    'dispatch: loop {
        match pc {
            0x828A6C40 => {
    //   block [0x828A6C40..0x828A713C)
	// 828A6C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6C44: 484027B9  bl 0x82ca93fc
	ctx.lr = 0x828A6C48;
	sub_82CA93D0(ctx, base);
	// 828A6C48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6C4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A6C50: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A6C54: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828A6C58: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828A6C5C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A6C60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A6C64: 419A0018  beq cr6, 0x828a6c7c
	if ctx.cr[6].eq {
	pc = 0x828A6C7C; continue 'dispatch;
	}
	// 828A6C68: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A6C6C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A6C70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6C74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6C78: 409A0008  bne cr6, 0x828a6c80
	if !ctx.cr[6].eq {
	pc = 0x828A6C80; continue 'dispatch;
	}
	// 828A6C7C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6C80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6C88: 419A04AC  beq cr6, 0x828a7134
	if ctx.cr[6].eq {
	pc = 0x828A7134; continue 'dispatch;
	}
	// 828A6C8C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A6C90: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828A6C94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A6C98: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A6C9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6CA0: 419A00F4  beq cr6, 0x828a6d94
	if ctx.cr[6].eq {
	pc = 0x828A6D94; continue 'dispatch;
	}
	// 828A6CA4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6CAC: 419A0024  beq cr6, 0x828a6cd0
	if ctx.cr[6].eq {
	pc = 0x828A6CD0; continue 'dispatch;
	}
	// 828A6CB0: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A6CB4: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6CB8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A6CBC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A6CC0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6CC4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A6CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6CCC: 480000CC  b 0x828a6d98
	pc = 0x828A6D98; continue 'dispatch;
	// 828A6CD0: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6CD4: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6CD8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6CDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A6CE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6CE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6CE8: 40810054  ble 0x828a6d3c
	if !ctx.cr[0].gt {
	pc = 0x828A6D3C; continue 'dispatch;
	}
	// 828A6CEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A6CF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6CF4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6CF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6CFC: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A6D00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6D04: 41980008  blt cr6, 0x828a6d0c
	if ctx.cr[6].lt {
	pc = 0x828A6D0C; continue 'dispatch;
	}
	// 828A6D08: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6D0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A6D10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6D14: 419A0014  beq cr6, 0x828a6d28
	if ctx.cr[6].eq {
	pc = 0x828A6D28; continue 'dispatch;
	}
	// 828A6D18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6D1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A6D20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6D24: 4800000C  b 0x828a6d30
	pc = 0x828A6D30; continue 'dispatch;
	// 828A6D28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6D2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A6D30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6D34: 4199FFB8  bgt cr6, 0x828a6cec
	if ctx.cr[6].gt {
	pc = 0x828A6CEC; continue 'dispatch;
	}
	// 828A6D38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6D3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A6D40: 419A0040  beq cr6, 0x828a6d80
	if ctx.cr[6].eq {
	pc = 0x828A6D80; continue 'dispatch;
	}
	// 828A6D44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6D48: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A6D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6D50: 41990008  bgt cr6, 0x828a6d58
	if ctx.cr[6].gt {
	pc = 0x828A6D58; continue 'dispatch;
	}
	// 828A6D54: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6D60: 409A0020  bne cr6, 0x828a6d80
	if !ctx.cr[6].eq {
	pc = 0x828A6D80; continue 'dispatch;
	}
	// 828A6D64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6D68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A6D6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6D70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6D74: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A6D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6D7C: 4800001C  b 0x828a6d98
	pc = 0x828A6D98; continue 'dispatch;
	// 828A6D80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A6D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6D88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A6D8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6D90: 48000008  b 0x828a6d98
	pc = 0x828A6D98; continue 'dispatch;
	// 828A6D94: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6D98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6DA0: 419A021C  beq cr6, 0x828a6fbc
	if ctx.cr[6].eq {
	pc = 0x828A6FBC; continue 'dispatch;
	}
	// 828A6DA4: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A6DA8: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828A6DAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6DB0: 419A0078  beq cr6, 0x828a6e28
	if ctx.cr[6].eq {
	pc = 0x828A6E28; continue 'dispatch;
	}
	// 828A6DB4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6DBC: 409A0064  bne cr6, 0x828a6e20
	if !ctx.cr[6].eq {
	pc = 0x828A6E20; continue 'dispatch;
	}
	// 828A6DC0: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6DC4: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6DC8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A6DCC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6DD0: 40810050  ble 0x828a6e20
	if !ctx.cr[0].gt {
	pc = 0x828A6E20; continue 'dispatch;
	}
	// 828A6DD4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A6DD8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6DDC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6DE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6DE4: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828A6DE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6DEC: 41980008  blt cr6, 0x828a6df4
	if ctx.cr[6].lt {
	pc = 0x828A6DF4; continue 'dispatch;
	}
	// 828A6DF0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6DF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A6DF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6DFC: 419A0014  beq cr6, 0x828a6e10
	if ctx.cr[6].eq {
	pc = 0x828A6E10; continue 'dispatch;
	}
	// 828A6E00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6E04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A6E08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6E0C: 4800000C  b 0x828a6e18
	pc = 0x828A6E18; continue 'dispatch;
	// 828A6E10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6E14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A6E18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6E1C: 4199FFB8  bgt cr6, 0x828a6dd4
	if ctx.cr[6].gt {
	pc = 0x828A6DD4; continue 'dispatch;
	}
	// 828A6E20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6E24: 48000008  b 0x828a6e2c
	pc = 0x828A6E2C; continue 'dispatch;
	// 828A6E28: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6E2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6E34: 419A0188  beq cr6, 0x828a6fbc
	if ctx.cr[6].eq {
	pc = 0x828A6FBC; continue 'dispatch;
	}
	// 828A6E38: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A6E3C: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 828A6E40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6E44: 419A00F0  beq cr6, 0x828a6f34
	if ctx.cr[6].eq {
	pc = 0x828A6F34; continue 'dispatch;
	}
	// 828A6E48: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6E4C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6E54: 419A0020  beq cr6, 0x828a6e74
	if ctx.cr[6].eq {
	pc = 0x828A6E74; continue 'dispatch;
	}
	// 828A6E58: 896B004A  lbz r11, 0x4a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(74 as u32) ) } as u64;
	// 828A6E5C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A6E60: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A6E64: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6E68: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A6E6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6E70: 480000C8  b 0x828a6f38
	pc = 0x828A6F38; continue 'dispatch;
	// 828A6E74: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A6E78: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6E7C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A6E80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6E84: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6E88: 40810054  ble 0x828a6edc
	if !ctx.cr[0].gt {
	pc = 0x828A6EDC; continue 'dispatch;
	}
	// 828A6E8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A6E90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A6E94: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A6E98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6E9C: 2F07004A  cmpwi cr6, r7, 0x4a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 74, &mut ctx.xer);
	// 828A6EA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A6EA4: 41980008  blt cr6, 0x828a6eac
	if ctx.cr[6].lt {
	pc = 0x828A6EAC; continue 'dispatch;
	}
	// 828A6EA8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A6EAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A6EB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A6EB4: 419A0014  beq cr6, 0x828a6ec8
	if ctx.cr[6].eq {
	pc = 0x828A6EC8; continue 'dispatch;
	}
	// 828A6EB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A6EBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A6EC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A6EC4: 4800000C  b 0x828a6ed0
	pc = 0x828A6ED0; continue 'dispatch;
	// 828A6EC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A6ECC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A6ED0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6ED4: 4199FFB8  bgt cr6, 0x828a6e8c
	if ctx.cr[6].gt {
	pc = 0x828A6E8C; continue 'dispatch;
	}
	// 828A6ED8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A6EDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A6EE0: 419A0040  beq cr6, 0x828a6f20
	if ctx.cr[6].eq {
	pc = 0x828A6F20; continue 'dispatch;
	}
	// 828A6EE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6EE8: 2F0B004A  cmpwi cr6, r11, 0x4a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 74, &mut ctx.xer);
	// 828A6EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6EF0: 41990008  bgt cr6, 0x828a6ef8
	if ctx.cr[6].gt {
	pc = 0x828A6EF8; continue 'dispatch;
	}
	// 828A6EF4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6EF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6F00: 409A0020  bne cr6, 0x828a6f20
	if !ctx.cr[6].eq {
	pc = 0x828A6F20; continue 'dispatch;
	}
	// 828A6F04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6F08: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A6F0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6F10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6F14: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A6F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6F1C: 4800001C  b 0x828a6f38
	pc = 0x828A6F38; continue 'dispatch;
	// 828A6F20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A6F24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6F28: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828A6F2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6F30: 48000008  b 0x828a6f38
	pc = 0x828A6F38; continue 'dispatch;
	// 828A6F34: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A6F38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6F40: 419A007C  beq cr6, 0x828a6fbc
	if ctx.cr[6].eq {
	pc = 0x828A6FBC; continue 'dispatch;
	}
	// 828A6F44: 81650018  lwz r11, 0x18(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A6F48: 7D6AD038  and r10, r11, r26
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[26].u64;
	// 828A6F4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6F50: 419A006C  beq cr6, 0x828a6fbc
	if ctx.cr[6].eq {
	pc = 0x828A6FBC; continue 'dispatch;
	}
	// 828A6F54: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6F58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A6F5C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6F60: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A6F64: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6F68: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A6F6C: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828A6F70: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828A6F74: 7CCA1E70  srawi r10, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828A6F78: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A6F7C: 48003195  bl 0x828aa110
	ctx.lr = 0x828A6F80;
	sub_828AA110(ctx, base);
	// 828A6F80: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6F84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A6F88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A6F8C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A6F90: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 828A6F94: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A6F98: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828A6F9C: 419A0020  beq cr6, 0x828a6fbc
	if ctx.cr[6].eq {
	pc = 0x828A6FBC; continue 'dispatch;
	}
	// 828A6FA0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6FA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6FA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A6FAC: 4BAAFB6D  bl 0x82356b18
	ctx.lr = 0x828A6FB0;
	sub_82356B18(ctx, base);
	// 828A6FB0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A6FB4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828A6FB8: 409AFFEC  bne cr6, 0x828a6fa4
	if !ctx.cr[6].eq {
	pc = 0x828A6FA4; continue 'dispatch;
	}
	// 828A6FBC: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828A6FC0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828A6FC4: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A6FC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A6FCC: 419A00F0  beq cr6, 0x828a70bc
	if ctx.cr[6].eq {
	pc = 0x828A70BC; continue 'dispatch;
	}
	// 828A6FD0: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6FD4: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A6FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6FDC: 419A0020  beq cr6, 0x828a6ffc
	if ctx.cr[6].eq {
	pc = 0x828A6FFC; continue 'dispatch;
	}
	// 828A6FE0: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828A6FE4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A6FE8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A6FEC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6FF0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A6FF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6FF8: 480000C8  b 0x828a70c0
	pc = 0x828A70C0; continue 'dispatch;
	// 828A6FFC: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A7000: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A7004: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A7008: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A700C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7010: 40810054  ble 0x828a7064
	if !ctx.cr[0].gt {
	pc = 0x828A7064; continue 'dispatch;
	}
	// 828A7014: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A7018: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A701C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A7020: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7024: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828A7028: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A702C: 41980008  blt cr6, 0x828a7034
	if ctx.cr[6].lt {
	pc = 0x828A7034; continue 'dispatch;
	}
	// 828A7030: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A7034: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A7038: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A703C: 419A0014  beq cr6, 0x828a7050
	if ctx.cr[6].eq {
	pc = 0x828A7050; continue 'dispatch;
	}
	// 828A7040: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A7044: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A7048: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A704C: 4800000C  b 0x828a7058
	pc = 0x828A7058; continue 'dispatch;
	// 828A7050: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A7054: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A7058: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A705C: 4199FFB8  bgt cr6, 0x828a7014
	if ctx.cr[6].gt {
	pc = 0x828A7014; continue 'dispatch;
	}
	// 828A7060: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A7064: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A7068: 419A0040  beq cr6, 0x828a70a8
	if ctx.cr[6].eq {
	pc = 0x828A70A8; continue 'dispatch;
	}
	// 828A706C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7070: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828A7074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7078: 41990008  bgt cr6, 0x828a7080
	if ctx.cr[6].gt {
	pc = 0x828A7080; continue 'dispatch;
	}
	// 828A707C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A7080: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7088: 409A0020  bne cr6, 0x828a70a8
	if !ctx.cr[6].eq {
	pc = 0x828A70A8; continue 'dispatch;
	}
	// 828A708C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A7090: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A7094: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7098: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A709C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A70A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A70A4: 4800001C  b 0x828a70c0
	pc = 0x828A70C0; continue 'dispatch;
	// 828A70A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A70AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A70B0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A70B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A70B8: 48000008  b 0x828a70c0
	pc = 0x828A70C0; continue 'dispatch;
	// 828A70BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A70C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A70C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A70C8: 419A006C  beq cr6, 0x828a7134
	if ctx.cr[6].eq {
	pc = 0x828A7134; continue 'dispatch;
	}
	// 828A70CC: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A70D0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A70D4: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 828A70D8: 4198005C  blt cr6, 0x828a7134
	if ctx.cr[6].lt {
	pc = 0x828A7134; continue 'dispatch;
	}
	// 828A70DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A70E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A70E4: 48041335  bl 0x828e8418
	ctx.lr = 0x828A70E8;
	sub_828E8418(ctx, base);
	// 828A70E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A70EC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A70F0: 419A0018  beq cr6, 0x828a7108
	if ctx.cr[6].eq {
	pc = 0x828A7108; continue 'dispatch;
	}
	// 828A70F4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A70F8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A70FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7100: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7104: 409A0008  bne cr6, 0x828a710c
	if !ctx.cr[6].eq {
	pc = 0x828A710C; continue 'dispatch;
	}
	// 828A7108: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828A710C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7114: 419A0014  beq cr6, 0x828a7128
	if ctx.cr[6].eq {
	pc = 0x828A7128; continue 'dispatch;
	}
	// 828A7118: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828A711C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A7120: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A7124: 4BFFFB1D  bl 0x828a6c40
	ctx.lr = 0x828A7128;
	sub_828A6C40(ctx, base);
	// 828A7128: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828A712C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828A7130: 4099FFAC  ble cr6, 0x828a70dc
	if !ctx.cr[6].gt {
	pc = 0x828A70DC; continue 'dispatch;
	}
	// 828A7134: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A7138: 48402314  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A7140 size=1284
    let mut pc: u32 = 0x828A7140;
    'dispatch: loop {
        match pc {
            0x828A7140 => {
    //   block [0x828A7140..0x828A7644)
	// 828A7140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7144: 484022A1  bl 0x82ca93e4
	ctx.lr = 0x828A7148;
	sub_82CA93D0(ctx, base);
	// 828A7148: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 828A714C: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7648 size=128
    let mut pc: u32 = 0x828A7648;
    'dispatch: loop {
        match pc {
            0x828A7648 => {
    //   block [0x828A7648..0x828A76C8)
	// 828A7648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A764C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A7654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A765C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A7660: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A7664: 4BFFECED  bl 0x828a6350
	ctx.lr = 0x828A7668;
	sub_828A6350(ctx, base);
	// 828A7668: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A766C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A7670: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A7674: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828A7678: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A767C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A7680: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A7684: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A7688: 419A0028  beq cr6, 0x828a76b0
	if ctx.cr[6].eq {
	pc = 0x828A76B0; continue 'dispatch;
	}
	// 828A768C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7690: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7694: 81090034  lwz r8, 0x34(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A7698: 7F08F800  cmpw cr6, r8, r31
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[31].s32, &mut ctx.xer);
	// 828A769C: 409A0008  bne cr6, 0x828a76a4
	if !ctx.cr[6].eq {
	pc = 0x828A76A4; continue 'dispatch;
	}
	// 828A76A0: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828A76A4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 828A76A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A76AC: 409AFFE4  bne cr6, 0x828a7690
	if !ctx.cr[6].eq {
	pc = 0x828A7690; continue 'dispatch;
	}
	// 828A76B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A76B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A76B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A76BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A76C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A76C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A76C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A76C8 size=300
    let mut pc: u32 = 0x828A76C8;
    'dispatch: loop {
        match pc {
            0x828A76C8 => {
    //   block [0x828A76C8..0x828A77F4)
	// 828A76C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A76CC: 48401D21  bl 0x82ca93ec
	ctx.lr = 0x828A76D0;
	sub_82CA93D0(ctx, base);
	// 828A76D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A76D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A76D8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 828A76DC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828A76E0: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 828A76E4: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 828A76E8: 4BFFEC69  bl 0x828a6350
	ctx.lr = 0x828A76EC;
	sub_828A6350(ctx, base);
	// 828A76EC: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A76F0: 3B00000C  li r24, 0xc
	ctx.r[24].s64 = 12;
	// 828A76F4: 815B0020  lwz r10, 0x20(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A76F8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828A76FC: 3BBB001C  addi r29, r27, 0x1c
	ctx.r[29].s64 = ctx.r[27].s64 + 28;
	// 828A7700: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A7704: 7C89C3D6  divw r4, r9, r24
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828A7708: 48002A09  bl 0x828aa110
	ctx.lr = 0x828A770C;
	sub_828AA110(ctx, base);
	// 828A770C: 811B0024  lwz r8, 0x24(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A7710: 80FB0020  lwz r7, 0x20(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A7714: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828A7718: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828A771C: 7CA6C3D7  divw. r5, r6, r24
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[24].s32;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828A7720: 418200CC  beq 0x828a77ec
	if ctx.cr[0].eq {
	pc = 0x828A77EC; continue 'dispatch;
	}
	// 828A7724: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A7728: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A772C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A7730: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828A7734: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828A7738: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 828A773C: 419A0014  beq cr6, 0x828a7750
	if ctx.cr[6].eq {
	pc = 0x828A7750; continue 'dispatch;
	}
	// 828A7740: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7744: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A7748: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828A774C: 409A0050  bne cr6, 0x828a779c
	if !ctx.cr[6].eq {
	pc = 0x828A779C; continue 'dispatch;
	}
	// 828A7750: 2F170002  cmpwi cr6, r23, 2
	ctx.cr[6].compare_i32(ctx.r[23].s32, 2, &mut ctx.xer);
	// 828A7754: 419A004C  beq cr6, 0x828a77a0
	if ctx.cr[6].eq {
	pc = 0x828A77A0; continue 'dispatch;
	}
	// 828A7758: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A775C: 4BDD50FD  bl 0x8267c858
	ctx.lr = 0x828A7760;
	sub_8267C858(ctx, base);
	// 828A7760: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 828A7764: 409A0014  bne cr6, 0x828a7778
	if !ctx.cr[6].eq {
	pc = 0x828A7778; continue 'dispatch;
	}
	// 828A7768: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A776C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7770: 419A002C  beq cr6, 0x828a779c
	if ctx.cr[6].eq {
	pc = 0x828A779C; continue 'dispatch;
	}
	// 828A7774: 48000018  b 0x828a778c
	pc = 0x828A778C; continue 'dispatch;
	// 828A7778: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 828A777C: 409A0010  bne cr6, 0x828a778c
	if !ctx.cr[6].eq {
	pc = 0x828A778C; continue 'dispatch;
	}
	// 828A7780: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A7784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7788: 409A0014  bne cr6, 0x828a779c
	if !ctx.cr[6].eq {
	pc = 0x828A779C; continue 'dispatch;
	}
	// 828A778C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7790: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A7794: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7798: 419A0008  beq cr6, 0x828a77a0
	if ctx.cr[6].eq {
	pc = 0x828A77A0; continue 'dispatch;
	}
	// 828A779C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A77A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A77A4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A77A8: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 828A77AC: 409A0008  bne cr6, 0x828a77b4
	if !ctx.cr[6].eq {
	pc = 0x828A77B4; continue 'dispatch;
	}
	// 828A77B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A77B4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828A77B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A77BC: 419A0010  beq cr6, 0x828a77cc
	if ctx.cr[6].eq {
	pc = 0x828A77CC; continue 'dispatch;
	}
	// 828A77C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A77C4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828A77C8: 4BAAF351  bl 0x82356b18
	ctx.lr = 0x828A77CC;
	sub_82356B18(ctx, base);
	// 828A77CC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A77D0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828A77D4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A77D8: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 828A77DC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A77E0: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828A77E4: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828A77E8: 4198FF40  blt cr6, 0x828a7728
	if ctx.cr[6].lt {
	pc = 0x828A7728; continue 'dispatch;
	}
	// 828A77EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A77F0: 48401C4C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A77F8 size=196
    let mut pc: u32 = 0x828A77F8;
    'dispatch: loop {
        match pc {
            0x828A77F8 => {
    //   block [0x828A77F8..0x828A78BC)
	// 828A77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A77FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7804: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A780C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828A7810: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A7814: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A7818: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A781C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A7820: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A7824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7828: 4BFFFEA1  bl 0x828a76c8
	ctx.lr = 0x828A782C;
	sub_828A76C8(ctx, base);
	// 828A782C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7830: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7838: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828A783C: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7840: 41820060  beq 0x828a78a0
	if ctx.cr[0].eq {
	pc = 0x828A78A0; continue 'dispatch;
	}
	// 828A7844: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A7848: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A784C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A7850: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7854: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7858: 80CA0078  lwz r6, 0x78(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A785C: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828A7860: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828A7864: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A7868: 7D245B96  divwu r9, r4, r11
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A786C: 908A0078  stw r4, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A7870: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A7874: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A7878: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A787C: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828A7880: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A7884: 4BB34FA5  bl 0x823dc828
	ctx.lr = 0x828A7888;
	sub_823DC828(ctx, base);
	// 828A7888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A788C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A789C: 4E800020  blr
	return;
	// 828A78A0: 4BB34F89  bl 0x823dc828
	ctx.lr = 0x828A78A4;
	sub_823DC828(ctx, base);
	// 828A78A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A78A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A78AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A78B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A78B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A78B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A78C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A78C0 size=196
    let mut pc: u32 = 0x828A78C0;
    'dispatch: loop {
        match pc {
            0x828A78C0 => {
    //   block [0x828A78C0..0x828A7984)
	// 828A78C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A78C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A78C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A78CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A78D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A78D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828A78D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A78DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A78E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A78E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828A78E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A78EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A78F0: 4BFFFDD9  bl 0x828a76c8
	ctx.lr = 0x828A78F4;
	sub_828A76C8(ctx, base);
	// 828A78F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A78F8: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A78FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7900: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828A7904: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7908: 41820060  beq 0x828a7968
	if ctx.cr[0].eq {
	pc = 0x828A7968; continue 'dispatch;
	}
	// 828A790C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A7910: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A7914: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A7918: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A791C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7920: 80CA0078  lwz r6, 0x78(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A7924: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828A7928: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828A792C: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A7930: 7D245B96  divwu r9, r4, r11
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A7934: 908A0078  stw r4, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A7938: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A793C: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A7940: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A7944: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828A7948: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A794C: 4BB34EDD  bl 0x823dc828
	ctx.lr = 0x828A7950;
	sub_823DC828(ctx, base);
	// 828A7950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A795C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7964: 4E800020  blr
	return;
	// 828A7968: 4BB34EC1  bl 0x823dc828
	ctx.lr = 0x828A796C;
	sub_823DC828(ctx, base);
	// 828A796C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A7970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A797C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7988 size=196
    let mut pc: u32 = 0x828A7988;
    'dispatch: loop {
        match pc {
            0x828A7988 => {
    //   block [0x828A7988..0x828A7A4C)
	// 828A7988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A798C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7994: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A799C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828A79A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A79A4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828A79A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A79AC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828A79B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A79B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A79B8: 4BFFFD11  bl 0x828a76c8
	ctx.lr = 0x828A79BC;
	sub_828A76C8(ctx, base);
	// 828A79BC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A79C0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A79C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A79C8: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828A79CC: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A79D0: 41820060  beq 0x828a7a30
	if ctx.cr[0].eq {
	pc = 0x828A7A30; continue 'dispatch;
	}
	// 828A79D4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A79D8: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A79DC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A79E0: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A79E4: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A79E8: 80CA0078  lwz r6, 0x78(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A79EC: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828A79F0: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828A79F4: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A79F8: 7D245B96  divwu r9, r4, r11
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A79FC: 908A0078  stw r4, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A7A00: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A7A04: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A7A08: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A7A0C: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828A7A10: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A7A14: 4BB34E15  bl 0x823dc828
	ctx.lr = 0x828A7A18;
	sub_823DC828(ctx, base);
	// 828A7A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7A28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7A2C: 4E800020  blr
	return;
	// 828A7A30: 4BB34DF9  bl 0x823dc828
	ctx.lr = 0x828A7A34;
	sub_823DC828(ctx, base);
	// 828A7A34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A7A38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7A50 size=196
    let mut pc: u32 = 0x828A7A50;
    'dispatch: loop {
        match pc {
            0x828A7A50 => {
    //   block [0x828A7A50..0x828A7B14)
	// 828A7A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7A5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7A64: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828A7A68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A7A6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A7A70: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7A74: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828A7A78: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A7A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7A80: 4BFFFC49  bl 0x828a76c8
	ctx.lr = 0x828A7A84;
	sub_828A76C8(ctx, base);
	// 828A7A84: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7A88: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7A8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7A90: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828A7A94: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7A98: 41820060  beq 0x828a7af8
	if ctx.cr[0].eq {
	pc = 0x828A7AF8; continue 'dispatch;
	}
	// 828A7A9C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A7AA0: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A7AA4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A7AA8: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7AAC: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7AB0: 80CA0078  lwz r6, 0x78(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A7AB4: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828A7AB8: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828A7ABC: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A7AC0: 7D245B96  divwu r9, r4, r11
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A7AC4: 908A0078  stw r4, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A7AC8: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A7ACC: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A7AD0: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A7AD4: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828A7AD8: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A7ADC: 4BB34D4D  bl 0x823dc828
	ctx.lr = 0x828A7AE0;
	sub_823DC828(ctx, base);
	// 828A7AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7AE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7AF4: 4E800020  blr
	return;
	// 828A7AF8: 4BB34D31  bl 0x823dc828
	ctx.lr = 0x828A7AFC;
	sub_823DC828(ctx, base);
	// 828A7AFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A7B00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7B04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7B08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7B18 size=616
    let mut pc: u32 = 0x828A7B18;
    'dispatch: loop {
        match pc {
            0x828A7B18 => {
    //   block [0x828A7B18..0x828A7D80)
	// 828A7B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7B1C: 484018E9  bl 0x82ca9404
	ctx.lr = 0x828A7B20;
	sub_82CA93D0(ctx, base);
	// 828A7B20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7B24: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A7B28: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828A7B2C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828A7B30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A7B34: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 828A7B38: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A7B3C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828A7B40: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7B44: 4BFFF0FD  bl 0x828a6c40
	ctx.lr = 0x828A7B48;
	sub_828A6C40(ctx, base);
	// 828A7B48: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7B4C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7B50: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 828A7B54: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828A7B58: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 828A7B5C: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 828A7B60: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 828A7B64: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A7B68: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 828A7B6C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7B70: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A7B74: 419A0050  beq cr6, 0x828a7bc4
	if ctx.cr[6].eq {
	pc = 0x828A7BC4; continue 'dispatch;
	}
	// 828A7B78: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7B7C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A7B80: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828A7B84: 409A0010  bne cr6, 0x828a7b94
	if !ctx.cr[6].eq {
	pc = 0x828A7B94; continue 'dispatch;
	}
	// 828A7B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7B8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A7B90: 4BAAEF89  bl 0x82356b18
	ctx.lr = 0x828A7B94;
	sub_82356B18(ctx, base);
	// 828A7B94: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A7B98: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828A7B9C: 409A0010  bne cr6, 0x828a7bac
	if !ctx.cr[6].eq {
	pc = 0x828A7BAC; continue 'dispatch;
	}
	// 828A7BA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7BA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A7BA8: 4BAAEF71  bl 0x82356b18
	ctx.lr = 0x828A7BAC;
	sub_82356B18(ctx, base);
	// 828A7BAC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7BB0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A7BB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A7BB8: 409AFFC0  bne cr6, 0x828a7b78
	if !ctx.cr[6].eq {
	pc = 0x828A7B78; continue 'dispatch;
	}
	// 828A7BBC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A7BC0: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828A7BC4: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A7BC8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 828A7BCC: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828A7BD0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A7BD4: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 828A7BD8: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 828A7BDC: 7CEA1E71  srawi. r10, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A7BE0: 418200EC  beq 0x828a7ccc
	if ctx.cr[0].eq {
	pc = 0x828A7CCC; continue 'dispatch;
	}
	// 828A7BE4: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 828A7BE8: 7FC95850  subf r30, r9, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A7BEC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 828A7BF0: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828A7BF4: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 828A7BF8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A7BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C00: 419A0030  beq cr6, 0x828a7c30
	if ctx.cr[6].eq {
	pc = 0x828A7C30; continue 'dispatch;
	}
	// 828A7C04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7C0C: 419A013C  beq cr6, 0x828a7d48
	if ctx.cr[6].eq {
	pc = 0x828A7D48; continue 'dispatch;
	}
	// 828A7C10: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A7C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C18: 419A0018  beq cr6, 0x828a7c30
	if ctx.cr[6].eq {
	pc = 0x828A7C30; continue 'dispatch;
	}
	// 828A7C1C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A7C20: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7C28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7C2C: 409A0008  bne cr6, 0x828a7c34
	if !ctx.cr[6].eq {
	pc = 0x828A7C34; continue 'dispatch;
	}
	// 828A7C30: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7C34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C3C: 419A0080  beq cr6, 0x828a7cbc
	if ctx.cr[6].eq {
	pc = 0x828A7CBC; continue 'dispatch;
	}
	// 828A7C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7C44: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 828A7C48: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A7C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C50: 419A0030  beq cr6, 0x828a7c80
	if ctx.cr[6].eq {
	pc = 0x828A7C80; continue 'dispatch;
	}
	// 828A7C54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7C5C: 419A00F4  beq cr6, 0x828a7d50
	if ctx.cr[6].eq {
	pc = 0x828A7D50; continue 'dispatch;
	}
	// 828A7C60: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A7C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C68: 419A0018  beq cr6, 0x828a7c80
	if ctx.cr[6].eq {
	pc = 0x828A7C80; continue 'dispatch;
	}
	// 828A7C6C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A7C70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7C74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7C78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7C7C: 409A0008  bne cr6, 0x828a7c84
	if !ctx.cr[6].eq {
	pc = 0x828A7C84; continue 'dispatch;
	}
	// 828A7C80: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7C84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C8C: 409A0030  bne cr6, 0x828a7cbc
	if !ctx.cr[6].eq {
	pc = 0x828A7CBC; continue 'dispatch;
	}
	// 828A7C90: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828A7C94: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A7C98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7C9C: 409A0020  bne cr6, 0x828a7cbc
	if !ctx.cr[6].eq {
	pc = 0x828A7CBC; continue 'dispatch;
	}
	// 828A7CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7CA4: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A7CA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7CAC: 409A0010  bne cr6, 0x828a7cbc
	if !ctx.cr[6].eq {
	pc = 0x828A7CBC; continue 'dispatch;
	}
	// 828A7CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7CB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7CB8: 4BAAEE61  bl 0x82356b18
	ctx.lr = 0x828A7CBC;
	sub_82356B18(ctx, base);
	// 828A7CBC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A7CC0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A7CC4: 4082FF2C  bne 0x828a7bf0
	if !ctx.cr[0].eq {
	pc = 0x828A7BF0; continue 'dispatch;
	}
	// 828A7CC8: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A7CCC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A7CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7CD4: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828A7CD8: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7CDC: 4182007C  beq 0x828a7d58
	if ctx.cr[0].eq {
	pc = 0x828A7D58; continue 'dispatch;
	}
	// 828A7CE0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A7CE4: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A7CE8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A7CEC: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7CF0: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7CF4: 80CA0078  lwz r6, 0x78(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A7CF8: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828A7CFC: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828A7D00: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A7D04: 7D245B96  divwu r9, r4, r11
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A7D08: 908A0078  stw r4, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A7D0C: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A7D10: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A7D14: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A7D18: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828A7D1C: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A7D20: 4BB34B09  bl 0x823dc828
	ctx.lr = 0x828A7D24;
	sub_823DC828(ctx, base);
	// 828A7D24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A7D28: 4BB34B01  bl 0x823dc828
	ctx.lr = 0x828A7D2C;
	sub_823DC828(ctx, base);
	// 828A7D2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A7D30: 4BB34AF9  bl 0x823dc828
	ctx.lr = 0x828A7D34;
	sub_823DC828(ctx, base);
	// 828A7D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7D38: 4BB34AF1  bl 0x823dc828
	ctx.lr = 0x828A7D3C;
	sub_823DC828(ctx, base);
	// 828A7D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7D40: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828A7D44: 48401710  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828A7D48: 4B8EC0F1  bl 0x82193e38
	ctx.lr = 0x828A7D4C;
	sub_82193E38(ctx, base);
	// 828A7D4C: 4BFFFEE4  b 0x828a7c30
	pc = 0x828A7C30; continue 'dispatch;
	// 828A7D50: 4B8EC0E9  bl 0x82193e38
	ctx.lr = 0x828A7D54;
	sub_82193E38(ctx, base);
	// 828A7D54: 4BFFFF2C  b 0x828a7c80
	pc = 0x828A7C80; continue 'dispatch;
	// 828A7D58: 4BB34AD1  bl 0x823dc828
	ctx.lr = 0x828A7D5C;
	sub_823DC828(ctx, base);
	// 828A7D5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A7D60: 4BB34AC9  bl 0x823dc828
	ctx.lr = 0x828A7D64;
	sub_823DC828(ctx, base);
	// 828A7D64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A7D68: 4BB34AC1  bl 0x823dc828
	ctx.lr = 0x828A7D6C;
	sub_823DC828(ctx, base);
	// 828A7D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7D70: 4BB34AB9  bl 0x823dc828
	ctx.lr = 0x828A7D74;
	sub_823DC828(ctx, base);
	// 828A7D74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A7D78: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828A7D7C: 484016D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7D80 size=1280
    let mut pc: u32 = 0x828A7D80;
    'dispatch: loop {
        match pc {
            0x828A7D80 => {
    //   block [0x828A7D80..0x828A8280)
	// 828A7D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7D84: 48401679  bl 0x82ca93fc
	ctx.lr = 0x828A7D88;
	sub_82CA93D0(ctx, base);
	// 828A7D88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7D8C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828A7D90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A7D94: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 828A7D98: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A7D9C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828A7DA0: 419A0018  beq cr6, 0x828a7db8
	if ctx.cr[6].eq {
	pc = 0x828A7DB8; continue 'dispatch;
	}
	// 828A7DA4: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A7DA8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7DAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7DB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7DB4: 409A0008  bne cr6, 0x828a7dbc
	if !ctx.cr[6].eq {
	pc = 0x828A7DBC; continue 'dispatch;
	}
	// 828A7DB8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7DBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7DC4: 419A04A4  beq cr6, 0x828a8268
	if ctx.cr[6].eq {
	pc = 0x828A8268; continue 'dispatch;
	}
	// 828A7DC8: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 828A7DCC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828A7DD0: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A7DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7DD8: 419A00F4  beq cr6, 0x828a7ecc
	if ctx.cr[6].eq {
	pc = 0x828A7ECC; continue 'dispatch;
	}
	// 828A7DDC: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A7DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7DE4: 419A0024  beq cr6, 0x828a7e08
	if ctx.cr[6].eq {
	pc = 0x828A7E08; continue 'dispatch;
	}
	// 828A7DE8: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828A7DEC: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A7DF0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A7DF4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A7DF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7DFC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A7E00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7E04: 480000CC  b 0x828a7ed0
	pc = 0x828A7ED0; continue 'dispatch;
	// 828A7E08: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A7E0C: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A7E10: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A7E14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A7E18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A7E1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7E20: 40810054  ble 0x828a7e74
	if !ctx.cr[0].gt {
	pc = 0x828A7E74; continue 'dispatch;
	}
	// 828A7E24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A7E28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A7E2C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A7E30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7E34: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828A7E38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A7E3C: 41980008  blt cr6, 0x828a7e44
	if ctx.cr[6].lt {
	pc = 0x828A7E44; continue 'dispatch;
	}
	// 828A7E40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A7E44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A7E48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A7E4C: 419A0014  beq cr6, 0x828a7e60
	if ctx.cr[6].eq {
	pc = 0x828A7E60; continue 'dispatch;
	}
	// 828A7E50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A7E54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A7E58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A7E5C: 4800000C  b 0x828a7e68
	pc = 0x828A7E68; continue 'dispatch;
	// 828A7E60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A7E64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A7E68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7E6C: 4199FFB8  bgt cr6, 0x828a7e24
	if ctx.cr[6].gt {
	pc = 0x828A7E24; continue 'dispatch;
	}
	// 828A7E70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A7E74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A7E78: 419A0040  beq cr6, 0x828a7eb8
	if ctx.cr[6].eq {
	pc = 0x828A7EB8; continue 'dispatch;
	}
	// 828A7E7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7E80: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828A7E84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7E88: 41990008  bgt cr6, 0x828a7e90
	if ctx.cr[6].gt {
	pc = 0x828A7E90; continue 'dispatch;
	}
	// 828A7E8C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7E90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7E98: 409A0020  bne cr6, 0x828a7eb8
	if !ctx.cr[6].eq {
	pc = 0x828A7EB8; continue 'dispatch;
	}
	// 828A7E9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A7EA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A7EA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7EA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7EAC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A7EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7EB4: 4800001C  b 0x828a7ed0
	pc = 0x828A7ED0; continue 'dispatch;
	// 828A7EB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A7EBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7EC0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A7EC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7EC8: 48000008  b 0x828a7ed0
	pc = 0x828A7ED0; continue 'dispatch;
	// 828A7ECC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7ED0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7ED8: 419A01B0  beq cr6, 0x828a8088
	if ctx.cr[6].eq {
	pc = 0x828A8088; continue 'dispatch;
	}
	// 828A7EDC: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A7EE0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A7EE4: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828A7EE8: 419801A0  blt cr6, 0x828a8088
	if ctx.cr[6].lt {
	pc = 0x828A8088; continue 'dispatch;
	}
	// 828A7EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7EF4: 48040525  bl 0x828e8418
	ctx.lr = 0x828A7EF8;
	sub_828E8418(ctx, base);
	// 828A7EF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7EFC: 419A0018  beq cr6, 0x828a7f14
	if ctx.cr[6].eq {
	pc = 0x828A7F14; continue 'dispatch;
	}
	// 828A7F00: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A7F04: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7F08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7F0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A7F10: 409A0008  bne cr6, 0x828a7f18
	if !ctx.cr[6].eq {
	pc = 0x828A7F18; continue 'dispatch;
	}
	// 828A7F14: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7F18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7F20: 419A0144  beq cr6, 0x828a8064
	if ctx.cr[6].eq {
	pc = 0x828A8064; continue 'dispatch;
	}
	// 828A7F24: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A7F28: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828A7F2C: 5569AFFE  rlwinm r9, r11, 0x15, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A7F30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A7F34: 419A00F4  beq cr6, 0x828a8028
	if ctx.cr[6].eq {
	pc = 0x828A8028; continue 'dispatch;
	}
	// 828A7F38: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A7F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7F40: 419A0024  beq cr6, 0x828a7f64
	if ctx.cr[6].eq {
	pc = 0x828A7F64; continue 'dispatch;
	}
	// 828A7F44: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A7F48: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A7F4C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A7F50: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A7F54: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7F58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A7F5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7F60: 480000CC  b 0x828a802c
	pc = 0x828A802C; continue 'dispatch;
	// 828A7F64: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A7F68: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A7F6C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A7F70: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A7F74: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A7F78: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7F7C: 40810054  ble 0x828a7fd0
	if !ctx.cr[0].gt {
	pc = 0x828A7FD0; continue 'dispatch;
	}
	// 828A7F80: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A7F84: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A7F88: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A7F8C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7F90: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A7F94: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A7F98: 41980008  blt cr6, 0x828a7fa0
	if ctx.cr[6].lt {
	pc = 0x828A7FA0; continue 'dispatch;
	}
	// 828A7F9C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A7FA0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A7FA4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A7FA8: 419A0014  beq cr6, 0x828a7fbc
	if ctx.cr[6].eq {
	pc = 0x828A7FBC; continue 'dispatch;
	}
	// 828A7FAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A7FB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A7FB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A7FB8: 4800000C  b 0x828a7fc4
	pc = 0x828A7FC4; continue 'dispatch;
	// 828A7FBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A7FC0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A7FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7FC8: 4199FFB8  bgt cr6, 0x828a7f80
	if ctx.cr[6].gt {
	pc = 0x828A7F80; continue 'dispatch;
	}
	// 828A7FCC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A7FD0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A7FD4: 419A0040  beq cr6, 0x828a8014
	if ctx.cr[6].eq {
	pc = 0x828A8014; continue 'dispatch;
	}
	// 828A7FD8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7FDC: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A7FE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7FE4: 41990008  bgt cr6, 0x828a7fec
	if ctx.cr[6].gt {
	pc = 0x828A7FEC; continue 'dispatch;
	}
	// 828A7FE8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A7FEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7FF4: 409A0020  bne cr6, 0x828a8014
	if !ctx.cr[6].eq {
	pc = 0x828A8014; continue 'dispatch;
	}
	// 828A7FF8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A7FFC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828A8000: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A8004: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8008: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A800C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8010: 4800001C  b 0x828a802c
	pc = 0x828A802C; continue 'dispatch;
	// 828A8014: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A8018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A801C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A8020: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8024: 48000008  b 0x828a802c
	pc = 0x828A802C; continue 'dispatch;
	// 828A8028: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A802C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8034: 419A0030  beq cr6, 0x828a8064
	if ctx.cr[6].eq {
	pc = 0x828A8064; continue 'dispatch;
	}
	// 828A8038: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A803C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8040: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A8044: 419A0020  beq cr6, 0x828a8064
	if ctx.cr[6].eq {
	pc = 0x828A8064; continue 'dispatch;
	}
	// 828A8048: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A804C: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A8050: 7F08C840  cmplw cr6, r8, r25
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828A8054: 419A0218  beq cr6, 0x828a826c
	if ctx.cr[6].eq {
	pc = 0x828A826C; continue 'dispatch;
	}
	// 828A8058: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828A805C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A8060: 409AFFE8  bne cr6, 0x828a8048
	if !ctx.cr[6].eq {
	pc = 0x828A8048; continue 'dispatch;
	}
	// 828A8064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8068: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828A806C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8070: 4BFFFD11  bl 0x828a7d80
	ctx.lr = 0x828A8074;
	sub_828A7D80(ctx, base);
	// 828A8074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8078: 409A01F4  bne cr6, 0x828a826c
	if !ctx.cr[6].eq {
	pc = 0x828A826C; continue 'dispatch;
	}
	// 828A807C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828A8080: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828A8084: 4099FE68  ble cr6, 0x828a7eec
	if !ctx.cr[6].gt {
	pc = 0x828A7EEC; continue 'dispatch;
	}
	// 828A8088: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A808C: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 828A8090: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8094: 419A01D4  beq cr6, 0x828a8268
	if ctx.cr[6].eq {
	pc = 0x828A8268; continue 'dispatch;
	}
	// 828A8098: 817A0030  lwz r11, 0x30(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A809C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828A80A0: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A80A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A80A8: 419A00F0  beq cr6, 0x828a8198
	if ctx.cr[6].eq {
	pc = 0x828A8198; continue 'dispatch;
	}
	// 828A80AC: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A80B0: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A80B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A80B8: 419A0020  beq cr6, 0x828a80d8
	if ctx.cr[6].eq {
	pc = 0x828A80D8; continue 'dispatch;
	}
	// 828A80BC: 896B006B  lbz r11, 0x6b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A80C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A80C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A80C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A80CC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 828A80D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A80D4: 480000C8  b 0x828a819c
	pc = 0x828A819C; continue 'dispatch;
	// 828A80D8: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A80DC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A80E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A80E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A80E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A80EC: 40810054  ble 0x828a8140
	if !ctx.cr[0].gt {
	pc = 0x828A8140; continue 'dispatch;
	}
	// 828A80F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A80F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A80F8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A80FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8100: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A8104: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A8108: 41980008  blt cr6, 0x828a8110
	if ctx.cr[6].lt {
	pc = 0x828A8110; continue 'dispatch;
	}
	// 828A810C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A8110: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A8114: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8118: 419A0014  beq cr6, 0x828a812c
	if ctx.cr[6].eq {
	pc = 0x828A812C; continue 'dispatch;
	}
	// 828A811C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A8120: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A8124: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8128: 4800000C  b 0x828a8134
	pc = 0x828A8134; continue 'dispatch;
	// 828A812C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A8130: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A8134: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8138: 4199FFB8  bgt cr6, 0x828a80f0
	if ctx.cr[6].gt {
	pc = 0x828A80F0; continue 'dispatch;
	}
	// 828A813C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A8140: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A8144: 419A0040  beq cr6, 0x828a8184
	if ctx.cr[6].eq {
	pc = 0x828A8184; continue 'dispatch;
	}
	// 828A8148: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A814C: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A8150: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8154: 41990008  bgt cr6, 0x828a815c
	if ctx.cr[6].gt {
	pc = 0x828A815C; continue 'dispatch;
	}
	// 828A8158: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A815C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8164: 409A0020  bne cr6, 0x828a8184
	if !ctx.cr[6].eq {
	pc = 0x828A8184; continue 'dispatch;
	}
	// 828A8168: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A816C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828A8170: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A8174: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8178: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 828A817C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8180: 4800001C  b 0x828a819c
	pc = 0x828A819C; continue 'dispatch;
	// 828A8184: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A8188: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A818C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 828A8190: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8194: 48000008  b 0x828a819c
	pc = 0x828A819C; continue 'dispatch;
	// 828A8198: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A819C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A81A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A81A4: 419A00C4  beq cr6, 0x828a8268
	if ctx.cr[6].eq {
	pc = 0x828A8268; continue 'dispatch;
	}
	// 828A81A8: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A81AC: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828A81B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A81B4: 419A0078  beq cr6, 0x828a822c
	if ctx.cr[6].eq {
	pc = 0x828A822C; continue 'dispatch;
	}
	// 828A81B8: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A81BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A81C0: 409A0064  bne cr6, 0x828a8224
	if !ctx.cr[6].eq {
	pc = 0x828A8224; continue 'dispatch;
	}
	// 828A81C4: 817A004C  lwz r11, 0x4c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A81C8: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A81CC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A81D0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A81D4: 40810050  ble 0x828a8224
	if !ctx.cr[0].gt {
	pc = 0x828A8224; continue 'dispatch;
	}
	// 828A81D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A81DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A81E0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828A81E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A81E8: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828A81EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A81F0: 41980008  blt cr6, 0x828a81f8
	if ctx.cr[6].lt {
	pc = 0x828A81F8; continue 'dispatch;
	}
	// 828A81F4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A81F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A81FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8200: 419A0014  beq cr6, 0x828a8214
	if ctx.cr[6].eq {
	pc = 0x828A8214; continue 'dispatch;
	}
	// 828A8204: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A8208: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A820C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8210: 4800000C  b 0x828a821c
	pc = 0x828A821C; continue 'dispatch;
	// 828A8214: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A8218: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A821C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8220: 4199FFB8  bgt cr6, 0x828a81d8
	if ctx.cr[6].gt {
	pc = 0x828A81D8; continue 'dispatch;
	}
	// 828A8224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8228: 48000008  b 0x828a8230
	pc = 0x828A8230; continue 'dispatch;
	// 828A822C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A8230: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8238: 419A0030  beq cr6, 0x828a8268
	if ctx.cr[6].eq {
	pc = 0x828A8268; continue 'dispatch;
	}
	// 828A823C: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A8240: 81460014  lwz r10, 0x14(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8244: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A8248: 419A0020  beq cr6, 0x828a8268
	if ctx.cr[6].eq {
	pc = 0x828A8268; continue 'dispatch;
	}
	// 828A824C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8250: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A8254: 7F08C840  cmplw cr6, r8, r25
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828A8258: 419A001C  beq cr6, 0x828a8274
	if ctx.cr[6].eq {
	pc = 0x828A8274; continue 'dispatch;
	}
	// 828A825C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828A8260: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A8264: 409AFFE8  bne cr6, 0x828a824c
	if !ctx.cr[6].eq {
	pc = 0x828A824C; continue 'dispatch;
	}
	// 828A8268: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A826C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8270: 484011DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828A8274: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A8278: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A827C: 484011D0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8280 size=648
    let mut pc: u32 = 0x828A8280;
    'dispatch: loop {
        match pc {
            0x828A8280 => {
    //   block [0x828A8280..0x828A8508)
	// 828A8280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8284: 48401175  bl 0x82ca93f8
	ctx.lr = 0x828A8288;
	sub_82CA93D0(ctx, base);
	// 828A8288: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A828C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A8290: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828A8294: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 828A8298: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828A829C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A82A0: 4BFFFAE1  bl 0x828a7d80
	ctx.lr = 0x828A82A4;
	sub_828A7D80(ctx, base);
	// 828A82A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A82A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A82AC: 419A0018  beq cr6, 0x828a82c4
	if ctx.cr[6].eq {
	pc = 0x828A82C4; continue 'dispatch;
	}
	// 828A82B0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A82B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A82B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A82BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A82C0: 409A0008  bne cr6, 0x828a82c8
	if !ctx.cr[6].eq {
	pc = 0x828A82C8; continue 'dispatch;
	}
	// 828A82C4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A82C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A82CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A82D0: 419A0204  beq cr6, 0x828a84d4
	if ctx.cr[6].eq {
	pc = 0x828A84D4; continue 'dispatch;
	}
	// 828A82D4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A82D8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828A82DC: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828A82E0: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 828A82E4: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A82E8: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828A82EC: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828A82F0: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828A82F4: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 828A82F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A82FC: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 828A8300: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 828A8304: 419A00F4  beq cr6, 0x828a83f8
	if ctx.cr[6].eq {
	pc = 0x828A83F8; continue 'dispatch;
	}
	// 828A8308: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A830C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8310: 419A0024  beq cr6, 0x828a8334
	if ctx.cr[6].eq {
	pc = 0x828A8334; continue 'dispatch;
	}
	// 828A8314: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A8318: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A831C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A8320: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A8324: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8328: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A832C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8330: 480000CC  b 0x828a83fc
	pc = 0x828A83FC; continue 'dispatch;
	// 828A8334: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8338: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A833C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A8340: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A8344: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A8348: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A834C: 40810054  ble 0x828a83a0
	if !ctx.cr[0].gt {
	pc = 0x828A83A0; continue 'dispatch;
	}
	// 828A8350: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A8354: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8358: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A835C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8360: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A8364: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A8368: 41980008  blt cr6, 0x828a8370
	if ctx.cr[6].lt {
	pc = 0x828A8370; continue 'dispatch;
	}
	// 828A836C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A8370: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A8374: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8378: 419A0014  beq cr6, 0x828a838c
	if ctx.cr[6].eq {
	pc = 0x828A838C; continue 'dispatch;
	}
	// 828A837C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A8380: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A8384: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8388: 4800000C  b 0x828a8394
	pc = 0x828A8394; continue 'dispatch;
	// 828A838C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A8390: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A8394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8398: 4199FFB8  bgt cr6, 0x828a8350
	if ctx.cr[6].gt {
	pc = 0x828A8350; continue 'dispatch;
	}
	// 828A839C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A83A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A83A4: 419A0040  beq cr6, 0x828a83e4
	if ctx.cr[6].eq {
	pc = 0x828A83E4; continue 'dispatch;
	}
	// 828A83A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A83AC: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A83B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A83B4: 41990008  bgt cr6, 0x828a83bc
	if ctx.cr[6].gt {
	pc = 0x828A83BC; continue 'dispatch;
	}
	// 828A83B8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A83BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A83C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A83C4: 409A0020  bne cr6, 0x828a83e4
	if !ctx.cr[6].eq {
	pc = 0x828A83E4; continue 'dispatch;
	}
	// 828A83C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A83CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A83D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A83D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A83D8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A83DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A83E0: 4800001C  b 0x828a83fc
	pc = 0x828A83FC; continue 'dispatch;
	// 828A83E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A83E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A83EC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A83F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A83F4: 48000008  b 0x828a83fc
	pc = 0x828A83FC; continue 'dispatch;
	// 828A83F8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A83FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8404: 419A0070  beq cr6, 0x828a8474
	if ctx.cr[6].eq {
	pc = 0x828A8474; continue 'dispatch;
	}
	// 828A8408: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828A840C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8410: 48000869  bl 0x828a8c78
	ctx.lr = 0x828A8414;
	sub_828A8C78(ctx, base);
	// 828A8414: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A8418: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A841C: 83830034  lwz r28, 0x34(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A8420: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8424: 419A0050  beq cr6, 0x828a8474
	if ctx.cr[6].eq {
	pc = 0x828A8474; continue 'dispatch;
	}
	// 828A8428: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A842C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A8430: 7F0BC800  cmpw cr6, r11, r25
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828A8434: 409A0010  bne cr6, 0x828a8444
	if !ctx.cr[6].eq {
	pc = 0x828A8444; continue 'dispatch;
	}
	// 828A8438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A843C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8440: 4BAAE6D9  bl 0x82356b18
	ctx.lr = 0x828A8444;
	sub_82356B18(ctx, base);
	// 828A8444: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A8448: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828A844C: 409A0010  bne cr6, 0x828a845c
	if !ctx.cr[6].eq {
	pc = 0x828A845C; continue 'dispatch;
	}
	// 828A8450: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A8454: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A8458: 4BAAE6C1  bl 0x82356b18
	ctx.lr = 0x828A845C;
	sub_82356B18(ctx, base);
	// 828A845C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8460: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A8464: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8468: 409AFFC0  bne cr6, 0x828a8428
	if !ctx.cr[6].eq {
	pc = 0x828A8428; continue 'dispatch;
	}
	// 828A846C: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A8470: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A8474: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A8478: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A847C: 7D3E5850  subf r9, r30, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 828A8480: 7D1A5050  subf r8, r26, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	// 828A8484: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828A8488: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828A848C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 828A8490: 409A0034  bne cr6, 0x828a84c4
	if !ctx.cr[6].eq {
	pc = 0x828A84C4; continue 'dispatch;
	}
	// 828A8494: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828A8498: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828A849C: 419A0028  beq cr6, 0x828a84c4
	if ctx.cr[6].eq {
	pc = 0x828A84C4; continue 'dispatch;
	}
	// 828A84A0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828A84A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A84A8: 80E80030  lwz r7, 0x30(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A84AC: 7F07C040  cmplw cr6, r7, r24
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828A84B0: 419A0030  beq cr6, 0x828a84e0
	if ctx.cr[6].eq {
	pc = 0x828A84E0; continue 'dispatch;
	}
	// 828A84B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A84B8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828A84BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828A84C0: 4198FFE4  blt cr6, 0x828a84a4
	if ctx.cr[6].lt {
	pc = 0x828A84A4; continue 'dispatch;
	}
	// 828A84C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A84C8: 4BB34361  bl 0x823dc828
	ctx.lr = 0x828A84CC;
	sub_823DC828(ctx, base);
	// 828A84CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A84D0: 4BB34359  bl 0x823dc828
	ctx.lr = 0x828A84D4;
	sub_823DC828(ctx, base);
	// 828A84D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A84D8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A84DC: 48400F6C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828A84E0: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A84E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A84E8: 7D4BD02E  lwzx r10, r11, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828A84EC: 83EA0030  lwz r31, 0x30(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A84F0: 4BB34339  bl 0x823dc828
	ctx.lr = 0x828A84F4;
	sub_823DC828(ctx, base);
	// 828A84F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A84F8: 4BB34331  bl 0x823dc828
	ctx.lr = 0x828A84FC;
	sub_823DC828(ctx, base);
	// 828A84FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8500: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A8504: 48400F44  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8508 size=292
    let mut pc: u32 = 0x828A8508;
    'dispatch: loop {
        match pc {
            0x828A8508 => {
    //   block [0x828A8508..0x828A862C)
	// 828A8508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A850C: 48400F01  bl 0x82ca940c
	ctx.lr = 0x828A8510;
	sub_82CA93D0(ctx, base);
	// 828A8510: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8514: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A8518: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 828A851C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828A8520: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A8524: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828A8528: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A852C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828A8530: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8534: 4BFFE70D  bl 0x828a6c40
	ctx.lr = 0x828A8538;
	sub_828A6C40(ctx, base);
	// 828A8538: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828A853C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828A8540: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 828A8544: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A8548: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828A854C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A8550: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8554: 419A0054  beq cr6, 0x828a85a8
	if ctx.cr[6].eq {
	pc = 0x828A85A8; continue 'dispatch;
	}
	// 828A8558: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A855C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A8560: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828A8564: 409A0030  bne cr6, 0x828a8594
	if !ctx.cr[6].eq {
	pc = 0x828A8594; continue 'dispatch;
	}
	// 828A8568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A856C: 4BDD42ED  bl 0x8267c858
	ctx.lr = 0x828A8570;
	sub_8267C858(ctx, base);
	// 828A8570: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A8574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8578: 409A001C  bne cr6, 0x828a8594
	if !ctx.cr[6].eq {
	pc = 0x828A8594; continue 'dispatch;
	}
	// 828A857C: 897E0038  lbz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A8580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8584: 409A0010  bne cr6, 0x828a8594
	if !ctx.cr[6].eq {
	pc = 0x828A8594; continue 'dispatch;
	}
	// 828A8588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A858C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8590: 4BAAE589  bl 0x82356b18
	ctx.lr = 0x828A8594;
	sub_82356B18(ctx, base);
	// 828A8594: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A8598: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A859C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A85A0: 409AFFB8  bne cr6, 0x828a8558
	if !ctx.cr[6].eq {
	pc = 0x828A8558; continue 'dispatch;
	}
	// 828A85A4: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A85A8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A85AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A85B0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A85B4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A85B8: 4182005C  beq 0x828a8614
	if ctx.cr[0].eq {
	pc = 0x828A8614; continue 'dispatch;
	}
	// 828A85BC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828A85C0: 81296AB8  lwz r9, 0x6ab8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A85C4: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A85C8: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A85CC: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A85D0: 80C90078  lwz r6, 0x78(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A85D4: 1D0624A1  mulli r8, r6, 0x24a1
	ctx.r[8].s64 = ctx.r[6].s64 * 9377;
	// 828A85D8: 38A824DF  addi r5, r8, 0x24df
	ctx.r[5].s64 = ctx.r[8].s64 + 9439;
	// 828A85DC: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828A85E0: 7D045B96  divwu r8, r4, r11
	ctx.r[8].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 828A85E4: 90890078  stw r4, 0x78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828A85E8: 7CE859D6  mullw r7, r8, r11
	ctx.r[7].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A85EC: 7CC72050  subf r6, r7, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 828A85F0: 54C51838  slwi r5, r6, 3
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828A85F4: 7C85502E  lwzx r4, r5, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828A85F8: 83E40030  lwz r31, 0x30(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A85FC: 4BB3422D  bl 0x823dc828
	ctx.lr = 0x828A8600;
	sub_823DC828(ctx, base);
	// 828A8600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8604: 4BB34225  bl 0x823dc828
	ctx.lr = 0x828A8608;
	sub_823DC828(ctx, base);
	// 828A8608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A860C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8610: 48400E4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828A8614: 4BB34215  bl 0x823dc828
	ctx.lr = 0x828A8618;
	sub_823DC828(ctx, base);
	// 828A8618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A861C: 4BB3420D  bl 0x823dc828
	ctx.lr = 0x828A8620;
	sub_823DC828(ctx, base);
	// 828A8620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A8624: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8628: 48400E34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8630 size=536
    let mut pc: u32 = 0x828A8630;
    'dispatch: loop {
        match pc {
            0x828A8630 => {
    //   block [0x828A8630..0x828A8848)
	// 828A8630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8634: 48400DD5  bl 0x82ca9408
	ctx.lr = 0x828A8638;
	sub_82CA93D0(ctx, base);
	// 828A8638: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A863C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8640: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8644: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A8648: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A864C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 828A8650: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828A8654: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828A8658: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828A865C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8660: 419A0174  beq cr6, 0x828a87d4
	if ctx.cr[6].eq {
	pc = 0x828A87D4; continue 'dispatch;
	}
	// 828A8664: 81650030  lwz r11, 0x30(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A8668: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A866C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8670: 419A00F4  beq cr6, 0x828a8764
	if ctx.cr[6].eq {
	pc = 0x828A8764; continue 'dispatch;
	}
	// 828A8674: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A8678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A867C: 419A0024  beq cr6, 0x828a86a0
	if ctx.cr[6].eq {
	pc = 0x828A86A0; continue 'dispatch;
	}
	// 828A8680: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A8684: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8688: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A868C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A8690: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8694: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A8698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A869C: 480000CC  b 0x828a8768
	pc = 0x828A8768; continue 'dispatch;
	// 828A86A0: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A86A4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A86A8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828A86AC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A86B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A86B4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A86B8: 40810054  ble 0x828a870c
	if !ctx.cr[0].gt {
	pc = 0x828A870C; continue 'dispatch;
	}
	// 828A86BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A86C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A86C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A86C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A86CC: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A86D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A86D4: 41980008  blt cr6, 0x828a86dc
	if ctx.cr[6].lt {
	pc = 0x828A86DC; continue 'dispatch;
	}
	// 828A86D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828A86DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A86E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A86E4: 419A0014  beq cr6, 0x828a86f8
	if ctx.cr[6].eq {
	pc = 0x828A86F8; continue 'dispatch;
	}
	// 828A86E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A86EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A86F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A86F4: 4800000C  b 0x828a8700
	pc = 0x828A8700; continue 'dispatch;
	// 828A86F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A86FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A8700: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8704: 4199FFB8  bgt cr6, 0x828a86bc
	if ctx.cr[6].gt {
	pc = 0x828A86BC; continue 'dispatch;
	}
	// 828A8708: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A870C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A8710: 419A0040  beq cr6, 0x828a8750
	if ctx.cr[6].eq {
	pc = 0x828A8750; continue 'dispatch;
	}
	// 828A8714: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8718: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A871C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8720: 41990008  bgt cr6, 0x828a8728
	if ctx.cr[6].gt {
	pc = 0x828A8728; continue 'dispatch;
	}
	// 828A8724: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828A8728: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A872C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8730: 409A0020  bne cr6, 0x828a8750
	if !ctx.cr[6].eq {
	pc = 0x828A8750; continue 'dispatch;
	}
	// 828A8734: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A8738: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A873C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A8740: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8744: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A8748: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A874C: 4800001C  b 0x828a8768
	pc = 0x828A8768; continue 'dispatch;
	// 828A8750: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A8754: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8758: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A875C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8760: 48000008  b 0x828a8768
	pc = 0x828A8768; continue 'dispatch;
	// 828A8764: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828A8768: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A876C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8770: 419A0064  beq cr6, 0x828a87d4
	if ctx.cr[6].eq {
	pc = 0x828A87D4; continue 'dispatch;
	}
	// 828A8774: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A8778: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A877C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8780: 419A0054  beq cr6, 0x828a87d4
	if ctx.cr[6].eq {
	pc = 0x828A87D4; continue 'dispatch;
	}
	// 828A8784: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8788: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A878C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828A8790: 409A0030  bne cr6, 0x828a87c0
	if !ctx.cr[6].eq {
	pc = 0x828A87C0; continue 'dispatch;
	}
	// 828A8794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8798: 4BDD40C1  bl 0x8267c858
	ctx.lr = 0x828A879C;
	sub_8267C858(ctx, base);
	// 828A879C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A87A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A87A4: 409A001C  bne cr6, 0x828a87c0
	if !ctx.cr[6].eq {
	pc = 0x828A87C0; continue 'dispatch;
	}
	// 828A87A8: 897E0038  lbz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A87AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A87B0: 409A0010  bne cr6, 0x828a87c0
	if !ctx.cr[6].eq {
	pc = 0x828A87C0; continue 'dispatch;
	}
	// 828A87B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A87B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A87BC: 4BAAE35D  bl 0x82356b18
	ctx.lr = 0x828A87C0;
	sub_82356B18(ctx, base);
	// 828A87C0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A87C4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A87C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A87CC: 409AFFB8  bne cr6, 0x828a8784
	if !ctx.cr[6].eq {
	pc = 0x828A8784; continue 'dispatch;
	}
	// 828A87D0: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A87D4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A87D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A87DC: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 828A87E0: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A87E4: 41820054  beq 0x828a8838
	if ctx.cr[0].eq {
	pc = 0x828A8838; continue 'dispatch;
	}
	// 828A87E8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A87EC: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A87F0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A87F4: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A87F8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A87FC: 80EA0078  lwz r7, 0x78(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A8800: 1D2724A1  mulli r9, r7, 0x24a1
	ctx.r[9].s64 = ctx.r[7].s64 * 9377;
	// 828A8804: 38C924DF  addi r6, r9, 0x24df
	ctx.r[6].s64 = ctx.r[9].s64 + 9439;
	// 828A8808: 54C5983E  rotlwi r5, r6, 0x13
	ctx.r[5].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 828A880C: 7D255B96  divwu r9, r5, r11
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 828A8810: 90AA0078  stw r5, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 828A8814: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A8818: 7CE82850  subf r7, r8, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 828A881C: 54E61838  slwi r6, r7, 3
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828A8820: 7CA6202E  lwzx r5, r6, r4
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 828A8824: 83E50030  lwz r31, 0x30(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A8828: 4BB34001  bl 0x823dc828
	ctx.lr = 0x828A882C;
	sub_823DC828(ctx, base);
	// 828A882C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8830: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8834: 48400C24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828A8838: 4BB33FF1  bl 0x823dc828
	ctx.lr = 0x828A883C;
	sub_823DC828(ctx, base);
	// 828A883C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A8840: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8844: 48400C14  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8848 size=844
    let mut pc: u32 = 0x828A8848;
    'dispatch: loop {
        match pc {
            0x828A8848 => {
    //   block [0x828A8848..0x828A8B94)
	// 828A8848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A884C: 48400BB9  bl 0x82ca9404
	ctx.lr = 0x828A8850;
	sub_82CA93D0(ctx, base);
	// 828A8850: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8854: 8165002C  lwz r11, 0x2c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 828A8858: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A885C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828A8860: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 828A8864: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A8868: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A886C: 419A0078  beq cr6, 0x828a88e4
	if ctx.cr[6].eq {
	pc = 0x828A88E4; continue 'dispatch;
	}
	// 828A8870: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A8874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8878: 409A0064  bne cr6, 0x828a88dc
	if !ctx.cr[6].eq {
	pc = 0x828A88DC; continue 'dispatch;
	}
	// 828A887C: 8165004C  lwz r11, 0x4c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A8880: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8884: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A8888: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A888C: 40810050  ble 0x828a88dc
	if !ctx.cr[0].gt {
	pc = 0x828A88DC; continue 'dispatch;
	}
	// 828A8890: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A8894: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8898: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A889C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A88A0: 2F07004A  cmpwi cr6, r7, 0x4a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 74, &mut ctx.xer);
	// 828A88A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A88A8: 41980008  blt cr6, 0x828a88b0
	if ctx.cr[6].lt {
	pc = 0x828A88B0; continue 'dispatch;
	}
	// 828A88AC: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828A88B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A88B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A88B8: 419A0014  beq cr6, 0x828a88cc
	if ctx.cr[6].eq {
	pc = 0x828A88CC; continue 'dispatch;
	}
	// 828A88BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A88C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A88C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A88C8: 4800000C  b 0x828a88d4
	pc = 0x828A88D4; continue 'dispatch;
	// 828A88CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A88D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A88D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A88D8: 4199FFB8  bgt cr6, 0x828a8890
	if ctx.cr[6].gt {
	pc = 0x828A8890; continue 'dispatch;
	}
	// 828A88DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A88E0: 48000008  b 0x828a88e8
	pc = 0x828A88E8; continue 'dispatch;
	// 828A88E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828A88E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A88EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A88F0: 419A0298  beq cr6, 0x828a8b88
	if ctx.cr[6].eq {
	pc = 0x828A8B88; continue 'dispatch;
	}
	// 828A88F4: 81650030  lwz r11, 0x30(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A88F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A88FC: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828A8900: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A8904: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828A8908: 90810068  stw r4, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	// 828A890C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8910: 419A00F4  beq cr6, 0x828a8a04
	if ctx.cr[6].eq {
	pc = 0x828A8A04; continue 'dispatch;
	}
	// 828A8914: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A8918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A891C: 419A0024  beq cr6, 0x828a8940
	if ctx.cr[6].eq {
	pc = 0x828A8940; continue 'dispatch;
	}
	// 828A8920: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A8924: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8928: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A892C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A8930: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8934: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A8938: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A893C: 480000CC  b 0x828a8a08
	pc = 0x828A8A08; continue 'dispatch;
	// 828A8940: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8944: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A8948: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828A894C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A8950: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A8954: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8958: 40810054  ble 0x828a89ac
	if !ctx.cr[0].gt {
	pc = 0x828A89AC; continue 'dispatch;
	}
	// 828A895C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A8960: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8964: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A8968: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A896C: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A8970: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A8974: 41980008  blt cr6, 0x828a897c
	if ctx.cr[6].lt {
	pc = 0x828A897C; continue 'dispatch;
	}
	// 828A8978: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828A897C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A8980: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8984: 419A0014  beq cr6, 0x828a8998
	if ctx.cr[6].eq {
	pc = 0x828A8998; continue 'dispatch;
	}
	// 828A8988: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A898C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A8990: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8994: 4800000C  b 0x828a89a0
	pc = 0x828A89A0; continue 'dispatch;
	// 828A8998: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A899C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A89A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A89A4: 4199FFB8  bgt cr6, 0x828a895c
	if ctx.cr[6].gt {
	pc = 0x828A895C; continue 'dispatch;
	}
	// 828A89A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A89AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A89B0: 419A0040  beq cr6, 0x828a89f0
	if ctx.cr[6].eq {
	pc = 0x828A89F0; continue 'dispatch;
	}
	// 828A89B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A89B8: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A89BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A89C0: 41990008  bgt cr6, 0x828a89c8
	if ctx.cr[6].gt {
	pc = 0x828A89C8; continue 'dispatch;
	}
	// 828A89C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828A89C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A89CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A89D0: 409A0020  bne cr6, 0x828a89f0
	if !ctx.cr[6].eq {
	pc = 0x828A89F0; continue 'dispatch;
	}
	// 828A89D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A89D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A89DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A89E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A89E4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A89E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A89EC: 4800001C  b 0x828a8a08
	pc = 0x828A8A08; continue 'dispatch;
	// 828A89F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A89F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A89F8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828A89FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8A00: 48000008  b 0x828a8a08
	pc = 0x828A8A08; continue 'dispatch;
	// 828A8A04: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828A8A08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8A10: 419A0108  beq cr6, 0x828a8b18
	if ctx.cr[6].eq {
	pc = 0x828A8B18; continue 'dispatch;
	}
	// 828A8A14: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8A18: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828A8A1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8A20: 419A0078  beq cr6, 0x828a8a98
	if ctx.cr[6].eq {
	pc = 0x828A8A98; continue 'dispatch;
	}
	// 828A8A24: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A8A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8A2C: 409A0064  bne cr6, 0x828a8a90
	if !ctx.cr[6].eq {
	pc = 0x828A8A90; continue 'dispatch;
	}
	// 828A8A30: 8165004C  lwz r11, 0x4c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A8A34: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8A38: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828A8A3C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8A40: 40810050  ble 0x828a8a90
	if !ctx.cr[0].gt {
	pc = 0x828A8A90; continue 'dispatch;
	}
	// 828A8A44: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A8A48: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8A4C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A8A50: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8A54: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828A8A58: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A8A5C: 41980008  blt cr6, 0x828a8a64
	if ctx.cr[6].lt {
	pc = 0x828A8A64; continue 'dispatch;
	}
	// 828A8A60: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828A8A64: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A8A68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8A6C: 419A0014  beq cr6, 0x828a8a80
	if ctx.cr[6].eq {
	pc = 0x828A8A80; continue 'dispatch;
	}
	// 828A8A70: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A8A74: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A8A78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8A7C: 4800000C  b 0x828a8a88
	pc = 0x828A8A88; continue 'dispatch;
	// 828A8A80: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A8A84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A8A88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8A8C: 4199FFB8  bgt cr6, 0x828a8a44
	if ctx.cr[6].gt {
	pc = 0x828A8A44; continue 'dispatch;
	}
	// 828A8A90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8A94: 48000008  b 0x828a8a9c
	pc = 0x828A8A9C; continue 'dispatch;
	// 828A8A98: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828A8A9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8AA4: 419A0074  beq cr6, 0x828a8b18
	if ctx.cr[6].eq {
	pc = 0x828A8B18; continue 'dispatch;
	}
	// 828A8AA8: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A8AAC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8AB0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8AB4: 419A0064  beq cr6, 0x828a8b18
	if ctx.cr[6].eq {
	pc = 0x828A8B18; continue 'dispatch;
	}
	// 828A8AB8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8ABC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A8AC0: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828A8AC4: 409A0040  bne cr6, 0x828a8b04
	if !ctx.cr[6].eq {
	pc = 0x828A8B04; continue 'dispatch;
	}
	// 828A8AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8ACC: 4BDD3D8D  bl 0x8267c858
	ctx.lr = 0x828A8AD0;
	sub_8267C858(ctx, base);
	// 828A8AD0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828A8AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8AD8: 419A002C  beq cr6, 0x828a8b04
	if ctx.cr[6].eq {
	pc = 0x828A8B04; continue 'dispatch;
	}
	// 828A8ADC: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A8AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8AE4: 409A0020  bne cr6, 0x828a8b04
	if !ctx.cr[6].eq {
	pc = 0x828A8B04; continue 'dispatch;
	}
	// 828A8AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8AEC: 4BFFD745  bl 0x828a6230
	ctx.lr = 0x828A8AF0;
	sub_828A6230(ctx, base);
	// 828A8AF0: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828A8AF4: 419A0010  beq cr6, 0x828a8b04
	if ctx.cr[6].eq {
	pc = 0x828A8B04; continue 'dispatch;
	}
	// 828A8AF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8AFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8B00: 4BAAE019  bl 0x82356b18
	ctx.lr = 0x828A8B04;
	sub_82356B18(ctx, base);
	// 828A8B04: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8B08: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828A8B0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8B10: 409AFFA8  bne cr6, 0x828a8ab8
	if !ctx.cr[6].eq {
	pc = 0x828A8AB8; continue 'dispatch;
	}
	// 828A8B14: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A8B18: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A8B1C: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 828A8B20: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8B24: 4182005C  beq 0x828a8b80
	if ctx.cr[0].eq {
	pc = 0x828A8B80; continue 'dispatch;
	}
	// 828A8B28: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828A8B2C: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A8B30: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A8B34: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A8B38: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8B3C: 80EA0078  lwz r7, 0x78(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A8B40: 1D2724A1  mulli r9, r7, 0x24a1
	ctx.r[9].s64 = ctx.r[7].s64 * 9377;
	// 828A8B44: 38C924DF  addi r6, r9, 0x24df
	ctx.r[6].s64 = ctx.r[9].s64 + 9439;
	// 828A8B48: 54C5983E  rotlwi r5, r6, 0x13
	ctx.r[5].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 828A8B4C: 90AA0078  stw r5, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 828A8B50: 7C655B96  divwu r3, r5, r11
	ctx.r[3].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 828A8B54: 7D6359D6  mullw r11, r3, r11
	ctx.r[11].s64 = (ctx.r[3].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A8B58: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 828A8B5C: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828A8B60: 7C69202E  lwzx r3, r9, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 828A8B64: 4BFFD6CD  bl 0x828a6230
	ctx.lr = 0x828A8B68;
	sub_828A6230(ctx, base);
	// 828A8B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A8B6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8B70: 4BB33CB9  bl 0x823dc828
	ctx.lr = 0x828A8B74;
	sub_823DC828(ctx, base);
	// 828A8B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8B78: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8B7C: 484008D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828A8B80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8B84: 4BB33CA5  bl 0x823dc828
	ctx.lr = 0x828A8B88;
	sub_823DC828(ctx, base);
	// 828A8B88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A8B8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8B90: 484008C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8B98 size=224
    let mut pc: u32 = 0x828A8B98;
    'dispatch: loop {
        match pc {
            0x828A8B98 => {
    //   block [0x828A8B98..0x828A8C78)
	// 828A8B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8B9C: 48400869  bl 0x82ca9404
	ctx.lr = 0x828A8BA0;
	sub_82CA93D0(ctx, base);
	// 828A8BA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8BA4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828A8BA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8BAC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828A8BB0: 419A0018  beq cr6, 0x828a8bc8
	if ctx.cr[6].eq {
	pc = 0x828A8BC8; continue 'dispatch;
	}
	// 828A8BB4: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A8BB8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A8BBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8BC4: 409A0008  bne cr6, 0x828a8bcc
	if !ctx.cr[6].eq {
	pc = 0x828A8BCC; continue 'dispatch;
	}
	// 828A8BC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828A8BCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8BD4: 419A0080  beq cr6, 0x828a8c54
	if ctx.cr[6].eq {
	pc = 0x828A8C54; continue 'dispatch;
	}
	// 828A8BD8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A8BDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A8BE0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828A8BE4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828A8BE8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828A8BEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A8BF0: 4BFFEAD9  bl 0x828a76c8
	ctx.lr = 0x828A8BF4;
	sub_828A76C8(ctx, base);
	// 828A8BF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A8BF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A8BFC: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A8C00: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828A8C04: 419A0048  beq cr6, 0x828a8c4c
	if ctx.cr[6].eq {
	pc = 0x828A8C4C; continue 'dispatch;
	}
	// 828A8C08: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8C0C: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 828A8C10: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8C18: 419A001C  beq cr6, 0x828a8c34
	if ctx.cr[6].eq {
	pc = 0x828A8C34; continue 'dispatch;
	}
	// 828A8C1C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8C20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8C24: 419A000C  beq cr6, 0x828a8c30
	if ctx.cr[6].eq {
	pc = 0x828A8C30; continue 'dispatch;
	}
	// 828A8C28: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A8C2C: 4800000C  b 0x828a8c38
	pc = 0x828A8C38; continue 'dispatch;
	// 828A8C30: 4B8EB209  bl 0x82193e38
	ctx.lr = 0x828A8C34;
	sub_82193E38(ctx, base);
	// 828A8C34: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828A8C38: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828A8C3C: 419A0024  beq cr6, 0x828a8c60
	if ctx.cr[6].eq {
	pc = 0x828A8C60; continue 'dispatch;
	}
	// 828A8C40: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A8C44: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828A8C48: 409AFFC0  bne cr6, 0x828a8c08
	if !ctx.cr[6].eq {
	pc = 0x828A8C08; continue 'dispatch;
	}
	// 828A8C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8C50: 4BB33BD9  bl 0x823dc828
	ctx.lr = 0x828A8C54;
	sub_823DC828(ctx, base);
	// 828A8C54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A8C58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8C5C: 484007F8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828A8C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8C64: 83FE0030  lwz r31, 0x30(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A8C68: 4BB33BC1  bl 0x823dc828
	ctx.lr = 0x828A8C6C;
	sub_823DC828(ctx, base);
	// 828A8C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8C70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8C74: 484007E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8C78 size=224
    let mut pc: u32 = 0x828A8C78;
    'dispatch: loop {
        match pc {
            0x828A8C78 => {
    //   block [0x828A8C78..0x828A8D58)
	// 828A8C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A8C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A8C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A8C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A8C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A8C94: 4BFFD6BD  bl 0x828a6350
	ctx.lr = 0x828A8C98;
	sub_828A6350(ctx, base);
	// 828A8C98: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A8C9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A8CA0: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8CA4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828A8CA8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A8CAC: 7D093850  subf r8, r9, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 828A8CB0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828A8CB4: 7D485BD7  divw. r10, r8, r11
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A8CB8: 40810048  ble 0x828a8d00
	if !ctx.cr[0].gt {
	pc = 0x828A8D00; continue 'dispatch;
	}
	// 828A8CBC: 7D4B0E70  srawi r11, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 828A8CC0: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8CC4: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828A8CC8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8CCC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 828A8CD0: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8CD4: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828A8CD8: 40980014  bge cr6, 0x828a8cec
	if !ctx.cr[6].lt {
	pc = 0x828A8CEC; continue 'dispatch;
	}
	// 828A8CDC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A8CE0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 828A8CE4: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828A8CE8: 4800000C  b 0x828a8cf4
	pc = 0x828A8CF4; continue 'dispatch;
	// 828A8CEC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828A8CF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A8CF4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A8CF8: 4199FFC4  bgt cr6, 0x828a8cbc
	if ctx.cr[6].gt {
	pc = 0x828A8CBC; continue 'dispatch;
	}
	// 828A8CFC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828A8D00: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828A8D04: 419A0020  beq cr6, 0x828a8d24
	if ctx.cr[6].eq {
	pc = 0x828A8D24; continue 'dispatch;
	}
	// 828A8D08: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8D0C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8D10: 41980014  blt cr6, 0x828a8d24
	if ctx.cr[6].lt {
	pc = 0x828A8D24; continue 'dispatch;
	}
	// 828A8D14: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A8D18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A8D1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A8D20: 48000008  b 0x828a8d28
	pc = 0x828A8D28; continue 'dispatch;
	// 828A8D24: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828A8D28: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8D2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A8D30: 419A000C  beq cr6, 0x828a8d3c
	if ctx.cr[6].eq {
	pc = 0x828A8D3C; continue 'dispatch;
	}
	// 828A8D34: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8D38: 48000008  b 0x828a8d40
	pc = 0x828A8D40; continue 'dispatch;
	// 828A8D3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A8D40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A8D44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A8D48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A8D4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A8D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A8D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8D58 size=416
    let mut pc: u32 = 0x828A8D58;
    'dispatch: loop {
        match pc {
            0x828A8D58 => {
    //   block [0x828A8D58..0x828A8EF8)
	// 828A8D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8D5C: 484006AD  bl 0x82ca9408
	ctx.lr = 0x828A8D60;
	sub_82CA93D0(ctx, base);
	// 828A8D60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8D64: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828A8D68: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828A8D6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A8D70: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A8D74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8D78: 419A00F4  beq cr6, 0x828a8e6c
	if ctx.cr[6].eq {
	pc = 0x828A8E6C; continue 'dispatch;
	}
	// 828A8D7C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A8D80: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A8D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8D88: 419A0020  beq cr6, 0x828a8da8
	if ctx.cr[6].eq {
	pc = 0x828A8DA8; continue 'dispatch;
	}
	// 828A8D8C: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828A8D90: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828A8D94: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A8D98: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8D9C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A8DA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8DA4: 480000CC  b 0x828a8e70
	pc = 0x828A8E70; continue 'dispatch;
	// 828A8DA8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A8DAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8DB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A8DB4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A8DB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A8DBC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8DC0: 40810054  ble 0x828a8e14
	if !ctx.cr[0].gt {
	pc = 0x828A8E14; continue 'dispatch;
	}
	// 828A8DC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A8DC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8DCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A8DD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8DD4: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828A8DD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A8DDC: 41980008  blt cr6, 0x828a8de4
	if ctx.cr[6].lt {
	pc = 0x828A8DE4; continue 'dispatch;
	}
	// 828A8DE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A8DE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A8DE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A8DEC: 419A0014  beq cr6, 0x828a8e00
	if ctx.cr[6].eq {
	pc = 0x828A8E00; continue 'dispatch;
	}
	// 828A8DF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A8DF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A8DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A8DFC: 4800000C  b 0x828a8e08
	pc = 0x828A8E08; continue 'dispatch;
	// 828A8E00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A8E04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A8E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8E0C: 4199FFB8  bgt cr6, 0x828a8dc4
	if ctx.cr[6].gt {
	pc = 0x828A8DC4; continue 'dispatch;
	}
	// 828A8E10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A8E14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A8E18: 419A0040  beq cr6, 0x828a8e58
	if ctx.cr[6].eq {
	pc = 0x828A8E58; continue 'dispatch;
	}
	// 828A8E1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8E20: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828A8E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8E28: 41990008  bgt cr6, 0x828a8e30
	if ctx.cr[6].gt {
	pc = 0x828A8E30; continue 'dispatch;
	}
	// 828A8E2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8E30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8E34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8E38: 409A0020  bne cr6, 0x828a8e58
	if !ctx.cr[6].eq {
	pc = 0x828A8E58; continue 'dispatch;
	}
	// 828A8E3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A8E40: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828A8E44: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A8E48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8E4C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A8E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8E54: 4800001C  b 0x828a8e70
	pc = 0x828A8E70; continue 'dispatch;
	// 828A8E58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A8E5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8E60: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A8E64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8E68: 48000008  b 0x828a8e70
	pc = 0x828A8E70; continue 'dispatch;
	// 828A8E6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8E70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8E78: 419A0078  beq cr6, 0x828a8ef0
	if ctx.cr[6].eq {
	pc = 0x828A8EF0; continue 'dispatch;
	}
	// 828A8E7C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A8E80: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A8E84: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828A8E88: 41980068  blt cr6, 0x828a8ef0
	if ctx.cr[6].lt {
	pc = 0x828A8EF0; continue 'dispatch;
	}
	// 828A8E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A8E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8E94: 4803F585  bl 0x828e8418
	ctx.lr = 0x828A8E98;
	sub_828E8418(ctx, base);
	// 828A8E98: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828A8E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8EA0: 419A0018  beq cr6, 0x828a8eb8
	if ctx.cr[6].eq {
	pc = 0x828A8EB8; continue 'dispatch;
	}
	// 828A8EA4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A8EA8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A8EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A8EB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A8EB4: 409A0008  bne cr6, 0x828a8ebc
	if !ctx.cr[6].eq {
	pc = 0x828A8EBC; continue 'dispatch;
	}
	// 828A8EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8EBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A8EC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8EC4: 419A0020  beq cr6, 0x828a8ee4
	if ctx.cr[6].eq {
	pc = 0x828A8EE4; continue 'dispatch;
	}
	// 828A8EC8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8ECC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A8ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8ED4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828A8ED8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A8EDC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828A8EE0: 481EE489  bl 0x82a97368
	ctx.lr = 0x828A8EE4;
	sub_82A97368(ctx, base);
	// 828A8EE4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828A8EE8: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828A8EEC: 4099FFA0  ble cr6, 0x828a8e8c
	if !ctx.cr[6].gt {
	pc = 0x828A8E8C; continue 'dispatch;
	}
	// 828A8EF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8EF4: 48400564  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8EF8 size=220
    let mut pc: u32 = 0x828A8EF8;
    'dispatch: loop {
        match pc {
            0x828A8EF8 => {
    //   block [0x828A8EF8..0x828A8FD4)
	// 828A8EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A8F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A8F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A8F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8F0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A8F10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A8F14: 4BFFD43D  bl 0x828a6350
	ctx.lr = 0x828A8F18;
	sub_828A6350(ctx, base);
	// 828A8F18: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A8F1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A8F20: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8F24: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828A8F28: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A8F2C: 7D093850  subf r8, r9, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 828A8F30: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828A8F34: 7D485BD7  divw. r10, r8, r11
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A8F38: 40810048  ble 0x828a8f80
	if !ctx.cr[0].gt {
	pc = 0x828A8F80; continue 'dispatch;
	}
	// 828A8F3C: 7D4B0E70  srawi r11, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 828A8F40: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8F44: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828A8F48: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A8F4C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 828A8F50: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F54: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828A8F58: 40980014  bge cr6, 0x828a8f6c
	if !ctx.cr[6].lt {
	pc = 0x828A8F6C; continue 'dispatch;
	}
	// 828A8F5C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A8F60: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 828A8F64: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828A8F68: 4800000C  b 0x828a8f74
	pc = 0x828A8F74; continue 'dispatch;
	// 828A8F6C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828A8F70: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828A8F74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A8F78: 4199FFC4  bgt cr6, 0x828a8f3c
	if ctx.cr[6].gt {
	pc = 0x828A8F3C; continue 'dispatch;
	}
	// 828A8F7C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828A8F80: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828A8F84: 419A0020  beq cr6, 0x828a8fa4
	if ctx.cr[6].eq {
	pc = 0x828A8FA4; continue 'dispatch;
	}
	// 828A8F88: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F8C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A8F90: 41980014  blt cr6, 0x828a8fa4
	if ctx.cr[6].lt {
	pc = 0x828A8FA4; continue 'dispatch;
	}
	// 828A8F94: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A8F98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A8F9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A8FA0: 48000008  b 0x828a8fa8
	pc = 0x828A8FA8; continue 'dispatch;
	// 828A8FA4: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828A8FA8: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A8FAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A8FB0: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828A8FB4: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828A8FB8: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 828A8FBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A8FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A8FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A8FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A8FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A8FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8FD8 size=148
    let mut pc: u32 = 0x828A8FD8;
    'dispatch: loop {
        match pc {
            0x828A8FD8 => {
    //   block [0x828A8FD8..0x828A906C)
	// 828A8FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A8FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A8FE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A8FEC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828A8FF0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828A8FF4: 4BFFFC85  bl 0x828a8c78
	ctx.lr = 0x828A8FF8;
	sub_828A8C78(ctx, base);
	// 828A8FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8FFC: 419A0010  beq cr6, 0x828a900c
	if ctx.cr[6].eq {
	pc = 0x828A900C; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9070 size=172
    let mut pc: u32 = 0x828A9070;
    'dispatch: loop {
        match pc {
            0x828A9070 => {
    //   block [0x828A9070..0x828A911C)
	// 828A9070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A907C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A9080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A9084: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828A9088: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828A908C: 4BFFFBED  bl 0x828a8c78
	ctx.lr = 0x828A9090;
	sub_828A8C78(ctx, base);
	// 828A9090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A9094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A909C: 419A0024  beq cr6, 0x828a90c0
	if ctx.cr[6].eq {
	pc = 0x828A90C0; continue 'dispatch;
	}
	// 828A90A0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9120 size=64
    let mut pc: u32 = 0x828A9120;
    'dispatch: loop {
        match pc {
            0x828A9120 => {
    //   block [0x828A9120..0x828A9160)
	// 828A9120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9128: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A912C: 4BFFFB4D  bl 0x828a8c78
	ctx.lr = 0x828A9130;
	sub_828A8C78(ctx, base);
	// 828A9130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9134: 419A0018  beq cr6, 0x828a914c
	if ctx.cr[6].eq {
	pc = 0x828A914C; continue 'dispatch;
	}
	// 828A9138: 4BFFD0F9  bl 0x828a6230
	ctx.lr = 0x828A913C;
	sub_828A6230(ctx, base);
	// 828A913C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A9148: 4E800020  blr
	return;
	// 828A914C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A9150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A915C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9160 size=64
    let mut pc: u32 = 0x828A9160;
    'dispatch: loop {
        match pc {
            0x828A9160 => {
    //   block [0x828A9160..0x828A91A0)
	// 828A9160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9168: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A916C: 4BFFFB0D  bl 0x828a8c78
	ctx.lr = 0x828A9170;
	sub_828A8C78(ctx, base);
	// 828A9170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9174: 419A0018  beq cr6, 0x828a918c
	if ctx.cr[6].eq {
	pc = 0x828A918C; continue 'dispatch;
	}
	// 828A9178: 80630034  lwz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A917C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A9188: 4E800020  blr
	return;
	// 828A918C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A9190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A919C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A91A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A91A0 size=108
    let mut pc: u32 = 0x828A91A0;
    'dispatch: loop {
        match pc {
            0x828A91A0 => {
    //   block [0x828A91A0..0x828A920C)
	// 828A91A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A91A4: 48400269  bl 0x82ca940c
	ctx.lr = 0x828A91A8;
	sub_82CA93D0(ctx, base);
	// 828A91A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A91AC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828A91B0: 4BFFFAC9  bl 0x828a8c78
	ctx.lr = 0x828A91B4;
	sub_828A8C78(ctx, base);
	// 828A91B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A91B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A91BC: 419A0048  beq cr6, 0x828a9204
	if ctx.cr[6].eq {
	pc = 0x828A9204; continue 'dispatch;
	}
	// 828A91C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A91C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A91C8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828A91CC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828A91D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A91D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A91D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A91DC: 4B96B6BD  bl 0x82214898
	ctx.lr = 0x828A91E0;
	sub_82214898(ctx, base);
	// 828A91E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A91E4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828A91E8: 4BC28CE1  bl 0x824d1ec8
	ctx.lr = 0x828A91EC;
	sub_824D1EC8(ctx, base);
	// 828A91EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828A91F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A91F4: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828A91F8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828A91FC: 4B8EAC3D  bl 0x82193e38
	ctx.lr = 0x828A9200;
	sub_82193E38(ctx, base);
	// 828A9200: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 828A9204: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A9208: 48400254  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9210 size=48
    let mut pc: u32 = 0x828A9210;
    'dispatch: loop {
        match pc {
            0x828A9210 => {
    //   block [0x828A9210..0x828A9240)
	// 828A9210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9218: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A921C: 4BFFFA5D  bl 0x828a8c78
	ctx.lr = 0x828A9220;
	sub_828A8C78(ctx, base);
	// 828A9220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9224: 419A000C  beq cr6, 0x828a9230
	if ctx.cr[6].eq {
	pc = 0x828A9230; continue 'dispatch;
	}
	// 828A9228: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A922C: 99630038  stb r11, 0x38(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 828A9230: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A923C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9240 size=64
    let mut pc: u32 = 0x828A9240;
    'dispatch: loop {
        match pc {
            0x828A9240 => {
    //   block [0x828A9240..0x828A9280)
	// 828A9240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9248: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A924C: 4BFFFA2D  bl 0x828a8c78
	ctx.lr = 0x828A9250;
	sub_828A8C78(ctx, base);
	// 828A9250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9254: 419A0018  beq cr6, 0x828a926c
	if ctx.cr[6].eq {
	pc = 0x828A926C; continue 'dispatch;
	}
	// 828A9258: 88630038  lbz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A925C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A9268: 4E800020  blr
	return;
	// 828A926C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A9270: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A9274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A9278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A927C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9280 size=64
    let mut pc: u32 = 0x828A9280;
    'dispatch: loop {
        match pc {
            0x828A9280 => {
    //   block [0x828A9280..0x828A92C0)
	// 828A9280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9288: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A928C: 4BFFF9ED  bl 0x828a8c78
	ctx.lr = 0x828A9290;
	sub_828A8C78(ctx, base);
	// 828A9290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9294: 419A0018  beq cr6, 0x828a92ac
	if ctx.cr[6].eq {
	pc = 0x828A92AC; continue 'dispatch;
	}
	// 828A9298: 4BDD35C1  bl 0x8267c858
	ctx.lr = 0x828A929C;
	sub_8267C858(ctx, base);
	// 828A929C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A92A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A92A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A92A8: 4E800020  blr
	return;
	// 828A92AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A92B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A92B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A92B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A92BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A92C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A92C0 size=124
    let mut pc: u32 = 0x828A92C0;
    'dispatch: loop {
        match pc {
            0x828A92C0 => {
    //   block [0x828A92C0..0x828A933C)
	// 828A92C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A92C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A92C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A92CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A92D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A92D4: 4BFFF9A5  bl 0x828a8c78
	ctx.lr = 0x828A92D8;
	sub_828A8C78(ctx, base);
	// 828A92D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A92DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A92E0: 419A0044  beq cr6, 0x828a9324
	if ctx.cr[6].eq {
	pc = 0x828A9324; continue 'dispatch;
	}
	// 828A92E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A92E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A92EC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828A92F0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828A92F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A92F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A92FC: 4B8EAB3D  bl 0x82193e38
	ctx.lr = 0x828A9300;
	sub_82193E38(ctx, base);
	// 828A9300: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9304: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828A9308: 4BC28BC1  bl 0x824d1ec8
	ctx.lr = 0x828A930C;
	sub_824D1EC8(ctx, base);
	// 828A930C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828A9310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9314: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828A9318: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828A931C: 4B8EAB1D  bl 0x82193e38
	ctx.lr = 0x828A9320;
	sub_82193E38(ctx, base);
	// 828A9320: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 828A9324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A9328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A932C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A9330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A9334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A9338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9340 size=548
    let mut pc: u32 = 0x828A9340;
    'dispatch: loop {
        match pc {
            0x828A9340 => {
    //   block [0x828A9340..0x828A9564)
	// 828A9340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9344: 484000C9  bl 0x82ca940c
	ctx.lr = 0x828A9348;
	sub_82CA93D0(ctx, base);
	// 828A9348: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A934C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A9350: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A9354: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A9358: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A935C: 4BFFEA25  bl 0x828a7d80
	ctx.lr = 0x828A9360;
	sub_828A7D80(ctx, base);
	// 828A9360: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A9364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9368: 419A0018  beq cr6, 0x828a9380
	if ctx.cr[6].eq {
	pc = 0x828A9380; continue 'dispatch;
	}
	// 828A936C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A9370: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A9374: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A9378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A937C: 409A0008  bne cr6, 0x828a9384
	if !ctx.cr[6].eq {
	pc = 0x828A9384; continue 'dispatch;
	}
	// 828A9380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A9384: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A9388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A938C: 419A01CC  beq cr6, 0x828a9558
	if ctx.cr[6].eq {
	pc = 0x828A9558; continue 'dispatch;
	}
	// 828A9390: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A9394: 556AAFFE  rlwinm r10, r11, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 828A9398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A939C: 419A00F8  beq cr6, 0x828a9494
	if ctx.cr[6].eq {
	pc = 0x828A9494; continue 'dispatch;
	}
	// 828A93A0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A93A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A93A8: 419A0024  beq cr6, 0x828a93cc
	if ctx.cr[6].eq {
	pc = 0x828A93CC; continue 'dispatch;
	}
	// 828A93AC: 894B006B  lbz r10, 0x6b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(107 as u32) ) } as u64;
	// 828A93B0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A93B4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828A93B8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A93BC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A93C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A93C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A93C8: 480000D0  b 0x828a9498
	pc = 0x828A9498; continue 'dispatch;
	// 828A93CC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828A93D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A93D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828A93D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A93DC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828A93E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A93E4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A93E8: 40810054  ble 0x828a943c
	if !ctx.cr[0].gt {
	pc = 0x828A943C; continue 'dispatch;
	}
	// 828A93EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828A93F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828A93F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828A93F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A93FC: 2F07006B  cmpwi cr6, r7, 0x6b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 107, &mut ctx.xer);
	// 828A9400: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A9404: 41980008  blt cr6, 0x828a940c
	if ctx.cr[6].lt {
	pc = 0x828A940C; continue 'dispatch;
	}
	// 828A9408: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A940C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828A9410: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828A9414: 419A0014  beq cr6, 0x828a9428
	if ctx.cr[6].eq {
	pc = 0x828A9428; continue 'dispatch;
	}
	// 828A9418: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828A941C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828A9420: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A9424: 4800000C  b 0x828a9430
	pc = 0x828A9430; continue 'dispatch;
	// 828A9428: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A942C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828A9430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A9434: 4199FFB8  bgt cr6, 0x828a93ec
	if ctx.cr[6].gt {
	pc = 0x828A93EC; continue 'dispatch;
	}
	// 828A9438: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828A943C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828A9440: 419A0040  beq cr6, 0x828a9480
	if ctx.cr[6].eq {
	pc = 0x828A9480; continue 'dispatch;
	}
	// 828A9444: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9448: 2F0B006B  cmpwi cr6, r11, 0x6b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 107, &mut ctx.xer);
	// 828A944C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A9450: 41990008  bgt cr6, 0x828a9458
	if ctx.cr[6].gt {
	pc = 0x828A9458; continue 'dispatch;
	}
	// 828A9454: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A9458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A945C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9460: 409A0020  bne cr6, 0x828a9480
	if !ctx.cr[6].eq {
	pc = 0x828A9480; continue 'dispatch;
	}
	// 828A9464: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828A9468: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828A946C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A9470: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A9474: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A9478: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A947C: 4800001C  b 0x828a9498
	pc = 0x828A9498; continue 'dispatch;
	// 828A9480: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828A9484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A9488: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A948C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A9490: 48000008  b 0x828a9498
	pc = 0x828A9498; continue 'dispatch;
	// 828A9494: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A9498: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A949C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A94A0: 419A00B8  beq cr6, 0x828a9558
	if ctx.cr[6].eq {
	pc = 0x828A9558; continue 'dispatch;
	}
	// 828A94A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A94A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A94AC: 4BFFF7CD  bl 0x828a8c78
	ctx.lr = 0x828A94B0;
	sub_828A8C78(ctx, base);
	// 828A94B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A94B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A94B8: 419A0008  beq cr6, 0x828a94c0
	if ctx.cr[6].eq {
	pc = 0x828A94C0; continue 'dispatch;
	}
	// 828A94BC: 80E30034  lwz r7, 0x34(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A94C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A94C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828A94C8: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A94CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828A94D0: 419A0030  beq cr6, 0x828a9500
	if ctx.cr[6].eq {
	pc = 0x828A9500; continue 'dispatch;
	}
	// 828A94D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A94D8: 80CA0034  lwz r6, 0x34(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A94DC: 7F063800  cmpw cr6, r6, r7
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[7].s32, &mut ctx.xer);
	// 828A94E0: 409A0014  bne cr6, 0x828a94f4
	if !ctx.cr[6].eq {
	pc = 0x828A94F4; continue 'dispatch;
	}
	// 828A94E4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A94E8: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828A94EC: 419A0014  beq cr6, 0x828a9500
	if ctx.cr[6].eq {
	pc = 0x828A9500; continue 'dispatch;
	}
	// 828A94F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828A94F4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828A94F8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828A94FC: 409AFFD8  bne cr6, 0x828a94d4
	if !ctx.cr[6].eq {
	pc = 0x828A94D4; continue 'dispatch;
	}
	// 828A9500: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A9504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9508: 419A0050  beq cr6, 0x828a9558
	if ctx.cr[6].eq {
	pc = 0x828A9558; continue 'dispatch;
	}
	// 828A950C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A9510: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A9514: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828A9518: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A951C: 4098003C  bge cr6, 0x828a9558
	if !ctx.cr[6].lt {
	pc = 0x828A9558; continue 'dispatch;
	}
	// 828A9520: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828A9524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9528: 419A0018  beq cr6, 0x828a9540
	if ctx.cr[6].eq {
	pc = 0x828A9540; continue 'dispatch;
	}
	// 828A952C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A9530: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A9534: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828A9538: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A953C: 41980008  blt cr6, 0x828a9544
	if ctx.cr[6].lt {
	pc = 0x828A9544; continue 'dispatch;
	}
	// 828A9540: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9544: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828A9548: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A954C: 4B8CA8ED  bl 0x82173e38
	ctx.lr = 0x828A9550;
	sub_82173E38(ctx, base);
	// 828A9550: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A9554: 483FFF08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828A9558: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A955C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A9560: 483FFEFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9568 size=1016
    let mut pc: u32 = 0x828A9568;
    'dispatch: loop {
        match pc {
            0x828A9568 => {
    //   block [0x828A9568..0x828A9960)
	// 828A9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A956C: 483FFE89  bl 0x82ca93f4
	ctx.lr = 0x828A9570;
	sub_82CA93D0(ctx, base);
	// 828A9570: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A9574: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 828A9578: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 828A957C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828A9580: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A9584: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A9588: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A958C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A9590: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A9594: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 828A9598: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828A959C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 828A95A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A95A4: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A95A8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A95AC: 83690000  lwz r27, 0(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A95B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A95B4: 4B9385F5  bl 0x821e1ba8
	ctx.lr = 0x828A95B8;
	sub_821E1BA8(ctx, base);
	// 828A95B8: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828A95BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A95C0: 38A8B278  addi r5, r8, -0x4d88
	ctx.r[5].s64 = ctx.r[8].s64 + -19848;
	// 828A95C4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828A95C8: 4BA10229  bl 0x822b97f0
	ctx.lr = 0x828A95CC;
	sub_822B97F0(ctx, base);
	// 828A95CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A95D0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828A95D4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A95D8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828A95DC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828A95E0: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 828A95E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828A95E8: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828A95EC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A95F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A95F4: 4BFFCFFD  bl 0x828a65f0
	ctx.lr = 0x828A95F8;
	sub_828A65F0(ctx, base);
	// 828A95F8: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A95FC: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A9600: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828A9604: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 828A9608: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A960C: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 828A9610: 40990008  ble cr6, 0x828a9618
	if !ctx.cr[6].gt {
	pc = 0x828A9618; continue 'dispatch;
	}
	// 828A9614: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9618: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A961C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A9620: 40990008  ble cr6, 0x828a9628
	if !ctx.cr[6].gt {
	pc = 0x828A9628; continue 'dispatch;
	}
	// 828A9624: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9628: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A962C: 419A020C  beq cr6, 0x828a9838
	if ctx.cr[6].eq {
	pc = 0x828A9838; continue 'dispatch;
	}
	// 828A9630: 41980008  blt cr6, 0x828a9638
	if ctx.cr[6].lt {
	pc = 0x828A9638; continue 'dispatch;
	}
	// 828A9634: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9638: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A963C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A9640: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9644: 40990008  ble cr6, 0x828a964c
	if !ctx.cr[6].gt {
	pc = 0x828A964C; continue 'dispatch;
	}
	// 828A9648: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A964C: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 828A9650: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A9654: 41980008  blt cr6, 0x828a965c
	if ctx.cr[6].lt {
	pc = 0x828A965C; continue 'dispatch;
	}
	// 828A9658: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A965C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A9660: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9664: 40990008  ble cr6, 0x828a966c
	if !ctx.cr[6].gt {
	pc = 0x828A966C; continue 'dispatch;
	}
	// 828A9668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A966C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9670: 419A01B0  beq cr6, 0x828a9820
	if ctx.cr[6].eq {
	pc = 0x828A9820; continue 'dispatch;
	}
	// 828A9674: 41980008  blt cr6, 0x828a967c
	if ctx.cr[6].lt {
	pc = 0x828A967C; continue 'dispatch;
	}
	// 828A9678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A967C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9680: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 828A9684: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A9688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A968C: 419A0030  beq cr6, 0x828a96bc
	if ctx.cr[6].eq {
	pc = 0x828A96BC; continue 'dispatch;
	}
	// 828A9690: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9694: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A9698: 419A0158  beq cr6, 0x828a97f0
	if ctx.cr[6].eq {
	pc = 0x828A97F0; continue 'dispatch;
	}
	// 828A969C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A96A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A96A4: 419A0018  beq cr6, 0x828a96bc
	if ctx.cr[6].eq {
	pc = 0x828A96BC; continue 'dispatch;
	}
	// 828A96A8: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A96AC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A96B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A96B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A96B8: 409A0008  bne cr6, 0x828a96c0
	if !ctx.cr[6].eq {
	pc = 0x828A96C0; continue 'dispatch;
	}
	// 828A96BC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A96C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A96C4: 572A063E  clrlwi r10, r25, 0x18
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828A96C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A96CC: 409A013C  bne cr6, 0x828a9808
	if !ctx.cr[6].eq {
	pc = 0x828A9808; continue 'dispatch;
	}
	// 828A96D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A96D4: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A96D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A96DC: 409A012C  bne cr6, 0x828a9808
	if !ctx.cr[6].eq {
	pc = 0x828A9808; continue 'dispatch;
	}
	// 828A96E0: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A96E4: 41980008  blt cr6, 0x828a96ec
	if ctx.cr[6].lt {
	pc = 0x828A96EC; continue 'dispatch;
	}
	// 828A96E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A96EC: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828A96F0: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828A96F4: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A96F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A96FC: 40990008  ble cr6, 0x828a9704
	if !ctx.cr[6].gt {
	pc = 0x828A9704; continue 'dispatch;
	}
	// 828A9700: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9704: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828A9708: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A970C: 41980008  blt cr6, 0x828a9714
	if ctx.cr[6].lt {
	pc = 0x828A9714; continue 'dispatch;
	}
	// 828A9710: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9714: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A9718: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A971C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9720: 40990008  ble cr6, 0x828a9728
	if !ctx.cr[6].gt {
	pc = 0x828A9728; continue 'dispatch;
	}
	// 828A9724: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9728: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828A972C: 419A0008  beq cr6, 0x828a9734
	if ctx.cr[6].eq {
	pc = 0x828A9734; continue 'dispatch;
	}
	// 828A9730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9734: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9738: 419A00D0  beq cr6, 0x828a9808
	if ctx.cr[6].eq {
	pc = 0x828A9808; continue 'dispatch;
	}
	// 828A973C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A9740: 41980008  blt cr6, 0x828a9748
	if ctx.cr[6].lt {
	pc = 0x828A9748; continue 'dispatch;
	}
	// 828A9744: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9748: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A974C: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 828A9750: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828A9754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9758: 419A0030  beq cr6, 0x828a9788
	if ctx.cr[6].eq {
	pc = 0x828A9788; continue 'dispatch;
	}
	// 828A975C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9760: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A9764: 419A0098  beq cr6, 0x828a97fc
	if ctx.cr[6].eq {
	pc = 0x828A97FC; continue 'dispatch;
	}
	// 828A9768: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828A976C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9770: 419A0018  beq cr6, 0x828a9788
	if ctx.cr[6].eq {
	pc = 0x828A9788; continue 'dispatch;
	}
	// 828A9774: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828A9778: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828A977C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A9780: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A9784: 409A0008  bne cr6, 0x828a978c
	if !ctx.cr[6].eq {
	pc = 0x828A978C; continue 'dispatch;
	}
	// 828A9788: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828A978C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A9790: 574A063E  clrlwi r10, r26, 0x18
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828A9794: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A9798: 409A0040  bne cr6, 0x828a97d8
	if !ctx.cr[6].eq {
	pc = 0x828A97D8; continue 'dispatch;
	}
	// 828A979C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A97A0: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A97A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A97A8: 409A0030  bne cr6, 0x828a97d8
	if !ctx.cr[6].eq {
	pc = 0x828A97D8; continue 'dispatch;
	}
	// 828A97AC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A97B0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A97B4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A97B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A97BC: 419A001C  beq cr6, 0x828a97d8
	if ctx.cr[6].eq {
	pc = 0x828A97D8; continue 'dispatch;
	}
	// 828A97C0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A97C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A97C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A97CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A97D0: 48000B71  bl 0x828aa340
	ctx.lr = 0x828A97D4;
	sub_828AA340(ctx, base);
	// 828A97D4: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A97D8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A97DC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A97E0: 41980008  blt cr6, 0x828a97e8
	if ctx.cr[6].lt {
	pc = 0x828A97E8; continue 'dispatch;
	}
	// 828A97E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A97E8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828A97EC: 4BFFFF1C  b 0x828a9708
	pc = 0x828A9708; continue 'dispatch;
	// 828A97F0: 4B8EA649  bl 0x82193e38
	ctx.lr = 0x828A97F4;
	sub_82193E38(ctx, base);
	// 828A97F4: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A97F8: 4BFFFEC4  b 0x828a96bc
	pc = 0x828A96BC; continue 'dispatch;
	// 828A97FC: 4B8EA63D  bl 0x82193e38
	ctx.lr = 0x828A9800;
	sub_82193E38(ctx, base);
	// 828A9800: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A9804: 4BFFFF84  b 0x828a9788
	pc = 0x828A9788; continue 'dispatch;
	// 828A9808: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A980C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828A9810: 41980008  blt cr6, 0x828a9818
	if ctx.cr[6].lt {
	pc = 0x828A9818; continue 'dispatch;
	}
	// 828A9814: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A9818: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828A981C: 4BFFFE34  b 0x828a9650
	pc = 0x828A9650; continue 'dispatch;
	// 828A9820: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828A9824: 41980008  blt cr6, 0x828a982c
	if ctx.cr[6].lt {
	pc = 0x828A982C; continue 'dispatch;
	}
	// 828A9828: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A982C: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A9830: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 828A9834: 4BFFFDE8  b 0x828a961c
	pc = 0x828A961C; continue 'dispatch;
	// 828A9838: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A983C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9840: 419A00F0  beq cr6, 0x828a9930
	if ctx.cr[6].eq {
	pc = 0x828A9930; continue 'dispatch;
	}
	// 828A9844: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A9848: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828A984C: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828A9850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9854: 419A00C8  beq cr6, 0x828a991c
	if ctx.cr[6].eq {
	pc = 0x828A991C; continue 'dispatch;
	}
	// 828A9858: 81586AB8  lwz r10, 0x6ab8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828A985C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A9860: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A9864: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A9868: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A986C: 80E80078  lwz r7, 0x78(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A9870: 1D4724A1  mulli r10, r7, 0x24a1
	ctx.r[10].s64 = ctx.r[7].s64 * 9377;
	// 828A9874: 38CA24DF  addi r6, r10, 0x24df
	ctx.r[6].s64 = ctx.r[10].s64 + 9439;
	// 828A9878: 54CA983E  rotlwi r10, r6, 0x13
	ctx.r[10].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 828A987C: 91480078  stw r10, 0x78(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828A9880: 419A0014  beq cr6, 0x828a9894
	if ctx.cr[6].eq {
	pc = 0x828A9894; continue 'dispatch;
	}
	// 828A9884: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 828A9888: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828A988C: 7FE85050  subf r31, r8, r10
	ctx.r[31].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828A9890: 48000008  b 0x828a9898
	pc = 0x828A9898; continue 'dispatch;
	// 828A9894: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828A9898: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A989C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A98A0: 419A0018  beq cr6, 0x828a98b8
	if ctx.cr[6].eq {
	pc = 0x828A98B8; continue 'dispatch;
	}
	// 828A98A4: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A98A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A98AC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828A98B0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A98B4: 41980008  blt cr6, 0x828a98bc
	if ctx.cr[6].lt {
	pc = 0x828A98BC; continue 'dispatch;
	}
	// 828A98B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A98BC: 57FE1838  slwi r30, r31, 3
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828A98C0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A98C4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828A98C8: 388A266C  addi r4, r10, 0x266c
	ctx.r[4].s64 = ctx.r[10].s64 + 9836;
	// 828A98CC: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828A98D0: 4BBF5239  bl 0x8249eb08
	ctx.lr = 0x828A98D4;
	sub_8249EB08(ctx, base);
	// 828A98D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A98D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A98DC: 419A0018  beq cr6, 0x828a98f4
	if ctx.cr[6].eq {
	pc = 0x828A98F4; continue 'dispatch;
	}
	// 828A98E0: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A98E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828A98E8: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828A98EC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A98F0: 41980008  blt cr6, 0x828a98f8
	if ctx.cr[6].lt {
	pc = 0x828A98F8; continue 'dispatch;
	}
	// 828A98F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828A98F8: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828A98FC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9900: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828A9904: 388A2678  addi r4, r10, 0x2678
	ctx.r[4].s64 = ctx.r[10].s64 + 9848;
	// 828A9908: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A990C: 4BBF51FD  bl 0x8249eb08
	ctx.lr = 0x828A9910;
	sub_8249EB08(ctx, base);
	// 828A9910: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A9914: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A9918: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A991C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A9920: 419A0010  beq cr6, 0x828a9930
	if ctx.cr[6].eq {
	pc = 0x828A9930; continue 'dispatch;
	}
	// 828A9924: 4B972415  bl 0x8221bd38
	ctx.lr = 0x828A9928;
	sub_8221BD38(ctx, base);
	// 828A9928: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A992C: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A9930: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828A9934: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A9938: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 828A993C: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 828A9940: 419A0014  beq cr6, 0x828a9954
	if ctx.cr[6].eq {
	pc = 0x828A9954; continue 'dispatch;
	}
	// 828A9944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9948: 48000CD9  bl 0x828aa620
	ctx.lr = 0x828A994C;
	sub_828AA620(ctx, base);
	// 828A994C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A9950: 4B9723E9  bl 0x8221bd38
	ctx.lr = 0x828A9954;
	sub_8221BD38(ctx, base);
	// 828A9954: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828A9958: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A995C: 483FFAE8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A9960 size=1964
    let mut pc: u32 = 0x828A9960;
    'dispatch: loop {
        match pc {
            0x828A9960 => {
    //   block [0x828A9960..0x828AA10C)
	// 828A9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A9964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A9968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A996C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A9970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A9974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A9978: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A997C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A9980: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9984: 4BB1561D  bl 0x823befa0
	ctx.lr = 0x828A9988;
	sub_823BEFA0(ctx, base);
	// 828A9988: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A998C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828A9990: 38AA62D0  addi r5, r10, 0x62d0
	ctx.r[5].s64 = ctx.r[10].s64 + 25296;
	// 828A9994: 38892684  addi r4, r9, 0x2684
	ctx.r[4].s64 = ctx.r[9].s64 + 9860;
	// 828A9998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A999C: 4BA5F815  bl 0x823091b0
	ctx.lr = 0x828A99A0;
	sub_823091B0(ctx, base);
	// 828A99A0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A99A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A99A8: 3BC8269C  addi r30, r8, 0x269c
	ctx.r[30].s64 = ctx.r[8].s64 + 9884;
	// 828A99AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A99B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A99B4: 4B98351D  bl 0x8222ced0
	ctx.lr = 0x828A99B8;
	sub_8222CED0(ctx, base);
	// 828A99B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A99BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A99C0: 480012F9  bl 0x828aacb8
	ctx.lr = 0x828A99C4;
	sub_828AACB8(ctx, base);
	// 828A99C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A99C8: 4B96B411  bl 0x82214dd8
	ctx.lr = 0x828A99CC;
	sub_82214DD8(ctx, base);
	// 828A99CC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828A99D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A99D4: 388726B0  addi r4, r7, 0x26b0
	ctx.r[4].s64 = ctx.r[7].s64 + 9904;
	// 828A99D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A99DC: 4B9834F5  bl 0x8222ced0
	ctx.lr = 0x828A99E0;
	sub_8222CED0(ctx, base);
	// 828A99E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A99E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A99E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A99EC: 4B9834E5  bl 0x8222ced0
	ctx.lr = 0x828A99F0;
	sub_8222CED0(ctx, base);
	// 828A99F0: 3CC0828A  lis r6, -0x7d76
	ctx.r[6].s64 = -2104885248;
	// 828A99F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A99F8: 38C677F8  addi r6, r6, 0x77f8
	ctx.r[6].s64 = ctx.r[6].s64 + 30712;
	// 828A99FC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828A9A00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9A04: 480014FD  bl 0x828aaf00
	ctx.lr = 0x828A9A08;
	sub_828AAF00(ctx, base);
	// 828A9A08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A0C: 4B96B3CD  bl 0x82214dd8
	ctx.lr = 0x828A9A10;
	sub_82214DD8(ctx, base);
	// 828A9A10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9A14: 4B96B3C5  bl 0x82214dd8
	ctx.lr = 0x828A9A18;
	sub_82214DD8(ctx, base);
	// 828A9A18: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828A9A1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9A20: 388426C8  addi r4, r4, 0x26c8
	ctx.r[4].s64 = ctx.r[4].s64 + 9928;
	// 828A9A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A28: 4B9834A9  bl 0x8222ced0
	ctx.lr = 0x828A9A2C;
	sub_8222CED0(ctx, base);
	// 828A9A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9A30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9A34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9A38: 4B983499  bl 0x8222ced0
	ctx.lr = 0x828A9A3C;
	sub_8222CED0(ctx, base);
	// 828A9A3C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9A44: 38CB78C0  addi r6, r11, 0x78c0
	ctx.r[6].s64 = ctx.r[11].s64 + 30912;
	// 828A9A48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9A4C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9A50: 480014B1  bl 0x828aaf00
	ctx.lr = 0x828A9A54;
	sub_828AAF00(ctx, base);
	// 828A9A54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9A58: 4B96B381  bl 0x82214dd8
	ctx.lr = 0x828A9A5C;
	sub_82214DD8(ctx, base);
	// 828A9A5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A60: 4B96B379  bl 0x82214dd8
	ctx.lr = 0x828A9A64;
	sub_82214DD8(ctx, base);
	// 828A9A64: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9A68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9A6C: 388A26DC  addi r4, r10, 0x26dc
	ctx.r[4].s64 = ctx.r[10].s64 + 9948;
	// 828A9A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A74: 4B98345D  bl 0x8222ced0
	ctx.lr = 0x828A9A78;
	sub_8222CED0(ctx, base);
	// 828A9A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9A7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9A80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9A84: 4B98344D  bl 0x8222ced0
	ctx.lr = 0x828A9A88;
	sub_8222CED0(ctx, base);
	// 828A9A88: 3D20828A  lis r9, -0x7d76
	ctx.r[9].s64 = -2104885248;
	// 828A9A8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9A90: 38C97988  addi r6, r9, 0x7988
	ctx.r[6].s64 = ctx.r[9].s64 + 31112;
	// 828A9A94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9A9C: 48001665  bl 0x828ab100
	ctx.lr = 0x828A9AA0;
	sub_828AB100(ctx, base);
	// 828A9AA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9AA4: 4B96B335  bl 0x82214dd8
	ctx.lr = 0x828A9AA8;
	sub_82214DD8(ctx, base);
	// 828A9AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9AAC: 4B96B32D  bl 0x82214dd8
	ctx.lr = 0x828A9AB0;
	sub_82214DD8(ctx, base);
	// 828A9AB0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A9AB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9AB8: 388826FC  addi r4, r8, 0x26fc
	ctx.r[4].s64 = ctx.r[8].s64 + 9980;
	// 828A9ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9AC0: 4B983411  bl 0x8222ced0
	ctx.lr = 0x828A9AC4;
	sub_8222CED0(ctx, base);
	// 828A9AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9AC8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9ACC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9AD0: 4B983401  bl 0x8222ced0
	ctx.lr = 0x828A9AD4;
	sub_8222CED0(ctx, base);
	// 828A9AD4: 3CE0828A  lis r7, -0x7d76
	ctx.r[7].s64 = -2104885248;
	// 828A9AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9ADC: 38C77A50  addi r6, r7, 0x7a50
	ctx.r[6].s64 = ctx.r[7].s64 + 31312;
	// 828A9AE0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9AE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9AE8: 48001419  bl 0x828aaf00
	ctx.lr = 0x828A9AEC;
	sub_828AAF00(ctx, base);
	// 828A9AEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9AF0: 4B96B2E9  bl 0x82214dd8
	ctx.lr = 0x828A9AF4;
	sub_82214DD8(ctx, base);
	// 828A9AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9AF8: 4B96B2E1  bl 0x82214dd8
	ctx.lr = 0x828A9AFC;
	sub_82214DD8(ctx, base);
	// 828A9AFC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A9B00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9B04: 38862708  addi r4, r6, 0x2708
	ctx.r[4].s64 = ctx.r[6].s64 + 9992;
	// 828A9B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B0C: 4B9833C5  bl 0x8222ced0
	ctx.lr = 0x828A9B10;
	sub_8222CED0(ctx, base);
	// 828A9B10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9B14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9B18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9B1C: 4B9833B5  bl 0x8222ced0
	ctx.lr = 0x828A9B20;
	sub_8222CED0(ctx, base);
	// 828A9B20: 3CA0828A  lis r5, -0x7d76
	ctx.r[5].s64 = -2104885248;
	// 828A9B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9B28: 38C57B18  addi r6, r5, 0x7b18
	ctx.r[6].s64 = ctx.r[5].s64 + 31512;
	// 828A9B2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9B30: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9B34: 480017D5  bl 0x828ab308
	ctx.lr = 0x828A9B38;
	sub_828AB308(ctx, base);
	// 828A9B38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9B3C: 4B96B29D  bl 0x82214dd8
	ctx.lr = 0x828A9B40;
	sub_82214DD8(ctx, base);
	// 828A9B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B44: 4B96B295  bl 0x82214dd8
	ctx.lr = 0x828A9B48;
	sub_82214DD8(ctx, base);
	// 828A9B48: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828A9B4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9B50: 38842740  addi r4, r4, 0x2740
	ctx.r[4].s64 = ctx.r[4].s64 + 10048;
	// 828A9B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B58: 4B983379  bl 0x8222ced0
	ctx.lr = 0x828A9B5C;
	sub_8222CED0(ctx, base);
	// 828A9B5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9B60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9B64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9B68: 4B983369  bl 0x8222ced0
	ctx.lr = 0x828A9B6C;
	sub_8222CED0(ctx, base);
	// 828A9B6C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828A9B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9B74: 38CB8280  addi r6, r11, -0x7d80
	ctx.r[6].s64 = ctx.r[11].s64 + -32128;
	// 828A9B78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9B7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9B80: 48001991  bl 0x828ab510
	ctx.lr = 0x828A9B84;
	sub_828AB510(ctx, base);
	// 828A9B84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9B88: 4B96B251  bl 0x82214dd8
	ctx.lr = 0x828A9B8C;
	sub_82214DD8(ctx, base);
	// 828A9B8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B90: 4B96B249  bl 0x82214dd8
	ctx.lr = 0x828A9B94;
	sub_82214DD8(ctx, base);
	// 828A9B94: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9B98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9B9C: 388A275C  addi r4, r10, 0x275c
	ctx.r[4].s64 = ctx.r[10].s64 + 10076;
	// 828A9BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9BA4: 4B98332D  bl 0x8222ced0
	ctx.lr = 0x828A9BA8;
	sub_8222CED0(ctx, base);
	// 828A9BA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9BAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9BB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9BB4: 4B98331D  bl 0x8222ced0
	ctx.lr = 0x828A9BB8;
	sub_8222CED0(ctx, base);
	// 828A9BB8: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828A9BBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9BC0: 38C98508  addi r6, r9, -0x7af8
	ctx.r[6].s64 = ctx.r[9].s64 + -31480;
	// 828A9BC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9BCC: 48001B4D  bl 0x828ab718
	ctx.lr = 0x828A9BD0;
	sub_828AB718(ctx, base);
	// 828A9BD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9BD4: 4B96B205  bl 0x82214dd8
	ctx.lr = 0x828A9BD8;
	sub_82214DD8(ctx, base);
	// 828A9BD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9BDC: 4B96B1FD  bl 0x82214dd8
	ctx.lr = 0x828A9BE0;
	sub_82214DD8(ctx, base);
	// 828A9BE0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A9BE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9BE8: 38882780  addi r4, r8, 0x2780
	ctx.r[4].s64 = ctx.r[8].s64 + 10112;
	// 828A9BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9BF0: 4B9832E1  bl 0x8222ced0
	ctx.lr = 0x828A9BF4;
	sub_8222CED0(ctx, base);
	// 828A9BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9BF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9BFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9C00: 4B9832D1  bl 0x8222ced0
	ctx.lr = 0x828A9C04;
	sub_8222CED0(ctx, base);
	// 828A9C04: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828A9C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9C0C: 38C78630  addi r6, r7, -0x79d0
	ctx.r[6].s64 = ctx.r[7].s64 + -31184;
	// 828A9C10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9C14: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9C18: 48001D09  bl 0x828ab920
	ctx.lr = 0x828A9C1C;
	sub_828AB920(ctx, base);
	// 828A9C1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9C20: 4B96B1B9  bl 0x82214dd8
	ctx.lr = 0x828A9C24;
	sub_82214DD8(ctx, base);
	// 828A9C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C28: 4B96B1B1  bl 0x82214dd8
	ctx.lr = 0x828A9C2C;
	sub_82214DD8(ctx, base);
	// 828A9C2C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A9C30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9C34: 388627A0  addi r4, r6, 0x27a0
	ctx.r[4].s64 = ctx.r[6].s64 + 10144;
	// 828A9C38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C3C: 4B983295  bl 0x8222ced0
	ctx.lr = 0x828A9C40;
	sub_8222CED0(ctx, base);
	// 828A9C40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9C44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9C48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9C4C: 4B983285  bl 0x8222ced0
	ctx.lr = 0x828A9C50;
	sub_8222CED0(ctx, base);
	// 828A9C50: 3CA0828B  lis r5, -0x7d75
	ctx.r[5].s64 = -2104819712;
	// 828A9C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9C58: 38C58848  addi r6, r5, -0x77b8
	ctx.r[6].s64 = ctx.r[5].s64 + -30648;
	// 828A9C5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9C60: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9C64: 48001EC5  bl 0x828abb28
	ctx.lr = 0x828A9C68;
	sub_828ABB28(ctx, base);
	// 828A9C68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9C6C: 4B96B16D  bl 0x82214dd8
	ctx.lr = 0x828A9C70;
	sub_82214DD8(ctx, base);
	// 828A9C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C74: 4B96B165  bl 0x82214dd8
	ctx.lr = 0x828A9C78;
	sub_82214DD8(ctx, base);
	// 828A9C78: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828A9C7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9C80: 388427C4  addi r4, r4, 0x27c4
	ctx.r[4].s64 = ctx.r[4].s64 + 10180;
	// 828A9C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C88: 4B983249  bl 0x8222ced0
	ctx.lr = 0x828A9C8C;
	sub_8222CED0(ctx, base);
	// 828A9C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9C90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9C94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9C98: 4B983239  bl 0x8222ced0
	ctx.lr = 0x828A9C9C;
	sub_8222CED0(ctx, base);
	// 828A9C9C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828A9CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9CA4: 38CB8B98  addi r6, r11, -0x7468
	ctx.r[6].s64 = ctx.r[11].s64 + -29800;
	// 828A9CA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9CAC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9CB0: 48002081  bl 0x828abd30
	ctx.lr = 0x828A9CB4;
	sub_828ABD30(ctx, base);
	// 828A9CB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9CB8: 4B96B121  bl 0x82214dd8
	ctx.lr = 0x828A9CBC;
	sub_82214DD8(ctx, base);
	// 828A9CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9CC0: 4B96B119  bl 0x82214dd8
	ctx.lr = 0x828A9CC4;
	sub_82214DD8(ctx, base);
	// 828A9CC4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9CC8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9CCC: 388A27E0  addi r4, r10, 0x27e0
	ctx.r[4].s64 = ctx.r[10].s64 + 10208;
	// 828A9CD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9CD4: 4B9831FD  bl 0x8222ced0
	ctx.lr = 0x828A9CD8;
	sub_8222CED0(ctx, base);
	// 828A9CD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9CDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9CE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9CE4: 4B9831ED  bl 0x8222ced0
	ctx.lr = 0x828A9CE8;
	sub_8222CED0(ctx, base);
	// 828A9CE8: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828A9CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9CF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9CF4: 38C98FD8  addi r6, r9, -0x7028
	ctx.r[6].s64 = ctx.r[9].s64 + -28712;
	// 828A9CF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9CFC: 4800223D  bl 0x828abf38
	ctx.lr = 0x828A9D00;
	sub_828ABF38(ctx, base);
	// 828A9D00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9D04: 4B96B0D5  bl 0x82214dd8
	ctx.lr = 0x828A9D08;
	sub_82214DD8(ctx, base);
	// 828A9D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D0C: 4B96B0CD  bl 0x82214dd8
	ctx.lr = 0x828A9D10;
	sub_82214DD8(ctx, base);
	// 828A9D10: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A9D14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9D18: 388827F8  addi r4, r8, 0x27f8
	ctx.r[4].s64 = ctx.r[8].s64 + 10232;
	// 828A9D1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D20: 4B9831B1  bl 0x8222ced0
	ctx.lr = 0x828A9D24;
	sub_8222CED0(ctx, base);
	// 828A9D24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9D28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9D2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9D30: 4B9831A1  bl 0x8222ced0
	ctx.lr = 0x828A9D34;
	sub_8222CED0(ctx, base);
	// 828A9D34: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828A9D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9D3C: 38C79070  addi r6, r7, -0x6f90
	ctx.r[6].s64 = ctx.r[7].s64 + -28560;
	// 828A9D40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9D44: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9D48: 480021F1  bl 0x828abf38
	ctx.lr = 0x828A9D4C;
	sub_828ABF38(ctx, base);
	// 828A9D4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9D50: 4B96B089  bl 0x82214dd8
	ctx.lr = 0x828A9D54;
	sub_82214DD8(ctx, base);
	// 828A9D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D58: 4B96B081  bl 0x82214dd8
	ctx.lr = 0x828A9D5C;
	sub_82214DD8(ctx, base);
	// 828A9D5C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A9D60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9D64: 38862810  addi r4, r6, 0x2810
	ctx.r[4].s64 = ctx.r[6].s64 + 10256;
	// 828A9D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D6C: 4B983165  bl 0x8222ced0
	ctx.lr = 0x828A9D70;
	sub_8222CED0(ctx, base);
	// 828A9D70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9D74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9D78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9D7C: 4B983155  bl 0x8222ced0
	ctx.lr = 0x828A9D80;
	sub_8222CED0(ctx, base);
	// 828A9D80: 3CA0828B  lis r5, -0x7d75
	ctx.r[5].s64 = -2104819712;
	// 828A9D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9D88: 38C59120  addi r6, r5, -0x6ee0
	ctx.r[6].s64 = ctx.r[5].s64 + -28384;
	// 828A9D8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9D90: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9D94: 480023A5  bl 0x828ac138
	ctx.lr = 0x828A9D98;
	sub_828AC138(ctx, base);
	// 828A9D98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9D9C: 4B96B03D  bl 0x82214dd8
	ctx.lr = 0x828A9DA0;
	sub_82214DD8(ctx, base);
	// 828A9DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9DA4: 4B96B035  bl 0x82214dd8
	ctx.lr = 0x828A9DA8;
	sub_82214DD8(ctx, base);
	// 828A9DA8: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828A9DAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9DB0: 3884282C  addi r4, r4, 0x282c
	ctx.r[4].s64 = ctx.r[4].s64 + 10284;
	// 828A9DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9DB8: 4B983119  bl 0x8222ced0
	ctx.lr = 0x828A9DBC;
	sub_8222CED0(ctx, base);
	// 828A9DBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9DC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9DC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9DC8: 4B983109  bl 0x8222ced0
	ctx.lr = 0x828A9DCC;
	sub_8222CED0(ctx, base);
	// 828A9DCC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828A9DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9DD4: 38CB91A0  addi r6, r11, -0x6e60
	ctx.r[6].s64 = ctx.r[11].s64 + -28256;
	// 828A9DD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9DDC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9DE0: 48002519  bl 0x828ac2f8
	ctx.lr = 0x828A9DE4;
	sub_828AC2F8(ctx, base);
	// 828A9DE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9DE8: 4B96AFF1  bl 0x82214dd8
	ctx.lr = 0x828A9DEC;
	sub_82214DD8(ctx, base);
	// 828A9DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9DF0: 4B96AFE9  bl 0x82214dd8
	ctx.lr = 0x828A9DF4;
	sub_82214DD8(ctx, base);
	// 828A9DF4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9DF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9DFC: 388A2840  addi r4, r10, 0x2840
	ctx.r[4].s64 = ctx.r[10].s64 + 10304;
	// 828A9E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E04: 4B9830CD  bl 0x8222ced0
	ctx.lr = 0x828A9E08;
	sub_8222CED0(ctx, base);
	// 828A9E08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9E0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9E10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9E14: 4B9830BD  bl 0x8222ced0
	ctx.lr = 0x828A9E18;
	sub_8222CED0(ctx, base);
	// 828A9E18: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828A9E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9E20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9E24: 38C992C0  addi r6, r9, -0x6d40
	ctx.r[6].s64 = ctx.r[9].s64 + -27968;
	// 828A9E28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9E2C: 480026D5  bl 0x828ac500
	ctx.lr = 0x828A9E30;
	sub_828AC500(ctx, base);
	// 828A9E30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9E34: 4B96AFA5  bl 0x82214dd8
	ctx.lr = 0x828A9E38;
	sub_82214DD8(ctx, base);
	// 828A9E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E3C: 4B96AF9D  bl 0x82214dd8
	ctx.lr = 0x828A9E40;
	sub_82214DD8(ctx, base);
	// 828A9E40: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A9E44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9E48: 38882850  addi r4, r8, 0x2850
	ctx.r[4].s64 = ctx.r[8].s64 + 10320;
	// 828A9E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E50: 4B983081  bl 0x8222ced0
	ctx.lr = 0x828A9E54;
	sub_8222CED0(ctx, base);
	// 828A9E54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9E58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9E5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9E60: 4B983071  bl 0x8222ced0
	ctx.lr = 0x828A9E64;
	sub_8222CED0(ctx, base);
	// 828A9E64: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828A9E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9E6C: 38C79340  addi r6, r7, -0x6cc0
	ctx.r[6].s64 = ctx.r[7].s64 + -27840;
	// 828A9E70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9E74: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9E78: 48002889  bl 0x828ac700
	ctx.lr = 0x828A9E7C;
	sub_828AC700(ctx, base);
	// 828A9E7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9E80: 4B96AF59  bl 0x82214dd8
	ctx.lr = 0x828A9E84;
	sub_82214DD8(ctx, base);
	// 828A9E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E88: 4B96AF51  bl 0x82214dd8
	ctx.lr = 0x828A9E8C;
	sub_82214DD8(ctx, base);
	// 828A9E8C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A9E90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9E94: 38862878  addi r4, r6, 0x2878
	ctx.r[4].s64 = ctx.r[6].s64 + 10360;
	// 828A9E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E9C: 4B983035  bl 0x8222ced0
	ctx.lr = 0x828A9EA0;
	sub_8222CED0(ctx, base);
	// 828A9EA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9EA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9EA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9EAC: 4B983025  bl 0x8222ced0
	ctx.lr = 0x828A9EB0;
	sub_8222CED0(ctx, base);
	// 828A9EB0: 3CA0828B  lis r5, -0x7d75
	ctx.r[5].s64 = -2104819712;
	// 828A9EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9EB8: 38C59210  addi r6, r5, -0x6df0
	ctx.r[6].s64 = ctx.r[5].s64 + -28144;
	// 828A9EBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9EC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9EC4: 4800263D  bl 0x828ac500
	ctx.lr = 0x828A9EC8;
	sub_828AC500(ctx, base);
	// 828A9EC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9ECC: 4B96AF0D  bl 0x82214dd8
	ctx.lr = 0x828A9ED0;
	sub_82214DD8(ctx, base);
	// 828A9ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9ED4: 4B96AF05  bl 0x82214dd8
	ctx.lr = 0x828A9ED8;
	sub_82214DD8(ctx, base);
	// 828A9ED8: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828A9EDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9EE0: 3884288C  addi r4, r4, 0x288c
	ctx.r[4].s64 = ctx.r[4].s64 + 10380;
	// 828A9EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9EE8: 4B982FE9  bl 0x8222ced0
	ctx.lr = 0x828A9EEC;
	sub_8222CED0(ctx, base);
	// 828A9EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9EF0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9EF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9EF8: 4B982FD9  bl 0x8222ced0
	ctx.lr = 0x828A9EFC;
	sub_8222CED0(ctx, base);
	// 828A9EFC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828A9F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9F04: 38CB9240  addi r6, r11, -0x6dc0
	ctx.r[6].s64 = ctx.r[11].s64 + -28096;
	// 828A9F08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9F0C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9F10: 480029B1  bl 0x828ac8c0
	ctx.lr = 0x828A9F14;
	sub_828AC8C0(ctx, base);
	// 828A9F14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9F18: 4B96AEC1  bl 0x82214dd8
	ctx.lr = 0x828A9F1C;
	sub_82214DD8(ctx, base);
	// 828A9F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F20: 4B96AEB9  bl 0x82214dd8
	ctx.lr = 0x828A9F24;
	sub_82214DD8(ctx, base);
	// 828A9F24: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828A9F28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9F2C: 388A28A4  addi r4, r10, 0x28a4
	ctx.r[4].s64 = ctx.r[10].s64 + 10404;
	// 828A9F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F34: 4B982F9D  bl 0x8222ced0
	ctx.lr = 0x828A9F38;
	sub_8222CED0(ctx, base);
	// 828A9F38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9F3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9F40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9F44: 4B982F8D  bl 0x8222ced0
	ctx.lr = 0x828A9F48;
	sub_8222CED0(ctx, base);
	// 828A9F48: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828A9F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9F50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9F54: 38C99280  addi r6, r9, -0x6d80
	ctx.r[6].s64 = ctx.r[9].s64 + -28032;
	// 828A9F58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9F5C: 48002965  bl 0x828ac8c0
	ctx.lr = 0x828A9F60;
	sub_828AC8C0(ctx, base);
	// 828A9F60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9F64: 4B96AE75  bl 0x82214dd8
	ctx.lr = 0x828A9F68;
	sub_82214DD8(ctx, base);
	// 828A9F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F6C: 4B96AE6D  bl 0x82214dd8
	ctx.lr = 0x828A9F70;
	sub_82214DD8(ctx, base);
	// 828A9F70: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828A9F74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9F78: 388828B8  addi r4, r8, 0x28b8
	ctx.r[4].s64 = ctx.r[8].s64 + 10424;
	// 828A9F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F80: 4B982F51  bl 0x8222ced0
	ctx.lr = 0x828A9F84;
	sub_8222CED0(ctx, base);
	// 828A9F84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9F88: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9F8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9F90: 4B982F41  bl 0x8222ced0
	ctx.lr = 0x828A9F94;
	sub_8222CED0(ctx, base);
	// 828A9F94: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828A9F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9F9C: 38C78EF8  addi r6, r7, -0x7108
	ctx.r[6].s64 = ctx.r[7].s64 + -28936;
	// 828A9FA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9FA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9FA8: 48002919  bl 0x828ac8c0
	ctx.lr = 0x828A9FAC;
	sub_828AC8C0(ctx, base);
	// 828A9FAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9FB0: 4B96AE29  bl 0x82214dd8
	ctx.lr = 0x828A9FB4;
	sub_82214DD8(ctx, base);
	// 828A9FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9FB8: 4B96AE21  bl 0x82214dd8
	ctx.lr = 0x828A9FBC;
	sub_82214DD8(ctx, base);
	// 828A9FBC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828A9FC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9FC4: 388628C8  addi r4, r6, 0x28c8
	ctx.r[4].s64 = ctx.r[6].s64 + 10440;
	// 828A9FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9FCC: 4B982F05  bl 0x8222ced0
	ctx.lr = 0x828A9FD0;
	sub_8222CED0(ctx, base);
	// 828A9FD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A9FD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828A9FD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9FDC: 4B982EF5  bl 0x8222ced0
	ctx.lr = 0x828A9FE0;
	sub_8222CED0(ctx, base);
	// 828A9FE0: 3CA0828B  lis r5, -0x7d75
	ctx.r[5].s64 = -2104819712;
	// 828A9FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A9FE8: 38C59160  addi r6, r5, -0x6ea0
	ctx.r[6].s64 = ctx.r[5].s64 + -28320;
	// 828A9FEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9FF0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9FF4: 48002ACD  bl 0x828acac0
	ctx.lr = 0x828A9FF8;
	sub_828ACAC0(ctx, base);
	// 828A9FF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9FFC: 4B96ADDD  bl 0x82214dd8
	ctx.lr = 0x828AA000;
	sub_82214DD8(ctx, base);
	// 828AA000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA004: 4B96ADD5  bl 0x82214dd8
	ctx.lr = 0x828AA008;
	sub_82214DD8(ctx, base);
	// 828AA008: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828AA00C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA010: 388428E4  addi r4, r4, 0x28e4
	ctx.r[4].s64 = ctx.r[4].s64 + 10468;
	// 828AA014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA018: 4B982EB9  bl 0x8222ced0
	ctx.lr = 0x828AA01C;
	sub_8222CED0(ctx, base);
	// 828AA01C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AA020: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA028: 4B982EA9  bl 0x8222ced0
	ctx.lr = 0x828AA02C;
	sub_8222CED0(ctx, base);
	// 828AA02C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA034: 38CB7648  addi r6, r11, 0x7648
	ctx.r[6].s64 = ctx.r[11].s64 + 30280;
	// 828AA038: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828AA03C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AA040: 48002C89  bl 0x828accc8
	ctx.lr = 0x828AA044;
	sub_828ACCC8(ctx, base);
	// 828AA044: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA048: 4B96AD91  bl 0x82214dd8
	ctx.lr = 0x828AA04C;
	sub_82214DD8(ctx, base);
	// 828AA04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA050: 4B96AD89  bl 0x82214dd8
	ctx.lr = 0x828AA054;
	sub_82214DD8(ctx, base);
	// 828AA054: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828AA058: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA05C: 388A2900  addi r4, r10, 0x2900
	ctx.r[4].s64 = ctx.r[10].s64 + 10496;
	// 828AA060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA064: 4B982E6D  bl 0x8222ced0
	ctx.lr = 0x828AA068;
	sub_8222CED0(ctx, base);
	// 828AA068: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AA06C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA074: 4B982E5D  bl 0x8222ced0
	ctx.lr = 0x828AA078;
	sub_8222CED0(ctx, base);
	// 828AA078: 3D20828A  lis r9, -0x7d76
	ctx.r[9].s64 = -2104885248;
	// 828AA07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA080: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828AA084: 38C97D80  addi r6, r9, 0x7d80
	ctx.r[6].s64 = ctx.r[9].s64 + 32128;
	// 828AA088: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AA08C: 48002E45  bl 0x828aced0
	ctx.lr = 0x828AA090;
	sub_828ACED0(ctx, base);
	// 828AA090: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA094: 4B96AD45  bl 0x82214dd8
	ctx.lr = 0x828AA098;
	sub_82214DD8(ctx, base);
	// 828AA098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA09C: 4B96AD3D  bl 0x82214dd8
	ctx.lr = 0x828AA0A0;
	sub_82214DD8(ctx, base);
	// 828AA0A0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828AA0A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA0A8: 38882920  addi r4, r8, 0x2920
	ctx.r[4].s64 = ctx.r[8].s64 + 10528;
	// 828AA0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0B0: 4B982E21  bl 0x8222ced0
	ctx.lr = 0x828AA0B4;
	sub_8222CED0(ctx, base);
	// 828AA0B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AA0B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AA0BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA0C0: 4B982E11  bl 0x8222ced0
	ctx.lr = 0x828AA0C4;
	sub_8222CED0(ctx, base);
	// 828AA0C4: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828AA0C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828AA0CC: 38C79568  addi r6, r7, -0x6a98
	ctx.r[6].s64 = ctx.r[7].s64 + -27288;
	// 828AA0D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AA0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA0D8: 48003001  bl 0x828ad0d8
	ctx.lr = 0x828AA0DC;
	sub_828AD0D8(ctx, base);
	// 828AA0DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA0E0: 4B96ACF9  bl 0x82214dd8
	ctx.lr = 0x828AA0E4;
	sub_82214DD8(ctx, base);
	// 828AA0E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0E8: 4B96ACF1  bl 0x82214dd8
	ctx.lr = 0x828AA0EC;
	sub_82214DD8(ctx, base);
	// 828AA0EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA0F0: 4B90DA29  bl 0x821b7b18
	ctx.lr = 0x828AA0F4;
	sub_821B7B18(ctx, base);
	// 828AA0F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AA0F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AA0FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AA100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AA104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AA108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA110 size=312
    let mut pc: u32 = 0x828AA110;
    'dispatch: loop {
        match pc {
            0x828AA110 => {
    //   block [0x828AA110..0x828AA248)
	// 828AA110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA114: 483FF2ED  bl 0x82ca9400
	ctx.lr = 0x828AA118;
	sub_82CA93D0(ctx, base);
	// 828AA118: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA11C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 828AA120: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828AA124: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 828AA128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AA12C: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA130: 40990010  ble cr6, 0x828aa140
	if !ctx.cr[6].gt {
	pc = 0x828AA140; continue 'dispatch;
	}
	// 828AA134: 4819D395  bl 0x82a474c8
	ctx.lr = 0x828AA138;
	sub_82A474C8(ctx, base);
	// 828AA138: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AA13C: 483FF314  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828AA140: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA148: 419A0010  beq cr6, 0x828aa158
	if ctx.cr[6].eq {
	pc = 0x828AA158; continue 'dispatch;
	}
	// 828AA14C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AA150: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA154: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA158: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828AA15C: 409800E4  bge cr6, 0x828aa240
	if !ctx.cr[6].lt {
	pc = 0x828AA240; continue 'dispatch;
	}
	// 828AA160: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828AA164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA168: 482067F1  bl 0x82ab0958
	ctx.lr = 0x828AA16C;
	sub_82AB0958(ctx, base);
	// 828AA16C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA170: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA178: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AA17C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AA180: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AA184: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828AA188: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AA18C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA190: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828AA194: 419A0054  beq cr6, 0x828aa1e8
	if ctx.cr[6].eq {
	pc = 0x828AA1E8; continue 'dispatch;
	}
	// 828AA198: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AA19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA1A0: 419A0038  beq cr6, 0x828aa1d8
	if ctx.cr[6].eq {
	pc = 0x828AA1D8; continue 'dispatch;
	}
	// 828AA1A4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA1A8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AA1AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA1B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AA1B4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AA1B8: 419A0020  beq cr6, 0x828aa1d8
	if ctx.cr[6].eq {
	pc = 0x828AA1D8; continue 'dispatch;
	}
	// 828AA1BC: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828AA1C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AA1C4: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828AA1C8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828AA1CC: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AA1D0: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AA1D4: 4082FFE8  bne 0x828aa1bc
	if !ctx.cr[0].eq {
	pc = 0x828AA1BC; continue 'dispatch;
	}
	// 828AA1D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AA1DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AA1E0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AA1E4: 409AFFB8  bne cr6, 0x828aa19c
	if !ctx.cr[6].eq {
	pc = 0x828AA19C; continue 'dispatch;
	}
	// 828AA1E8: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA1EC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA1F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AA1F4: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 828AA1F8: 7D7B1E70  srawi r27, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828AA1FC: 419A0028  beq cr6, 0x828aa224
	if ctx.cr[6].eq {
	pc = 0x828AA224; continue 'dispatch;
	}
	// 828AA200: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA204: 419A0018  beq cr6, 0x828aa21c
	if ctx.cr[6].eq {
	pc = 0x828AA21C; continue 'dispatch;
	}
	// 828AA208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AA20C: 4B90D90D  bl 0x821b7b18
	ctx.lr = 0x828AA210;
	sub_821B7B18(ctx, base);
	// 828AA210: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828AA214: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA218: 409AFFF0  bne cr6, 0x828aa208
	if !ctx.cr[6].eq {
	pc = 0x828AA208; continue 'dispatch;
	}
	// 828AA21C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA220: 4B971B19  bl 0x8221bd38
	ctx.lr = 0x828AA224;
	sub_8221BD38(ctx, base);
	// 828AA224: 574A1838  slwi r10, r26, 3
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AA228: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828AA22C: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AA230: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828AA234: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828AA238: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828AA23C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AA240: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AA244: 483FF20C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA248 size=248
    let mut pc: u32 = 0x828AA248;
    'dispatch: loop {
        match pc {
            0x828AA248 => {
    //   block [0x828AA248..0x828AA340)
	// 828AA248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AA250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AA254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AA258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA25C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AA260: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AA264: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AA268: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA270: 409A000C  bne cr6, 0x828aa27c
	if !ctx.cr[6].eq {
	pc = 0x828AA27C; continue 'dispatch;
	}
	// 828AA274: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA278: 48000010  b 0x828aa288
	pc = 0x828AA288; continue 'dispatch;
	// 828AA27C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA280: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA284: 7D241E70  srawi r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA288: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828AA28C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AA290: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828AA294: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828AA298: 419A000C  beq cr6, 0x828aa2a4
	if ctx.cr[6].eq {
	pc = 0x828AA2A4; continue 'dispatch;
	}
	// 828AA29C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AA2A0: 4BAC17A1  bl 0x8236ba40
	ctx.lr = 0x828AA2A4;
	sub_8236BA40(ctx, base);
	// 828AA2A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828AA2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA2AC: 419A0078  beq cr6, 0x828aa324
	if ctx.cr[6].eq {
	pc = 0x828AA324; continue 'dispatch;
	}
	// 828AA2B0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA2B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA2B8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AA2BC: 4099000C  ble cr6, 0x828aa2c8
	if !ctx.cr[6].gt {
	pc = 0x828AA2C8; continue 'dispatch;
	}
	// 828AA2C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA2C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA2C8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA2CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AA2D0: 419A0050  beq cr6, 0x828aa320
	if ctx.cr[6].eq {
	pc = 0x828AA320; continue 'dispatch;
	}
	// 828AA2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA2D8: 419A0038  beq cr6, 0x828aa310
	if ctx.cr[6].eq {
	pc = 0x828AA310; continue 'dispatch;
	}
	// 828AA2DC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA2E0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AA2E4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA2E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AA2EC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AA2F0: 419A0020  beq cr6, 0x828aa310
	if ctx.cr[6].eq {
	pc = 0x828AA310; continue 'dispatch;
	}
	// 828AA2F4: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828AA2F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AA2FC: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828AA300: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828AA304: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AA308: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AA30C: 4082FFE8  bne 0x828aa2f4
	if !ctx.cr[0].eq {
	pc = 0x828AA2F4; continue 'dispatch;
	}
	// 828AA310: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AA314: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AA318: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AA31C: 409AFFB8  bne cr6, 0x828aa2d4
	if !ctx.cr[6].eq {
	pc = 0x828AA2D4; continue 'dispatch;
	}
	// 828AA320: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AA324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AA328: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AA32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AA330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AA334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AA338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AA33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA340 size=184
    let mut pc: u32 = 0x828AA340;
    'dispatch: loop {
        match pc {
            0x828AA340 => {
    //   block [0x828AA340..0x828AA3F8)
	// 828AA340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AA348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA34C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA350: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828AA354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA358: 409A000C  bne cr6, 0x828aa364
	if !ctx.cr[6].eq {
	pc = 0x828AA364; continue 'dispatch;
	}
	// 828AA35C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AA360: 48000010  b 0x828aa370
	pc = 0x828AA370; continue 'dispatch;
	// 828AA364: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA368: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA36C: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA374: 419A004C  beq cr6, 0x828aa3c0
	if ctx.cr[6].eq {
	pc = 0x828AA3C0; continue 'dispatch;
	}
	// 828AA378: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AA37C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA380: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828AA384: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA388: 40980038  bge cr6, 0x828aa3c0
	if !ctx.cr[6].lt {
	pc = 0x828AA3C0; continue 'dispatch;
	}
	// 828AA38C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA394: 419A0014  beq cr6, 0x828aa3a8
	if ctx.cr[6].eq {
	pc = 0x828AA3A8; continue 'dispatch;
	}
	// 828AA398: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA39C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AA3A0: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA3A4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AA3A8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AA3AC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828AA3B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AA3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AA3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AA3BC: 4E800020  blr
	return;
	// 828AA3C0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA3C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA3C8: 40990008  ble cr6, 0x828aa3d0
	if !ctx.cr[6].gt {
	pc = 0x828AA3D0; continue 'dispatch;
	}
	// 828AA3CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA3D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828AA3D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA3D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA3DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AA3E0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA3E4: 4800015D  bl 0x828aa540
	ctx.lr = 0x828AA3E8;
	sub_828AA540(ctx, base);
	// 828AA3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AA3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AA3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AA3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA3F8 size=220
    let mut pc: u32 = 0x828AA3F8;
    'dispatch: loop {
        match pc {
            0x828AA3F8 => {
    //   block [0x828AA3F8..0x828AA4D4)
	// 828AA3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA3FC: 483FF011  bl 0x82ca940c
	ctx.lr = 0x828AA400;
	sub_82CA93D0(ctx, base);
	// 828AA400: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA404: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AA408: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AA40C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AA410: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 828AA414: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA41C: 419A0014  beq cr6, 0x828aa430
	if ctx.cr[6].eq {
	pc = 0x828AA430; continue 'dispatch;
	}
	// 828AA420: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA424: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA428: 7D292E71  srawi. r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828AA42C: 4082000C  bne 0x828aa438
	if !ctx.cr[0].eq {
	pc = 0x828AA438; continue 'dispatch;
	}
	// 828AA430: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828AA434: 48000034  b 0x828aa468
	pc = 0x828AA468; continue 'dispatch;
	// 828AA438: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA43C: 40990008  ble cr6, 0x828aa444
	if !ctx.cr[6].gt {
	pc = 0x828AA444; continue 'dispatch;
	}
	// 828AA440: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA444: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828AA448: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA44C: 419A000C  beq cr6, 0x828aa458
	if ctx.cr[6].eq {
	pc = 0x828AA458; continue 'dispatch;
	}
	// 828AA450: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AA454: 419A0008  beq cr6, 0x828aa45c
	if ctx.cr[6].eq {
	pc = 0x828AA45C; continue 'dispatch;
	}
	// 828AA458: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA45C: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828AA460: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA464: 7D3E2E70  srawi r30, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 828AA468: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AA46C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA470: 48000209  bl 0x828aa678
	ctx.lr = 0x828AA474;
	sub_828AA678(ctx, base);
	// 828AA474: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA478: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA47C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA480: 40990008  ble cr6, 0x828aa488
	if !ctx.cr[6].gt {
	pc = 0x828AA488; continue 'dispatch;
	}
	// 828AA484: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA488: 57CA2834  slwi r10, r30, 5
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AA48C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA490: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828AA494: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828AA498: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AA49C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA4A0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AA4A4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828AA4A8: 41990010  bgt cr6, 0x828aa4b8
	if ctx.cr[6].gt {
	pc = 0x828AA4B8; continue 'dispatch;
	}
	// 828AA4AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA4B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AA4B4: 40980008  bge cr6, 0x828aa4bc
	if !ctx.cr[6].lt {
	pc = 0x828AA4BC; continue 'dispatch;
	}
	// 828AA4B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA4BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AA4C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AA4C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA4C8: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828AA4CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AA4D0: 483FEF8C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA4D8 size=100
    let mut pc: u32 = 0x828AA4D8;
    'dispatch: loop {
        match pc {
            0x828AA4D8 => {
    //   block [0x828AA4D8..0x828AA53C)
	// 828AA4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA4DC: 483FEF29  bl 0x82ca9404
	ctx.lr = 0x828AA4E0;
	sub_82CA93D0(ctx, base);
	// 828AA4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA4E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828AA4E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828AA4EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828AA4F0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828AA4F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AA4F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AA4FC: 419A0030  beq cr6, 0x828aa52c
	if ctx.cr[6].eq {
	pc = 0x828AA52C; continue 'dispatch;
	}
	// 828AA500: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AA504: 419A001C  beq cr6, 0x828aa520
	if ctx.cr[6].eq {
	pc = 0x828AA520; continue 'dispatch;
	}
	// 828AA508: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AA50C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA510: 4BFFFD39  bl 0x828aa248
	ctx.lr = 0x828AA514;
	sub_828AA248(ctx, base);
	// 828AA514: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 828AA518: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828AA51C: 4BFFFD2D  bl 0x828aa248
	ctx.lr = 0x828AA520;
	sub_828AA248(ctx, base);
	// 828AA520: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828AA524: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 828AA528: 4082FFD8  bne 0x828aa500
	if !ctx.cr[0].eq {
	pc = 0x828AA500; continue 'dispatch;
	}
	// 828AA52C: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AA530: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828AA534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AA538: 483FEF1C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA540 size=220
    let mut pc: u32 = 0x828AA540;
    'dispatch: loop {
        match pc {
            0x828AA540 => {
    //   block [0x828AA540..0x828AA61C)
	// 828AA540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA544: 483FEEC9  bl 0x82ca940c
	ctx.lr = 0x828AA548;
	sub_82CA93D0(ctx, base);
	// 828AA548: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA54C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AA550: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AA554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AA558: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 828AA55C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA564: 419A0014  beq cr6, 0x828aa578
	if ctx.cr[6].eq {
	pc = 0x828AA578; continue 'dispatch;
	}
	// 828AA568: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA56C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA570: 7D291E71  srawi. r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828AA574: 4082000C  bne 0x828aa580
	if !ctx.cr[0].eq {
	pc = 0x828AA580; continue 'dispatch;
	}
	// 828AA578: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828AA57C: 48000034  b 0x828aa5b0
	pc = 0x828AA5B0; continue 'dispatch;
	// 828AA580: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA584: 40990008  ble cr6, 0x828aa58c
	if !ctx.cr[6].gt {
	pc = 0x828AA58C; continue 'dispatch;
	}
	// 828AA588: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA58C: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828AA590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA594: 419A000C  beq cr6, 0x828aa5a0
	if ctx.cr[6].eq {
	pc = 0x828AA5A0; continue 'dispatch;
	}
	// 828AA598: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AA59C: 419A0008  beq cr6, 0x828aa5a4
	if ctx.cr[6].eq {
	pc = 0x828AA5A4; continue 'dispatch;
	}
	// 828AA5A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA5A4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828AA5A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AA5AC: 7D3E1E70  srawi r30, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA5B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AA5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA5B8: 48000399  bl 0x828aa950
	ctx.lr = 0x828AA5BC;
	sub_828AA950(ctx, base);
	// 828AA5BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA5C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA5C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AA5C8: 40990008  ble cr6, 0x828aa5d0
	if !ctx.cr[6].gt {
	pc = 0x828AA5D0; continue 'dispatch;
	}
	// 828AA5CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA5D0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AA5D4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA5D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828AA5DC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828AA5E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AA5E4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA5E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AA5EC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828AA5F0: 41990010  bgt cr6, 0x828aa600
	if ctx.cr[6].gt {
	pc = 0x828AA600; continue 'dispatch;
	}
	// 828AA5F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA5F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AA5FC: 40980008  bge cr6, 0x828aa604
	if !ctx.cr[6].lt {
	pc = 0x828AA604; continue 'dispatch;
	}
	// 828AA600: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AA604: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AA608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AA60C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AA610: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828AA614: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AA618: 483FEE44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA620 size=88
    let mut pc: u32 = 0x828AA620;
    'dispatch: loop {
        match pc {
            0x828AA620 => {
    //   block [0x828AA620..0x828AA678)
	// 828AA620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AA628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AA62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AA630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA634: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828AA638: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AA63C: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AA640: 419A0020  beq cr6, 0x828aa660
	if ctx.cr[6].eq {
	pc = 0x828AA660; continue 'dispatch;
	}
	// 828AA644: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828AA648: 4BB321E1  bl 0x823dc828
	ctx.lr = 0x828AA64C;
	sub_823DC828(ctx, base);
	// 828AA64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA650: 4BB321D9  bl 0x823dc828
	ctx.lr = 0x828AA654;
	sub_823DC828(ctx, base);
	// 828AA654: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 828AA658: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AA65C: 409AFFE8  bne cr6, 0x828aa644
	if !ctx.cr[6].eq {
	pc = 0x828AA644; continue 'dispatch;
	}
	// 828AA660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AA664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AA668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AA66C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AA670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AA674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA678 size=724
    let mut pc: u32 = 0x828AA678;
    'dispatch: loop {
        match pc {
            0x828AA678 => {
    //   block [0x828AA678..0x828AA94C)
	// 828AA678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA67C: 483FED8D  bl 0x82ca9408
	ctx.lr = 0x828AA680;
	sub_82CA93D0(ctx, base);
	// 828AA680: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA684: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828AA688: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 828AA68C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AA690: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AA694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA698: 4BFFFBB1  bl 0x828aa248
	ctx.lr = 0x828AA69C;
	sub_828AA248(ctx, base);
	// 828AA69C: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828AA6A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA6A4: 4BFFFBA5  bl 0x828aa248
	ctx.lr = 0x828AA6A8;
	sub_828AA248(ctx, base);
	// 828AA6A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA6AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA6B0: 409A000C  bne cr6, 0x828aa6bc
	if !ctx.cr[6].eq {
	pc = 0x828AA6BC; continue 'dispatch;
	}
	// 828AA6B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AA6B8: 48000010  b 0x828aa6c8
	pc = 0x828AA6C8; continue 'dispatch;
	// 828AA6BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AA6C0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA6C4: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 828AA6C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA6CC: 409A000C  bne cr6, 0x828aa6d8
	if !ctx.cr[6].eq {
	pc = 0x828AA6D8; continue 'dispatch;
	}
	// 828AA6D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA6D4: 48000010  b 0x828aa6e4
	pc = 0x828AA6E4; continue 'dispatch;
	// 828AA6D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA6DC: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA6E0: 7D0B2E70  srawi r11, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 828AA6E4: 3D0007FF  lis r8, 0x7ff
	ctx.r[8].s64 = 134152192;
	// 828AA6E8: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 828AA6EC: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828AA6F0: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828AA6F4: 4098000C  bge cr6, 0x828aa700
	if !ctx.cr[6].lt {
	pc = 0x828AA700; continue 'dispatch;
	}
	// 828AA6F8: 4BC4A3D9  bl 0x824f4ad0
	ctx.lr = 0x828AA6FC;
	sub_824F4AD0(ctx, base);
	// 828AA6FC: 48000238  b 0x828aa934
	pc = 0x828AA934; continue 'dispatch;
	// 828AA700: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA704: 409A000C  bne cr6, 0x828aa710
	if !ctx.cr[6].eq {
	pc = 0x828AA710; continue 'dispatch;
	}
	// 828AA708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA70C: 48000010  b 0x828aa71c
	pc = 0x828AA71C; continue 'dispatch;
	// 828AA710: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA714: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA718: 7CEB2E70  srawi r11, r7, 5
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 5) as i64;
	// 828AA71C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AA720: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AA724: 40980114  bge cr6, 0x828aa838
	if !ctx.cr[6].lt {
	pc = 0x828AA838; continue 'dispatch;
	}
	// 828AA728: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AA72C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AA730: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828AA734: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AA738: 41980008  blt cr6, 0x828aa740
	if ctx.cr[6].lt {
	pc = 0x828AA740; continue 'dispatch;
	}
	// 828AA73C: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828AA740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA744: 409A000C  bne cr6, 0x828aa750
	if !ctx.cr[6].eq {
	pc = 0x828AA750; continue 'dispatch;
	}
	// 828AA748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA74C: 48000010  b 0x828aa75c
	pc = 0x828AA75C; continue 'dispatch;
	// 828AA750: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA754: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA758: 7D2B2E70  srawi r11, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 828AA75C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AA760: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AA764: 40980024  bge cr6, 0x828aa788
	if !ctx.cr[6].lt {
	pc = 0x828AA788; continue 'dispatch;
	}
	// 828AA768: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA76C: 409A000C  bne cr6, 0x828aa778
	if !ctx.cr[6].eq {
	pc = 0x828AA778; continue 'dispatch;
	}
	// 828AA770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA774: 48000010  b 0x828aa784
	pc = 0x828AA784; continue 'dispatch;
	// 828AA778: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA77C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA780: 7D4B2E70  srawi r11, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 828AA784: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 828AA788: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AA78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA790: 48166E41  bl 0x82a115d0
	ctx.lr = 0x828AA794;
	sub_82A115D0(ctx, base);
	// 828AA794: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828AA798: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AA79C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA7A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828AA7A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828AA7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA7AC: 48002B35  bl 0x828ad2e0
	ctx.lr = 0x828AA7B0;
	sub_828AD2E0(ctx, base);
	// 828AA7B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA7B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AA7B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AA7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA7C0: 4BFFFD19  bl 0x828aa4d8
	ctx.lr = 0x828AA7C4;
	sub_828AA4D8(ctx, base);
	// 828AA7C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AA7C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AA7CC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA7D4: 48002B0D  bl 0x828ad2e0
	ctx.lr = 0x828AA7D8;
	sub_828AD2E0(ctx, base);
	// 828AA7D8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA7DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AA7E0: 409A000C  bne cr6, 0x828aa7ec
	if !ctx.cr[6].eq {
	pc = 0x828AA7EC; continue 'dispatch;
	}
	// 828AA7E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA7E8: 48000010  b 0x828aa7f8
	pc = 0x828AA7F8; continue 'dispatch;
	// 828AA7EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA7F0: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 828AA7F4: 7D4B2E70  srawi r11, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 828AA7F8: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 828AA7FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AA800: 419A0018  beq cr6, 0x828aa818
	if ctx.cr[6].eq {
	pc = 0x828AA818; continue 'dispatch;
	}
	// 828AA804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA808: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA80C: 4BFFFE15  bl 0x828aa620
	ctx.lr = 0x828AA810;
	sub_828AA620(ctx, base);
	// 828AA810: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA814: 4B971525  bl 0x8221bd38
	ctx.lr = 0x828AA818;
	sub_8221BD38(ctx, base);
	// 828AA818: 578B2834  slwi r11, r28, 5
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AA81C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AA820: 57AA2834  slwi r10, r29, 5
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AA824: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828AA828: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828AA82C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828AA830: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AA834: 48000100  b 0x828aa934
	pc = 0x828AA934; continue 'dispatch;
	// 828AA838: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828AA83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA840: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA844: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 828AA848: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 828AA84C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828AA850: 4098006C  bge cr6, 0x828aa8bc
	if !ctx.cr[6].lt {
	pc = 0x828AA8BC; continue 'dispatch;
	}
	// 828AA854: 38DE0020  addi r6, r30, 0x20
	ctx.r[6].s64 = ctx.r[30].s64 + 32;
	// 828AA858: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AA85C: 48002A85  bl 0x828ad2e0
	ctx.lr = 0x828AA860;
	sub_828AD2E0(ctx, base);
	// 828AA860: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA864: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AA868: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 828AA86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA870: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 828AA874: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 828AA878: 4BFFFC61  bl 0x828aa4d8
	ctx.lr = 0x828AA87C;
	sub_828AA4D8(ctx, base);
	// 828AA87C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA880: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 828AA884: 3BABFFE0  addi r29, r11, -0x20
	ctx.r[29].s64 = ctx.r[11].s64 + -32;
	// 828AA888: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828AA88C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA890: 419A00A4  beq cr6, 0x828aa934
	if ctx.cr[6].eq {
	pc = 0x828AA934; continue 'dispatch;
	}
	// 828AA894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AA89C: 48003B9D  bl 0x828ae438
	ctx.lr = 0x828AA8A0;
	sub_828AE438(ctx, base);
	// 828AA8A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AA8A4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828AA8A8: 48003B91  bl 0x828ae438
	ctx.lr = 0x828AA8AC;
	sub_828AE438(ctx, base);
	// 828AA8AC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 828AA8B0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA8B4: 409AFFE0  bne cr6, 0x828aa894
	if !ctx.cr[6].eq {
	pc = 0x828AA894; continue 'dispatch;
	}
	// 828AA8B8: 4800007C  b 0x828aa934
	pc = 0x828AA934; continue 'dispatch;
	// 828AA8BC: 3BA5FFE0  addi r29, r5, -0x20
	ctx.r[29].s64 = ctx.r[5].s64 + -32;
	// 828AA8C0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 828AA8C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AA8C8: 48002A19  bl 0x828ad2e0
	ctx.lr = 0x828AA8CC;
	sub_828AD2E0(ctx, base);
	// 828AA8CC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828AA8D0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828AA8D4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA8D8: 419A0028  beq cr6, 0x828aa900
	if ctx.cr[6].eq {
	pc = 0x828AA900; continue 'dispatch;
	}
	// 828AA8DC: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 828AA8E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AA8E4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828AA8E8: 48003B51  bl 0x828ae438
	ctx.lr = 0x828AA8EC;
	sub_828AE438(ctx, base);
	// 828AA8EC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828AA8F0: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 828AA8F4: 48003B45  bl 0x828ae438
	ctx.lr = 0x828AA8F8;
	sub_828AE438(ctx, base);
	// 828AA8F8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AA8FC: 409AFFE0  bne cr6, 0x828aa8dc
	if !ctx.cr[6].eq {
	pc = 0x828AA8DC; continue 'dispatch;
	}
	// 828AA900: 3BBE0020  addi r29, r30, 0x20
	ctx.r[29].s64 = ctx.r[30].s64 + 32;
	// 828AA904: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828AA908: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA90C: 419A0028  beq cr6, 0x828aa934
	if ctx.cr[6].eq {
	pc = 0x828AA934; continue 'dispatch;
	}
	// 828AA910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA918: 48003B21  bl 0x828ae438
	ctx.lr = 0x828AA91C;
	sub_828AE438(ctx, base);
	// 828AA91C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AA920: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828AA924: 48003B15  bl 0x828ae438
	ctx.lr = 0x828AA928;
	sub_828AE438(ctx, base);
	// 828AA928: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 828AA92C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AA930: 409AFFE0  bne cr6, 0x828aa910
	if !ctx.cr[6].eq {
	pc = 0x828AA910; continue 'dispatch;
	}
	// 828AA934: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA938: 4BB31EF1  bl 0x823dc828
	ctx.lr = 0x828AA93C;
	sub_823DC828(ctx, base);
	// 828AA93C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA940: 4BB31EE9  bl 0x823dc828
	ctx.lr = 0x828AA944;
	sub_823DC828(ctx, base);
	// 828AA944: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828AA948: 483FEB10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AA950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AA950 size=868
    let mut pc: u32 = 0x828AA950;
    'dispatch: loop {
        match pc {
            0x828AA950 => {
    //   block [0x828AA950..0x828AACB4)
	// 828AA950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AA954: 483FEAB1  bl 0x82ca9404
	ctx.lr = 0x828AA958;
	sub_82CA93D0(ctx, base);
	// 828AA958: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AA95C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AA960: EB660000  ld r27, 0(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 828AA964: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 828AA968: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828AA96C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AA970: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA974: 409A000C  bne cr6, 0x828aa980
	if !ctx.cr[6].eq {
	pc = 0x828AA980; continue 'dispatch;
	}
	// 828AA978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AA97C: 48000010  b 0x828aa98c
	pc = 0x828AA98C; continue 'dispatch;
	// 828AA980: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AA984: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA988: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA98C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AA990: 419A031C  beq cr6, 0x828aacac
	if ctx.cr[6].eq {
	pc = 0x828AACAC; continue 'dispatch;
	}
	// 828AA994: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA998: 409A000C  bne cr6, 0x828aa9a4
	if !ctx.cr[6].eq {
	pc = 0x828AA9A4; continue 'dispatch;
	}
	// 828AA99C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA9A0: 48000010  b 0x828aa9b0
	pc = 0x828AA9B0; continue 'dispatch;
	// 828AA9A4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA9A8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA9AC: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AA9B0: 3D201FFF  lis r9, 0x1fff
	ctx.r[9].s64 = 536805376;
	// 828AA9B4: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 828AA9B8: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828AA9BC: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AA9C0: 40980010  bge cr6, 0x828aa9d0
	if !ctx.cr[6].lt {
	pc = 0x828AA9D0; continue 'dispatch;
	}
	// 828AA9C4: 4BC4A10D  bl 0x824f4ad0
	ctx.lr = 0x828AA9C8;
	sub_824F4AD0(ctx, base);
	// 828AA9C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AA9CC: 483FEA88  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AA9D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AA9D4: 409A000C  bne cr6, 0x828aa9e0
	if !ctx.cr[6].eq {
	pc = 0x828AA9E0; continue 'dispatch;
	}
	// 828AA9D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AA9DC: 48000010  b 0x828aa9ec
	pc = 0x828AA9EC; continue 'dispatch;
	// 828AA9E0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA9E4: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AA9E8: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828AA9EC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828AA9F0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AA9F4: 40980174  bge cr6, 0x828aab68
	if !ctx.cr[6].lt {
	pc = 0x828AAB68; continue 'dispatch;
	}
	// 828AA9F8: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AA9FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AAA00: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828AAA04: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAA08: 41980008  blt cr6, 0x828aaa10
	if ctx.cr[6].lt {
	pc = 0x828AAA10; continue 'dispatch;
	}
	// 828AAA0C: 7F8B4214  add r28, r11, r8
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828AAA10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AAA14: 409A000C  bne cr6, 0x828aaa20
	if !ctx.cr[6].eq {
	pc = 0x828AAA20; continue 'dispatch;
	}
	// 828AAA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AAA1C: 48000010  b 0x828aaa2c
	pc = 0x828AAA2C; continue 'dispatch;
	// 828AAA20: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAA24: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AAA28: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AAA2C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828AAA30: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AAA34: 40980024  bge cr6, 0x828aaa58
	if !ctx.cr[6].lt {
	pc = 0x828AAA58; continue 'dispatch;
	}
	// 828AAA38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AAA3C: 409A000C  bne cr6, 0x828aaa48
	if !ctx.cr[6].eq {
	pc = 0x828AAA48; continue 'dispatch;
	}
	// 828AAA40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AAA44: 48000010  b 0x828aaa54
	pc = 0x828AAA54; continue 'dispatch;
	// 828AAA48: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAA4C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828AAA50: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828AAA54: 7F8BFA14  add r28, r11, r31
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828AAA58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828AAA5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA60: 4BB4F579  bl 0x823f9fd8
	ctx.lr = 0x828AAA64;
	sub_823F9FD8(ctx, base);
	// 828AAA64: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAA68: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828AAA6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AAA70: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828AAA74: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828AAA78: 419A002C  beq cr6, 0x828aaaa4
	if ctx.cr[6].eq {
	pc = 0x828AAAA4; continue 'dispatch;
	}
	// 828AAA7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AAA80: 419A0014  beq cr6, 0x828aaa94
	if ctx.cr[6].eq {
	pc = 0x828AAA94; continue 'dispatch;
	}
	// 828AAA84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAA88: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AAA8C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAA90: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828AAA94: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AAA98: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AAA9C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828AAAA0: 409AFFDC  bne cr6, 0x828aaa7c
	if !ctx.cr[6].eq {
	pc = 0x828AAA7C; continue 'dispatch;
	}
	// 828AAAA4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828AAAA8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828AAAAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AAAB0: 419A001C  beq cr6, 0x828aaacc
	if ctx.cr[6].eq {
	pc = 0x828AAACC; continue 'dispatch;
	}
	// 828AAAB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAAB8: 419A0008  beq cr6, 0x828aaac0
	if ctx.cr[6].eq {
	pc = 0x828AAAC0; continue 'dispatch;
	}
	// 828AAABC: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828AAAC0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828AAAC4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AAAC8: 4082FFEC  bne 0x828aaab4
	if !ctx.cr[0].eq {
	pc = 0x828AAAB4; continue 'dispatch;
	}
	// 828AAACC: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAAD0: 57E91838  slwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828AAAD4: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828AAAD8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAADC: 419A0038  beq cr6, 0x828aab14
	if ctx.cr[6].eq {
	pc = 0x828AAB14; continue 'dispatch;
	}
	// 828AAAE0: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AAAE4: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828AAAE8: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 828AAAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAAF0: 419A0014  beq cr6, 0x828aab04
	if ctx.cr[6].eq {
	pc = 0x828AAB04; continue 'dispatch;
	}
	// 828AAAF4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAAF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AAAFC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAB00: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828AAB04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AAB08: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AAB0C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAB10: 409AFFDC  bne cr6, 0x828aaaec
	if !ctx.cr[6].eq {
	pc = 0x828AAAEC; continue 'dispatch;
	}
	// 828AAB14: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAB18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAB1C: 409A000C  bne cr6, 0x828aab28
	if !ctx.cr[6].eq {
	pc = 0x828AAB28; continue 'dispatch;
	}
	// 828AAB20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AAB24: 48000010  b 0x828aab34
	pc = 0x828AAB34; continue 'dispatch;
	// 828AAB28: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAB2C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828AAB30: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828AAB34: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828AAB38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAB3C: 419A0008  beq cr6, 0x828aab44
	if ctx.cr[6].eq {
	pc = 0x828AAB44; continue 'dispatch;
	}
	// 828AAB40: 4B9711F9  bl 0x8221bd38
	ctx.lr = 0x828AAB44;
	sub_8221BD38(ctx, base);
	// 828AAB44: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AAB48: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AAB4C: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AAB50: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828AAB54: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828AAB58: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828AAB5C: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AAB60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AAB64: 483FE8F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AAB68: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828AAB6C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAB70: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828AAB74: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828AAB78: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AAB7C: 409800A0  bge cr6, 0x828aac1c
	if !ctx.cr[6].lt {
	pc = 0x828AAC1C; continue 'dispatch;
	}
	// 828AAB80: 57E91838  slwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828AAB84: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAB88: 7D693A14  add r11, r9, r7
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 828AAB8C: 419A0030  beq cr6, 0x828aabbc
	if ctx.cr[6].eq {
	pc = 0x828AABBC; continue 'dispatch;
	}
	// 828AAB90: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AAB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAB98: 419A0014  beq cr6, 0x828aabac
	if ctx.cr[6].eq {
	pc = 0x828AABAC; continue 'dispatch;
	}
	// 828AAB9C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AABA0: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828AABA4: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AABA8: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828AABAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AABB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AABB4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AABB8: 409AFFDC  bne cr6, 0x828aab94
	if !ctx.cr[6].eq {
	pc = 0x828AAB94; continue 'dispatch;
	}
	// 828AABBC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AABC0: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 828AABC4: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828AABC8: 7D48F851  subf. r10, r8, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828AABCC: 4182001C  beq 0x828aabe8
	if ctx.cr[0].eq {
	pc = 0x828AABE8; continue 'dispatch;
	}
	// 828AABD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AABD4: 419A0008  beq cr6, 0x828aabdc
	if ctx.cr[6].eq {
	pc = 0x828AABDC; continue 'dispatch;
	}
	// 828AABD8: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828AABDC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828AABE0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AABE4: 4082FFEC  bne 0x828aabd0
	if !ctx.cr[0].eq {
	pc = 0x828AABD0; continue 'dispatch;
	}
	// 828AABE8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AABEC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828AABF0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828AABF4: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828AABF8: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AABFC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AAC00: 419A00AC  beq cr6, 0x828aacac
	if ctx.cr[6].eq {
	pc = 0x828AACAC; continue 'dispatch;
	}
	// 828AAC04: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828AAC08: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AAC0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AAC10: 409AFFF4  bne cr6, 0x828aac04
	if !ctx.cr[6].eq {
	pc = 0x828AAC04; continue 'dispatch;
	}
	// 828AAC14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AAC18: 483FE83C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AAC1C: 57E61838  slwi r6, r31, 3
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828AAC20: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828AAC24: 7D664050  subf r11, r6, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 828AAC28: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828AAC2C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAC30: 419A002C  beq cr6, 0x828aac5c
	if ctx.cr[6].eq {
	pc = 0x828AAC5C; continue 'dispatch;
	}
	// 828AAC34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AAC38: 419A0014  beq cr6, 0x828aac4c
	if ctx.cr[6].eq {
	pc = 0x828AAC4C; continue 'dispatch;
	}
	// 828AAC3C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAC40: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 828AAC44: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAC48: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828AAC4C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828AAC50: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AAC54: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AAC58: 409AFFDC  bne cr6, 0x828aac34
	if !ctx.cr[6].eq {
	pc = 0x828AAC34; continue 'dispatch;
	}
	// 828AAC5C: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AAC60: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AAC64: 419A0028  beq cr6, 0x828aac8c
	if ctx.cr[6].eq {
	pc = 0x828AAC8C; continue 'dispatch;
	}
	// 828AAC68: 7D465A14  add r10, r6, r11
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828AAC6C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 828AAC70: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 828AAC74: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828AAC78: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAC7C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AAC80: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAC84: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828AAC88: 409AFFE4  bne cr6, 0x828aac6c
	if !ctx.cr[6].eq {
	pc = 0x828AAC6C; continue 'dispatch;
	}
	// 828AAC8C: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 828AAC90: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828AAC94: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AAC98: 419A0014  beq cr6, 0x828aacac
	if ctx.cr[6].eq {
	pc = 0x828AACAC; continue 'dispatch;
	}
	// 828AAC9C: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828AACA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AACA4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AACA8: 409AFFF4  bne cr6, 0x828aac9c
	if !ctx.cr[6].eq {
	pc = 0x828AAC9C; continue 'dispatch;
	}
	// 828AACAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AACB0: 483FE7A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AACB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AACB8 size=584
    let mut pc: u32 = 0x828AACB8;
    'dispatch: loop {
        match pc {
            0x828AACB8 => {
    //   block [0x828AACB8..0x828AAF00)
	// 828AACB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AACBC: 483FE745  bl 0x82ca9400
	ctx.lr = 0x828AACC0;
	sub_82CA93D0(ctx, base);
	// 828AACC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AACC4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AACC8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AACCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AACD0: 409A0010  bne cr6, 0x828aace0
	if !ctx.cr[6].eq {
	pc = 0x828AACE0; continue 'dispatch;
	}
	// 828AACD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AACD8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828AACDC: 48000008  b 0x828aace4
	pc = 0x828AACE4; continue 'dispatch;
	// 828AACE0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AACE4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AACE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AACEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AACF0: 4BB238D1  bl 0x823ce5c0
	ctx.lr = 0x828AACF4;
	sub_823CE5C0(ctx, base);
	// 828AACF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AACF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AACFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AAD00: 4BB23501  bl 0x823ce200
	ctx.lr = 0x828AAD04;
	sub_823CE200(ctx, base);
	// 828AAD04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAD08: 4B90CE11  bl 0x821b7b18
	ctx.lr = 0x828AAD0C;
	sub_821B7B18(ctx, base);
	// 828AAD0C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828AAD10: 4B974549  bl 0x8221f258
	ctx.lr = 0x828AAD14;
	sub_8221F258(ctx, base);
	// 828AAD14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AAD18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AAD1C: 419A0040  beq cr6, 0x828aad5c
	if ctx.cr[6].eq {
	pc = 0x828AAD5C; continue 'dispatch;
	}
	// 828AAD20: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828AAD24: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AAD28: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828AAD2C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AAD30: 4B974529  bl 0x8221f258
	ctx.lr = 0x828AAD34;
	sub_8221F258(ctx, base);
	// 828AAD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAD38: 419A0028  beq cr6, 0x828aad60
	if ctx.cr[6].eq {
	pc = 0x828AAD60; continue 'dispatch;
	}
	// 828AAD3C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AAD40: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AAD44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AAD48: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AAD4C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AAD50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AAD54: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AAD58: 4800000C  b 0x828aad64
	pc = 0x828AAD64; continue 'dispatch;
	// 828AAD5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AAD60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AAD64: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AAD68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AAD6C: 419A00FC  beq cr6, 0x828aae68
	if ctx.cr[6].eq {
	pc = 0x828AAE68; continue 'dispatch;
	}
	// 828AAD70: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAD74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AAD78: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAD7C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AAD80: 4B97E389  bl 0x82229108
	ctx.lr = 0x828AAD84;
	sub_82229108(ctx, base);
	// 828AAD84: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AAD88: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AAD8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AAD90: 3BCBD3B0  addi r30, r11, -0x2c50
	ctx.r[30].s64 = ctx.r[11].s64 + -11344;
	// 828AAD94: 4B97CAED  bl 0x82227880
	ctx.lr = 0x828AAD98;
	sub_82227880(ctx, base);
	// 828AAD98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AAD9C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828AADA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AADA4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828AADA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AADAC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AADB0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AADB4: 4B8EFCCD  bl 0x8219aa80
	ctx.lr = 0x828AADB8;
	sub_8219AA80(ctx, base);
	// 828AADB8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828AADBC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828AADC0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828AADC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AADC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AADCC: 4BB23655  bl 0x823ce420
	ctx.lr = 0x828AADD0;
	sub_823CE420(ctx, base);
	// 828AADD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AADD4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AADD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AADDC: 481798ED  bl 0x82a246c8
	ctx.lr = 0x828AADE0;
	sub_82A246C8(ctx, base);
	// 828AADE0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AADE4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AADE8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828AADEC: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828AADF0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AADF4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AADF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AADFC: 4B97E30D  bl 0x82229108
	ctx.lr = 0x828AAE00;
	sub_82229108(ctx, base);
	// 828AAE00: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AAE04: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AAE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AAE0C: 3BEB6288  addi r31, r11, 0x6288
	ctx.r[31].s64 = ctx.r[11].s64 + 25224;
	// 828AAE10: 4B97CA71  bl 0x82227880
	ctx.lr = 0x828AAE14;
	sub_82227880(ctx, base);
	// 828AAE14: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828AAE18: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828AAE1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AAE20: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828AAE24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AAE28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AAE2C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828AAE30: 4B8EFC51  bl 0x8219aa80
	ctx.lr = 0x828AAE34;
	sub_8219AA80(ctx, base);
	// 828AAE34: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828AAE38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AAE3C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828AAE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AAE44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AAE48: 4BB235D9  bl 0x823ce420
	ctx.lr = 0x828AAE4C;
	sub_823CE420(ctx, base);
	// 828AAE4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AAE50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AAE54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AAE58: 48179871  bl 0x82a246c8
	ctx.lr = 0x828AAE5C;
	sub_82A246C8(ctx, base);
	// 828AAE5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAE60: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828AAE64: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828AAE68: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828AAE6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828AAE70: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828AAE74: 419A0020  beq cr6, 0x828aae94
	if ctx.cr[6].eq {
	pc = 0x828AAE94; continue 'dispatch;
	}
	// 828AAE78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AAE7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAE80: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AAE84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AAE88: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AAE8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAE90: 4082FFE8  bne 0x828aae78
	if !ctx.cr[0].eq {
	pc = 0x828AAE78; continue 'dispatch;
	}
	// 828AAE94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAE98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AAE9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AAEA0: 4BA4AAA9  bl 0x822f5948
	ctx.lr = 0x828AAEA4;
	sub_822F5948(ctx, base);
	// 828AAEA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AAEA8: 4B90CC71  bl 0x821b7b18
	ctx.lr = 0x828AAEAC;
	sub_821B7B18(ctx, base);
	// 828AAEAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828AAEB0: 419A0040  beq cr6, 0x828aaef0
	if ctx.cr[6].eq {
	pc = 0x828AAEF0; continue 'dispatch;
	}
	// 828AAEB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AAEB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAEBC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AAEC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AAEC4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AAEC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAECC: 4082FFE8  bne 0x828aaeb4
	if !ctx.cr[0].eq {
	pc = 0x828AAEB4; continue 'dispatch;
	}
	// 828AAED0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AAED4: 409A001C  bne cr6, 0x828aaef0
	if !ctx.cr[6].eq {
	pc = 0x828AAEF0; continue 'dispatch;
	}
	// 828AAED8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAEDC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAEE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AAEE4: 4E800421  bctrl
	ctx.lr = 0x828AAEE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AAEE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAEEC: 4B970E4D  bl 0x8221bd38
	ctx.lr = 0x828AAEF0;
	sub_8221BD38(ctx, base);
	// 828AAEF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AAEF4: 4B90CC25  bl 0x821b7b18
	ctx.lr = 0x828AAEF8;
	sub_821B7B18(ctx, base);
	// 828AAEF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828AAEFC: 483FE554  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AAF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AAF00 size=512
    let mut pc: u32 = 0x828AAF00;
    'dispatch: loop {
        match pc {
            0x828AAF00 => {
    //   block [0x828AAF00..0x828AB100)
	// 828AAF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AAF04: 483FE4F9  bl 0x82ca93fc
	ctx.lr = 0x828AAF08;
	sub_82CA93D0(ctx, base);
	// 828AAF08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AAF0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AAF10: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AAF14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AAF18: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828AAF1C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AAF20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAF24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828AAF28: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AAF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAF30: 419A0008  beq cr6, 0x828aaf38
	if ctx.cr[6].eq {
	pc = 0x828AAF38; continue 'dispatch;
	}
	// 828AAF34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAF38: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAF3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAF40: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAF44: 4BB2367D  bl 0x823ce5c0
	ctx.lr = 0x828AAF48;
	sub_823CE5C0(ctx, base);
	// 828AAF48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAF4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AAF50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AAF54: 4BB231BD  bl 0x823ce110
	ctx.lr = 0x828AAF58;
	sub_823CE110(ctx, base);
	// 828AAF58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAF5C: 4B90CBBD  bl 0x821b7b18
	ctx.lr = 0x828AAF60;
	sub_821B7B18(ctx, base);
	// 828AAF60: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AAF64: 4B9742F5  bl 0x8221f258
	ctx.lr = 0x828AAF68;
	sub_8221F258(ctx, base);
	// 828AAF68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AAF6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AAF70: 419A005C  beq cr6, 0x828aafcc
	if ctx.cr[6].eq {
	pc = 0x828AAFCC; continue 'dispatch;
	}
	// 828AAF74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AAF78: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AAF7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AAF80: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AAF84: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AAF88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AAF8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AAF90: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AAF94: 4B9452AD  bl 0x821f0240
	ctx.lr = 0x828AAF98;
	sub_821F0240(ctx, base);
	// 828AAF98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AAF9C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AAFA0: 4B9742B9  bl 0x8221f258
	ctx.lr = 0x828AAFA4;
	sub_8221F258(ctx, base);
	// 828AAFA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAFA8: 419A0028  beq cr6, 0x828aafd0
	if ctx.cr[6].eq {
	pc = 0x828AAFD0; continue 'dispatch;
	}
	// 828AAFAC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AAFB0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AAFB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AAFB8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AAFBC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AAFC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AAFC4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AAFC8: 4800000C  b 0x828aafd4
	pc = 0x828AAFD4; continue 'dispatch;
	// 828AAFCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AAFD0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AAFD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAFD8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AAFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAFE0: 419A0008  beq cr6, 0x828aafe8
	if ctx.cr[6].eq {
	pc = 0x828AAFE8; continue 'dispatch;
	}
	// 828AAFE4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAFE8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AAFEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAFF0: 419A0078  beq cr6, 0x828ab068
	if ctx.cr[6].eq {
	pc = 0x828AB068; continue 'dispatch;
	}
	// 828AAFF4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAFF8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AAFFC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB004: 4B97E105  bl 0x82229108
	ctx.lr = 0x828AB008;
	sub_82229108(ctx, base);
	// 828AB008: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AB00C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AB010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB014: 3BCBDEF0  addi r30, r11, -0x2110
	ctx.r[30].s64 = ctx.r[11].s64 + -8464;
	// 828AB018: 4B97C869  bl 0x82227880
	ctx.lr = 0x828AB01C;
	sub_82227880(ctx, base);
	// 828AB01C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AB020: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB024: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AB028: 388AEA28  addi r4, r10, -0x15d8
	ctx.r[4].s64 = ctx.r[10].s64 + -5592;
	// 828AB02C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB030: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AB034: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AB038: 4B8EFA49  bl 0x8219aa80
	ctx.lr = 0x828AB03C;
	sub_8219AA80(ctx, base);
	// 828AB03C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB040: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AB044: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB048: 4BB233D9  bl 0x823ce420
	ctx.lr = 0x828AB04C;
	sub_823CE420(ctx, base);
	// 828AB04C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB050: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AB054: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB058: 48179671  bl 0x82a246c8
	ctx.lr = 0x828AB05C;
	sub_82A246C8(ctx, base);
	// 828AB05C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB060: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AB064: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AB068: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AB06C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB070: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AB074: 419A0020  beq cr6, 0x828ab094
	if ctx.cr[6].eq {
	pc = 0x828AB094; continue 'dispatch;
	}
	// 828AB078: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB07C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB080: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB084: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AB088: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB08C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB090: 4082FFE8  bne 0x828ab078
	if !ctx.cr[0].eq {
	pc = 0x828AB078; continue 'dispatch;
	}
	// 828AB094: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB098: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AB09C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AB0A0: 4BA4A8A9  bl 0x822f5948
	ctx.lr = 0x828AB0A4;
	sub_822F5948(ctx, base);
	// 828AB0A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB0A8: 4B90CA71  bl 0x821b7b18
	ctx.lr = 0x828AB0AC;
	sub_821B7B18(ctx, base);
	// 828AB0AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB0B0: 419A0040  beq cr6, 0x828ab0f0
	if ctx.cr[6].eq {
	pc = 0x828AB0F0; continue 'dispatch;
	}
	// 828AB0B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB0B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB0BC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB0C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AB0C4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB0C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB0CC: 4082FFE8  bne 0x828ab0b4
	if !ctx.cr[0].eq {
	pc = 0x828AB0B4; continue 'dispatch;
	}
	// 828AB0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AB0D4: 409A001C  bne cr6, 0x828ab0f0
	if !ctx.cr[6].eq {
	pc = 0x828AB0F0; continue 'dispatch;
	}
	// 828AB0D8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB0DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB0E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB0E4: 4E800421  bctrl
	ctx.lr = 0x828AB0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB0E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB0EC: 4B970C4D  bl 0x8221bd38
	ctx.lr = 0x828AB0F0;
	sub_8221BD38(ctx, base);
	// 828AB0F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB0F4: 4B90CA25  bl 0x821b7b18
	ctx.lr = 0x828AB0F8;
	sub_821B7B18(ctx, base);
	// 828AB0F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AB0FC: 483FE350  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB100 size=516
    let mut pc: u32 = 0x828AB100;
    'dispatch: loop {
        match pc {
            0x828AB100 => {
    //   block [0x828AB100..0x828AB304)
	// 828AB100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB104: 483FE2F9  bl 0x82ca93fc
	ctx.lr = 0x828AB108;
	sub_82CA93D0(ctx, base);
	// 828AB108: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB10C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AB110: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB114: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828AB118: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AB11C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AB120: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB124: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AB128: 3BAA7988  addi r29, r10, 0x7988
	ctx.r[29].s64 = ctx.r[10].s64 + 31112;
	// 828AB12C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB130: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB134: 419A0008  beq cr6, 0x828ab13c
	if ctx.cr[6].eq {
	pc = 0x828AB13C; continue 'dispatch;
	}
	// 828AB138: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB13C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB144: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB148: 4BB23479  bl 0x823ce5c0
	ctx.lr = 0x828AB14C;
	sub_823CE5C0(ctx, base);
	// 828AB14C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB150: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB154: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB158: 4BB22FB9  bl 0x823ce110
	ctx.lr = 0x828AB15C;
	sub_823CE110(ctx, base);
	// 828AB15C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB160: 4B90C9B9  bl 0x821b7b18
	ctx.lr = 0x828AB164;
	sub_821B7B18(ctx, base);
	// 828AB164: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AB168: 4B9740F1  bl 0x8221f258
	ctx.lr = 0x828AB16C;
	sub_8221F258(ctx, base);
	// 828AB16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB170: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AB174: 419A005C  beq cr6, 0x828ab1d0
	if ctx.cr[6].eq {
	pc = 0x828AB1D0; continue 'dispatch;
	}
	// 828AB178: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AB17C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AB180: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AB184: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AB188: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AB18C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB190: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AB194: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AB198: 4B9450A9  bl 0x821f0240
	ctx.lr = 0x828AB19C;
	sub_821F0240(ctx, base);
	// 828AB19C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AB1A0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AB1A4: 4B9740B5  bl 0x8221f258
	ctx.lr = 0x828AB1A8;
	sub_8221F258(ctx, base);
	// 828AB1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB1AC: 419A0028  beq cr6, 0x828ab1d4
	if ctx.cr[6].eq {
	pc = 0x828AB1D4; continue 'dispatch;
	}
	// 828AB1B0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AB1B4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AB1B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB1BC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AB1C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AB1C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB1C8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AB1CC: 4800000C  b 0x828ab1d8
	pc = 0x828AB1D8; continue 'dispatch;
	// 828AB1D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AB1D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AB1D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB1DC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB1E4: 419A0008  beq cr6, 0x828ab1ec
	if ctx.cr[6].eq {
	pc = 0x828AB1EC; continue 'dispatch;
	}
	// 828AB1E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB1EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AB1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB1F4: 419A0078  beq cr6, 0x828ab26c
	if ctx.cr[6].eq {
	pc = 0x828AB26C; continue 'dispatch;
	}
	// 828AB1F8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB1FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AB200: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB204: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB208: 4B97DF01  bl 0x82229108
	ctx.lr = 0x828AB20C;
	sub_82229108(ctx, base);
	// 828AB20C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AB210: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AB214: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB218: 3BCBD728  addi r30, r11, -0x28d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10456;
	// 828AB21C: 4B97C665  bl 0x82227880
	ctx.lr = 0x828AB220;
	sub_82227880(ctx, base);
	// 828AB220: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AB224: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB228: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AB22C: 388AEAD0  addi r4, r10, -0x1530
	ctx.r[4].s64 = ctx.r[10].s64 + -5424;
	// 828AB230: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB234: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AB238: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AB23C: 4B8EF845  bl 0x8219aa80
	ctx.lr = 0x828AB240;
	sub_8219AA80(ctx, base);
	// 828AB240: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB244: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AB248: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB24C: 4BB231D5  bl 0x823ce420
	ctx.lr = 0x828AB250;
	sub_823CE420(ctx, base);
	// 828AB250: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB254: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AB258: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB25C: 4817946D  bl 0x82a246c8
	ctx.lr = 0x828AB260;
	sub_82A246C8(ctx, base);
	// 828AB260: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB264: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AB268: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AB26C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AB270: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB274: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AB278: 419A0020  beq cr6, 0x828ab298
	if ctx.cr[6].eq {
	pc = 0x828AB298; continue 'dispatch;
	}
	// 828AB27C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB280: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB284: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB288: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AB28C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB290: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB294: 4082FFE8  bne 0x828ab27c
	if !ctx.cr[0].eq {
	pc = 0x828AB27C; continue 'dispatch;
	}
	// 828AB298: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB29C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AB2A0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AB2A4: 4BA4A6A5  bl 0x822f5948
	ctx.lr = 0x828AB2A8;
	sub_822F5948(ctx, base);
	// 828AB2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB2AC: 4B90C86D  bl 0x821b7b18
	ctx.lr = 0x828AB2B0;
	sub_821B7B18(ctx, base);
	// 828AB2B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB2B4: 419A0040  beq cr6, 0x828ab2f4
	if ctx.cr[6].eq {
	pc = 0x828AB2F4; continue 'dispatch;
	}
	// 828AB2B8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB2BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB2C0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB2C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AB2C8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB2CC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB2D0: 4082FFE8  bne 0x828ab2b8
	if !ctx.cr[0].eq {
	pc = 0x828AB2B8; continue 'dispatch;
	}
	// 828AB2D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AB2D8: 409A001C  bne cr6, 0x828ab2f4
	if !ctx.cr[6].eq {
	pc = 0x828AB2F4; continue 'dispatch;
	}
	// 828AB2DC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB2E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB2E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB2E8: 4E800421  bctrl
	ctx.lr = 0x828AB2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB2EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB2F0: 4B970A49  bl 0x8221bd38
	ctx.lr = 0x828AB2F4;
	sub_8221BD38(ctx, base);
	// 828AB2F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB2F8: 4B90C821  bl 0x821b7b18
	ctx.lr = 0x828AB2FC;
	sub_821B7B18(ctx, base);
	// 828AB2FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AB300: 483FE14C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB308 size=516
    let mut pc: u32 = 0x828AB308;
    'dispatch: loop {
        match pc {
            0x828AB308 => {
    //   block [0x828AB308..0x828AB50C)
	// 828AB308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB30C: 483FE0F1  bl 0x82ca93fc
	ctx.lr = 0x828AB310;
	sub_82CA93D0(ctx, base);
	// 828AB310: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB314: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AB318: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB31C: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828AB320: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AB324: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AB328: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB32C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AB330: 3BAA7B18  addi r29, r10, 0x7b18
	ctx.r[29].s64 = ctx.r[10].s64 + 31512;
	// 828AB334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB338: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB33C: 419A0008  beq cr6, 0x828ab344
	if ctx.cr[6].eq {
	pc = 0x828AB344; continue 'dispatch;
	}
	// 828AB340: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB344: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB348: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB34C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB350: 4BB23271  bl 0x823ce5c0
	ctx.lr = 0x828AB354;
	sub_823CE5C0(ctx, base);
	// 828AB354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB358: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB35C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB360: 4BB22DB1  bl 0x823ce110
	ctx.lr = 0x828AB364;
	sub_823CE110(ctx, base);
	// 828AB364: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB368: 4B90C7B1  bl 0x821b7b18
	ctx.lr = 0x828AB36C;
	sub_821B7B18(ctx, base);
	// 828AB36C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AB370: 4B973EE9  bl 0x8221f258
	ctx.lr = 0x828AB374;
	sub_8221F258(ctx, base);
	// 828AB374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB378: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AB37C: 419A005C  beq cr6, 0x828ab3d8
	if ctx.cr[6].eq {
	pc = 0x828AB3D8; continue 'dispatch;
	}
	// 828AB380: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AB384: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AB388: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AB38C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AB390: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AB394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB398: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AB39C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AB3A0: 4B944EA1  bl 0x821f0240
	ctx.lr = 0x828AB3A4;
	sub_821F0240(ctx, base);
	// 828AB3A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AB3A8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AB3AC: 4B973EAD  bl 0x8221f258
	ctx.lr = 0x828AB3B0;
	sub_8221F258(ctx, base);
	// 828AB3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB3B4: 419A0028  beq cr6, 0x828ab3dc
	if ctx.cr[6].eq {
	pc = 0x828AB3DC; continue 'dispatch;
	}
	// 828AB3B8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AB3BC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AB3C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB3C4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AB3C8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AB3CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB3D0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AB3D4: 4800000C  b 0x828ab3e0
	pc = 0x828AB3E0; continue 'dispatch;
	// 828AB3D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AB3DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AB3E0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB3E4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB3EC: 419A0008  beq cr6, 0x828ab3f4
	if ctx.cr[6].eq {
	pc = 0x828AB3F4; continue 'dispatch;
	}
	// 828AB3F0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB3F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AB3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB3FC: 419A0078  beq cr6, 0x828ab474
	if ctx.cr[6].eq {
	pc = 0x828AB474; continue 'dispatch;
	}
	// 828AB400: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB404: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AB408: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB40C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB410: 4B97DCF9  bl 0x82229108
	ctx.lr = 0x828AB414;
	sub_82229108(ctx, base);
	// 828AB414: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AB418: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AB41C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB420: 3BCBD3F0  addi r30, r11, -0x2c10
	ctx.r[30].s64 = ctx.r[11].s64 + -11280;
	// 828AB424: 4B97C45D  bl 0x82227880
	ctx.lr = 0x828AB428;
	sub_82227880(ctx, base);
	// 828AB428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AB42C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB430: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AB434: 388AEB98  addi r4, r10, -0x1468
	ctx.r[4].s64 = ctx.r[10].s64 + -5224;
	// 828AB438: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB43C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AB440: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AB444: 4B8EF63D  bl 0x8219aa80
	ctx.lr = 0x828AB448;
	sub_8219AA80(ctx, base);
	// 828AB448: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB44C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AB450: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB454: 4BB22FCD  bl 0x823ce420
	ctx.lr = 0x828AB458;
	sub_823CE420(ctx, base);
	// 828AB458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB45C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AB460: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB464: 48179265  bl 0x82a246c8
	ctx.lr = 0x828AB468;
	sub_82A246C8(ctx, base);
	// 828AB468: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB46C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AB470: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AB474: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AB478: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB47C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AB480: 419A0020  beq cr6, 0x828ab4a0
	if ctx.cr[6].eq {
	pc = 0x828AB4A0; continue 'dispatch;
	}
	// 828AB484: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB488: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB48C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB490: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AB494: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB498: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB49C: 4082FFE8  bne 0x828ab484
	if !ctx.cr[0].eq {
	pc = 0x828AB484; continue 'dispatch;
	}
	// 828AB4A0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB4A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AB4A8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AB4AC: 4BA4A49D  bl 0x822f5948
	ctx.lr = 0x828AB4B0;
	sub_822F5948(ctx, base);
	// 828AB4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB4B4: 4B90C665  bl 0x821b7b18
	ctx.lr = 0x828AB4B8;
	sub_821B7B18(ctx, base);
	// 828AB4B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB4BC: 419A0040  beq cr6, 0x828ab4fc
	if ctx.cr[6].eq {
	pc = 0x828AB4FC; continue 'dispatch;
	}
	// 828AB4C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB4C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB4C8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB4CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AB4D0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB4D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB4D8: 4082FFE8  bne 0x828ab4c0
	if !ctx.cr[0].eq {
	pc = 0x828AB4C0; continue 'dispatch;
	}
	// 828AB4DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AB4E0: 409A001C  bne cr6, 0x828ab4fc
	if !ctx.cr[6].eq {
	pc = 0x828AB4FC; continue 'dispatch;
	}
	// 828AB4E4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB4E8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB4EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB4F0: 4E800421  bctrl
	ctx.lr = 0x828AB4F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB4F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB4F8: 4B970841  bl 0x8221bd38
	ctx.lr = 0x828AB4FC;
	sub_8221BD38(ctx, base);
	// 828AB4FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB500: 4B90C619  bl 0x821b7b18
	ctx.lr = 0x828AB504;
	sub_821B7B18(ctx, base);
	// 828AB504: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AB508: 483FDF44  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB510 size=516
    let mut pc: u32 = 0x828AB510;
    'dispatch: loop {
        match pc {
            0x828AB510 => {
    //   block [0x828AB510..0x828AB714)
	// 828AB510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB514: 483FDEE9  bl 0x82ca93fc
	ctx.lr = 0x828AB518;
	sub_82CA93D0(ctx, base);
	// 828AB518: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB51C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AB520: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB524: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB528: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AB52C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AB530: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB534: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AB538: 3BAA8280  addi r29, r10, -0x7d80
	ctx.r[29].s64 = ctx.r[10].s64 + -32128;
	// 828AB53C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB540: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB544: 419A0008  beq cr6, 0x828ab54c
	if ctx.cr[6].eq {
	pc = 0x828AB54C; continue 'dispatch;
	}
	// 828AB548: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB54C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB550: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB554: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB558: 4BB23069  bl 0x823ce5c0
	ctx.lr = 0x828AB55C;
	sub_823CE5C0(ctx, base);
	// 828AB55C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB560: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB564: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB568: 4BB22BA9  bl 0x823ce110
	ctx.lr = 0x828AB56C;
	sub_823CE110(ctx, base);
	// 828AB56C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB570: 4B90C5A9  bl 0x821b7b18
	ctx.lr = 0x828AB574;
	sub_821B7B18(ctx, base);
	// 828AB574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AB578: 4B973CE1  bl 0x8221f258
	ctx.lr = 0x828AB57C;
	sub_8221F258(ctx, base);
	// 828AB57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB580: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AB584: 419A005C  beq cr6, 0x828ab5e0
	if ctx.cr[6].eq {
	pc = 0x828AB5E0; continue 'dispatch;
	}
	// 828AB588: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AB58C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828AB590: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AB594: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AB598: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AB59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB5A0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AB5A4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AB5A8: 4B944C99  bl 0x821f0240
	ctx.lr = 0x828AB5AC;
	sub_821F0240(ctx, base);
	// 828AB5AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AB5B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AB5B4: 4B973CA5  bl 0x8221f258
	ctx.lr = 0x828AB5B8;
	sub_8221F258(ctx, base);
	// 828AB5B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB5BC: 419A0028  beq cr6, 0x828ab5e4
	if ctx.cr[6].eq {
	pc = 0x828AB5E4; continue 'dispatch;
	}
	// 828AB5C0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AB5C4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AB5C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB5CC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AB5D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AB5D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB5D8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AB5DC: 4800000C  b 0x828ab5e8
	pc = 0x828AB5E8; continue 'dispatch;
	// 828AB5E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AB5E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AB5E8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB5EC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB5F4: 419A0008  beq cr6, 0x828ab5fc
	if ctx.cr[6].eq {
	pc = 0x828AB5FC; continue 'dispatch;
	}
	// 828AB5F8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB5FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AB600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB604: 419A0078  beq cr6, 0x828ab67c
	if ctx.cr[6].eq {
	pc = 0x828AB67C; continue 'dispatch;
	}
	// 828AB608: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB60C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AB610: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB614: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB618: 4B97DAF1  bl 0x82229108
	ctx.lr = 0x828AB61C;
	sub_82229108(ctx, base);
	// 828AB61C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AB620: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AB624: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB628: 3BCBD588  addi r30, r11, -0x2a78
	ctx.r[30].s64 = ctx.r[11].s64 + -10872;
	// 828AB62C: 4B97C255  bl 0x82227880
	ctx.lr = 0x828AB630;
	sub_82227880(ctx, base);
	// 828AB630: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AB634: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB638: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AB63C: 388AEBD0  addi r4, r10, -0x1430
	ctx.r[4].s64 = ctx.r[10].s64 + -5168;
	// 828AB640: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB644: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AB648: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AB64C: 4B8EF435  bl 0x8219aa80
	ctx.lr = 0x828AB650;
	sub_8219AA80(ctx, base);
	// 828AB650: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB654: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AB658: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB65C: 4BB22DC5  bl 0x823ce420
	ctx.lr = 0x828AB660;
	sub_823CE420(ctx, base);
	// 828AB660: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB664: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AB668: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB66C: 4817905D  bl 0x82a246c8
	ctx.lr = 0x828AB670;
	sub_82A246C8(ctx, base);
	// 828AB670: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB674: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AB678: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AB67C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AB680: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB684: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AB688: 419A0020  beq cr6, 0x828ab6a8
	if ctx.cr[6].eq {
	pc = 0x828AB6A8; continue 'dispatch;
	}
	// 828AB68C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB690: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB694: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AB69C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB6A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB6A4: 4082FFE8  bne 0x828ab68c
	if !ctx.cr[0].eq {
	pc = 0x828AB68C; continue 'dispatch;
	}
	// 828AB6A8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB6AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AB6B0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AB6B4: 4BA4A295  bl 0x822f5948
	ctx.lr = 0x828AB6B8;
	sub_822F5948(ctx, base);
	// 828AB6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB6BC: 4B90C45D  bl 0x821b7b18
	ctx.lr = 0x828AB6C0;
	sub_821B7B18(ctx, base);
	// 828AB6C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB6C4: 419A0040  beq cr6, 0x828ab704
	if ctx.cr[6].eq {
	pc = 0x828AB704; continue 'dispatch;
	}
	// 828AB6C8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB6CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB6D0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB6D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AB6D8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB6DC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB6E0: 4082FFE8  bne 0x828ab6c8
	if !ctx.cr[0].eq {
	pc = 0x828AB6C8; continue 'dispatch;
	}
	// 828AB6E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AB6E8: 409A001C  bne cr6, 0x828ab704
	if !ctx.cr[6].eq {
	pc = 0x828AB704; continue 'dispatch;
	}
	// 828AB6EC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB6F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB6F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB6F8: 4E800421  bctrl
	ctx.lr = 0x828AB6FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB6FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB700: 4B970639  bl 0x8221bd38
	ctx.lr = 0x828AB704;
	sub_8221BD38(ctx, base);
	// 828AB704: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB708: 4B90C411  bl 0x821b7b18
	ctx.lr = 0x828AB70C;
	sub_821B7B18(ctx, base);
	// 828AB70C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AB710: 483FDD3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB718 size=516
    let mut pc: u32 = 0x828AB718;
    'dispatch: loop {
        match pc {
            0x828AB718 => {
    //   block [0x828AB718..0x828AB91C)
	// 828AB718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB71C: 483FDCE1  bl 0x82ca93fc
	ctx.lr = 0x828AB720;
	sub_82CA93D0(ctx, base);
	// 828AB720: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB724: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AB728: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB72C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB730: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AB734: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AB738: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB73C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AB740: 3BAA8508  addi r29, r10, -0x7af8
	ctx.r[29].s64 = ctx.r[10].s64 + -31480;
	// 828AB744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB748: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB74C: 419A0008  beq cr6, 0x828ab754
	if ctx.cr[6].eq {
	pc = 0x828AB754; continue 'dispatch;
	}
	// 828AB750: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB754: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB75C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB760: 4BB22E61  bl 0x823ce5c0
	ctx.lr = 0x828AB764;
	sub_823CE5C0(ctx, base);
	// 828AB764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB768: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB76C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB770: 4BB229A1  bl 0x823ce110
	ctx.lr = 0x828AB774;
	sub_823CE110(ctx, base);
	// 828AB774: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB778: 4B90C3A1  bl 0x821b7b18
	ctx.lr = 0x828AB77C;
	sub_821B7B18(ctx, base);
	// 828AB77C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AB780: 4B973AD9  bl 0x8221f258
	ctx.lr = 0x828AB784;
	sub_8221F258(ctx, base);
	// 828AB784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB788: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AB78C: 419A005C  beq cr6, 0x828ab7e8
	if ctx.cr[6].eq {
	pc = 0x828AB7E8; continue 'dispatch;
	}
	// 828AB790: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AB794: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AB798: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AB79C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AB7A0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AB7A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB7A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AB7AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AB7B0: 4B944A91  bl 0x821f0240
	ctx.lr = 0x828AB7B4;
	sub_821F0240(ctx, base);
	// 828AB7B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AB7B8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AB7BC: 4B973A9D  bl 0x8221f258
	ctx.lr = 0x828AB7C0;
	sub_8221F258(ctx, base);
	// 828AB7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB7C4: 419A0028  beq cr6, 0x828ab7ec
	if ctx.cr[6].eq {
	pc = 0x828AB7EC; continue 'dispatch;
	}
	// 828AB7C8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AB7CC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AB7D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB7D4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AB7D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AB7DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB7E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AB7E4: 4800000C  b 0x828ab7f0
	pc = 0x828AB7F0; continue 'dispatch;
	// 828AB7E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AB7EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AB7F0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB7F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB7F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB7FC: 419A0008  beq cr6, 0x828ab804
	if ctx.cr[6].eq {
	pc = 0x828AB804; continue 'dispatch;
	}
	// 828AB800: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB804: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AB808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB80C: 419A0078  beq cr6, 0x828ab884
	if ctx.cr[6].eq {
	pc = 0x828AB884; continue 'dispatch;
	}
	// 828AB810: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB814: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AB818: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB81C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB820: 4B97D8E9  bl 0x82229108
	ctx.lr = 0x828AB824;
	sub_82229108(ctx, base);
	// 828AB824: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AB828: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AB82C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB830: 3BCBD728  addi r30, r11, -0x28d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10456;
	// 828AB834: 4B97C04D  bl 0x82227880
	ctx.lr = 0x828AB838;
	sub_82227880(ctx, base);
	// 828AB838: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AB83C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB840: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AB844: 388AEC98  addi r4, r10, -0x1368
	ctx.r[4].s64 = ctx.r[10].s64 + -4968;
	// 828AB848: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB84C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AB850: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AB854: 4B8EF22D  bl 0x8219aa80
	ctx.lr = 0x828AB858;
	sub_8219AA80(ctx, base);
	// 828AB858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB85C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AB860: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB864: 4BB22BBD  bl 0x823ce420
	ctx.lr = 0x828AB868;
	sub_823CE420(ctx, base);
	// 828AB868: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB86C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AB870: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB874: 48178E55  bl 0x82a246c8
	ctx.lr = 0x828AB878;
	sub_82A246C8(ctx, base);
	// 828AB878: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB87C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AB880: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AB884: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AB888: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB88C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AB890: 419A0020  beq cr6, 0x828ab8b0
	if ctx.cr[6].eq {
	pc = 0x828AB8B0; continue 'dispatch;
	}
	// 828AB894: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB898: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB89C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB8A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AB8A4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB8A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB8AC: 4082FFE8  bne 0x828ab894
	if !ctx.cr[0].eq {
	pc = 0x828AB894; continue 'dispatch;
	}
	// 828AB8B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB8B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AB8B8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AB8BC: 4BA4A08D  bl 0x822f5948
	ctx.lr = 0x828AB8C0;
	sub_822F5948(ctx, base);
	// 828AB8C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB8C4: 4B90C255  bl 0x821b7b18
	ctx.lr = 0x828AB8C8;
	sub_821B7B18(ctx, base);
	// 828AB8C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AB8CC: 419A0040  beq cr6, 0x828ab90c
	if ctx.cr[6].eq {
	pc = 0x828AB90C; continue 'dispatch;
	}
	// 828AB8D0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AB8D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB8D8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AB8DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AB8E0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB8E4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB8E8: 4082FFE8  bne 0x828ab8d0
	if !ctx.cr[0].eq {
	pc = 0x828AB8D0; continue 'dispatch;
	}
	// 828AB8EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AB8F0: 409A001C  bne cr6, 0x828ab90c
	if !ctx.cr[6].eq {
	pc = 0x828AB90C; continue 'dispatch;
	}
	// 828AB8F4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB8F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB8FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB900: 4E800421  bctrl
	ctx.lr = 0x828AB904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB904: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB908: 4B970431  bl 0x8221bd38
	ctx.lr = 0x828AB90C;
	sub_8221BD38(ctx, base);
	// 828AB90C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB910: 4B90C209  bl 0x821b7b18
	ctx.lr = 0x828AB914;
	sub_821B7B18(ctx, base);
	// 828AB914: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AB918: 483FDB34  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB920 size=516
    let mut pc: u32 = 0x828AB920;
    'dispatch: loop {
        match pc {
            0x828AB920 => {
    //   block [0x828AB920..0x828ABB24)
	// 828AB920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB924: 483FDAD9  bl 0x82ca93fc
	ctx.lr = 0x828AB928;
	sub_82CA93D0(ctx, base);
	// 828AB928: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB92C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AB930: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB934: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AB938: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AB93C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AB940: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB944: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AB948: 3BAA8630  addi r29, r10, -0x79d0
	ctx.r[29].s64 = ctx.r[10].s64 + -31184;
	// 828AB94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB950: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AB954: 419A0008  beq cr6, 0x828ab95c
	if ctx.cr[6].eq {
	pc = 0x828AB95C; continue 'dispatch;
	}
	// 828AB958: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB95C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB960: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB964: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB968: 4BB22C59  bl 0x823ce5c0
	ctx.lr = 0x828AB96C;
	sub_823CE5C0(ctx, base);
	// 828AB96C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB970: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB974: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB978: 4BB22799  bl 0x823ce110
	ctx.lr = 0x828AB97C;
	sub_823CE110(ctx, base);
	// 828AB97C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB980: 4B90C199  bl 0x821b7b18
	ctx.lr = 0x828AB984;
	sub_821B7B18(ctx, base);
	// 828AB984: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AB988: 4B9738D1  bl 0x8221f258
	ctx.lr = 0x828AB98C;
	sub_8221F258(ctx, base);
	// 828AB98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB990: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AB994: 419A005C  beq cr6, 0x828ab9f0
	if ctx.cr[6].eq {
	pc = 0x828AB9F0; continue 'dispatch;
	}
	// 828AB998: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AB99C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AB9A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AB9A4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AB9A8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AB9AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB9B0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AB9B4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AB9B8: 4B944889  bl 0x821f0240
	ctx.lr = 0x828AB9BC;
	sub_821F0240(ctx, base);
	// 828AB9BC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AB9C0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AB9C4: 4B973895  bl 0x8221f258
	ctx.lr = 0x828AB9C8;
	sub_8221F258(ctx, base);
	// 828AB9C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB9CC: 419A0028  beq cr6, 0x828ab9f4
	if ctx.cr[6].eq {
	pc = 0x828AB9F4; continue 'dispatch;
	}
	// 828AB9D0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AB9D4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AB9D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB9DC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AB9E0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AB9E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB9E8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AB9EC: 4800000C  b 0x828ab9f8
	pc = 0x828AB9F8; continue 'dispatch;
	// 828AB9F0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AB9F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AB9F8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB9FC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABA00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABA04: 419A0008  beq cr6, 0x828aba0c
	if ctx.cr[6].eq {
	pc = 0x828ABA0C; continue 'dispatch;
	}
	// 828ABA08: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABA0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ABA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABA14: 419A0078  beq cr6, 0x828aba8c
	if ctx.cr[6].eq {
	pc = 0x828ABA8C; continue 'dispatch;
	}
	// 828ABA18: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABA1C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ABA20: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABA24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABA28: 4B97D6E1  bl 0x82229108
	ctx.lr = 0x828ABA2C;
	sub_82229108(ctx, base);
	// 828ABA2C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ABA30: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ABA34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABA38: 3BCBD728  addi r30, r11, -0x28d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10456;
	// 828ABA3C: 4B97BE45  bl 0x82227880
	ctx.lr = 0x828ABA40;
	sub_82227880(ctx, base);
	// 828ABA40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ABA44: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ABA48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ABA4C: 388AED60  addi r4, r10, -0x12a0
	ctx.r[4].s64 = ctx.r[10].s64 + -4768;
	// 828ABA50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABA54: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828ABA58: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828ABA5C: 4B8EF025  bl 0x8219aa80
	ctx.lr = 0x828ABA60;
	sub_8219AA80(ctx, base);
	// 828ABA60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABA64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ABA68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABA6C: 4BB229B5  bl 0x823ce420
	ctx.lr = 0x828ABA70;
	sub_823CE420(ctx, base);
	// 828ABA70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABA74: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ABA78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABA7C: 48178C4D  bl 0x82a246c8
	ctx.lr = 0x828ABA80;
	sub_82A246C8(ctx, base);
	// 828ABA80: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABA84: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ABA88: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ABA8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ABA90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABA94: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ABA98: 419A0020  beq cr6, 0x828abab8
	if ctx.cr[6].eq {
	pc = 0x828ABAB8; continue 'dispatch;
	}
	// 828ABA9C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABAA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABAA4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABAA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ABAAC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABAB0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABAB4: 4082FFE8  bne 0x828aba9c
	if !ctx.cr[0].eq {
	pc = 0x828ABA9C; continue 'dispatch;
	}
	// 828ABAB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABABC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ABAC0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ABAC4: 4BA49E85  bl 0x822f5948
	ctx.lr = 0x828ABAC8;
	sub_822F5948(ctx, base);
	// 828ABAC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ABACC: 4B90C04D  bl 0x821b7b18
	ctx.lr = 0x828ABAD0;
	sub_821B7B18(ctx, base);
	// 828ABAD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABAD4: 419A0040  beq cr6, 0x828abb14
	if ctx.cr[6].eq {
	pc = 0x828ABB14; continue 'dispatch;
	}
	// 828ABAD8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABADC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABAE0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABAE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ABAE8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABAEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABAF0: 4082FFE8  bne 0x828abad8
	if !ctx.cr[0].eq {
	pc = 0x828ABAD8; continue 'dispatch;
	}
	// 828ABAF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ABAF8: 409A001C  bne cr6, 0x828abb14
	if !ctx.cr[6].eq {
	pc = 0x828ABB14; continue 'dispatch;
	}
	// 828ABAFC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABB00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABB04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ABB08: 4E800421  bctrl
	ctx.lr = 0x828ABB0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ABB0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ABB10: 4B970229  bl 0x8221bd38
	ctx.lr = 0x828ABB14;
	sub_8221BD38(ctx, base);
	// 828ABB14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABB18: 4B90C001  bl 0x821b7b18
	ctx.lr = 0x828ABB1C;
	sub_821B7B18(ctx, base);
	// 828ABB1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ABB20: 483FD92C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABB28 size=516
    let mut pc: u32 = 0x828ABB28;
    'dispatch: loop {
        match pc {
            0x828ABB28 => {
    //   block [0x828ABB28..0x828ABD2C)
	// 828ABB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABB2C: 483FD8D1  bl 0x82ca93fc
	ctx.lr = 0x828ABB30;
	sub_82CA93D0(ctx, base);
	// 828ABB30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABB34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ABB38: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ABB3C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ABB40: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828ABB44: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ABB48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABB4C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ABB50: 3BAA8848  addi r29, r10, -0x77b8
	ctx.r[29].s64 = ctx.r[10].s64 + -30648;
	// 828ABB54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABB58: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABB5C: 419A0008  beq cr6, 0x828abb64
	if ctx.cr[6].eq {
	pc = 0x828ABB64; continue 'dispatch;
	}
	// 828ABB60: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABB64: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABB68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABB6C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABB70: 4BB22A51  bl 0x823ce5c0
	ctx.lr = 0x828ABB74;
	sub_823CE5C0(ctx, base);
	// 828ABB74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ABB78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABB7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABB80: 4BB22591  bl 0x823ce110
	ctx.lr = 0x828ABB84;
	sub_823CE110(ctx, base);
	// 828ABB84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABB88: 4B90BF91  bl 0x821b7b18
	ctx.lr = 0x828ABB8C;
	sub_821B7B18(ctx, base);
	// 828ABB8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ABB90: 4B9736C9  bl 0x8221f258
	ctx.lr = 0x828ABB94;
	sub_8221F258(ctx, base);
	// 828ABB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABB98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ABB9C: 419A005C  beq cr6, 0x828abbf8
	if ctx.cr[6].eq {
	pc = 0x828ABBF8; continue 'dispatch;
	}
	// 828ABBA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ABBA4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ABBA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ABBAC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ABBB0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ABBB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ABBB8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ABBBC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ABBC0: 4B944681  bl 0x821f0240
	ctx.lr = 0x828ABBC4;
	sub_821F0240(ctx, base);
	// 828ABBC4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ABBC8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ABBCC: 4B97368D  bl 0x8221f258
	ctx.lr = 0x828ABBD0;
	sub_8221F258(ctx, base);
	// 828ABBD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ABBD4: 419A0028  beq cr6, 0x828abbfc
	if ctx.cr[6].eq {
	pc = 0x828ABBFC; continue 'dispatch;
	}
	// 828ABBD8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ABBDC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ABBE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ABBE4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ABBE8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ABBEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ABBF0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828ABBF4: 4800000C  b 0x828abc00
	pc = 0x828ABC00; continue 'dispatch;
	// 828ABBF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ABBFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ABC00: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABC04: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABC0C: 419A0008  beq cr6, 0x828abc14
	if ctx.cr[6].eq {
	pc = 0x828ABC14; continue 'dispatch;
	}
	// 828ABC10: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABC14: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ABC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABC1C: 419A0078  beq cr6, 0x828abc94
	if ctx.cr[6].eq {
	pc = 0x828ABC94; continue 'dispatch;
	}
	// 828ABC20: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABC24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ABC28: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABC2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABC30: 4B97D4D9  bl 0x82229108
	ctx.lr = 0x828ABC34;
	sub_82229108(ctx, base);
	// 828ABC34: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ABC38: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ABC3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABC40: 3BCBD3F0  addi r30, r11, -0x2c10
	ctx.r[30].s64 = ctx.r[11].s64 + -11280;
	// 828ABC44: 4B97BC3D  bl 0x82227880
	ctx.lr = 0x828ABC48;
	sub_82227880(ctx, base);
	// 828ABC48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ABC4C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ABC50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ABC54: 388AEE28  addi r4, r10, -0x11d8
	ctx.r[4].s64 = ctx.r[10].s64 + -4568;
	// 828ABC58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABC5C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828ABC60: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828ABC64: 4B8EEE1D  bl 0x8219aa80
	ctx.lr = 0x828ABC68;
	sub_8219AA80(ctx, base);
	// 828ABC68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABC6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ABC70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABC74: 4BB227AD  bl 0x823ce420
	ctx.lr = 0x828ABC78;
	sub_823CE420(ctx, base);
	// 828ABC78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABC7C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ABC80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABC84: 48178A45  bl 0x82a246c8
	ctx.lr = 0x828ABC88;
	sub_82A246C8(ctx, base);
	// 828ABC88: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABC8C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ABC90: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ABC94: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ABC98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABC9C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ABCA0: 419A0020  beq cr6, 0x828abcc0
	if ctx.cr[6].eq {
	pc = 0x828ABCC0; continue 'dispatch;
	}
	// 828ABCA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABCA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABCAC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABCB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ABCB4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABCB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABCBC: 4082FFE8  bne 0x828abca4
	if !ctx.cr[0].eq {
	pc = 0x828ABCA4; continue 'dispatch;
	}
	// 828ABCC0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABCC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ABCC8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ABCCC: 4BA49C7D  bl 0x822f5948
	ctx.lr = 0x828ABCD0;
	sub_822F5948(ctx, base);
	// 828ABCD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ABCD4: 4B90BE45  bl 0x821b7b18
	ctx.lr = 0x828ABCD8;
	sub_821B7B18(ctx, base);
	// 828ABCD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABCDC: 419A0040  beq cr6, 0x828abd1c
	if ctx.cr[6].eq {
	pc = 0x828ABD1C; continue 'dispatch;
	}
	// 828ABCE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABCE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABCE8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABCEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ABCF0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABCF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABCF8: 4082FFE8  bne 0x828abce0
	if !ctx.cr[0].eq {
	pc = 0x828ABCE0; continue 'dispatch;
	}
	// 828ABCFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ABD00: 409A001C  bne cr6, 0x828abd1c
	if !ctx.cr[6].eq {
	pc = 0x828ABD1C; continue 'dispatch;
	}
	// 828ABD04: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABD08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABD0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ABD10: 4E800421  bctrl
	ctx.lr = 0x828ABD14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ABD14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ABD18: 4B970021  bl 0x8221bd38
	ctx.lr = 0x828ABD1C;
	sub_8221BD38(ctx, base);
	// 828ABD1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABD20: 4B90BDF9  bl 0x821b7b18
	ctx.lr = 0x828ABD24;
	sub_821B7B18(ctx, base);
	// 828ABD24: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ABD28: 483FD724  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABD30 size=516
    let mut pc: u32 = 0x828ABD30;
    'dispatch: loop {
        match pc {
            0x828ABD30 => {
    //   block [0x828ABD30..0x828ABF34)
	// 828ABD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABD34: 483FD6C9  bl 0x82ca93fc
	ctx.lr = 0x828ABD38;
	sub_82CA93D0(ctx, base);
	// 828ABD38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABD3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ABD40: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ABD44: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ABD48: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828ABD4C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ABD50: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABD54: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ABD58: 3BAA8B98  addi r29, r10, -0x7468
	ctx.r[29].s64 = ctx.r[10].s64 + -29800;
	// 828ABD5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABD60: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABD64: 419A0008  beq cr6, 0x828abd6c
	if ctx.cr[6].eq {
	pc = 0x828ABD6C; continue 'dispatch;
	}
	// 828ABD68: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABD6C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABD70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABD74: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABD78: 4BB22849  bl 0x823ce5c0
	ctx.lr = 0x828ABD7C;
	sub_823CE5C0(ctx, base);
	// 828ABD7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ABD80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABD84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABD88: 4BB22389  bl 0x823ce110
	ctx.lr = 0x828ABD8C;
	sub_823CE110(ctx, base);
	// 828ABD8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABD90: 4B90BD89  bl 0x821b7b18
	ctx.lr = 0x828ABD94;
	sub_821B7B18(ctx, base);
	// 828ABD94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ABD98: 4B9734C1  bl 0x8221f258
	ctx.lr = 0x828ABD9C;
	sub_8221F258(ctx, base);
	// 828ABD9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABDA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ABDA4: 419A005C  beq cr6, 0x828abe00
	if ctx.cr[6].eq {
	pc = 0x828ABE00; continue 'dispatch;
	}
	// 828ABDA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ABDAC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ABDB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ABDB4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ABDB8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ABDBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ABDC0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ABDC4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ABDC8: 4B944479  bl 0x821f0240
	ctx.lr = 0x828ABDCC;
	sub_821F0240(ctx, base);
	// 828ABDCC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ABDD0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ABDD4: 4B973485  bl 0x8221f258
	ctx.lr = 0x828ABDD8;
	sub_8221F258(ctx, base);
	// 828ABDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ABDDC: 419A0028  beq cr6, 0x828abe04
	if ctx.cr[6].eq {
	pc = 0x828ABE04; continue 'dispatch;
	}
	// 828ABDE0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ABDE4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ABDE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ABDEC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ABDF0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ABDF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ABDF8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828ABDFC: 4800000C  b 0x828abe08
	pc = 0x828ABE08; continue 'dispatch;
	// 828ABE00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ABE04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ABE08: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABE0C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABE14: 419A0008  beq cr6, 0x828abe1c
	if ctx.cr[6].eq {
	pc = 0x828ABE1C; continue 'dispatch;
	}
	// 828ABE18: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABE1C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ABE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABE24: 419A0078  beq cr6, 0x828abe9c
	if ctx.cr[6].eq {
	pc = 0x828ABE9C; continue 'dispatch;
	}
	// 828ABE28: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABE2C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ABE30: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABE34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABE38: 4B97D2D1  bl 0x82229108
	ctx.lr = 0x828ABE3C;
	sub_82229108(ctx, base);
	// 828ABE3C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ABE40: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ABE44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABE48: 3BCBD728  addi r30, r11, -0x28d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10456;
	// 828ABE4C: 4B97BA35  bl 0x82227880
	ctx.lr = 0x828ABE50;
	sub_82227880(ctx, base);
	// 828ABE50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ABE54: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ABE58: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ABE5C: 388AEEE8  addi r4, r10, -0x1118
	ctx.r[4].s64 = ctx.r[10].s64 + -4376;
	// 828ABE60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABE64: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828ABE68: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828ABE6C: 4B8EEC15  bl 0x8219aa80
	ctx.lr = 0x828ABE70;
	sub_8219AA80(ctx, base);
	// 828ABE70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABE74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ABE78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABE7C: 4BB225A5  bl 0x823ce420
	ctx.lr = 0x828ABE80;
	sub_823CE420(ctx, base);
	// 828ABE80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABE84: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ABE88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ABE8C: 4817883D  bl 0x82a246c8
	ctx.lr = 0x828ABE90;
	sub_82A246C8(ctx, base);
	// 828ABE90: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABE94: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ABE98: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ABE9C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ABEA0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABEA4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ABEA8: 419A0020  beq cr6, 0x828abec8
	if ctx.cr[6].eq {
	pc = 0x828ABEC8; continue 'dispatch;
	}
	// 828ABEAC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABEB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABEB4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABEB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ABEBC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABEC0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABEC4: 4082FFE8  bne 0x828abeac
	if !ctx.cr[0].eq {
	pc = 0x828ABEAC; continue 'dispatch;
	}
	// 828ABEC8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ABED0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ABED4: 4BA49A75  bl 0x822f5948
	ctx.lr = 0x828ABED8;
	sub_822F5948(ctx, base);
	// 828ABED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ABEDC: 4B90BC3D  bl 0x821b7b18
	ctx.lr = 0x828ABEE0;
	sub_821B7B18(ctx, base);
	// 828ABEE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ABEE4: 419A0040  beq cr6, 0x828abf24
	if ctx.cr[6].eq {
	pc = 0x828ABF24; continue 'dispatch;
	}
	// 828ABEE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ABEEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABEF0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ABEF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ABEF8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ABEFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ABF00: 4082FFE8  bne 0x828abee8
	if !ctx.cr[0].eq {
	pc = 0x828ABEE8; continue 'dispatch;
	}
	// 828ABF04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ABF08: 409A001C  bne cr6, 0x828abf24
	if !ctx.cr[6].eq {
	pc = 0x828ABF24; continue 'dispatch;
	}
	// 828ABF0C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ABF10: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABF14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ABF18: 4E800421  bctrl
	ctx.lr = 0x828ABF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ABF1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ABF20: 4B96FE19  bl 0x8221bd38
	ctx.lr = 0x828ABF24;
	sub_8221BD38(ctx, base);
	// 828ABF24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABF28: 4B90BBF1  bl 0x821b7b18
	ctx.lr = 0x828ABF2C;
	sub_821B7B18(ctx, base);
	// 828ABF2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ABF30: 483FD51C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABF38 size=512
    let mut pc: u32 = 0x828ABF38;
    'dispatch: loop {
        match pc {
            0x828ABF38 => {
    //   block [0x828ABF38..0x828AC138)
	// 828ABF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABF3C: 483FD4C1  bl 0x82ca93fc
	ctx.lr = 0x828ABF40;
	sub_82CA93D0(ctx, base);
	// 828ABF40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABF44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ABF48: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ABF4C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ABF50: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828ABF54: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ABF58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABF5C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828ABF60: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ABF64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABF68: 419A0008  beq cr6, 0x828abf70
	if ctx.cr[6].eq {
	pc = 0x828ABF70; continue 'dispatch;
	}
	// 828ABF6C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABF70: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ABF74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABF78: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ABF7C: 4BB22645  bl 0x823ce5c0
	ctx.lr = 0x828ABF80;
	sub_823CE5C0(ctx, base);
	// 828ABF80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ABF84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ABF88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ABF8C: 4BB22185  bl 0x823ce110
	ctx.lr = 0x828ABF90;
	sub_823CE110(ctx, base);
	// 828ABF90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ABF94: 4B90BB85  bl 0x821b7b18
	ctx.lr = 0x828ABF98;
	sub_821B7B18(ctx, base);
	// 828ABF98: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ABF9C: 4B9732BD  bl 0x8221f258
	ctx.lr = 0x828ABFA0;
	sub_8221F258(ctx, base);
	// 828ABFA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABFA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ABFA8: 419A005C  beq cr6, 0x828ac004
	if ctx.cr[6].eq {
	pc = 0x828AC004; continue 'dispatch;
	}
	// 828ABFAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ABFB0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ABFB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ABFB8: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ABFBC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ABFC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ABFC4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ABFC8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ABFCC: 4B944275  bl 0x821f0240
	ctx.lr = 0x828ABFD0;
	sub_821F0240(ctx, base);
	// 828ABFD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ABFD4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ABFD8: 4B973281  bl 0x8221f258
	ctx.lr = 0x828ABFDC;
	sub_8221F258(ctx, base);
	// 828ABFDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ABFE0: 419A0028  beq cr6, 0x828ac008
	if ctx.cr[6].eq {
	pc = 0x828AC008; continue 'dispatch;
	}
	// 828ABFE4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ABFE8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ABFEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ABFF0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ABFF4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ABFF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ABFFC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AC000: 4800000C  b 0x828ac00c
	pc = 0x828AC00C; continue 'dispatch;
	// 828AC004: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC008: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AC00C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC010: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC018: 419A0008  beq cr6, 0x828ac020
	if ctx.cr[6].eq {
	pc = 0x828AC020; continue 'dispatch;
	}
	// 828AC01C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC020: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AC024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC028: 419A0078  beq cr6, 0x828ac0a0
	if ctx.cr[6].eq {
	pc = 0x828AC0A0; continue 'dispatch;
	}
	// 828AC02C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC030: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC034: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC038: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC03C: 4B97D0CD  bl 0x82229108
	ctx.lr = 0x828AC040;
	sub_82229108(ctx, base);
	// 828AC040: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC044: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC048: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC04C: 3BCBD8C8  addi r30, r11, -0x2738
	ctx.r[30].s64 = ctx.r[11].s64 + -10040;
	// 828AC050: 4B97B831  bl 0x82227880
	ctx.lr = 0x828AC054;
	sub_82227880(ctx, base);
	// 828AC054: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC058: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AC05C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC060: 388AEFB0  addi r4, r10, -0x1050
	ctx.r[4].s64 = ctx.r[10].s64 + -4176;
	// 828AC064: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC068: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AC06C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC070: 4B8EEA11  bl 0x8219aa80
	ctx.lr = 0x828AC074;
	sub_8219AA80(ctx, base);
	// 828AC074: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC078: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AC07C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC080: 4BB223A1  bl 0x823ce420
	ctx.lr = 0x828AC084;
	sub_823CE420(ctx, base);
	// 828AC084: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC088: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AC08C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC090: 48178639  bl 0x82a246c8
	ctx.lr = 0x828AC094;
	sub_82A246C8(ctx, base);
	// 828AC094: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC098: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AC09C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AC0A0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AC0A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC0A8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AC0AC: 419A0020  beq cr6, 0x828ac0cc
	if ctx.cr[6].eq {
	pc = 0x828AC0CC; continue 'dispatch;
	}
	// 828AC0B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC0B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC0B8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC0BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AC0C0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC0C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC0C8: 4082FFE8  bne 0x828ac0b0
	if !ctx.cr[0].eq {
	pc = 0x828AC0B0; continue 'dispatch;
	}
	// 828AC0CC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC0D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC0D4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AC0D8: 4BA49871  bl 0x822f5948
	ctx.lr = 0x828AC0DC;
	sub_822F5948(ctx, base);
	// 828AC0DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC0E0: 4B90BA39  bl 0x821b7b18
	ctx.lr = 0x828AC0E4;
	sub_821B7B18(ctx, base);
	// 828AC0E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC0E8: 419A0040  beq cr6, 0x828ac128
	if ctx.cr[6].eq {
	pc = 0x828AC128; continue 'dispatch;
	}
	// 828AC0EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC0F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC0F4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC0F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AC0FC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC100: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC104: 4082FFE8  bne 0x828ac0ec
	if !ctx.cr[0].eq {
	pc = 0x828AC0EC; continue 'dispatch;
	}
	// 828AC108: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AC10C: 409A001C  bne cr6, 0x828ac128
	if !ctx.cr[6].eq {
	pc = 0x828AC128; continue 'dispatch;
	}
	// 828AC110: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC114: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AC11C: 4E800421  bctrl
	ctx.lr = 0x828AC120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AC120: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC124: 4B96FC15  bl 0x8221bd38
	ctx.lr = 0x828AC128;
	sub_8221BD38(ctx, base);
	// 828AC128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC12C: 4B90B9ED  bl 0x821b7b18
	ctx.lr = 0x828AC130;
	sub_821B7B18(ctx, base);
	// 828AC130: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AC134: 483FD318  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC138 size=448
    let mut pc: u32 = 0x828AC138;
    'dispatch: loop {
        match pc {
            0x828AC138 => {
    //   block [0x828AC138..0x828AC2F8)
	// 828AC138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC13C: 483FD2C1  bl 0x82ca93fc
	ctx.lr = 0x828AC140;
	sub_82CA93D0(ctx, base);
	// 828AC140: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC144: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC148: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AC14C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AC150: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AC154: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AC158: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC15C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AC160: 3BAA9120  addi r29, r10, -0x6ee0
	ctx.r[29].s64 = ctx.r[10].s64 + -28384;
	// 828AC164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC168: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC16C: 419A0008  beq cr6, 0x828ac174
	if ctx.cr[6].eq {
	pc = 0x828AC174; continue 'dispatch;
	}
	// 828AC170: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC174: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC178: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC17C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC180: 4BB22441  bl 0x823ce5c0
	ctx.lr = 0x828AC184;
	sub_823CE5C0(ctx, base);
	// 828AC184: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AC188: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC18C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC190: 4BB21F81  bl 0x823ce110
	ctx.lr = 0x828AC194;
	sub_823CE110(ctx, base);
	// 828AC194: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC198: 4B90B981  bl 0x821b7b18
	ctx.lr = 0x828AC19C;
	sub_821B7B18(ctx, base);
	// 828AC19C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AC1A0: 4B9730B9  bl 0x8221f258
	ctx.lr = 0x828AC1A4;
	sub_8221F258(ctx, base);
	// 828AC1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC1A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC1AC: 419A002C  beq cr6, 0x828ac1d8
	if ctx.cr[6].eq {
	pc = 0x828AC1D8; continue 'dispatch;
	}
	// 828AC1B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AC1B4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AC1B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC1BC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AC1C0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AC1C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AC1C8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AC1CC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AC1D0: 4B944071  bl 0x821f0240
	ctx.lr = 0x828AC1D4;
	sub_821F0240(ctx, base);
	// 828AC1D4: 48000008  b 0x828ac1dc
	pc = 0x828AC1DC; continue 'dispatch;
	// 828AC1D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828AC1DC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828AC1E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC1E4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828AC1E8: 419A0018  beq cr6, 0x828ac200
	if ctx.cr[6].eq {
	pc = 0x828AC200; continue 'dispatch;
	}
	// 828AC1EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC1F0: 48158AD1  bl 0x82a04cc0
	ctx.lr = 0x828AC1F4;
	sub_82A04CC0(ctx, base);
	// 828AC1F4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AC1F8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AC1FC: 4800000C  b 0x828ac208
	pc = 0x828AC208; continue 'dispatch;
	// 828AC200: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC204: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828AC208: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC20C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC214: 419A0008  beq cr6, 0x828ac21c
	if ctx.cr[6].eq {
	pc = 0x828AC21C; continue 'dispatch;
	}
	// 828AC218: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC21C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828AC220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC224: 419A0078  beq cr6, 0x828ac29c
	if ctx.cr[6].eq {
	pc = 0x828AC29C; continue 'dispatch;
	}
	// 828AC228: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC22C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC230: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC234: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC238: 4B97CED1  bl 0x82229108
	ctx.lr = 0x828AC23C;
	sub_82229108(ctx, base);
	// 828AC23C: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC240: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC244: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC248: 3BCBDEF0  addi r30, r11, -0x2110
	ctx.r[30].s64 = ctx.r[11].s64 + -8464;
	// 828AC24C: 4B97B635  bl 0x82227880
	ctx.lr = 0x828AC250;
	sub_82227880(ctx, base);
	// 828AC250: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC254: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828AC258: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC25C: 388A9E78  addi r4, r10, -0x6188
	ctx.r[4].s64 = ctx.r[10].s64 + -24968;
	// 828AC260: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC264: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AC268: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC26C: 4B8EE815  bl 0x8219aa80
	ctx.lr = 0x828AC270;
	sub_8219AA80(ctx, base);
	// 828AC270: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC274: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AC278: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC27C: 4BB221A5  bl 0x823ce420
	ctx.lr = 0x828AC280;
	sub_823CE420(ctx, base);
	// 828AC280: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC284: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AC288: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC28C: 4817843D  bl 0x82a246c8
	ctx.lr = 0x828AC290;
	sub_82A246C8(ctx, base);
	// 828AC290: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC294: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AC298: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AC29C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828AC2A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828AC2A4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828AC2A8: 419A0020  beq cr6, 0x828ac2c8
	if ctx.cr[6].eq {
	pc = 0x828AC2C8; continue 'dispatch;
	}
	// 828AC2AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC2B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC2B4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC2B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AC2BC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC2C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC2C4: 4082FFE8  bne 0x828ac2ac
	if !ctx.cr[0].eq {
	pc = 0x828AC2AC; continue 'dispatch;
	}
	// 828AC2C8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC2CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC2D0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AC2D4: 4BA49675  bl 0x822f5948
	ctx.lr = 0x828AC2D8;
	sub_822F5948(ctx, base);
	// 828AC2D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC2DC: 4B90B83D  bl 0x821b7b18
	ctx.lr = 0x828AC2E0;
	sub_821B7B18(ctx, base);
	// 828AC2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC2E4: 4B90B835  bl 0x821b7b18
	ctx.lr = 0x828AC2E8;
	sub_821B7B18(ctx, base);
	// 828AC2E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC2EC: 4B90B82D  bl 0x821b7b18
	ctx.lr = 0x828AC2F0;
	sub_821B7B18(ctx, base);
	// 828AC2F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AC2F4: 483FD158  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC2F8 size=516
    let mut pc: u32 = 0x828AC2F8;
    'dispatch: loop {
        match pc {
            0x828AC2F8 => {
    //   block [0x828AC2F8..0x828AC4FC)
	// 828AC2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC2FC: 483FD101  bl 0x82ca93fc
	ctx.lr = 0x828AC300;
	sub_82CA93D0(ctx, base);
	// 828AC300: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC304: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC308: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AC30C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AC310: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AC314: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AC318: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC31C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AC320: 3BAA91A0  addi r29, r10, -0x6e60
	ctx.r[29].s64 = ctx.r[10].s64 + -28256;
	// 828AC324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC328: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC32C: 419A0008  beq cr6, 0x828ac334
	if ctx.cr[6].eq {
	pc = 0x828AC334; continue 'dispatch;
	}
	// 828AC330: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC334: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC338: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC33C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC340: 4BB22281  bl 0x823ce5c0
	ctx.lr = 0x828AC344;
	sub_823CE5C0(ctx, base);
	// 828AC344: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AC348: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC34C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC350: 4BB21DC1  bl 0x823ce110
	ctx.lr = 0x828AC354;
	sub_823CE110(ctx, base);
	// 828AC354: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC358: 4B90B7C1  bl 0x821b7b18
	ctx.lr = 0x828AC35C;
	sub_821B7B18(ctx, base);
	// 828AC35C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AC360: 4B972EF9  bl 0x8221f258
	ctx.lr = 0x828AC364;
	sub_8221F258(ctx, base);
	// 828AC364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC36C: 419A005C  beq cr6, 0x828ac3c8
	if ctx.cr[6].eq {
	pc = 0x828AC3C8; continue 'dispatch;
	}
	// 828AC370: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AC374: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828AC378: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC37C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AC380: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AC384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AC388: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AC38C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AC390: 4B943EB1  bl 0x821f0240
	ctx.lr = 0x828AC394;
	sub_821F0240(ctx, base);
	// 828AC394: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AC398: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AC39C: 4B972EBD  bl 0x8221f258
	ctx.lr = 0x828AC3A0;
	sub_8221F258(ctx, base);
	// 828AC3A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AC3A4: 419A0028  beq cr6, 0x828ac3cc
	if ctx.cr[6].eq {
	pc = 0x828AC3CC; continue 'dispatch;
	}
	// 828AC3A8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AC3AC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AC3B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AC3B4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AC3B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AC3BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC3C0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AC3C4: 4800000C  b 0x828ac3d0
	pc = 0x828AC3D0; continue 'dispatch;
	// 828AC3C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC3CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AC3D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC3D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC3DC: 419A0008  beq cr6, 0x828ac3e4
	if ctx.cr[6].eq {
	pc = 0x828AC3E4; continue 'dispatch;
	}
	// 828AC3E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC3E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AC3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC3EC: 419A0078  beq cr6, 0x828ac464
	if ctx.cr[6].eq {
	pc = 0x828AC464; continue 'dispatch;
	}
	// 828AC3F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC3F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC3F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC3FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC400: 4B97CD09  bl 0x82229108
	ctx.lr = 0x828AC404;
	sub_82229108(ctx, base);
	// 828AC404: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC408: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC40C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC410: 3BCBDBF0  addi r30, r11, -0x2410
	ctx.r[30].s64 = ctx.r[11].s64 + -9232;
	// 828AC414: 4B97B46D  bl 0x82227880
	ctx.lr = 0x828AC418;
	sub_82227880(ctx, base);
	// 828AC418: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC41C: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AC420: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC424: 388AF040  addi r4, r10, -0xfc0
	ctx.r[4].s64 = ctx.r[10].s64 + -4032;
	// 828AC428: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC42C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AC430: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC434: 4B8EE64D  bl 0x8219aa80
	ctx.lr = 0x828AC438;
	sub_8219AA80(ctx, base);
	// 828AC438: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC43C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AC440: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC444: 4BB21FDD  bl 0x823ce420
	ctx.lr = 0x828AC448;
	sub_823CE420(ctx, base);
	// 828AC448: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC44C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AC450: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC454: 48178275  bl 0x82a246c8
	ctx.lr = 0x828AC458;
	sub_82A246C8(ctx, base);
	// 828AC458: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC45C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AC460: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AC464: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AC468: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC46C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AC470: 419A0020  beq cr6, 0x828ac490
	if ctx.cr[6].eq {
	pc = 0x828AC490; continue 'dispatch;
	}
	// 828AC474: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC478: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC47C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC480: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AC484: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC488: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC48C: 4082FFE8  bne 0x828ac474
	if !ctx.cr[0].eq {
	pc = 0x828AC474; continue 'dispatch;
	}
	// 828AC490: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC494: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC498: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AC49C: 4BA494AD  bl 0x822f5948
	ctx.lr = 0x828AC4A0;
	sub_822F5948(ctx, base);
	// 828AC4A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC4A4: 4B90B675  bl 0x821b7b18
	ctx.lr = 0x828AC4A8;
	sub_821B7B18(ctx, base);
	// 828AC4A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC4AC: 419A0040  beq cr6, 0x828ac4ec
	if ctx.cr[6].eq {
	pc = 0x828AC4EC; continue 'dispatch;
	}
	// 828AC4B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC4B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC4B8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC4BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AC4C0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC4C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC4C8: 4082FFE8  bne 0x828ac4b0
	if !ctx.cr[0].eq {
	pc = 0x828AC4B0; continue 'dispatch;
	}
	// 828AC4CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AC4D0: 409A001C  bne cr6, 0x828ac4ec
	if !ctx.cr[6].eq {
	pc = 0x828AC4EC; continue 'dispatch;
	}
	// 828AC4D4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC4D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC4DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AC4E0: 4E800421  bctrl
	ctx.lr = 0x828AC4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AC4E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC4E8: 4B96F851  bl 0x8221bd38
	ctx.lr = 0x828AC4EC;
	sub_8221BD38(ctx, base);
	// 828AC4EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC4F0: 4B90B629  bl 0x821b7b18
	ctx.lr = 0x828AC4F4;
	sub_821B7B18(ctx, base);
	// 828AC4F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AC4F8: 483FCF54  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC500 size=512
    let mut pc: u32 = 0x828AC500;
    'dispatch: loop {
        match pc {
            0x828AC500 => {
    //   block [0x828AC500..0x828AC700)
	// 828AC500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC504: 483FCEF9  bl 0x82ca93fc
	ctx.lr = 0x828AC508;
	sub_82CA93D0(ctx, base);
	// 828AC508: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC50C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC510: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AC514: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AC518: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828AC51C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AC520: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC524: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828AC528: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC530: 419A0008  beq cr6, 0x828ac538
	if ctx.cr[6].eq {
	pc = 0x828AC538; continue 'dispatch;
	}
	// 828AC534: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC538: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC53C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC540: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC544: 4BB2207D  bl 0x823ce5c0
	ctx.lr = 0x828AC548;
	sub_823CE5C0(ctx, base);
	// 828AC548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AC54C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC550: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC554: 4BB21BBD  bl 0x823ce110
	ctx.lr = 0x828AC558;
	sub_823CE110(ctx, base);
	// 828AC558: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC55C: 4B90B5BD  bl 0x821b7b18
	ctx.lr = 0x828AC560;
	sub_821B7B18(ctx, base);
	// 828AC560: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AC564: 4B972CF5  bl 0x8221f258
	ctx.lr = 0x828AC568;
	sub_8221F258(ctx, base);
	// 828AC568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC56C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC570: 419A005C  beq cr6, 0x828ac5cc
	if ctx.cr[6].eq {
	pc = 0x828AC5CC; continue 'dispatch;
	}
	// 828AC574: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AC578: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828AC57C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC580: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AC584: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AC588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AC58C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AC590: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AC594: 4B943CAD  bl 0x821f0240
	ctx.lr = 0x828AC598;
	sub_821F0240(ctx, base);
	// 828AC598: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AC59C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AC5A0: 4B972CB9  bl 0x8221f258
	ctx.lr = 0x828AC5A4;
	sub_8221F258(ctx, base);
	// 828AC5A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AC5A8: 419A0028  beq cr6, 0x828ac5d0
	if ctx.cr[6].eq {
	pc = 0x828AC5D0; continue 'dispatch;
	}
	// 828AC5AC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AC5B0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AC5B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AC5B8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AC5BC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AC5C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC5C4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AC5C8: 4800000C  b 0x828ac5d4
	pc = 0x828AC5D4; continue 'dispatch;
	// 828AC5CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC5D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AC5D4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC5D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC5DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC5E0: 419A0008  beq cr6, 0x828ac5e8
	if ctx.cr[6].eq {
	pc = 0x828AC5E8; continue 'dispatch;
	}
	// 828AC5E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC5E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AC5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC5F0: 419A0078  beq cr6, 0x828ac668
	if ctx.cr[6].eq {
	pc = 0x828AC668; continue 'dispatch;
	}
	// 828AC5F4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC5F8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC5FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC600: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC604: 4B97CB05  bl 0x82229108
	ctx.lr = 0x828AC608;
	sub_82229108(ctx, base);
	// 828AC608: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC60C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC610: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC614: 3BCBDD78  addi r30, r11, -0x2288
	ctx.r[30].s64 = ctx.r[11].s64 + -8840;
	// 828AC618: 4B97B269  bl 0x82227880
	ctx.lr = 0x828AC61C;
	sub_82227880(ctx, base);
	// 828AC61C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC620: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 828AC624: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC628: 388A1CE0  addi r4, r10, 0x1ce0
	ctx.r[4].s64 = ctx.r[10].s64 + 7392;
	// 828AC62C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC630: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AC634: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC638: 4B8EE449  bl 0x8219aa80
	ctx.lr = 0x828AC63C;
	sub_8219AA80(ctx, base);
	// 828AC63C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC640: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AC644: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC648: 4BB21DD9  bl 0x823ce420
	ctx.lr = 0x828AC64C;
	sub_823CE420(ctx, base);
	// 828AC64C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC650: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AC654: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC658: 48178071  bl 0x82a246c8
	ctx.lr = 0x828AC65C;
	sub_82A246C8(ctx, base);
	// 828AC65C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC660: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AC664: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AC668: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AC66C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC670: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AC674: 419A0020  beq cr6, 0x828ac694
	if ctx.cr[6].eq {
	pc = 0x828AC694; continue 'dispatch;
	}
	// 828AC678: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC67C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC680: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC684: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AC688: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC68C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC690: 4082FFE8  bne 0x828ac678
	if !ctx.cr[0].eq {
	pc = 0x828AC678; continue 'dispatch;
	}
	// 828AC694: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC698: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC69C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AC6A0: 4BA492A9  bl 0x822f5948
	ctx.lr = 0x828AC6A4;
	sub_822F5948(ctx, base);
	// 828AC6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC6A8: 4B90B471  bl 0x821b7b18
	ctx.lr = 0x828AC6AC;
	sub_821B7B18(ctx, base);
	// 828AC6AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AC6B0: 419A0040  beq cr6, 0x828ac6f0
	if ctx.cr[6].eq {
	pc = 0x828AC6F0; continue 'dispatch;
	}
	// 828AC6B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC6B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC6BC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC6C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AC6C4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC6C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC6CC: 4082FFE8  bne 0x828ac6b4
	if !ctx.cr[0].eq {
	pc = 0x828AC6B4; continue 'dispatch;
	}
	// 828AC6D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AC6D4: 409A001C  bne cr6, 0x828ac6f0
	if !ctx.cr[6].eq {
	pc = 0x828AC6F0; continue 'dispatch;
	}
	// 828AC6D8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC6DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AC6E4: 4E800421  bctrl
	ctx.lr = 0x828AC6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AC6E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC6EC: 4B96F64D  bl 0x8221bd38
	ctx.lr = 0x828AC6F0;
	sub_8221BD38(ctx, base);
	// 828AC6F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC6F4: 4B90B425  bl 0x821b7b18
	ctx.lr = 0x828AC6F8;
	sub_821B7B18(ctx, base);
	// 828AC6F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AC6FC: 483FCD50  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC700 size=448
    let mut pc: u32 = 0x828AC700;
    'dispatch: loop {
        match pc {
            0x828AC700 => {
    //   block [0x828AC700..0x828AC8C0)
	// 828AC700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC704: 483FCCF9  bl 0x82ca93fc
	ctx.lr = 0x828AC708;
	sub_82CA93D0(ctx, base);
	// 828AC708: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC70C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC710: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AC714: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AC718: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AC71C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AC720: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC724: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AC728: 3BAA9340  addi r29, r10, -0x6cc0
	ctx.r[29].s64 = ctx.r[10].s64 + -27840;
	// 828AC72C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC730: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC734: 419A0008  beq cr6, 0x828ac73c
	if ctx.cr[6].eq {
	pc = 0x828AC73C; continue 'dispatch;
	}
	// 828AC738: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC73C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC740: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC744: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC748: 4BB21E79  bl 0x823ce5c0
	ctx.lr = 0x828AC74C;
	sub_823CE5C0(ctx, base);
	// 828AC74C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AC750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC754: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC758: 4BB219B9  bl 0x823ce110
	ctx.lr = 0x828AC75C;
	sub_823CE110(ctx, base);
	// 828AC75C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC760: 4B90B3B9  bl 0x821b7b18
	ctx.lr = 0x828AC764;
	sub_821B7B18(ctx, base);
	// 828AC764: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AC768: 4B972AF1  bl 0x8221f258
	ctx.lr = 0x828AC76C;
	sub_8221F258(ctx, base);
	// 828AC76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC774: 419A002C  beq cr6, 0x828ac7a0
	if ctx.cr[6].eq {
	pc = 0x828AC7A0; continue 'dispatch;
	}
	// 828AC778: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AC77C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828AC780: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC784: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AC788: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AC78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AC790: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AC794: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AC798: 4B943AA9  bl 0x821f0240
	ctx.lr = 0x828AC79C;
	sub_821F0240(ctx, base);
	// 828AC79C: 48000008  b 0x828ac7a4
	pc = 0x828AC7A4; continue 'dispatch;
	// 828AC7A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828AC7A4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828AC7A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC7AC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828AC7B0: 419A0018  beq cr6, 0x828ac7c8
	if ctx.cr[6].eq {
	pc = 0x828AC7C8; continue 'dispatch;
	}
	// 828AC7B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC7B8: 48158509  bl 0x82a04cc0
	ctx.lr = 0x828AC7BC;
	sub_82A04CC0(ctx, base);
	// 828AC7BC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AC7C0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AC7C4: 4800000C  b 0x828ac7d0
	pc = 0x828AC7D0; continue 'dispatch;
	// 828AC7C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC7CC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828AC7D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC7D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC7DC: 419A0008  beq cr6, 0x828ac7e4
	if ctx.cr[6].eq {
	pc = 0x828AC7E4; continue 'dispatch;
	}
	// 828AC7E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC7E4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828AC7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC7EC: 419A0078  beq cr6, 0x828ac864
	if ctx.cr[6].eq {
	pc = 0x828AC864; continue 'dispatch;
	}
	// 828AC7F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC7F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC7F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC7FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC800: 4B97C909  bl 0x82229108
	ctx.lr = 0x828AC804;
	sub_82229108(ctx, base);
	// 828AC804: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC808: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC80C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC810: 3BCBDA60  addi r30, r11, -0x25a0
	ctx.r[30].s64 = ctx.r[11].s64 + -9632;
	// 828AC814: 4B97B06D  bl 0x82227880
	ctx.lr = 0x828AC818;
	sub_82227880(ctx, base);
	// 828AC818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC81C: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828AC820: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC824: 388A9E78  addi r4, r10, -0x6188
	ctx.r[4].s64 = ctx.r[10].s64 + -24968;
	// 828AC828: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC82C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AC830: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC834: 4B8EE24D  bl 0x8219aa80
	ctx.lr = 0x828AC838;
	sub_8219AA80(ctx, base);
	// 828AC838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC83C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AC840: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC844: 4BB21BDD  bl 0x823ce420
	ctx.lr = 0x828AC848;
	sub_823CE420(ctx, base);
	// 828AC848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC84C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AC850: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC854: 48177E75  bl 0x82a246c8
	ctx.lr = 0x828AC858;
	sub_82A246C8(ctx, base);
	// 828AC858: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AC85C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AC860: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AC864: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828AC868: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828AC86C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828AC870: 419A0020  beq cr6, 0x828ac890
	if ctx.cr[6].eq {
	pc = 0x828AC890; continue 'dispatch;
	}
	// 828AC874: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AC878: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC87C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AC880: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AC884: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC888: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC88C: 4082FFE8  bne 0x828ac874
	if !ctx.cr[0].eq {
	pc = 0x828AC874; continue 'dispatch;
	}
	// 828AC890: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC894: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC898: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AC89C: 4BA490AD  bl 0x822f5948
	ctx.lr = 0x828AC8A0;
	sub_822F5948(ctx, base);
	// 828AC8A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC8A4: 4B90B275  bl 0x821b7b18
	ctx.lr = 0x828AC8A8;
	sub_821B7B18(ctx, base);
	// 828AC8A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC8AC: 4B90B26D  bl 0x821b7b18
	ctx.lr = 0x828AC8B0;
	sub_821B7B18(ctx, base);
	// 828AC8B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC8B4: 4B90B265  bl 0x821b7b18
	ctx.lr = 0x828AC8B8;
	sub_821B7B18(ctx, base);
	// 828AC8B8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AC8BC: 483FCB90  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC8C0 size=512
    let mut pc: u32 = 0x828AC8C0;
    'dispatch: loop {
        match pc {
            0x828AC8C0 => {
    //   block [0x828AC8C0..0x828ACAC0)
	// 828AC8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC8C4: 483FCB39  bl 0x82ca93fc
	ctx.lr = 0x828AC8C8;
	sub_82CA93D0(ctx, base);
	// 828AC8C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC8CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC8D0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AC8D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AC8D8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828AC8DC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AC8E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC8E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828AC8E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC8EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC8F0: 419A0008  beq cr6, 0x828ac8f8
	if ctx.cr[6].eq {
	pc = 0x828AC8F8; continue 'dispatch;
	}
	// 828AC8F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC8F8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC8FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC900: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC904: 4BB21CBD  bl 0x823ce5c0
	ctx.lr = 0x828AC908;
	sub_823CE5C0(ctx, base);
	// 828AC908: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AC90C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC910: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC914: 4BB217FD  bl 0x823ce110
	ctx.lr = 0x828AC918;
	sub_823CE110(ctx, base);
	// 828AC918: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC91C: 4B90B1FD  bl 0x821b7b18
	ctx.lr = 0x828AC920;
	sub_821B7B18(ctx, base);
	// 828AC920: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AC924: 4B972935  bl 0x8221f258
	ctx.lr = 0x828AC928;
	sub_8221F258(ctx, base);
	// 828AC928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC92C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AC930: 419A005C  beq cr6, 0x828ac98c
	if ctx.cr[6].eq {
	pc = 0x828AC98C; continue 'dispatch;
	}
	// 828AC934: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AC938: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AC93C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC940: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AC944: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828AC948: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AC94C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AC950: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AC954: 4B9438ED  bl 0x821f0240
	ctx.lr = 0x828AC958;
	sub_821F0240(ctx, base);
	// 828AC958: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AC95C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AC960: 4B9728F9  bl 0x8221f258
	ctx.lr = 0x828AC964;
	sub_8221F258(ctx, base);
	// 828AC964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AC968: 419A0028  beq cr6, 0x828ac990
	if ctx.cr[6].eq {
	pc = 0x828AC990; continue 'dispatch;
	}
	// 828AC96C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AC970: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AC974: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AC978: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AC97C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AC980: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC984: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AC988: 4800000C  b 0x828ac994
	pc = 0x828AC994; continue 'dispatch;
	// 828AC98C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AC990: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AC994: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC998: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AC99C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC9A0: 419A0008  beq cr6, 0x828ac9a8
	if ctx.cr[6].eq {
	pc = 0x828AC9A8; continue 'dispatch;
	}
	// 828AC9A4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC9A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AC9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC9B0: 419A0078  beq cr6, 0x828aca28
	if ctx.cr[6].eq {
	pc = 0x828ACA28; continue 'dispatch;
	}
	// 828AC9B4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC9B8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AC9BC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC9C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC9C4: 4B97C745  bl 0x82229108
	ctx.lr = 0x828AC9C8;
	sub_82229108(ctx, base);
	// 828AC9C8: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AC9CC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AC9D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC9D4: 3BCBDEF0  addi r30, r11, -0x2110
	ctx.r[30].s64 = ctx.r[11].s64 + -8464;
	// 828AC9D8: 4B97AEA9  bl 0x82227880
	ctx.lr = 0x828AC9DC;
	sub_82227880(ctx, base);
	// 828AC9DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC9E0: 3D40821D  lis r10, -0x7de3
	ctx.r[10].s64 = -2112028672;
	// 828AC9E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AC9E8: 388A4CE8  addi r4, r10, 0x4ce8
	ctx.r[4].s64 = ctx.r[10].s64 + 19688;
	// 828AC9EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AC9F0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AC9F4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AC9F8: 4B8EE089  bl 0x8219aa80
	ctx.lr = 0x828AC9FC;
	sub_8219AA80(ctx, base);
	// 828AC9FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACA00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ACA04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACA08: 4BB21A19  bl 0x823ce420
	ctx.lr = 0x828ACA0C;
	sub_823CE420(ctx, base);
	// 828ACA0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACA10: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ACA14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACA18: 48177CB1  bl 0x82a246c8
	ctx.lr = 0x828ACA1C;
	sub_82A246C8(ctx, base);
	// 828ACA1C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACA20: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ACA24: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ACA28: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ACA2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACA30: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ACA34: 419A0020  beq cr6, 0x828aca54
	if ctx.cr[6].eq {
	pc = 0x828ACA54; continue 'dispatch;
	}
	// 828ACA38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACA3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACA40: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACA44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ACA48: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACA4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACA50: 4082FFE8  bne 0x828aca38
	if !ctx.cr[0].eq {
	pc = 0x828ACA38; continue 'dispatch;
	}
	// 828ACA54: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACA58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ACA5C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ACA60: 4BA48EE9  bl 0x822f5948
	ctx.lr = 0x828ACA64;
	sub_822F5948(ctx, base);
	// 828ACA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACA68: 4B90B0B1  bl 0x821b7b18
	ctx.lr = 0x828ACA6C;
	sub_821B7B18(ctx, base);
	// 828ACA6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACA70: 419A0040  beq cr6, 0x828acab0
	if ctx.cr[6].eq {
	pc = 0x828ACAB0; continue 'dispatch;
	}
	// 828ACA74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACA78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACA7C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACA80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ACA84: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACA88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACA8C: 4082FFE8  bne 0x828aca74
	if !ctx.cr[0].eq {
	pc = 0x828ACA74; continue 'dispatch;
	}
	// 828ACA90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ACA94: 409A001C  bne cr6, 0x828acab0
	if !ctx.cr[6].eq {
	pc = 0x828ACAB0; continue 'dispatch;
	}
	// 828ACA98: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACA9C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACAA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ACAA4: 4E800421  bctrl
	ctx.lr = 0x828ACAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ACAA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACAAC: 4B96F28D  bl 0x8221bd38
	ctx.lr = 0x828ACAB0;
	sub_8221BD38(ctx, base);
	// 828ACAB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACAB4: 4B90B065  bl 0x821b7b18
	ctx.lr = 0x828ACAB8;
	sub_821B7B18(ctx, base);
	// 828ACAB8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ACABC: 483FC990  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ACAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ACAC0 size=516
    let mut pc: u32 = 0x828ACAC0;
    'dispatch: loop {
        match pc {
            0x828ACAC0 => {
    //   block [0x828ACAC0..0x828ACCC4)
	// 828ACAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ACAC4: 483FC939  bl 0x82ca93fc
	ctx.lr = 0x828ACAC8;
	sub_82CA93D0(ctx, base);
	// 828ACAC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ACACC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ACAD0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ACAD4: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ACAD8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828ACADC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ACAE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACAE4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ACAE8: 3BAA9160  addi r29, r10, -0x6ea0
	ctx.r[29].s64 = ctx.r[10].s64 + -28320;
	// 828ACAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACAF0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACAF4: 419A0008  beq cr6, 0x828acafc
	if ctx.cr[6].eq {
	pc = 0x828ACAFC; continue 'dispatch;
	}
	// 828ACAF8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACAFC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACB00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACB04: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACB08: 4BB21AB9  bl 0x823ce5c0
	ctx.lr = 0x828ACB0C;
	sub_823CE5C0(ctx, base);
	// 828ACB0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ACB10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACB14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACB18: 4BB215F9  bl 0x823ce110
	ctx.lr = 0x828ACB1C;
	sub_823CE110(ctx, base);
	// 828ACB1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACB20: 4B90AFF9  bl 0x821b7b18
	ctx.lr = 0x828ACB24;
	sub_821B7B18(ctx, base);
	// 828ACB24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ACB28: 4B972731  bl 0x8221f258
	ctx.lr = 0x828ACB2C;
	sub_8221F258(ctx, base);
	// 828ACB2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ACB30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ACB34: 419A005C  beq cr6, 0x828acb90
	if ctx.cr[6].eq {
	pc = 0x828ACB90; continue 'dispatch;
	}
	// 828ACB38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ACB3C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ACB40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ACB44: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ACB48: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ACB4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ACB50: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ACB54: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ACB58: 4B9436E9  bl 0x821f0240
	ctx.lr = 0x828ACB5C;
	sub_821F0240(ctx, base);
	// 828ACB5C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ACB60: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ACB64: 4B9726F5  bl 0x8221f258
	ctx.lr = 0x828ACB68;
	sub_8221F258(ctx, base);
	// 828ACB68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ACB6C: 419A0028  beq cr6, 0x828acb94
	if ctx.cr[6].eq {
	pc = 0x828ACB94; continue 'dispatch;
	}
	// 828ACB70: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ACB74: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ACB78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ACB7C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ACB80: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ACB84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ACB88: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828ACB8C: 4800000C  b 0x828acb98
	pc = 0x828ACB98; continue 'dispatch;
	// 828ACB90: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ACB94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ACB98: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACB9C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACBA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACBA4: 419A0008  beq cr6, 0x828acbac
	if ctx.cr[6].eq {
	pc = 0x828ACBAC; continue 'dispatch;
	}
	// 828ACBA8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACBAC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ACBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACBB4: 419A0078  beq cr6, 0x828acc2c
	if ctx.cr[6].eq {
	pc = 0x828ACC2C; continue 'dispatch;
	}
	// 828ACBB8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACBBC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ACBC0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACBC4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACBC8: 4B97C541  bl 0x82229108
	ctx.lr = 0x828ACBCC;
	sub_82229108(ctx, base);
	// 828ACBCC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ACBD0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ACBD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACBD8: 3BCBDEF0  addi r30, r11, -0x2110
	ctx.r[30].s64 = ctx.r[11].s64 + -8464;
	// 828ACBDC: 4B97ACA5  bl 0x82227880
	ctx.lr = 0x828ACBE0;
	sub_82227880(ctx, base);
	// 828ACBE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ACBE4: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ACBE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ACBEC: 388AF0D8  addi r4, r10, -0xf28
	ctx.r[4].s64 = ctx.r[10].s64 + -3880;
	// 828ACBF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACBF4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828ACBF8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828ACBFC: 4B8EDE85  bl 0x8219aa80
	ctx.lr = 0x828ACC00;
	sub_8219AA80(ctx, base);
	// 828ACC00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACC04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ACC08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACC0C: 4BB21815  bl 0x823ce420
	ctx.lr = 0x828ACC10;
	sub_823CE420(ctx, base);
	// 828ACC10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACC14: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ACC18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACC1C: 48177AAD  bl 0x82a246c8
	ctx.lr = 0x828ACC20;
	sub_82A246C8(ctx, base);
	// 828ACC20: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACC24: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ACC28: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ACC2C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ACC30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACC34: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ACC38: 419A0020  beq cr6, 0x828acc58
	if ctx.cr[6].eq {
	pc = 0x828ACC58; continue 'dispatch;
	}
	// 828ACC3C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACC40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACC44: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACC48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ACC4C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACC50: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACC54: 4082FFE8  bne 0x828acc3c
	if !ctx.cr[0].eq {
	pc = 0x828ACC3C; continue 'dispatch;
	}
	// 828ACC58: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACC5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ACC60: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ACC64: 4BA48CE5  bl 0x822f5948
	ctx.lr = 0x828ACC68;
	sub_822F5948(ctx, base);
	// 828ACC68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACC6C: 4B90AEAD  bl 0x821b7b18
	ctx.lr = 0x828ACC70;
	sub_821B7B18(ctx, base);
	// 828ACC70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACC74: 419A0040  beq cr6, 0x828accb4
	if ctx.cr[6].eq {
	pc = 0x828ACCB4; continue 'dispatch;
	}
	// 828ACC78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACC7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACC80: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACC84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ACC88: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACC8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACC90: 4082FFE8  bne 0x828acc78
	if !ctx.cr[0].eq {
	pc = 0x828ACC78; continue 'dispatch;
	}
	// 828ACC94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ACC98: 409A001C  bne cr6, 0x828accb4
	if !ctx.cr[6].eq {
	pc = 0x828ACCB4; continue 'dispatch;
	}
	// 828ACC9C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACCA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACCA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ACCA8: 4E800421  bctrl
	ctx.lr = 0x828ACCAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ACCAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACCB0: 4B96F089  bl 0x8221bd38
	ctx.lr = 0x828ACCB4;
	sub_8221BD38(ctx, base);
	// 828ACCB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACCB8: 4B90AE61  bl 0x821b7b18
	ctx.lr = 0x828ACCBC;
	sub_821B7B18(ctx, base);
	// 828ACCBC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ACCC0: 483FC78C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ACCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ACCC8 size=516
    let mut pc: u32 = 0x828ACCC8;
    'dispatch: loop {
        match pc {
            0x828ACCC8 => {
    //   block [0x828ACCC8..0x828ACECC)
	// 828ACCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ACCCC: 483FC731  bl 0x82ca93fc
	ctx.lr = 0x828ACCD0;
	sub_82CA93D0(ctx, base);
	// 828ACCD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ACCD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ACCD8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ACCDC: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828ACCE0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828ACCE4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ACCE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACCEC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ACCF0: 3BAA7648  addi r29, r10, 0x7648
	ctx.r[29].s64 = ctx.r[10].s64 + 30280;
	// 828ACCF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACCF8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACCFC: 419A0008  beq cr6, 0x828acd04
	if ctx.cr[6].eq {
	pc = 0x828ACD04; continue 'dispatch;
	}
	// 828ACD00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACD04: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACD08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACD0C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACD10: 4BB218B1  bl 0x823ce5c0
	ctx.lr = 0x828ACD14;
	sub_823CE5C0(ctx, base);
	// 828ACD14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ACD18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACD1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACD20: 4BB213F1  bl 0x823ce110
	ctx.lr = 0x828ACD24;
	sub_823CE110(ctx, base);
	// 828ACD24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACD28: 4B90ADF1  bl 0x821b7b18
	ctx.lr = 0x828ACD2C;
	sub_821B7B18(ctx, base);
	// 828ACD2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ACD30: 4B972529  bl 0x8221f258
	ctx.lr = 0x828ACD34;
	sub_8221F258(ctx, base);
	// 828ACD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ACD38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ACD3C: 419A005C  beq cr6, 0x828acd98
	if ctx.cr[6].eq {
	pc = 0x828ACD98; continue 'dispatch;
	}
	// 828ACD40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ACD44: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ACD48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ACD4C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ACD50: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ACD54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ACD58: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ACD5C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ACD60: 4B9434E1  bl 0x821f0240
	ctx.lr = 0x828ACD64;
	sub_821F0240(ctx, base);
	// 828ACD64: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ACD68: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ACD6C: 4B9724ED  bl 0x8221f258
	ctx.lr = 0x828ACD70;
	sub_8221F258(ctx, base);
	// 828ACD70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ACD74: 419A0028  beq cr6, 0x828acd9c
	if ctx.cr[6].eq {
	pc = 0x828ACD9C; continue 'dispatch;
	}
	// 828ACD78: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ACD7C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ACD80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ACD84: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ACD88: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ACD8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ACD90: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828ACD94: 4800000C  b 0x828acda0
	pc = 0x828ACDA0; continue 'dispatch;
	// 828ACD98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ACD9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ACDA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACDA4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACDA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACDAC: 419A0008  beq cr6, 0x828acdb4
	if ctx.cr[6].eq {
	pc = 0x828ACDB4; continue 'dispatch;
	}
	// 828ACDB0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACDB4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ACDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACDBC: 419A0078  beq cr6, 0x828ace34
	if ctx.cr[6].eq {
	pc = 0x828ACE34; continue 'dispatch;
	}
	// 828ACDC0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACDC4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ACDC8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACDCC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACDD0: 4B97C339  bl 0x82229108
	ctx.lr = 0x828ACDD4;
	sub_82229108(ctx, base);
	// 828ACDD4: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ACDD8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ACDDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACDE0: 3BCBDEF0  addi r30, r11, -0x2110
	ctx.r[30].s64 = ctx.r[11].s64 + -8464;
	// 828ACDE4: 4B97AA9D  bl 0x82227880
	ctx.lr = 0x828ACDE8;
	sub_82227880(ctx, base);
	// 828ACDE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ACDEC: 3D408250  lis r10, -0x7db0
	ctx.r[10].s64 = -2108686336;
	// 828ACDF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ACDF4: 388A8990  addi r4, r10, -0x7670
	ctx.r[4].s64 = ctx.r[10].s64 + -30320;
	// 828ACDF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACDFC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828ACE00: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828ACE04: 4B8EDC7D  bl 0x8219aa80
	ctx.lr = 0x828ACE08;
	sub_8219AA80(ctx, base);
	// 828ACE08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACE0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ACE10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACE14: 4BB2160D  bl 0x823ce420
	ctx.lr = 0x828ACE18;
	sub_823CE420(ctx, base);
	// 828ACE18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACE1C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828ACE20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACE24: 481778A5  bl 0x82a246c8
	ctx.lr = 0x828ACE28;
	sub_82A246C8(ctx, base);
	// 828ACE28: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACE2C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828ACE30: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828ACE34: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ACE38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACE3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828ACE40: 419A0020  beq cr6, 0x828ace60
	if ctx.cr[6].eq {
	pc = 0x828ACE60; continue 'dispatch;
	}
	// 828ACE44: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACE48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE4C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACE50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828ACE54: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACE58: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE5C: 4082FFE8  bne 0x828ace44
	if !ctx.cr[0].eq {
	pc = 0x828ACE44; continue 'dispatch;
	}
	// 828ACE60: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACE64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ACE68: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828ACE6C: 4BA48ADD  bl 0x822f5948
	ctx.lr = 0x828ACE70;
	sub_822F5948(ctx, base);
	// 828ACE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACE74: 4B90ACA5  bl 0x821b7b18
	ctx.lr = 0x828ACE78;
	sub_821B7B18(ctx, base);
	// 828ACE78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828ACE7C: 419A0040  beq cr6, 0x828acebc
	if ctx.cr[6].eq {
	pc = 0x828ACEBC; continue 'dispatch;
	}
	// 828ACE80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828ACE84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE88: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828ACE8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ACE90: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACE94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE98: 4082FFE8  bne 0x828ace80
	if !ctx.cr[0].eq {
	pc = 0x828ACE80; continue 'dispatch;
	}
	// 828ACE9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ACEA0: 409A001C  bne cr6, 0x828acebc
	if !ctx.cr[6].eq {
	pc = 0x828ACEBC; continue 'dispatch;
	}
	// 828ACEA4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ACEA8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACEAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ACEB0: 4E800421  bctrl
	ctx.lr = 0x828ACEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ACEB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACEB8: 4B96EE81  bl 0x8221bd38
	ctx.lr = 0x828ACEBC;
	sub_8221BD38(ctx, base);
	// 828ACEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACEC0: 4B90AC59  bl 0x821b7b18
	ctx.lr = 0x828ACEC4;
	sub_821B7B18(ctx, base);
	// 828ACEC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828ACEC8: 483FC584  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ACED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ACED0 size=516
    let mut pc: u32 = 0x828ACED0;
    'dispatch: loop {
        match pc {
            0x828ACED0 => {
    //   block [0x828ACED0..0x828AD0D4)
	// 828ACED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ACED4: 483FC529  bl 0x82ca93fc
	ctx.lr = 0x828ACED8;
	sub_82CA93D0(ctx, base);
	// 828ACED8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ACEDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ACEE0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ACEE4: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828ACEE8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828ACEEC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828ACEF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACEF4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828ACEF8: 3BAA7D80  addi r29, r10, 0x7d80
	ctx.r[29].s64 = ctx.r[10].s64 + 32128;
	// 828ACEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACF00: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACF04: 419A0008  beq cr6, 0x828acf0c
	if ctx.cr[6].eq {
	pc = 0x828ACF0C; continue 'dispatch;
	}
	// 828ACF08: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACF0C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACF10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACF14: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACF18: 4BB216A9  bl 0x823ce5c0
	ctx.lr = 0x828ACF1C;
	sub_823CE5C0(ctx, base);
	// 828ACF1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828ACF20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACF24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ACF28: 4BB211E9  bl 0x823ce110
	ctx.lr = 0x828ACF2C;
	sub_823CE110(ctx, base);
	// 828ACF2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACF30: 4B90ABE9  bl 0x821b7b18
	ctx.lr = 0x828ACF34;
	sub_821B7B18(ctx, base);
	// 828ACF34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ACF38: 4B972321  bl 0x8221f258
	ctx.lr = 0x828ACF3C;
	sub_8221F258(ctx, base);
	// 828ACF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ACF40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ACF44: 419A005C  beq cr6, 0x828acfa0
	if ctx.cr[6].eq {
	pc = 0x828ACFA0; continue 'dispatch;
	}
	// 828ACF48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828ACF4C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ACF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ACF54: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828ACF58: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828ACF5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ACF60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828ACF64: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828ACF68: 4B9432D9  bl 0x821f0240
	ctx.lr = 0x828ACF6C;
	sub_821F0240(ctx, base);
	// 828ACF6C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ACF70: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828ACF74: 4B9722E5  bl 0x8221f258
	ctx.lr = 0x828ACF78;
	sub_8221F258(ctx, base);
	// 828ACF78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ACF7C: 419A0028  beq cr6, 0x828acfa4
	if ctx.cr[6].eq {
	pc = 0x828ACFA4; continue 'dispatch;
	}
	// 828ACF80: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828ACF84: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ACF88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ACF8C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828ACF90: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ACF94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ACF98: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828ACF9C: 4800000C  b 0x828acfa8
	pc = 0x828ACFA8; continue 'dispatch;
	// 828ACFA0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ACFA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ACFA8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACFAC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ACFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACFB4: 419A0008  beq cr6, 0x828acfbc
	if ctx.cr[6].eq {
	pc = 0x828ACFBC; continue 'dispatch;
	}
	// 828ACFB8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACFBC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828ACFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACFC4: 419A0078  beq cr6, 0x828ad03c
	if ctx.cr[6].eq {
	pc = 0x828AD03C; continue 'dispatch;
	}
	// 828ACFC8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACFCC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828ACFD0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACFD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACFD8: 4B97C131  bl 0x82229108
	ctx.lr = 0x828ACFDC;
	sub_82229108(ctx, base);
	// 828ACFDC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828ACFE0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828ACFE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ACFE8: 3BCBD728  addi r30, r11, -0x28d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10456;
	// 828ACFEC: 4B97A895  bl 0x82227880
	ctx.lr = 0x828ACFF0;
	sub_82227880(ctx, base);
	// 828ACFF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ACFF4: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828ACFF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ACFFC: 388AF180  addi r4, r10, -0xe80
	ctx.r[4].s64 = ctx.r[10].s64 + -3712;
	// 828AD000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD004: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AD008: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AD00C: 4B8EDA75  bl 0x8219aa80
	ctx.lr = 0x828AD010;
	sub_8219AA80(ctx, base);
	// 828AD010: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AD014: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AD018: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD01C: 4BB21405  bl 0x823ce420
	ctx.lr = 0x828AD020;
	sub_823CE420(ctx, base);
	// 828AD020: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AD024: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AD028: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD02C: 4817769D  bl 0x82a246c8
	ctx.lr = 0x828AD030;
	sub_82A246C8(ctx, base);
	// 828AD030: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD034: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AD038: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AD03C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AD040: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AD044: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AD048: 419A0020  beq cr6, 0x828ad068
	if ctx.cr[6].eq {
	pc = 0x828AD068; continue 'dispatch;
	}
	// 828AD04C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AD050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD054: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AD058: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AD05C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD060: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD064: 4082FFE8  bne 0x828ad04c
	if !ctx.cr[0].eq {
	pc = 0x828AD04C; continue 'dispatch;
	}
	// 828AD068: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD070: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AD074: 4BA488D5  bl 0x822f5948
	ctx.lr = 0x828AD078;
	sub_822F5948(ctx, base);
	// 828AD078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD07C: 4B90AA9D  bl 0x821b7b18
	ctx.lr = 0x828AD080;
	sub_821B7B18(ctx, base);
	// 828AD080: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AD084: 419A0040  beq cr6, 0x828ad0c4
	if ctx.cr[6].eq {
	pc = 0x828AD0C4; continue 'dispatch;
	}
	// 828AD088: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AD08C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD090: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AD094: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD098: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD09C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD0A0: 4082FFE8  bne 0x828ad088
	if !ctx.cr[0].eq {
	pc = 0x828AD088; continue 'dispatch;
	}
	// 828AD0A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD0A8: 409A001C  bne cr6, 0x828ad0c4
	if !ctx.cr[6].eq {
	pc = 0x828AD0C4; continue 'dispatch;
	}
	// 828AD0AC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD0B0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD0B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD0B8: 4E800421  bctrl
	ctx.lr = 0x828AD0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD0BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AD0C0: 4B96EC79  bl 0x8221bd38
	ctx.lr = 0x828AD0C4;
	sub_8221BD38(ctx, base);
	// 828AD0C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD0C8: 4B90AA51  bl 0x821b7b18
	ctx.lr = 0x828AD0CC;
	sub_821B7B18(ctx, base);
	// 828AD0CC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AD0D0: 483FC37C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD0D8 size=516
    let mut pc: u32 = 0x828AD0D8;
    'dispatch: loop {
        match pc {
            0x828AD0D8 => {
    //   block [0x828AD0D8..0x828AD2DC)
	// 828AD0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD0DC: 483FC321  bl 0x82ca93fc
	ctx.lr = 0x828AD0E0;
	sub_82CA93D0(ctx, base);
	// 828AD0E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD0E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AD0E8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AD0EC: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AD0F0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828AD0F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AD0F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD0FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AD100: 3BAA9568  addi r29, r10, -0x6a98
	ctx.r[29].s64 = ctx.r[10].s64 + -27288;
	// 828AD104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD108: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AD10C: 419A0008  beq cr6, 0x828ad114
	if ctx.cr[6].eq {
	pc = 0x828AD114; continue 'dispatch;
	}
	// 828AD110: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD114: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD118: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AD11C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD120: 4BB214A1  bl 0x823ce5c0
	ctx.lr = 0x828AD124;
	sub_823CE5C0(ctx, base);
	// 828AD124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AD128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD12C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AD130: 4BB20FE1  bl 0x823ce110
	ctx.lr = 0x828AD134;
	sub_823CE110(ctx, base);
	// 828AD134: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AD138: 4B90A9E1  bl 0x821b7b18
	ctx.lr = 0x828AD13C;
	sub_821B7B18(ctx, base);
	// 828AD13C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828AD140: 4B972119  bl 0x8221f258
	ctx.lr = 0x828AD144;
	sub_8221F258(ctx, base);
	// 828AD144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD148: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AD14C: 419A005C  beq cr6, 0x828ad1a8
	if ctx.cr[6].eq {
	pc = 0x828AD1A8; continue 'dispatch;
	}
	// 828AD150: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AD154: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828AD158: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD15C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828AD160: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AD164: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AD168: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AD16C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AD170: 4B9430D1  bl 0x821f0240
	ctx.lr = 0x828AD174;
	sub_821F0240(ctx, base);
	// 828AD174: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828AD178: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AD17C: 4B9720DD  bl 0x8221f258
	ctx.lr = 0x828AD180;
	sub_8221F258(ctx, base);
	// 828AD180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AD184: 419A0028  beq cr6, 0x828ad1ac
	if ctx.cr[6].eq {
	pc = 0x828AD1AC; continue 'dispatch;
	}
	// 828AD188: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828AD18C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828AD190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AD194: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828AD198: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AD19C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AD1A0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AD1A4: 4800000C  b 0x828ad1b0
	pc = 0x828AD1B0; continue 'dispatch;
	// 828AD1A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828AD1AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AD1B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD1B4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AD1B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD1BC: 419A0008  beq cr6, 0x828ad1c4
	if ctx.cr[6].eq {
	pc = 0x828AD1C4; continue 'dispatch;
	}
	// 828AD1C0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD1C4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AD1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD1CC: 419A0078  beq cr6, 0x828ad244
	if ctx.cr[6].eq {
	pc = 0x828AD244; continue 'dispatch;
	}
	// 828AD1D0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD1D4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AD1D8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD1DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD1E0: 4B97BF29  bl 0x82229108
	ctx.lr = 0x828AD1E4;
	sub_82229108(ctx, base);
	// 828AD1E4: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828AD1E8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828AD1EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD1F0: 3BCBE080  addi r30, r11, -0x1f80
	ctx.r[30].s64 = ctx.r[11].s64 + -8064;
	// 828AD1F4: 4B97A68D  bl 0x82227880
	ctx.lr = 0x828AD1F8;
	sub_82227880(ctx, base);
	// 828AD1F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AD1FC: 3D40828B  lis r10, -0x7d75
	ctx.r[10].s64 = -2104819712;
	// 828AD200: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AD204: 388AF220  addi r4, r10, -0xde0
	ctx.r[4].s64 = ctx.r[10].s64 + -3552;
	// 828AD208: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD20C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AD210: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AD214: 4B8ED86D  bl 0x8219aa80
	ctx.lr = 0x828AD218;
	sub_8219AA80(ctx, base);
	// 828AD218: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AD21C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AD220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD224: 4BB211FD  bl 0x823ce420
	ctx.lr = 0x828AD228;
	sub_823CE420(ctx, base);
	// 828AD228: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AD22C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828AD230: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AD234: 48177495  bl 0x82a246c8
	ctx.lr = 0x828AD238;
	sub_82A246C8(ctx, base);
	// 828AD238: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD23C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828AD240: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828AD244: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828AD248: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AD24C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AD250: 419A0020  beq cr6, 0x828ad270
	if ctx.cr[6].eq {
	pc = 0x828AD270; continue 'dispatch;
	}
	// 828AD254: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AD258: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD25C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AD260: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AD264: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD268: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD26C: 4082FFE8  bne 0x828ad254
	if !ctx.cr[0].eq {
	pc = 0x828AD254; continue 'dispatch;
	}
	// 828AD270: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD274: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD278: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828AD27C: 4BA486CD  bl 0x822f5948
	ctx.lr = 0x828AD280;
	sub_822F5948(ctx, base);
	// 828AD280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD284: 4B90A895  bl 0x821b7b18
	ctx.lr = 0x828AD288;
	sub_821B7B18(ctx, base);
	// 828AD288: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828AD28C: 419A0040  beq cr6, 0x828ad2cc
	if ctx.cr[6].eq {
	pc = 0x828AD2CC; continue 'dispatch;
	}
	// 828AD290: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AD294: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD298: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AD29C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD2A0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD2A4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD2A8: 4082FFE8  bne 0x828ad290
	if !ctx.cr[0].eq {
	pc = 0x828AD290; continue 'dispatch;
	}
	// 828AD2AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD2B0: 409A001C  bne cr6, 0x828ad2cc
	if !ctx.cr[6].eq {
	pc = 0x828AD2CC; continue 'dispatch;
	}
	// 828AD2B4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD2B8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD2BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD2C0: 4E800421  bctrl
	ctx.lr = 0x828AD2C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD2C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AD2C8: 4B96EA71  bl 0x8221bd38
	ctx.lr = 0x828AD2CC;
	sub_8221BD38(ctx, base);
	// 828AD2CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD2D0: 4B90A849  bl 0x821b7b18
	ctx.lr = 0x828AD2D4;
	sub_821B7B18(ctx, base);
	// 828AD2D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AD2D8: 483FC174  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD2E0 size=92
    let mut pc: u32 = 0x828AD2E0;
    'dispatch: loop {
        match pc {
            0x828AD2E0 => {
    //   block [0x828AD2E0..0x828AD33C)
	// 828AD2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD2E4: 483FC129  bl 0x82ca940c
	ctx.lr = 0x828AD2E8;
	sub_82CA93D0(ctx, base);
	// 828AD2E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD2EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828AD2F0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828AD2F4: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AD2F8: 419A0038  beq cr6, 0x828ad330
	if ctx.cr[6].eq {
	pc = 0x828AD330; continue 'dispatch;
	}
	// 828AD2FC: 7FDF2050  subf r30, r31, r4
	ctx.r[30].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 828AD300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AD304: 419A001C  beq cr6, 0x828ad320
	if ctx.cr[6].eq {
	pc = 0x828AD320; continue 'dispatch;
	}
	// 828AD308: 7C9EFA14  add r4, r30, r31
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 828AD30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD310: 4BFFCF39  bl 0x828aa248
	ctx.lr = 0x828AD314;
	sub_828AA248(ctx, base);
	// 828AD314: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828AD318: 7C9E1A14  add r4, r30, r3
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 828AD31C: 4BFFCF2D  bl 0x828aa248
	ctx.lr = 0x828AD320;
	sub_828AA248(ctx, base);
	// 828AD320: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 828AD324: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 828AD328: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AD32C: 409AFFD4  bne cr6, 0x828ad300
	if !ctx.cr[6].eq {
	pc = 0x828AD300; continue 'dispatch;
	}
	// 828AD330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD338: 483FC124  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AD340 size=12
    let mut pc: u32 = 0x828AD340;
    'dispatch: loop {
        match pc {
            0x828AD340 => {
    //   block [0x828AD340..0x828AD34C)
	// 828AD340: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 828AD344: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828AD348: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD34C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AD34C size=100
    let mut pc: u32 = 0x828AD34C;
    'dispatch: loop {
        match pc {
            0x828AD34C => {
    //   block [0x828AD34C..0x828AD3B0)
	// 828AD34C: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 828AD350: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 828AD354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AD358: 419A0040  beq cr6, 0x828ad398
	if ctx.cr[6].eq {
	pc = 0x828AD398; continue 'dispatch;
	}
	// 828AD35C: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 828AD360: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AD364: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD368: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 828AD36C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD370: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD374: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AD378: 419A0020  beq cr6, 0x828ad398
	if ctx.cr[6].eq {
	pc = 0x828AD398; continue 'dispatch;
	}
	// 828AD37C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828AD380: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD384: 7D005028  lwarx r8, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828AD388: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828AD38C: 7D00512D  stwcx. r8, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD390: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD394: 4082FFE8  bne 0x828ad37c
	if !ctx.cr[0].eq {
	pc = 0x828AD37C; continue 'dispatch;
	}
	// 828AD398: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 828AD39C: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 828AD3A0: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 828AD3A4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828AD3A8: 409AFFAC  bne cr6, 0x828ad354
	if !ctx.cr[6].eq {
	pc = 0x828AD354; continue 'dispatch;
	}
	// 828AD3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AD3B0 size=56
    let mut pc: u32 = 0x828AD3B0;
    'dispatch: loop {
        match pc {
            0x828AD3B0 => {
    //   block [0x828AD3B0..0x828AD3E8)
	// 828AD3B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AD3B4: 419A0018  beq cr6, 0x828ad3cc
	if ctx.cr[6].eq {
	pc = 0x828AD3CC; continue 'dispatch;
	}
	// 828AD3B8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AD3BC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828AD3C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD3C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD3C8: 409A0008  bne cr6, 0x828ad3d0
	if !ctx.cr[6].eq {
	pc = 0x828AD3D0; continue 'dispatch;
	}
	// 828AD3CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD3D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD3D8: 419A0010  beq cr6, 0x828ad3e8
	if ctx.cr[6].eq {
		sub_828AD3E8(ctx, base);
		return;
	}
	// 828AD3DC: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AD3E0: 5563B7FE  rlwinm r3, r11, 0x16, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 828AD3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AD3E8 size=8
    let mut pc: u32 = 0x828AD3E8;
    'dispatch: loop {
        match pc {
            0x828AD3E8 => {
    //   block [0x828AD3E8..0x828AD3F0)
	// 828AD3E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AD3EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD3F0 size=408
    let mut pc: u32 = 0x828AD3F0;
    'dispatch: loop {
        match pc {
            0x828AD3F0 => {
    //   block [0x828AD3F0..0x828AD588)
	// 828AD3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD3F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AD3FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD404: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828AD408: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AD40C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828AD410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD414: 419A0018  beq cr6, 0x828ad42c
	if ctx.cr[6].eq {
	pc = 0x828AD42C; continue 'dispatch;
	}
	// 828AD418: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AD41C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828AD420: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AD424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AD428: 409A0008  bne cr6, 0x828ad430
	if !ctx.cr[6].eq {
	pc = 0x828AD430; continue 'dispatch;
	}
	// 828AD42C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD430: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828AD434: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD438: 419A0134  beq cr6, 0x828ad56c
	if ctx.cr[6].eq {
	pc = 0x828AD56C; continue 'dispatch;
	}
	// 828AD43C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AD440: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD444: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828AD448: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828AD44C: 419A00F8  beq cr6, 0x828ad544
	if ctx.cr[6].eq {
	pc = 0x828AD544; continue 'dispatch;
	}
	// 828AD450: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AD454: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD458: 419A0024  beq cr6, 0x828ad47c
	if ctx.cr[6].eq {
	pc = 0x828AD47C; continue 'dispatch;
	}
	// 828AD45C: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828AD460: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD464: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828AD468: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AD46C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD470: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD474: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD478: 480000D0  b 0x828ad548
	pc = 0x828AD548; continue 'dispatch;
	// 828AD47C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD480: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AD484: 83CB004C  lwz r30, 0x4c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AD488: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828AD48C: 7D0AF050  subf r8, r10, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 828AD490: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD494: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD498: 40810054  ble 0x828ad4ec
	if !ctx.cr[0].gt {
	pc = 0x828AD4EC; continue 'dispatch;
	}
	// 828AD49C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AD4A0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828AD4A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AD4A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828AD4AC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD4B0: 2F06006A  cmpwi cr6, r6, 0x6a
	ctx.cr[6].compare_i32(ctx.r[6].s32, 106, &mut ctx.xer);
	// 828AD4B4: 41980008  blt cr6, 0x828ad4bc
	if ctx.cr[6].lt {
	pc = 0x828AD4BC; continue 'dispatch;
	}
	// 828AD4B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828AD4BC: 57E6063E  clrlwi r6, r31, 0x18
	ctx.r[6].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828AD4C0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828AD4C4: 419A0014  beq cr6, 0x828ad4d8
	if ctx.cr[6].eq {
	pc = 0x828AD4D8; continue 'dispatch;
	}
	// 828AD4C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AD4CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AD4D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD4D4: 4800000C  b 0x828ad4e0
	pc = 0x828AD4E0; continue 'dispatch;
	// 828AD4D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828AD4DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828AD4E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD4E4: 4199FFB8  bgt cr6, 0x828ad49c
	if ctx.cr[6].gt {
	pc = 0x828AD49C; continue 'dispatch;
	}
	// 828AD4E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD4EC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AD4F0: 419A0040  beq cr6, 0x828ad530
	if ctx.cr[6].eq {
	pc = 0x828AD530; continue 'dispatch;
	}
	// 828AD4F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD4F8: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828AD4FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD500: 41990008  bgt cr6, 0x828ad508
	if ctx.cr[6].gt {
	pc = 0x828AD508; continue 'dispatch;
	}
	// 828AD504: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD508: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD510: 409A0020  bne cr6, 0x828ad530
	if !ctx.cr[6].eq {
	pc = 0x828AD530; continue 'dispatch;
	}
	// 828AD514: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AD518: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AD51C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AD520: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD524: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD52C: 4800001C  b 0x828ad548
	pc = 0x828AD548; continue 'dispatch;
	// 828AD530: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828AD534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD538: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD53C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD540: 48000008  b 0x828ad548
	pc = 0x828AD548; continue 'dispatch;
	// 828AD544: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD548: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD550: 419A001C  beq cr6, 0x828ad56c
	if ctx.cr[6].eq {
	pc = 0x828AD56C; continue 'dispatch;
	}
	// 828AD554: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD558: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 828AD55C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828AD560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD564: 4E800421  bctrl
	ctx.lr = 0x828AD568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD568: 48000008  b 0x828ad570
	pc = 0x828AD570; continue 'dispatch;
	// 828AD56C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AD570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD57C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AD580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD588 size=412
    let mut pc: u32 = 0x828AD588;
    'dispatch: loop {
        match pc {
            0x828AD588 => {
    //   block [0x828AD588..0x828AD724)
	// 828AD588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD594: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD598: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828AD59C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AD5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD5A4: 419A0018  beq cr6, 0x828ad5bc
	if ctx.cr[6].eq {
	pc = 0x828AD5BC; continue 'dispatch;
	}
	// 828AD5A8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AD5AC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828AD5B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AD5B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AD5B8: 409A0008  bne cr6, 0x828ad5c0
	if !ctx.cr[6].eq {
	pc = 0x828AD5C0; continue 'dispatch;
	}
	// 828AD5BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD5C0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828AD5C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD5C8: 419A0144  beq cr6, 0x828ad70c
	if ctx.cr[6].eq {
	pc = 0x828AD70C; continue 'dispatch;
	}
	// 828AD5CC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AD5D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD5D4: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828AD5D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828AD5DC: 419A00F8  beq cr6, 0x828ad6d4
	if ctx.cr[6].eq {
	pc = 0x828AD6D4; continue 'dispatch;
	}
	// 828AD5E0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AD5E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD5E8: 419A0024  beq cr6, 0x828ad60c
	if ctx.cr[6].eq {
	pc = 0x828AD60C; continue 'dispatch;
	}
	// 828AD5EC: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828AD5F0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD5F4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828AD5F8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AD5FC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD600: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD604: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD608: 480000D0  b 0x828ad6d8
	pc = 0x828AD6D8; continue 'dispatch;
	// 828AD60C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD610: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AD614: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AD618: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828AD61C: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828AD620: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD624: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD628: 40810054  ble 0x828ad67c
	if !ctx.cr[0].gt {
	pc = 0x828AD67C; continue 'dispatch;
	}
	// 828AD62C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AD630: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AD634: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828AD638: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD63C: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828AD640: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828AD644: 41980008  blt cr6, 0x828ad64c
	if ctx.cr[6].lt {
	pc = 0x828AD64C; continue 'dispatch;
	}
	// 828AD648: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828AD64C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828AD650: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828AD654: 419A0014  beq cr6, 0x828ad668
	if ctx.cr[6].eq {
	pc = 0x828AD668; continue 'dispatch;
	}
	// 828AD658: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AD65C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AD660: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD664: 4800000C  b 0x828ad670
	pc = 0x828AD670; continue 'dispatch;
	// 828AD668: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828AD66C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828AD670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD674: 4199FFB8  bgt cr6, 0x828ad62c
	if ctx.cr[6].gt {
	pc = 0x828AD62C; continue 'dispatch;
	}
	// 828AD678: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD67C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AD680: 419A0040  beq cr6, 0x828ad6c0
	if ctx.cr[6].eq {
	pc = 0x828AD6C0; continue 'dispatch;
	}
	// 828AD684: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD688: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828AD68C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD690: 41990008  bgt cr6, 0x828ad698
	if ctx.cr[6].gt {
	pc = 0x828AD698; continue 'dispatch;
	}
	// 828AD694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD698: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD6A0: 409A0020  bne cr6, 0x828ad6c0
	if !ctx.cr[6].eq {
	pc = 0x828AD6C0; continue 'dispatch;
	}
	// 828AD6A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AD6A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AD6AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AD6B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD6B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD6B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD6BC: 4800001C  b 0x828ad6d8
	pc = 0x828AD6D8; continue 'dispatch;
	// 828AD6C0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828AD6C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD6C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD6CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD6D0: 48000008  b 0x828ad6d8
	pc = 0x828AD6D8; continue 'dispatch;
	// 828AD6D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD6D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD6E0: 419A002C  beq cr6, 0x828ad70c
	if ctx.cr[6].eq {
	pc = 0x828AD70C; continue 'dispatch;
	}
	// 828AD6E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD6E8: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828AD6EC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828AD6F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD6F4: 4E800421  bctrl
	ctx.lr = 0x828AD6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD6F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD6FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD708: 4E800020  blr
	return;
	// 828AD70C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AD710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD71C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD728 size=412
    let mut pc: u32 = 0x828AD728;
    'dispatch: loop {
        match pc {
            0x828AD728 => {
    //   block [0x828AD728..0x828AD8C4)
	// 828AD728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD734: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD738: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828AD73C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AD740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD744: 419A0018  beq cr6, 0x828ad75c
	if ctx.cr[6].eq {
	pc = 0x828AD75C; continue 'dispatch;
	}
	// 828AD748: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AD74C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828AD750: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AD754: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AD758: 409A0008  bne cr6, 0x828ad760
	if !ctx.cr[6].eq {
	pc = 0x828AD760; continue 'dispatch;
	}
	// 828AD75C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD760: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828AD764: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD768: 419A0144  beq cr6, 0x828ad8ac
	if ctx.cr[6].eq {
	pc = 0x828AD8AC; continue 'dispatch;
	}
	// 828AD76C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AD770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD774: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828AD778: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828AD77C: 419A00F8  beq cr6, 0x828ad874
	if ctx.cr[6].eq {
	pc = 0x828AD874; continue 'dispatch;
	}
	// 828AD780: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AD784: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD788: 419A0024  beq cr6, 0x828ad7ac
	if ctx.cr[6].eq {
	pc = 0x828AD7AC; continue 'dispatch;
	}
	// 828AD78C: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828AD790: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD794: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828AD798: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AD79C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD7A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD7A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD7A8: 480000D0  b 0x828ad878
	pc = 0x828AD878; continue 'dispatch;
	// 828AD7AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD7B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AD7B4: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AD7B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828AD7BC: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828AD7C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD7C4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD7C8: 40810054  ble 0x828ad81c
	if !ctx.cr[0].gt {
	pc = 0x828AD81C; continue 'dispatch;
	}
	// 828AD7CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AD7D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AD7D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828AD7D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD7DC: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828AD7E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828AD7E4: 41980008  blt cr6, 0x828ad7ec
	if ctx.cr[6].lt {
	pc = 0x828AD7EC; continue 'dispatch;
	}
	// 828AD7E8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828AD7EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828AD7F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828AD7F4: 419A0014  beq cr6, 0x828ad808
	if ctx.cr[6].eq {
	pc = 0x828AD808; continue 'dispatch;
	}
	// 828AD7F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AD7FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AD800: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD804: 4800000C  b 0x828ad810
	pc = 0x828AD810; continue 'dispatch;
	// 828AD808: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828AD80C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828AD810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD814: 4199FFB8  bgt cr6, 0x828ad7cc
	if ctx.cr[6].gt {
	pc = 0x828AD7CC; continue 'dispatch;
	}
	// 828AD818: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD81C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AD820: 419A0040  beq cr6, 0x828ad860
	if ctx.cr[6].eq {
	pc = 0x828AD860; continue 'dispatch;
	}
	// 828AD824: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD828: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828AD82C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD830: 41990008  bgt cr6, 0x828ad838
	if ctx.cr[6].gt {
	pc = 0x828AD838; continue 'dispatch;
	}
	// 828AD834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD838: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD840: 409A0020  bne cr6, 0x828ad860
	if !ctx.cr[6].eq {
	pc = 0x828AD860; continue 'dispatch;
	}
	// 828AD844: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AD848: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AD84C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AD850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD854: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD85C: 4800001C  b 0x828ad878
	pc = 0x828AD878; continue 'dispatch;
	// 828AD860: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828AD864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD868: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD86C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD870: 48000008  b 0x828ad878
	pc = 0x828AD878; continue 'dispatch;
	// 828AD874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD878: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD880: 419A002C  beq cr6, 0x828ad8ac
	if ctx.cr[6].eq {
	pc = 0x828AD8AC; continue 'dispatch;
	}
	// 828AD884: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AD888: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828AD88C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828AD890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD894: 4E800421  bctrl
	ctx.lr = 0x828AD898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD89C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD8A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD8A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD8A8: 4E800020  blr
	return;
	// 828AD8AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AD8B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD8B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD8B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD8C8 size=408
    let mut pc: u32 = 0x828AD8C8;
    'dispatch: loop {
        match pc {
            0x828AD8C8 => {
    //   block [0x828AD8C8..0x828ADA60)
	// 828AD8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD8D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD8D8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828AD8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD8E4: 419A0018  beq cr6, 0x828ad8fc
	if ctx.cr[6].eq {
	pc = 0x828AD8FC; continue 'dispatch;
	}
	// 828AD8E8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AD8EC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828AD8F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AD8F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AD8F8: 409A0008  bne cr6, 0x828ad900
	if !ctx.cr[6].eq {
	pc = 0x828AD900; continue 'dispatch;
	}
	// 828AD8FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD900: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828AD904: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD908: 419A0140  beq cr6, 0x828ada48
	if ctx.cr[6].eq {
	pc = 0x828ADA48; continue 'dispatch;
	}
	// 828AD90C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AD910: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AD914: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828AD918: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828AD91C: 419A00F8  beq cr6, 0x828ada14
	if ctx.cr[6].eq {
	pc = 0x828ADA14; continue 'dispatch;
	}
	// 828AD920: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AD924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AD928: 419A0024  beq cr6, 0x828ad94c
	if ctx.cr[6].eq {
	pc = 0x828AD94C; continue 'dispatch;
	}
	// 828AD92C: 894A006A  lbz r10, 0x6a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828AD930: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD934: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828AD938: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828AD93C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD940: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD948: 480000D0  b 0x828ada18
	pc = 0x828ADA18; continue 'dispatch;
	// 828AD94C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AD950: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AD954: 806B004C  lwz r3, 0x4c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AD958: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828AD95C: 7D0A1850  subf r8, r10, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 828AD960: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD964: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD968: 40810054  ble 0x828ad9bc
	if !ctx.cr[0].gt {
	pc = 0x828AD9BC; continue 'dispatch;
	}
	// 828AD96C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AD970: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AD974: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828AD978: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD97C: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828AD980: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828AD984: 41980008  blt cr6, 0x828ad98c
	if ctx.cr[6].lt {
	pc = 0x828AD98C; continue 'dispatch;
	}
	// 828AD988: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828AD98C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828AD990: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828AD994: 419A0014  beq cr6, 0x828ad9a8
	if ctx.cr[6].eq {
	pc = 0x828AD9A8; continue 'dispatch;
	}
	// 828AD998: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AD99C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AD9A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AD9A4: 4800000C  b 0x828ad9b0
	pc = 0x828AD9B0; continue 'dispatch;
	// 828AD9A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828AD9AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828AD9B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD9B4: 4199FFB8  bgt cr6, 0x828ad96c
	if ctx.cr[6].gt {
	pc = 0x828AD96C; continue 'dispatch;
	}
	// 828AD9B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AD9BC: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828AD9C0: 419A0040  beq cr6, 0x828ada00
	if ctx.cr[6].eq {
	pc = 0x828ADA00; continue 'dispatch;
	}
	// 828AD9C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD9C8: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828AD9CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD9D0: 41990008  bgt cr6, 0x828ad9d8
	if ctx.cr[6].gt {
	pc = 0x828AD9D8; continue 'dispatch;
	}
	// 828AD9D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AD9D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AD9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD9E0: 409A0020  bne cr6, 0x828ada00
	if !ctx.cr[6].eq {
	pc = 0x828ADA00; continue 'dispatch;
	}
	// 828AD9E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AD9E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AD9EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AD9F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD9F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AD9F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AD9FC: 4800001C  b 0x828ada18
	pc = 0x828ADA18; continue 'dispatch;
	// 828ADA00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828ADA04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADA08: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADA0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADA10: 48000008  b 0x828ada18
	pc = 0x828ADA18; continue 'dispatch;
	// 828ADA14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADA18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADA1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADA20: 419A0028  beq cr6, 0x828ada48
	if ctx.cr[6].eq {
	pc = 0x828ADA48; continue 'dispatch;
	}
	// 828ADA24: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ADA28: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828ADA2C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 828ADA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADA34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ADA38: 4E800421  bctrl
	ctx.lr = 0x828ADA3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ADA3C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADA60 size=396
    let mut pc: u32 = 0x828ADA60;
    'dispatch: loop {
        match pc {
            0x828ADA60 => {
    //   block [0x828ADA60..0x828ADBEC)
	// 828ADA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADA68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADA6C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828ADA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADA74: 419A0018  beq cr6, 0x828ada8c
	if ctx.cr[6].eq {
	pc = 0x828ADA8C; continue 'dispatch;
	}
	// 828ADA78: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ADA7C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828ADA80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ADA84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828ADA88: 409A0008  bne cr6, 0x828ada90
	if !ctx.cr[6].eq {
	pc = 0x828ADA90; continue 'dispatch;
	}
	// 828ADA8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADA90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828ADA94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADA98: 419A0140  beq cr6, 0x828adbd8
	if ctx.cr[6].eq {
	pc = 0x828ADBD8; continue 'dispatch;
	}
	// 828ADA9C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828ADAA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADAA4: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828ADAA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828ADAAC: 419A00F8  beq cr6, 0x828adba4
	if ctx.cr[6].eq {
	pc = 0x828ADBA4; continue 'dispatch;
	}
	// 828ADAB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828ADAB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADAB8: 419A0024  beq cr6, 0x828adadc
	if ctx.cr[6].eq {
	pc = 0x828ADADC; continue 'dispatch;
	}
	// 828ADABC: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828ADAC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADAC4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828ADAC8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828ADACC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADAD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADAD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADAD8: 480000D0  b 0x828adba8
	pc = 0x828ADBA8; continue 'dispatch;
	// 828ADADC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADAE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828ADAE4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828ADAE8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828ADAEC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828ADAF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADAF4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADAF8: 40810054  ble 0x828adb4c
	if !ctx.cr[0].gt {
	pc = 0x828ADB4C; continue 'dispatch;
	}
	// 828ADAFC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828ADB00: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828ADB04: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828ADB08: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADB0C: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828ADB10: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ADB14: 41980008  blt cr6, 0x828adb1c
	if ctx.cr[6].lt {
	pc = 0x828ADB1C; continue 'dispatch;
	}
	// 828ADB18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ADB1C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828ADB20: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828ADB24: 419A0014  beq cr6, 0x828adb38
	if ctx.cr[6].eq {
	pc = 0x828ADB38; continue 'dispatch;
	}
	// 828ADB28: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828ADB2C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828ADB30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ADB34: 4800000C  b 0x828adb40
	pc = 0x828ADB40; continue 'dispatch;
	// 828ADB38: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828ADB3C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828ADB40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADB44: 4199FFB8  bgt cr6, 0x828adafc
	if ctx.cr[6].gt {
	pc = 0x828ADAFC; continue 'dispatch;
	}
	// 828ADB48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADB4C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828ADB50: 419A0040  beq cr6, 0x828adb90
	if ctx.cr[6].eq {
	pc = 0x828ADB90; continue 'dispatch;
	}
	// 828ADB54: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADB58: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828ADB5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADB60: 41990008  bgt cr6, 0x828adb68
	if ctx.cr[6].gt {
	pc = 0x828ADB68; continue 'dispatch;
	}
	// 828ADB64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADB68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADB70: 409A0020  bne cr6, 0x828adb90
	if !ctx.cr[6].eq {
	pc = 0x828ADB90; continue 'dispatch;
	}
	// 828ADB74: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828ADB78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828ADB7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ADB80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADB84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADB88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADB8C: 4800001C  b 0x828adba8
	pc = 0x828ADBA8; continue 'dispatch;
	// 828ADB90: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828ADB94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADB98: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADB9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADBA0: 48000008  b 0x828adba8
	pc = 0x828ADBA8; continue 'dispatch;
	// 828ADBA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADBA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADBAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADBB0: 419A0028  beq cr6, 0x828adbd8
	if ctx.cr[6].eq {
	pc = 0x828ADBD8; continue 'dispatch;
	}
	// 828ADBB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADBB8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828ADBBC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828ADBC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ADBC4: 4E800421  bctrl
	ctx.lr = 0x828ADBC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ADBC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ADBCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADBD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADBD4: 4E800020  blr
	return;
	// 828ADBD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828ADBDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ADBE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADBE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADBF0 size=388
    let mut pc: u32 = 0x828ADBF0;
    'dispatch: loop {
        match pc {
            0x828ADBF0 => {
    //   block [0x828ADBF0..0x828ADD74)
	// 828ADBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADBF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADBFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADC00: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828ADC04: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828ADC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADC0C: 419A0018  beq cr6, 0x828adc24
	if ctx.cr[6].eq {
	pc = 0x828ADC24; continue 'dispatch;
	}
	// 828ADC10: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ADC14: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828ADC18: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ADC1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828ADC20: 409A0008  bne cr6, 0x828adc28
	if !ctx.cr[6].eq {
	pc = 0x828ADC28; continue 'dispatch;
	}
	// 828ADC24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADC28: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828ADC2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADC30: 419A0130  beq cr6, 0x828add60
	if ctx.cr[6].eq {
	pc = 0x828ADD60; continue 'dispatch;
	}
	// 828ADC34: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828ADC38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADC3C: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828ADC40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828ADC44: 419A00F8  beq cr6, 0x828add3c
	if ctx.cr[6].eq {
	pc = 0x828ADD3C; continue 'dispatch;
	}
	// 828ADC48: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828ADC4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADC50: 419A0024  beq cr6, 0x828adc74
	if ctx.cr[6].eq {
	pc = 0x828ADC74; continue 'dispatch;
	}
	// 828ADC54: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828ADC58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADC5C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828ADC60: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828ADC64: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADC68: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADC6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADC70: 480000D0  b 0x828add40
	pc = 0x828ADD40; continue 'dispatch;
	// 828ADC74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADC78: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828ADC7C: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828ADC80: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828ADC84: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828ADC88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADC8C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADC90: 40810054  ble 0x828adce4
	if !ctx.cr[0].gt {
	pc = 0x828ADCE4; continue 'dispatch;
	}
	// 828ADC94: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828ADC98: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828ADC9C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828ADCA0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADCA4: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828ADCA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ADCAC: 41980008  blt cr6, 0x828adcb4
	if ctx.cr[6].lt {
	pc = 0x828ADCB4; continue 'dispatch;
	}
	// 828ADCB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ADCB4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828ADCB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828ADCBC: 419A0014  beq cr6, 0x828adcd0
	if ctx.cr[6].eq {
	pc = 0x828ADCD0; continue 'dispatch;
	}
	// 828ADCC0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828ADCC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828ADCC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ADCCC: 4800000C  b 0x828adcd8
	pc = 0x828ADCD8; continue 'dispatch;
	// 828ADCD0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828ADCD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828ADCD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADCDC: 4199FFB8  bgt cr6, 0x828adc94
	if ctx.cr[6].gt {
	pc = 0x828ADC94; continue 'dispatch;
	}
	// 828ADCE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADCE4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828ADCE8: 419A0040  beq cr6, 0x828add28
	if ctx.cr[6].eq {
	pc = 0x828ADD28; continue 'dispatch;
	}
	// 828ADCEC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADCF0: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828ADCF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADCF8: 41990008  bgt cr6, 0x828add00
	if ctx.cr[6].gt {
	pc = 0x828ADD00; continue 'dispatch;
	}
	// 828ADCFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADD00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADD04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADD08: 409A0020  bne cr6, 0x828add28
	if !ctx.cr[6].eq {
	pc = 0x828ADD28; continue 'dispatch;
	}
	// 828ADD0C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828ADD10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828ADD14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ADD18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADD1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADD20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADD24: 4800001C  b 0x828add40
	pc = 0x828ADD40; continue 'dispatch;
	// 828ADD28: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828ADD2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADD30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADD34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADD38: 48000008  b 0x828add40
	pc = 0x828ADD40; continue 'dispatch;
	// 828ADD3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADD40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADD44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADD48: 419A0018  beq cr6, 0x828add60
	if ctx.cr[6].eq {
	pc = 0x828ADD60; continue 'dispatch;
	}
	// 828ADD4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADD50: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828ADD54: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828ADD58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ADD5C: 4E800421  bctrl
	ctx.lr = 0x828ADD60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ADD60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADD64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADD68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADD6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADD70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADD78 size=376
    let mut pc: u32 = 0x828ADD78;
    'dispatch: loop {
        match pc {
            0x828ADD78 => {
    //   block [0x828ADD78..0x828ADEF0)
	// 828ADD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADD7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADD80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADD84: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828ADD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADD8C: 419A0018  beq cr6, 0x828adda4
	if ctx.cr[6].eq {
	pc = 0x828ADDA4; continue 'dispatch;
	}
	// 828ADD90: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ADD94: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828ADD98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ADD9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828ADDA0: 409A0008  bne cr6, 0x828adda8
	if !ctx.cr[6].eq {
	pc = 0x828ADDA8; continue 'dispatch;
	}
	// 828ADDA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADDA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828ADDAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADDB0: 419A0130  beq cr6, 0x828adee0
	if ctx.cr[6].eq {
	pc = 0x828ADEE0; continue 'dispatch;
	}
	// 828ADDB4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828ADDB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADDBC: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828ADDC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828ADDC4: 419A00F8  beq cr6, 0x828adebc
	if ctx.cr[6].eq {
	pc = 0x828ADEBC; continue 'dispatch;
	}
	// 828ADDC8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828ADDCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADDD0: 419A0024  beq cr6, 0x828addf4
	if ctx.cr[6].eq {
	pc = 0x828ADDF4; continue 'dispatch;
	}
	// 828ADDD4: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828ADDD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADDDC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828ADDE0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828ADDE4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADDE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADDEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADDF0: 480000D0  b 0x828adec0
	pc = 0x828ADEC0; continue 'dispatch;
	// 828ADDF4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADDF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828ADDFC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828ADE00: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828ADE04: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828ADE08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADE0C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADE10: 40810054  ble 0x828ade64
	if !ctx.cr[0].gt {
	pc = 0x828ADE64; continue 'dispatch;
	}
	// 828ADE14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828ADE18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828ADE1C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828ADE20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADE24: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828ADE28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ADE2C: 41980008  blt cr6, 0x828ade34
	if ctx.cr[6].lt {
	pc = 0x828ADE34; continue 'dispatch;
	}
	// 828ADE30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ADE34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828ADE38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828ADE3C: 419A0014  beq cr6, 0x828ade50
	if ctx.cr[6].eq {
	pc = 0x828ADE50; continue 'dispatch;
	}
	// 828ADE40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828ADE44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828ADE48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ADE4C: 4800000C  b 0x828ade58
	pc = 0x828ADE58; continue 'dispatch;
	// 828ADE50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828ADE54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828ADE58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADE5C: 4199FFB8  bgt cr6, 0x828ade14
	if ctx.cr[6].gt {
	pc = 0x828ADE14; continue 'dispatch;
	}
	// 828ADE60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADE64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828ADE68: 419A0040  beq cr6, 0x828adea8
	if ctx.cr[6].eq {
	pc = 0x828ADEA8; continue 'dispatch;
	}
	// 828ADE6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADE70: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828ADE74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADE78: 41990008  bgt cr6, 0x828ade80
	if ctx.cr[6].gt {
	pc = 0x828ADE80; continue 'dispatch;
	}
	// 828ADE7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADE80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADE88: 409A0020  bne cr6, 0x828adea8
	if !ctx.cr[6].eq {
	pc = 0x828ADEA8; continue 'dispatch;
	}
	// 828ADE8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828ADE90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828ADE94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ADE98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADE9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADEA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADEA4: 4800001C  b 0x828adec0
	pc = 0x828ADEC0; continue 'dispatch;
	// 828ADEA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828ADEAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADEB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADEB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADEB8: 48000008  b 0x828adec0
	pc = 0x828ADEC0; continue 'dispatch;
	// 828ADEBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADEC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADEC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADEC8: 419A0018  beq cr6, 0x828adee0
	if ctx.cr[6].eq {
	pc = 0x828ADEE0; continue 'dispatch;
	}
	// 828ADECC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADED0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828ADED4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828ADED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ADEDC: 4E800421  bctrl
	ctx.lr = 0x828ADEE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ADEE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ADEE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADEE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADEEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADEF0 size=396
    let mut pc: u32 = 0x828ADEF0;
    'dispatch: loop {
        match pc {
            0x828ADEF0 => {
    //   block [0x828ADEF0..0x828AE07C)
	// 828ADEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADEF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADEFC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828ADF00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADF04: 419A0018  beq cr6, 0x828adf1c
	if ctx.cr[6].eq {
	pc = 0x828ADF1C; continue 'dispatch;
	}
	// 828ADF08: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ADF0C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828ADF10: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828ADF14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828ADF18: 409A0008  bne cr6, 0x828adf20
	if !ctx.cr[6].eq {
	pc = 0x828ADF20; continue 'dispatch;
	}
	// 828ADF1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADF20: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828ADF24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADF28: 419A0140  beq cr6, 0x828ae068
	if ctx.cr[6].eq {
	pc = 0x828AE068; continue 'dispatch;
	}
	// 828ADF2C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828ADF30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ADF34: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828ADF38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828ADF3C: 419A00F8  beq cr6, 0x828ae034
	if ctx.cr[6].eq {
	pc = 0x828AE034; continue 'dispatch;
	}
	// 828ADF40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828ADF44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ADF48: 419A0024  beq cr6, 0x828adf6c
	if ctx.cr[6].eq {
	pc = 0x828ADF6C; continue 'dispatch;
	}
	// 828ADF4C: 892A006A  lbz r9, 0x6a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(106 as u32) ) } as u64;
	// 828ADF50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADF54: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828ADF58: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828ADF5C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ADF60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828ADF64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADF68: 480000D0  b 0x828ae038
	pc = 0x828AE038; continue 'dispatch;
	// 828ADF6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ADF70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828ADF74: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828ADF78: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828ADF7C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828ADF80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADF84: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADF88: 40810054  ble 0x828adfdc
	if !ctx.cr[0].gt {
	pc = 0x828ADFDC; continue 'dispatch;
	}
	// 828ADF8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828ADF90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828ADF94: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828ADF98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADF9C: 2F07006A  cmpwi cr6, r7, 0x6a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 106, &mut ctx.xer);
	// 828ADFA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ADFA4: 41980008  blt cr6, 0x828adfac
	if ctx.cr[6].lt {
	pc = 0x828ADFAC; continue 'dispatch;
	}
	// 828ADFA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ADFAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828ADFB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828ADFB4: 419A0014  beq cr6, 0x828adfc8
	if ctx.cr[6].eq {
	pc = 0x828ADFC8; continue 'dispatch;
	}
	// 828ADFB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828ADFBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828ADFC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ADFC4: 4800000C  b 0x828adfd0
	pc = 0x828ADFD0; continue 'dispatch;
	// 828ADFC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828ADFCC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828ADFD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ADFD4: 4199FFB8  bgt cr6, 0x828adf8c
	if ctx.cr[6].gt {
	pc = 0x828ADF8C; continue 'dispatch;
	}
	// 828ADFD8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ADFDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828ADFE0: 419A0040  beq cr6, 0x828ae020
	if ctx.cr[6].eq {
	pc = 0x828AE020; continue 'dispatch;
	}
	// 828ADFE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADFE8: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828ADFEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ADFF0: 41990008  bgt cr6, 0x828adff8
	if ctx.cr[6].gt {
	pc = 0x828ADFF8; continue 'dispatch;
	}
	// 828ADFF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADFF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ADFFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE000: 409A0020  bne cr6, 0x828ae020
	if !ctx.cr[6].eq {
	pc = 0x828AE020; continue 'dispatch;
	}
	// 828AE004: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE008: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AE00C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE010: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE014: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AE018: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE01C: 4800001C  b 0x828ae038
	pc = 0x828AE038; continue 'dispatch;
	// 828AE020: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828AE024: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE028: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828AE02C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE030: 48000008  b 0x828ae038
	pc = 0x828AE038; continue 'dispatch;
	// 828AE034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AE03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE040: 419A0028  beq cr6, 0x828ae068
	if ctx.cr[6].eq {
	pc = 0x828AE068; continue 'dispatch;
	}
	// 828AE044: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE048: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828AE04C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828AE050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE054: 4E800421  bctrl
	ctx.lr = 0x828AE058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AE05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AE060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AE064: 4E800020  blr
	return;
	// 828AE068: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AE06C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AE070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AE074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AE078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AE080 size=464
    let mut pc: u32 = 0x828AE080;
    'dispatch: loop {
        match pc {
            0x828AE080 => {
    //   block [0x828AE080..0x828AE250)
	// 828AE080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE084: 483FB37D  bl 0x82ca9400
	ctx.lr = 0x828AE088;
	sub_82CA93D0(ctx, base);
	// 828AE088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE08C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828AE090: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828AE094: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 828AE098: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 828AE09C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AE0A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828AE0A4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 828AE0A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828AE0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE0B0: 419A0018  beq cr6, 0x828ae0c8
	if ctx.cr[6].eq {
	pc = 0x828AE0C8; continue 'dispatch;
	}
	// 828AE0B4: 892B0090  lbz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AE0B8: 55240672  rlwinm r4, r9, 0, 0x19, 0x19
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828AE0BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AE0C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AE0C4: 409A0008  bne cr6, 0x828ae0cc
	if !ctx.cr[6].eq {
	pc = 0x828AE0CC; continue 'dispatch;
	}
	// 828AE0C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AE0CC: 5489063E  clrlwi r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828AE0D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AE0D4: 419A0168  beq cr6, 0x828ae23c
	if ctx.cr[6].eq {
	pc = 0x828AE23C; continue 'dispatch;
	}
	// 828AE0D8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AE0DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AE0E0: 5523B7FE  rlwinm r3, r9, 0x16, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 828AE0E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE0E8: 419A00E8  beq cr6, 0x828ae1d0
	if ctx.cr[6].eq {
	pc = 0x828AE1D0; continue 'dispatch;
	}
	// 828AE0EC: 808B008C  lwz r4, 0x8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AE0F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AE0F4: 419A0020  beq cr6, 0x828ae114
	if ctx.cr[6].eq {
	pc = 0x828AE114; continue 'dispatch;
	}
	// 828AE0F8: 8924006A  lbz r9, 0x6a(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(106 as u32) ) } as u64;
	// 828AE0FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AE100: 5524183E  rotlwi r4, r9, 3
	ctx.r[4].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828AE104: 7C845A14  add r4, r4, r11
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828AE108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE10C: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE110: 480000C4  b 0x828ae1d4
	pc = 0x828AE1D4; continue 'dispatch;
	// 828AE114: 806B0048  lwz r3, 0x48(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AE118: 83AB004C  lwz r29, 0x4c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AE11C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828AE120: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 828AE124: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828AE128: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE12C: 40810054  ble 0x828ae180
	if !ctx.cr[0].gt {
	pc = 0x828AE180; continue 'dispatch;
	}
	// 828AE130: 7D7F0E70  srawi r31, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AE134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AE138: 57FE1838  slwi r30, r31, 3
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828AE13C: 7C7E1A14  add r3, r30, r3
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 828AE140: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE144: 2F09006A  cmpwi cr6, r9, 0x6a
	ctx.cr[6].compare_i32(ctx.r[9].s32, 106, &mut ctx.xer);
	// 828AE148: 41980008  blt cr6, 0x828ae150
	if ctx.cr[6].lt {
	pc = 0x828AE150; continue 'dispatch;
	}
	// 828AE14C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AE150: 5489063E  clrlwi r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828AE154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AE158: 419A0014  beq cr6, 0x828ae16c
	if ctx.cr[6].eq {
	pc = 0x828AE16C; continue 'dispatch;
	}
	// 828AE15C: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828AE160: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 828AE164: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AE168: 4800000C  b 0x828ae174
	pc = 0x828AE174; continue 'dispatch;
	// 828AE16C: 7C7E1850  subf r3, r30, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 828AE170: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828AE174: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE178: 4199FFB8  bgt cr6, 0x828ae130
	if ctx.cr[6].gt {
	pc = 0x828AE130; continue 'dispatch;
	}
	// 828AE17C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828AE180: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AE184: 419A003C  beq cr6, 0x828ae1c0
	if ctx.cr[6].eq {
	pc = 0x828AE1C0; continue 'dispatch;
	}
	// 828AE188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE18C: 2F0B006A  cmpwi cr6, r11, 0x6a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 106, &mut ctx.xer);
	// 828AE190: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE194: 41990008  bgt cr6, 0x828ae19c
	if ctx.cr[6].gt {
	pc = 0x828AE19C; continue 'dispatch;
	}
	// 828AE198: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE19C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AE1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE1A4: 409A001C  bne cr6, 0x828ae1c0
	if !ctx.cr[6].eq {
	pc = 0x828AE1C0; continue 'dispatch;
	}
	// 828AE1A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE1AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828AE1B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE1B4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE1BC: 48000018  b 0x828ae1d4
	pc = 0x828AE1D4; continue 'dispatch;
	// 828AE1C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828AE1C4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE1C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE1CC: 48000008  b 0x828ae1d4
	pc = 0x828AE1D4; continue 'dispatch;
	// 828AE1D0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE1D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AE1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE1DC: 419A0060  beq cr6, 0x828ae23c
	if ctx.cr[6].eq {
	pc = 0x828AE23C; continue 'dispatch;
	}
	// 828AE1E0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE1E4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 828AE1E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE1EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE1F0: 4E800421  bctrl
	ctx.lr = 0x828AE1F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE1F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE1F8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE1FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE200: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828AE204: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE208: 419A0020  beq cr6, 0x828ae228
	if ctx.cr[6].eq {
	pc = 0x828AE228; continue 'dispatch;
	}
	// 828AE20C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AE210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE214: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AE218: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AE21C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AE220: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE224: 4082FFE8  bne 0x828ae20c
	if !ctx.cr[0].eq {
	pc = 0x828AE20C; continue 'dispatch;
	}
	// 828AE228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE22C: 4B9098ED  bl 0x821b7b18
	ctx.lr = 0x828AE230;
	sub_821B7B18(ctx, base);
	// 828AE230: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE234: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AE238: 483FB218  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828AE23C: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828AE240: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE244: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828AE248: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AE24C: 483FB204  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE250 size=484
    let mut pc: u32 = 0x828AE250;
    'dispatch: loop {
        match pc {
            0x828AE250 => {
    //   block [0x828AE250..0x828AE434)
	// 828AE250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE254: 483FB1A5  bl 0x82ca93f8
	ctx.lr = 0x828AE258;
	sub_82CA93D0(ctx, base);
	// 828AE258: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE25C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AE260: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828AE264: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 828AE268: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 828AE26C: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 828AE270: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828AE274: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828AE278: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828AE27C: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828AE280: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828AE284: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 828AE288: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828AE28C: 409900A0  ble cr6, 0x828ae32c
	if !ctx.cr[6].gt {
	pc = 0x828AE32C; continue 'dispatch;
	}
	// 828AE290: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828AE294: 409900B8  ble cr6, 0x828ae34c
	if !ctx.cr[6].gt {
	pc = 0x828AE34C; continue 'dispatch;
	}
	// 828AE298: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AE29C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AE2A0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AE2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE2A8: 48000491  bl 0x828ae738
	ctx.lr = 0x828AE2AC;
	sub_828AE738(ctx, base);
	// 828AE2AC: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 828AE2B0: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AE2B4: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828AE2B8: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE2BC: 7CE9F050  subf r7, r9, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 828AE2C0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AE2C4: 7CDB4050  subf r6, r27, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[27].s64;
	// 828AE2C8: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 828AE2CC: 7CA7D3D6  divw r5, r7, r26
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	// 828AE2D0: 7C86D3D6  divw r4, r6, r26
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[26].s32;
	// 828AE2D4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828AE2D8: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 828AE2DC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AE2E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AE2E4: 40980020  bge cr6, 0x828ae304
	if !ctx.cr[6].lt {
	pc = 0x828AE304; continue 'dispatch;
	}
	// 828AE2E8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828AE2EC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE2F0: 4BFFFF61  bl 0x828ae250
	ctx.lr = 0x828AE2F4;
	sub_828AE250(ctx, base);
	// 828AE2F4: EB210058  ld r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AE2F8: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 828AE2FC: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828AE300: 4800001C  b 0x828ae31c
	pc = 0x828AE31C; continue 'dispatch;
	// 828AE304: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828AE308: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AE30C: 4BFFFF45  bl 0x828ae250
	ctx.lr = 0x828AE310;
	sub_828AE250(ctx, base);
	// 828AE310: EB010050  ld r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE314: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 828AE318: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828AE31C: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828AE320: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 828AE324: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828AE328: 4199FF68  bgt cr6, 0x828ae290
	if ctx.cr[6].gt {
	pc = 0x828AE290; continue 'dispatch;
	}
	// 828AE32C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828AE330: 40990014  ble cr6, 0x828ae344
	if !ctx.cr[6].gt {
	pc = 0x828AE344; continue 'dispatch;
	}
	// 828AE334: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AE338: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828AE33C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828AE340: 48277481  bl 0x82b257c0
	ctx.lr = 0x828AE344;
	sub_82B257C0(ctx, base);
	// 828AE344: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AE348: 483FB100  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828AE34C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828AE350: 4099FFDC  ble cr6, 0x828ae32c
	if !ctx.cr[6].gt {
	pc = 0x828AE32C; continue 'dispatch;
	}
	// 828AE354: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828AE358: 7FABD3D6  divw r29, r11, r26
	ctx.r[29].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 828AE35C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828AE360: 40990084  ble cr6, 0x828ae3e4
	if !ctx.cr[6].gt {
	pc = 0x828AE3E4; continue 'dispatch;
	}
	// 828AE364: 7FAB0E70  srawi r11, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 828AE368: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828AE36C: 40810078  ble 0x828ae3e4
	if !ctx.cr[0].gt {
	pc = 0x828AE3E4; continue 'dispatch;
	}
	// 828AE370: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE374: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828AE378: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE37C: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828AE380: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 828AE384: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 828AE388: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE38C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE390: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE398: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828AE39C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828AE3A0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828AE3A4: 419A0020  beq cr6, 0x828ae3c4
	if ctx.cr[6].eq {
	pc = 0x828AE3C4; continue 'dispatch;
	}
	// 828AE3A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AE3AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE3B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AE3B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AE3B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AE3BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE3C0: 4082FFE8  bne 0x828ae3a8
	if !ctx.cr[0].eq {
	pc = 0x828AE3A8; continue 'dispatch;
	}
	// 828AE3C4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828AE3C8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AE3CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828AE3D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE3D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828AE3D8: 48001071  bl 0x828af448
	ctx.lr = 0x828AE3DC;
	sub_828AF448(ctx, base);
	// 828AE3DC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828AE3E0: 4199FFA0  bgt cr6, 0x828ae380
	if ctx.cr[6].gt {
	pc = 0x828AE380; continue 'dispatch;
	}
	// 828AE3E4: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 828AE3E8: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828AE3EC: 4099FF58  ble cr6, 0x828ae344
	if !ctx.cr[6].gt {
	pc = 0x828AE344; continue 'dispatch;
	}
	// 828AE3F0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828AE3F4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE3F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828AE3FC: 40990018  ble cr6, 0x828ae414
	if !ctx.cr[6].gt {
	pc = 0x828AE414; continue 'dispatch;
	}
	// 828AE400: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AE404: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE408: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AE40C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828AE410: 480014C9  bl 0x828af8d8
	ctx.lr = 0x828AE414;
	sub_828AF8D8(ctx, base);
	// 828AE414: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 828AE418: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 828AE41C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828AE420: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 828AE424: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828AE428: 4199FFD8  bgt cr6, 0x828ae400
	if ctx.cr[6].gt {
	pc = 0x828AE400; continue 'dispatch;
	}
	// 828AE42C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AE430: 483FB018  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AE438 size=764
    let mut pc: u32 = 0x828AE438;
    'dispatch: loop {
        match pc {
            0x828AE438 => {
    //   block [0x828AE438..0x828AE734)
	// 828AE438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE43C: 483FAFC9  bl 0x82ca9404
	ctx.lr = 0x828AE440;
	sub_82CA93D0(ctx, base);
	// 828AE440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE444: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AE448: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828AE44C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AE450: 419A02D8  beq cr6, 0x828ae728
	if ctx.cr[6].eq {
	pc = 0x828AE728; continue 'dispatch;
	}
	// 828AE454: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE45C: 419A0018  beq cr6, 0x828ae474
	if ctx.cr[6].eq {
	pc = 0x828AE474; continue 'dispatch;
	}
	// 828AE460: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE464: 7D632050  subf r11, r3, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 828AE468: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828AE46C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AE470: 409A0064  bne cr6, 0x828ae4d4
	if !ctx.cr[6].eq {
	pc = 0x828AE4D4; continue 'dispatch;
	}
	// 828AE474: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE478: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE47C: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828AE480: 40990010  ble cr6, 0x828ae490
	if !ctx.cr[6].gt {
	pc = 0x828AE490; continue 'dispatch;
	}
	// 828AE484: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AE488: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828AE48C: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828AE490: 419A0298  beq cr6, 0x828ae728
	if ctx.cr[6].eq {
	pc = 0x828AE728; continue 'dispatch;
	}
	// 828AE494: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828AE498: 482BC5E1  bl 0x82b6aa78
	ctx.lr = 0x828AE49C;
	sub_82B6AA78(ctx, base);
	// 828AE49C: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE4A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AE4A4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828AE4A8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE4AC: 419A0018  beq cr6, 0x828ae4c4
	if ctx.cr[6].eq {
	pc = 0x828AE4C4; continue 'dispatch;
	}
	// 828AE4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE4B4: 4B909665  bl 0x821b7b18
	ctx.lr = 0x828AE4B8;
	sub_821B7B18(ctx, base);
	// 828AE4B8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828AE4BC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE4C0: 409AFFF0  bne cr6, 0x828ae4b0
	if !ctx.cr[6].eq {
	pc = 0x828AE4B0; continue 'dispatch;
	}
	// 828AE4C4: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828AE4C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE4CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE4D0: 483FAF84  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AE4D4: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE4D8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828AE4DC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828AE4E0: 409A000C  bne cr6, 0x828ae4ec
	if !ctx.cr[6].eq {
	pc = 0x828AE4EC; continue 'dispatch;
	}
	// 828AE4E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE4E8: 48000010  b 0x828ae4f8
	pc = 0x828AE4F8; continue 'dispatch;
	// 828AE4EC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE4F0: 7D255850  subf r9, r5, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 828AE4F4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AE4F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AE4FC: 41990080  bgt cr6, 0x828ae57c
	if ctx.cr[6].gt {
	pc = 0x828AE57C; continue 'dispatch;
	}
	// 828AE500: 482BC579  bl 0x82b6aa78
	ctx.lr = 0x828AE504;
	sub_82B6AA78(ctx, base);
	// 828AE504: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE50C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE510: 419A0018  beq cr6, 0x828ae528
	if ctx.cr[6].eq {
	pc = 0x828AE528; continue 'dispatch;
	}
	// 828AE514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE518: 4B909601  bl 0x821b7b18
	ctx.lr = 0x828AE51C;
	sub_821B7B18(ctx, base);
	// 828AE51C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828AE520: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE524: 409AFFF0  bne cr6, 0x828ae514
	if !ctx.cr[6].eq {
	pc = 0x828AE514; continue 'dispatch;
	}
	// 828AE528: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE530: 409A0024  bne cr6, 0x828ae554
	if !ctx.cr[6].eq {
	pc = 0x828AE554; continue 'dispatch;
	}
	// 828AE534: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE538: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE53C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE540: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE544: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AE548: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828AE54C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE550: 483FAF04  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AE554: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE558: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE55C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AE560: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE564: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AE568: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE56C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AE570: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828AE574: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE578: 483FAEDC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AE57C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828AE580: 409A000C  bne cr6, 0x828ae58c
	if !ctx.cr[6].eq {
	pc = 0x828AE58C; continue 'dispatch;
	}
	// 828AE584: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE588: 48000010  b 0x828ae598
	pc = 0x828AE598; continue 'dispatch;
	// 828AE58C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AE590: 7D255850  subf r9, r5, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 828AE594: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AE598: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AE59C: 419900A4  bgt cr6, 0x828ae640
	if ctx.cr[6].gt {
	pc = 0x828AE640; continue 'dispatch;
	}
	// 828AE5A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828AE5A4: 409A000C  bne cr6, 0x828ae5b0
	if !ctx.cr[6].eq {
	pc = 0x828AE5B0; continue 'dispatch;
	}
	// 828AE5A8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AE5AC: 48000010  b 0x828ae5bc
	pc = 0x828AE5BC; continue 'dispatch;
	// 828AE5B0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE5B4: 7D455850  subf r10, r5, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 828AE5B8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828AE5BC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE5C0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE5C4: 7FEB1A14  add r31, r11, r3
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828AE5C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE5CC: 482BC4AD  bl 0x82b6aa78
	ctx.lr = 0x828AE5D0;
	sub_82B6AA78(ctx, base);
	// 828AE5D0: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE5D4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE5D8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828AE5DC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AE5E0: 419A0144  beq cr6, 0x828ae724
	if ctx.cr[6].eq {
	pc = 0x828AE724; continue 'dispatch;
	}
	// 828AE5E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AE5E8: 419A0038  beq cr6, 0x828ae620
	if ctx.cr[6].eq {
	pc = 0x828AE620; continue 'dispatch;
	}
	// 828AE5EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE5F0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AE5F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE5F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AE5FC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AE600: 419A0020  beq cr6, 0x828ae620
	if ctx.cr[6].eq {
	pc = 0x828AE620; continue 'dispatch;
	}
	// 828AE604: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828AE608: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE60C: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828AE610: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828AE614: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AE618: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE61C: 4082FFE8  bne 0x828ae604
	if !ctx.cr[0].eq {
	pc = 0x828AE604; continue 'dispatch;
	}
	// 828AE620: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AE624: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AE628: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AE62C: 409AFFB8  bne cr6, 0x828ae5e4
	if !ctx.cr[6].eq {
	pc = 0x828AE5E4; continue 'dispatch;
	}
	// 828AE630: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AE634: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE638: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE63C: 483FAE18  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828AE640: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828AE644: 419A0030  beq cr6, 0x828ae674
	if ctx.cr[6].eq {
	pc = 0x828AE674; continue 'dispatch;
	}
	// 828AE648: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE64C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828AE650: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE654: 419A0018  beq cr6, 0x828ae66c
	if ctx.cr[6].eq {
	pc = 0x828AE66C; continue 'dispatch;
	}
	// 828AE658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE65C: 4B9094BD  bl 0x821b7b18
	ctx.lr = 0x828AE660;
	sub_821B7B18(ctx, base);
	// 828AE660: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828AE664: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AE668: 409AFFF0  bne cr6, 0x828ae658
	if !ctx.cr[6].eq {
	pc = 0x828AE658; continue 'dispatch;
	}
	// 828AE66C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE670: 4B96D6C9  bl 0x8221bd38
	ctx.lr = 0x828AE674;
	sub_8221BD38(ctx, base);
	// 828AE674: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE67C: 409A000C  bne cr6, 0x828ae688
	if !ctx.cr[6].eq {
	pc = 0x828AE688; continue 'dispatch;
	}
	// 828AE680: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AE684: 48000010  b 0x828ae694
	pc = 0x828AE694; continue 'dispatch;
	// 828AE688: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE68C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AE690: 7D241E70  srawi r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828AE694: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828AE698: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AE69C: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828AE6A0: 937C000C  stw r27, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 828AE6A4: 409A000C  bne cr6, 0x828ae6b0
	if !ctx.cr[6].eq {
	pc = 0x828AE6B0; continue 'dispatch;
	}
	// 828AE6A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AE6AC: 4800000C  b 0x828ae6b8
	pc = 0x828AE6B8; continue 'dispatch;
	// 828AE6B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE6B4: 4BABD38D  bl 0x8236ba40
	ctx.lr = 0x828AE6B8;
	sub_8236BA40(ctx, base);
	// 828AE6B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828AE6BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE6C0: 419A0068  beq cr6, 0x828ae728
	if ctx.cr[6].eq {
	pc = 0x828AE728; continue 'dispatch;
	}
	// 828AE6C4: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AE6C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE6CC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE6D0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AE6D4: 419A0050  beq cr6, 0x828ae724
	if ctx.cr[6].eq {
	pc = 0x828AE724; continue 'dispatch;
	}
	// 828AE6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AE6DC: 419A0038  beq cr6, 0x828ae714
	if ctx.cr[6].eq {
	pc = 0x828AE714; continue 'dispatch;
	}
	// 828AE6E0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE6E4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AE6E8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE6EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828AE6F0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828AE6F4: 419A0020  beq cr6, 0x828ae714
	if ctx.cr[6].eq {
	pc = 0x828AE714; continue 'dispatch;
	}
	// 828AE6F8: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828AE6FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE700: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828AE704: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828AE708: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AE70C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE710: 4082FFE8  bne 0x828ae6f8
	if !ctx.cr[0].eq {
	pc = 0x828AE6F8; continue 'dispatch;
	}
	// 828AE714: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AE718: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AE71C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828AE720: 409AFFB8  bne cr6, 0x828ae6d8
	if !ctx.cr[6].eq {
	pc = 0x828AE6D8; continue 'dispatch;
	}
	// 828AE724: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828AE728: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE72C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE730: 483FAD24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE738 size=748
    let mut pc: u32 = 0x828AE738;
    'dispatch: loop {
        match pc {
            0x828AE738 => {
    //   block [0x828AE738..0x828AEA24)
	// 828AE738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE73C: 483FACBD  bl 0x82ca93f8
	ctx.lr = 0x828AE740;
	sub_82CA93D0(ctx, base);
	// 828AE740: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE744: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 828AE748: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828AE74C: 834100DC  lwz r26, 0xdc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828AE750: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828AE754: F8A100E0  std r5, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[5].u64 ) };
	// 828AE758: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828AE75C: 832100E4  lwz r25, 0xe4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 828AE760: 3959FFF4  addi r10, r25, -0xc
	ctx.r[10].s64 = ctx.r[25].s64 + -12;
	// 828AE764: 7D3AC850  subf r9, r26, r25
	ctx.r[9].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 828AE768: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 828AE76C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828AE770: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828AE774: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 828AE778: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 828AE77C: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828AE780: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AE784: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AE788: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE78C: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828AE790: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828AE794: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AE798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AE79C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828AE7A0: 48000AB9  bl 0x828af258
	ctx.lr = 0x828AE7A4;
	sub_828AF258(ctx, base);
	// 828AE7A4: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 828AE7A8: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 828AE7AC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828AE7B0: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AE7B4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828AE7B8: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828AE7BC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE7C0: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 828AE7C4: 40980030  bge cr6, 0x828ae7f4
	if !ctx.cr[6].lt {
	pc = 0x828AE7F4; continue 'dispatch;
	}
	// 828AE7C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE7CC: 813FFFF4  lwz r9, -0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828AE7D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AE7D4: 41980020  blt cr6, 0x828ae7f4
	if ctx.cr[6].lt {
	pc = 0x828AE7F4; continue 'dispatch;
	}
	// 828AE7D8: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828AE7DC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AE7E0: 41980014  blt cr6, 0x828ae7f4
	if ctx.cr[6].lt {
	pc = 0x828AE7F4; continue 'dispatch;
	}
	// 828AE7E4: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 828AE7E8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828AE7EC: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AE7F0: 4198FFD8  blt cr6, 0x828ae7c8
	if ctx.cr[6].lt {
	pc = 0x828AE7C8; continue 'dispatch;
	}
	// 828AE7F4: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AE7F8: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE7FC: 40980028  bge cr6, 0x828ae824
	if !ctx.cr[6].lt {
	pc = 0x828AE824; continue 'dispatch;
	}
	// 828AE800: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE804: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE808: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AE80C: 41990018  bgt cr6, 0x828ae824
	if ctx.cr[6].gt {
	pc = 0x828AE824; continue 'dispatch;
	}
	// 828AE810: 41980014  blt cr6, 0x828ae824
	if ctx.cr[6].lt {
	pc = 0x828AE824; continue 'dispatch;
	}
	// 828AE814: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 828AE818: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828AE81C: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE820: 4198FFE4  blt cr6, 0x828ae804
	if ctx.cr[6].lt {
	pc = 0x828AE804; continue 'dispatch;
	}
	// 828AE824: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AE828: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE82C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828AE830: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 828AE834: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AE838: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AE83C: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE840: 40980058  bge cr6, 0x828ae898
	if !ctx.cr[6].lt {
	pc = 0x828AE898; continue 'dispatch;
	}
	// 828AE844: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE848: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE84C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AE850: 41990038  bgt cr6, 0x828ae888
	if ctx.cr[6].gt {
	pc = 0x828AE888; continue 'dispatch;
	}
	// 828AE854: 41980044  blt cr6, 0x828ae898
	if ctx.cr[6].lt {
	pc = 0x828AE898; continue 'dispatch;
	}
	// 828AE858: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AE85C: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 828AE860: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE864: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 828AE868: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828AE86C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828AE870: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AE874: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828AE878: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE87C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE880: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AE884: 4BBF850D  bl 0x824a6d90
	ctx.lr = 0x828AE888;
	sub_824A6D90(ctx, base);
	// 828AE888: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 828AE88C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828AE890: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE894: 4198FFB0  blt cr6, 0x828ae844
	if ctx.cr[6].lt {
	pc = 0x828AE844; continue 'dispatch;
	}
	// 828AE898: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828AE89C: 40990058  ble cr6, 0x828ae8f4
	if !ctx.cr[6].gt {
	pc = 0x828AE8F4; continue 'dispatch;
	}
	// 828AE8A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE8A4: 3BDCFFF4  addi r30, r28, -0xc
	ctx.r[30].s64 = ctx.r[28].s64 + -12;
	// 828AE8A8: 815CFFF4  lwz r10, -0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828AE8AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AE8B0: 41980034  blt cr6, 0x828ae8e4
	if ctx.cr[6].lt {
	pc = 0x828AE8E4; continue 'dispatch;
	}
	// 828AE8B4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE8B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AE8BC: 41980034  blt cr6, 0x828ae8f0
	if ctx.cr[6].lt {
	pc = 0x828AE8F0; continue 'dispatch;
	}
	// 828AE8C0: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 828AE8C4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AE8C8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828AE8CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828AE8D0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AE8D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE8D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AE8DC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE8E0: 4BBF84B1  bl 0x824a6d90
	ctx.lr = 0x828AE8E4;
	sub_824A6D90(ctx, base);
	// 828AE8E4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 828AE8E8: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828AE8EC: 4198FFB4  blt cr6, 0x828ae8a0
	if ctx.cr[6].lt {
	pc = 0x828AE8A0; continue 'dispatch;
	}
	// 828AE8F0: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828AE8F4: 409A0080  bne cr6, 0x828ae974
	if !ctx.cr[6].eq {
	pc = 0x828AE974; continue 'dispatch;
	}
	// 828AE8F8: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE8FC: 419A010C  beq cr6, 0x828aea08
	if ctx.cr[6].eq {
	pc = 0x828AEA08; continue 'dispatch;
	}
	// 828AE900: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828AE904: 419A0020  beq cr6, 0x828ae924
	if ctx.cr[6].eq {
	pc = 0x828AE924; continue 'dispatch;
	}
	// 828AE908: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE90C: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 828AE910: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE914: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AE918: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AE91C: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE920: 4BBF8471  bl 0x824a6d90
	ctx.lr = 0x828AE924;
	sub_824A6D90(ctx, base);
	// 828AE924: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AE928: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 828AE92C: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828AE930: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 828AE934: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828AE938: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828AE93C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828AE940: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828AE944: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828AE948: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AE94C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 828AE950: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 828AE954: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AE958: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828AE95C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE960: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE964: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828AE968: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828AE96C: 4BBF8425  bl 0x824a6d90
	ctx.lr = 0x828AE970;
	sub_824A6D90(ctx, base);
	// 828AE970: 4BFFFECC  b 0x828ae83c
	pc = 0x828AE83C; continue 'dispatch;
	// 828AE974: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828AE978: 3B9CFFF4  addi r28, r28, -0xc
	ctx.r[28].s64 = ctx.r[28].s64 + -12;
	// 828AE97C: 409A0058  bne cr6, 0x828ae9d4
	if !ctx.cr[6].eq {
	pc = 0x828AE9D4; continue 'dispatch;
	}
	// 828AE980: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 828AE984: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828AE988: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828AE98C: 419A0020  beq cr6, 0x828ae9ac
	if ctx.cr[6].eq {
	pc = 0x828AE9AC; continue 'dispatch;
	}
	// 828AE990: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE994: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828AE998: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE99C: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 828AE9A0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AE9A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE9A8: 4BBF83E9  bl 0x824a6d90
	ctx.lr = 0x828AE9AC;
	sub_824A6D90(ctx, base);
	// 828AE9AC: 3B7BFFF4  addi r27, r27, -0xc
	ctx.r[27].s64 = ctx.r[27].s64 + -12;
	// 828AE9B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE9B4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AE9B8: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 828AE9BC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828AE9C0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE9C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE9C8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AE9CC: 4BBF83C5  bl 0x824a6d90
	ctx.lr = 0x828AE9D0;
	sub_824A6D90(ctx, base);
	// 828AE9D0: 4BFFFE6C  b 0x828ae83c
	pc = 0x828AE83C; continue 'dispatch;
	// 828AE9D4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828AE9D8: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 828AE9DC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE9E0: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 828AE9E4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828AE9E8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828AE9EC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AE9F0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828AE9F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE9F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE9FC: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AEA00: 4BBF8391  bl 0x824a6d90
	ctx.lr = 0x828AEA04;
	sub_824A6D90(ctx, base);
	// 828AEA04: 4BFFFE38  b 0x828ae83c
	pc = 0x828AE83C; continue 'dispatch;
	// 828AEA08: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AEA0C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828AEA10: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEA14: F9780000  std r11, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828AEA18: F9580008  std r10, 8(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 828AEA1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828AEA20: 483FAA28  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEA28 size=168
    let mut pc: u32 = 0x828AEA28;
    'dispatch: loop {
        match pc {
            0x828AEA28 => {
    //   block [0x828AEA28..0x828AEAD0)
	// 828AEA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEA2C: 483FA9DD  bl 0x82ca9408
	ctx.lr = 0x828AEA30;
	sub_82CA93D0(ctx, base);
	// 828AEA30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEA34: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEA3C: 4B9796BD  bl 0x822280f8
	ctx.lr = 0x828AEA40;
	sub_822280F8(ctx, base);
	// 828AEA40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AEA44: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AEA48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AEA4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEA54: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AEA58: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEA5C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEA60: 4B979699  bl 0x822280f8
	ctx.lr = 0x828AEA64;
	sub_822280F8(ctx, base);
	// 828AEA64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEA68: 4B978AF9  bl 0x82227560
	ctx.lr = 0x828AEA6C;
	sub_82227560(ctx, base);
	// 828AEA6C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEA70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEA74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEA78: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEA7C: 4BF43BF5  bl 0x827f2670
	ctx.lr = 0x828AEA80;
	sub_827F2670(ctx, base);
	// 828AEA80: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEA84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AEA88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEA8C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEA90: 4E800421  bctrl
	ctx.lr = 0x828AEA94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEA94: 78680020  clrldi r8, r3, 0x20
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AEA98: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEA9C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828AEAA0: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828AEAA4: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEAA8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AEAAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEAB0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AEAB4: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AEAB8: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828AEABC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEAC0: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828AEAC4: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 828AEAC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEACC: 483FA98C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEAD0 size=200
    let mut pc: u32 = 0x828AEAD0;
    'dispatch: loop {
        match pc {
            0x828AEAD0 => {
    //   block [0x828AEAD0..0x828AEB98)
	// 828AEAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEAD4: 483FA931  bl 0x82ca9404
	ctx.lr = 0x828AEAD8;
	sub_82CA93D0(ctx, base);
	// 828AEAD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEADC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEAE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEAE4: 4B979615  bl 0x822280f8
	ctx.lr = 0x828AEAE8;
	sub_822280F8(ctx, base);
	// 828AEAE8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AEAEC: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 828AEAF0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828AEAF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AEAF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEB00: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AEB04: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AEB08: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEB0C: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEB10: 4B9795E9  bl 0x822280f8
	ctx.lr = 0x828AEB14;
	sub_822280F8(ctx, base);
	// 828AEB14: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEB18: 4B978A49  bl 0x82227560
	ctx.lr = 0x828AEB1C;
	sub_82227560(ctx, base);
	// 828AEB1C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AEB20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEB24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEB28: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEB2C: 4BA77B5D  bl 0x82326688
	ctx.lr = 0x828AEB30;
	sub_82326688(ctx, base);
	// 828AEB30: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEB34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEB38: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AEB3C: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828AEB40: 4BF43B31  bl 0x827f2670
	ctx.lr = 0x828AEB44;
	sub_827F2670(ctx, base);
	// 828AEB44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEB48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AEB4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEB50: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AEB54: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEB58: 4E800421  bctrl
	ctx.lr = 0x828AEB5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEB5C: 78670020  clrldi r7, r3, 0x20
	ctx.r[7].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AEB60: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEB64: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AEB68: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828AEB6C: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEB70: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AEB74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEB78: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AEB7C: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AEB80: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828AEB84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEB88: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828AEB8C: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828AEB90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEB94: 483FA8C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AEB98 size=56
    let mut pc: u32 = 0x828AEB98;
    'dispatch: loop {
        match pc {
            0x828AEB98 => {
    //   block [0x828AEB98..0x828AEBD0)
	// 828AEB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AEBA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEBA4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEBA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEBAC: 4B97954D  bl 0x822280f8
	ctx.lr = 0x828AEBB0;
	sub_822280F8(ctx, base);
	// 828AEBB0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828AEBB4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEBB8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEBBC: 48000A05  bl 0x828af5c0
	ctx.lr = 0x828AEBC0;
	sub_828AF5C0(ctx, base);
	// 828AEBC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AEBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AEBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AEBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEBD0 size=200
    let mut pc: u32 = 0x828AEBD0;
    'dispatch: loop {
        match pc {
            0x828AEBD0 => {
    //   block [0x828AEBD0..0x828AEC98)
	// 828AEBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEBD4: 483FA831  bl 0x82ca9404
	ctx.lr = 0x828AEBD8;
	sub_82CA93D0(ctx, base);
	// 828AEBD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEBDC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEBE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEBE4: 4B979515  bl 0x822280f8
	ctx.lr = 0x828AEBE8;
	sub_822280F8(ctx, base);
	// 828AEBE8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AEBEC: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 828AEBF0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828AEBF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AEBF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEC00: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AEC04: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AEC08: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEC0C: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEC10: 4B9794E9  bl 0x822280f8
	ctx.lr = 0x828AEC14;
	sub_822280F8(ctx, base);
	// 828AEC14: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEC18: 4B978949  bl 0x82227560
	ctx.lr = 0x828AEC1C;
	sub_82227560(ctx, base);
	// 828AEC1C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AEC20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEC24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEC28: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEC2C: 4BF43A45  bl 0x827f2670
	ctx.lr = 0x828AEC30;
	sub_827F2670(ctx, base);
	// 828AEC30: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEC34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEC38: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AEC3C: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828AEC40: 4BA77A49  bl 0x82326688
	ctx.lr = 0x828AEC44;
	sub_82326688(ctx, base);
	// 828AEC44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEC48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AEC4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEC50: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AEC54: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEC58: 4E800421  bctrl
	ctx.lr = 0x828AEC5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEC5C: 78670020  clrldi r7, r3, 0x20
	ctx.r[7].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AEC60: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEC64: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AEC68: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828AEC6C: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEC70: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AEC74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEC78: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AEC7C: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AEC80: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828AEC84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEC88: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828AEC8C: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828AEC90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEC94: 483FA7C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEC98 size=200
    let mut pc: u32 = 0x828AEC98;
    'dispatch: loop {
        match pc {
            0x828AEC98 => {
    //   block [0x828AEC98..0x828AED60)
	// 828AEC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEC9C: 483FA769  bl 0x82ca9404
	ctx.lr = 0x828AECA0;
	sub_82CA93D0(ctx, base);
	// 828AECA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AECA4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AECA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AECAC: 4B97944D  bl 0x822280f8
	ctx.lr = 0x828AECB0;
	sub_822280F8(ctx, base);
	// 828AECB0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AECB4: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 828AECB8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828AECBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AECC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AECC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AECC8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AECCC: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AECD0: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AECD4: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AECD8: 4B979421  bl 0x822280f8
	ctx.lr = 0x828AECDC;
	sub_822280F8(ctx, base);
	// 828AECDC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AECE0: 4B978881  bl 0x82227560
	ctx.lr = 0x828AECE4;
	sub_82227560(ctx, base);
	// 828AECE4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AECE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AECEC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AECF0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AECF4: 4BF4397D  bl 0x827f2670
	ctx.lr = 0x828AECF8;
	sub_827F2670(ctx, base);
	// 828AECF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AECFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AED00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AED04: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828AED08: 4BF43969  bl 0x827f2670
	ctx.lr = 0x828AED0C;
	sub_827F2670(ctx, base);
	// 828AED0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AED10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AED14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AED18: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AED1C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AED20: 4E800421  bctrl
	ctx.lr = 0x828AED24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AED24: 78670020  clrldi r7, r3, 0x20
	ctx.r[7].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AED28: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AED2C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AED30: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828AED34: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AED38: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AED3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AED40: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AED44: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AED48: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828AED4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AED50: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828AED54: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828AED58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AED5C: 483FA6F8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AED60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AED60 size=196
    let mut pc: u32 = 0x828AED60;
    'dispatch: loop {
        match pc {
            0x828AED60 => {
    //   block [0x828AED60..0x828AEE24)
	// 828AED60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AED64: 483FA6A1  bl 0x82ca9404
	ctx.lr = 0x828AED68;
	sub_82CA93D0(ctx, base);
	// 828AED68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AED6C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AED70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AED74: 4B979385  bl 0x822280f8
	ctx.lr = 0x828AED78;
	sub_822280F8(ctx, base);
	// 828AED78: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AED7C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AED80: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AED84: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828AED88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AED8C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AED90: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AED94: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AED98: 4B979361  bl 0x822280f8
	ctx.lr = 0x828AED9C;
	sub_822280F8(ctx, base);
	// 828AED9C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEDA0: 4B9787C1  bl 0x82227560
	ctx.lr = 0x828AEDA4;
	sub_82227560(ctx, base);
	// 828AEDA4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEDA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEDAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEDB0: 4B979349  bl 0x822280f8
	ctx.lr = 0x828AEDB4;
	sub_822280F8(ctx, base);
	// 828AEDB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEDB8: 4B9787A9  bl 0x82227560
	ctx.lr = 0x828AEDBC;
	sub_82227560(ctx, base);
	// 828AEDBC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEDC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEDC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AEDC8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEDCC: 4BF438A5  bl 0x827f2670
	ctx.lr = 0x828AEDD0;
	sub_827F2670(ctx, base);
	// 828AEDD0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEDD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AEDD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEDDC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AEDE0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEDE4: 4E800421  bctrl
	ctx.lr = 0x828AEDE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEDE8: 78680020  clrldi r8, r3, 0x20
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AEDEC: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEDF0: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828AEDF4: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828AEDF8: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEDFC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AEE00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEE04: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AEE08: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AEE0C: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828AEE10: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEE14: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828AEE18: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 828AEE1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEE20: 483FA634  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AEE28 size=188
    let mut pc: u32 = 0x828AEE28;
    'dispatch: loop {
        match pc {
            0x828AEE28 => {
    //   block [0x828AEE28..0x828AEEE4)
	// 828AEE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEE2C: 483FA5D5  bl 0x82ca9400
	ctx.lr = 0x828AEE30;
	sub_82CA93D0(ctx, base);
	// 828AEE30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEE34: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEE38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEE3C: 4B9792BD  bl 0x822280f8
	ctx.lr = 0x828AEE40;
	sub_822280F8(ctx, base);
	// 828AEE40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AEE44: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AEE48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AEE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEE50: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828AEE54: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AEE58: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEE5C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEE60: 4B979299  bl 0x822280f8
	ctx.lr = 0x828AEE64;
	sub_822280F8(ctx, base);
	// 828AEE64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEE68: 4B9786F9  bl 0x82227560
	ctx.lr = 0x828AEE6C;
	sub_82227560(ctx, base);
	// 828AEE6C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEE74: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828AEE78: 4B979281  bl 0x822280f8
	ctx.lr = 0x828AEE7C;
	sub_822280F8(ctx, base);
	// 828AEE7C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEE80: 4B9786E1  bl 0x82227560
	ctx.lr = 0x828AEE84;
	sub_82227560(ctx, base);
	// 828AEE84: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AEE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEE8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEE90: 4B979269  bl 0x822280f8
	ctx.lr = 0x828AEE94;
	sub_822280F8(ctx, base);
	// 828AEE94: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEE98: 4B9786C9  bl 0x82227560
	ctx.lr = 0x828AEE9C;
	sub_82227560(ctx, base);
	// 828AEE9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEEA0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEEA4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AEEA8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEEAC: 4BF437C5  bl 0x827f2670
	ctx.lr = 0x828AEEB0;
	sub_827F2670(ctx, base);
	// 828AEEB0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AEEB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828AEEB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEEBC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AEEC0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828AEEC4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEEC8: 4E800421  bctrl
	ctx.lr = 0x828AEECC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEECC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AEED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEED4: 4BAF40ED  bl 0x823a2fc0
	ctx.lr = 0x828AEED8;
	sub_823A2FC0(ctx, base);
	// 828AEED8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEEDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEEE0: 483FA570  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEEE8 size=196
    let mut pc: u32 = 0x828AEEE8;
    'dispatch: loop {
        match pc {
            0x828AEEE8 => {
    //   block [0x828AEEE8..0x828AEFAC)
	// 828AEEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEEEC: 483FA519  bl 0x82ca9404
	ctx.lr = 0x828AEEF0;
	sub_82CA93D0(ctx, base);
	// 828AEEF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEEF4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEEFC: 4B9791FD  bl 0x822280f8
	ctx.lr = 0x828AEF00;
	sub_822280F8(ctx, base);
	// 828AEF00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AEF04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AEF08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AEF0C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828AEF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEF14: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AEF18: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEF1C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEF20: 4B9791D9  bl 0x822280f8
	ctx.lr = 0x828AEF24;
	sub_822280F8(ctx, base);
	// 828AEF24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEF28: 4B978639  bl 0x82227560
	ctx.lr = 0x828AEF2C;
	sub_82227560(ctx, base);
	// 828AEF2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AEF30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEF38: 4B9791C1  bl 0x822280f8
	ctx.lr = 0x828AEF3C;
	sub_822280F8(ctx, base);
	// 828AEF3C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEF40: 4B978621  bl 0x82227560
	ctx.lr = 0x828AEF44;
	sub_82227560(ctx, base);
	// 828AEF44: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AEF48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEF4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AEF50: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AEF54: 4BF4371D  bl 0x827f2670
	ctx.lr = 0x828AEF58;
	sub_827F2670(ctx, base);
	// 828AEF58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AEF5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AEF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AEF64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AEF68: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AEF6C: 4E800421  bctrl
	ctx.lr = 0x828AEF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AEF70: 78680020  clrldi r8, r3, 0x20
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AEF74: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEF78: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828AEF7C: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828AEF80: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AEF84: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AEF88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AEF8C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AEF90: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AEF94: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828AEF98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AEF9C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828AEFA0: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 828AEFA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AEFA8: 483FA4AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AEFB0 size=140
    let mut pc: u32 = 0x828AEFB0;
    'dispatch: loop {
        match pc {
            0x828AEFB0 => {
    //   block [0x828AEFB0..0x828AF03C)
	// 828AEFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEFB4: 483FA455  bl 0x82ca9408
	ctx.lr = 0x828AEFB8;
	sub_82CA93D0(ctx, base);
	// 828AEFB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEFBC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AEFC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEFC4: 4B979135  bl 0x822280f8
	ctx.lr = 0x828AEFC8;
	sub_822280F8(ctx, base);
	// 828AEFC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AEFCC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AEFD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AEFD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEFD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AEFDC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AEFE0: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEFE4: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEFE8: 4B979111  bl 0x822280f8
	ctx.lr = 0x828AEFEC;
	sub_822280F8(ctx, base);
	// 828AEFEC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEFF0: 4B978571  bl 0x82227560
	ctx.lr = 0x828AEFF4;
	sub_82227560(ctx, base);
	// 828AEFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AEFF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AEFFC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF000: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF004: 4BA77685  bl 0x82326688
	ctx.lr = 0x828AF008;
	sub_82326688(ctx, base);
	// 828AF008: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AF00C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AF010: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF014: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AF018: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AF01C: 4E800421  bctrl
	ctx.lr = 0x828AF020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF020: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828AF024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF040 size=148
    let mut pc: u32 = 0x828AF040;
    'dispatch: loop {
        match pc {
            0x828AF040 => {
    //   block [0x828AF040..0x828AF0D4)
	// 828AF040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF044: 483FA3C5  bl 0x82ca9408
	ctx.lr = 0x828AF048;
	sub_82CA93D0(ctx, base);
	// 828AF048: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF04C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AF050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF054: 4B9790A5  bl 0x822280f8
	ctx.lr = 0x828AF058;
	sub_822280F8(ctx, base);
	// 828AF058: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AF05C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AF060: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AF064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF068: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828AF06C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AF070: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF074: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF078: 4B979081  bl 0x822280f8
	ctx.lr = 0x828AF07C;
	sub_822280F8(ctx, base);
	// 828AF07C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF080: 4B9784E1  bl 0x82227560
	ctx.lr = 0x828AF084;
	sub_82227560(ctx, base);
	// 828AF084: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF08C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AF090: 4B979069  bl 0x822280f8
	ctx.lr = 0x828AF094;
	sub_822280F8(ctx, base);
	// 828AF094: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF098: 4B9784C9  bl 0x82227560
	ctx.lr = 0x828AF09C;
	sub_82227560(ctx, base);
	// 828AF09C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF0A0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AF0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF0A8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF0AC: 4BA775DD  bl 0x82326688
	ctx.lr = 0x828AF0B0;
	sub_82326688(ctx, base);
	// 828AF0B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AF0B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF0B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF0BC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AF0C0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AF0C4: 4E800421  bctrl
	ctx.lr = 0x828AF0C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF0C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AF0CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AF0D0: 483FA388  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF0D8 size=168
    let mut pc: u32 = 0x828AF0D8;
    'dispatch: loop {
        match pc {
            0x828AF0D8 => {
    //   block [0x828AF0D8..0x828AF180)
	// 828AF0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF0DC: 483FA32D  bl 0x82ca9408
	ctx.lr = 0x828AF0E0;
	sub_82CA93D0(ctx, base);
	// 828AF0E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF0E4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AF0E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF0EC: 4B97900D  bl 0x822280f8
	ctx.lr = 0x828AF0F0;
	sub_822280F8(ctx, base);
	// 828AF0F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AF0F4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AF0F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AF0FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AF100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF104: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AF108: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF10C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF110: 4B978FE9  bl 0x822280f8
	ctx.lr = 0x828AF114;
	sub_822280F8(ctx, base);
	// 828AF114: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF118: 4B978449  bl 0x82227560
	ctx.lr = 0x828AF11C;
	sub_82227560(ctx, base);
	// 828AF11C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AF120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF124: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF128: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF12C: 4BA7755D  bl 0x82326688
	ctx.lr = 0x828AF130;
	sub_82326688(ctx, base);
	// 828AF130: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AF134: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AF138: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF13C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AF140: 4E800421  bctrl
	ctx.lr = 0x828AF144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF144: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 828AF148: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF14C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828AF150: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828AF154: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF158: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AF15C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AF160: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AF164: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AF168: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828AF16C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF170: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828AF174: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 828AF178: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AF17C: 483FA2DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF180 size=160
    let mut pc: u32 = 0x828AF180;
    'dispatch: loop {
        match pc {
            0x828AF180 => {
    //   block [0x828AF180..0x828AF220)
	// 828AF180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF184: 483FA281  bl 0x82ca9404
	ctx.lr = 0x828AF188;
	sub_82CA93D0(ctx, base);
	// 828AF188: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF18C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AF190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF194: 4B978F65  bl 0x822280f8
	ctx.lr = 0x828AF198;
	sub_822280F8(ctx, base);
	// 828AF198: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828AF19C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AF1A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828AF1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF1A8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828AF1AC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828AF1B0: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF1B4: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF1B8: 4B978F41  bl 0x822280f8
	ctx.lr = 0x828AF1BC;
	sub_822280F8(ctx, base);
	// 828AF1BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF1C0: 4B9783A1  bl 0x82227560
	ctx.lr = 0x828AF1C4;
	sub_82227560(ctx, base);
	// 828AF1C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF1C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF1CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AF1D0: 4B978F29  bl 0x822280f8
	ctx.lr = 0x828AF1D4;
	sub_822280F8(ctx, base);
	// 828AF1D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF1D8: 4B978389  bl 0x82227560
	ctx.lr = 0x828AF1DC;
	sub_82227560(ctx, base);
	// 828AF1DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF1E0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AF1E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AF1E8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF1EC: 4BA7749D  bl 0x82326688
	ctx.lr = 0x828AF1F0;
	sub_82326688(ctx, base);
	// 828AF1F0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AF1F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AF1F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AF1FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF200: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AF204: 4E800421  bctrl
	ctx.lr = 0x828AF208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF208: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AF20C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF210: 4BAF3DB1  bl 0x823a2fc0
	ctx.lr = 0x828AF214;
	sub_823A2FC0(ctx, base);
	// 828AF214: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AF218: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AF21C: 483FA238  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF220 size=56
    let mut pc: u32 = 0x828AF220;
    'dispatch: loop {
        match pc {
            0x828AF220 => {
    //   block [0x828AF220..0x828AF258)
	// 828AF220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AF228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF22C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828AF230: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AF234: 4B978EC5  bl 0x822280f8
	ctx.lr = 0x828AF238;
	sub_822280F8(ctx, base);
	// 828AF238: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828AF23C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF240: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF244: 4800045D  bl 0x828af6a0
	ctx.lr = 0x828AF248;
	sub_828AF6A0(ctx, base);
	// 828AF248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AF24C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AF250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AF254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF258 size=296
    let mut pc: u32 = 0x828AF258;
    'dispatch: loop {
        match pc {
            0x828AF258 => {
    //   block [0x828AF258..0x828AF380)
	// 828AF258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF25C: 483FA19D  bl 0x82ca93f8
	ctx.lr = 0x828AF260;
	sub_82CA93D0(ctx, base);
	// 828AF260: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AF268: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828AF26C: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 828AF270: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828AF274: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 828AF278: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828AF27C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828AF280: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828AF284: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828AF288: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 828AF28C: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828AF290: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 828AF294: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 828AF298: 409900D4  ble cr6, 0x828af36c
	if !ctx.cr[6].gt {
	pc = 0x828AF36C; continue 'dispatch;
	}
	// 828AF29C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AF2A0: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828AF2A4: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 828AF2A8: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828AF2AC: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828AF2B0: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828AF2B4: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AF2B8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828AF2BC: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828AF2C0: 54FF103A  slwi r31, r7, 2
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828AF2C4: 54B91838  slwi r25, r5, 3
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 828AF2C8: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828AF2CC: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 828AF2D0: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828AF2D4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828AF2D8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AF2DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF2E0: 480000A1  bl 0x828af380
	ctx.lr = 0x828AF2E4;
	sub_828AF380(ctx, base);
	// 828AF2E4: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828AF2E8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AF2EC: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 828AF2F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF2F4: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828AF2F8: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 828AF2FC: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828AF300: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 828AF304: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AF308: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF30C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AF310: 48000071  bl 0x828af380
	ctx.lr = 0x828AF314;
	sub_828AF380(ctx, base);
	// 828AF314: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828AF318: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828AF31C: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 828AF320: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828AF324: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AF328: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AF32C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AF330: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828AF334: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF338: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AF33C: 48000045  bl 0x828af380
	ctx.lr = 0x828AF340;
	sub_828AF380(ctx, base);
	// 828AF340: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828AF344: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828AF348: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828AF34C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF350: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828AF354: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828AF358: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF35C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828AF360: 48000021  bl 0x828af380
	ctx.lr = 0x828AF364;
	sub_828AF380(ctx, base);
	// 828AF364: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AF368: 483FA0E0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828AF36C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AF370: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF374: 4800000D  bl 0x828af380
	ctx.lr = 0x828AF378;
	sub_828AF380(ctx, base);
	// 828AF378: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AF37C: 483FA0CC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF380 size=200
    let mut pc: u32 = 0x828AF380;
    'dispatch: loop {
        match pc {
            0x828AF380 => {
    //   block [0x828AF380..0x828AF448)
	// 828AF380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AF388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AF38C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AF390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF394: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 828AF398: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 828AF39C: 83E1008C  lwz r31, 0x8c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AF3A0: 83C10084  lwz r30, 0x84(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828AF3A4: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 828AF3A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF3AC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF3B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AF3B4: 40980020  bge cr6, 0x828af3d4
	if !ctx.cr[6].lt {
	pc = 0x828AF3D4; continue 'dispatch;
	}
	// 828AF3B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF3BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF3C0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828AF3C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AF3C8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AF3CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AF3D0: 4BBF79C1  bl 0x824a6d90
	ctx.lr = 0x828AF3D4;
	sub_824A6D90(ctx, base);
	// 828AF3D4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828AF3D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF3DC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF3E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AF3E4: 40980020  bge cr6, 0x828af404
	if !ctx.cr[6].lt {
	pc = 0x828AF404; continue 'dispatch;
	}
	// 828AF3E8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF3EC: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828AF3F0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AF3F4: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828AF3F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AF3FC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828AF400: 4BBF7991  bl 0x824a6d90
	ctx.lr = 0x828AF404;
	sub_824A6D90(ctx, base);
	// 828AF404: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF408: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF40C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AF410: 40980020  bge cr6, 0x828af430
	if !ctx.cr[6].lt {
	pc = 0x828AF430; continue 'dispatch;
	}
	// 828AF414: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF418: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF41C: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828AF420: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AF424: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AF428: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AF42C: 4BBF7965  bl 0x824a6d90
	ctx.lr = 0x828AF430;
	sub_824A6D90(ctx, base);
	// 828AF430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AF434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AF438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AF43C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AF440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AF444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF448 size=372
    let mut pc: u32 = 0x828AF448;
    'dispatch: loop {
        match pc {
            0x828AF448 => {
    //   block [0x828AF448..0x828AF5BC)
	// 828AF448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF44C: 483F9FA5  bl 0x82ca93f0
	ctx.lr = 0x828AF450;
	sub_82CA93D0(ctx, base);
	// 828AF450: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF454: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 828AF458: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828AF45C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828AF460: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828AF464: FB0100D0  std r24, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[24].u64 ) };
	// 828AF468: 838100D4  lwz r28, 0xd4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828AF46C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 828AF470: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 828AF474: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 828AF478: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828AF47C: 409800AC  bge cr6, 0x828af528
	if !ctx.cr[6].lt {
	pc = 0x828AF528; continue 'dispatch;
	}
	// 828AF480: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF484: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828AF488: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF48C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828AF490: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 828AF494: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AF498: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828AF49C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF4A0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AF4A4: 40980008  bge cr6, 0x828af4ac
	if !ctx.cr[6].lt {
	pc = 0x828AF4AC; continue 'dispatch;
	}
	// 828AF4A8: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 828AF4AC: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF4B0: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF4B4: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828AF4B8: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828AF4BC: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF4C0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF4C4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828AF4C8: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828AF4CC: 3BAA0004  addi r29, r10, 4
	ctx.r[29].s64 = ctx.r[10].s64 + 4;
	// 828AF4D0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF4D4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828AF4D8: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF4DC: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF4E0: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AF4E4: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF4E8: 419A0028  beq cr6, 0x828af510
	if ctx.cr[6].eq {
	pc = 0x828AF510; continue 'dispatch;
	}
	// 828AF4EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF4F0: 4B908629  bl 0x821b7b18
	ctx.lr = 0x828AF4F4;
	sub_821B7B18(ctx, base);
	// 828AF4F4: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828AF4F8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AF4FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AF500: 419A0010  beq cr6, 0x828af510
	if ctx.cr[6].eq {
	pc = 0x828AF510; continue 'dispatch;
	}
	// 828AF504: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF508: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AF50C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AF510: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 828AF514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF518: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828AF51C: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828AF520: 4198FF60  blt cr6, 0x828af480
	if ctx.cr[6].lt {
	pc = 0x828AF480; continue 'dispatch;
	}
	// 828AF524: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828AF528: 409A0030  bne cr6, 0x828af558
	if !ctx.cr[6].eq {
	pc = 0x828AF558; continue 'dispatch;
	}
	// 828AF52C: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF530: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF534: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 828AF538: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828AF53C: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF540: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF544: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828AF548: 7C6AE214  add r3, r10, r28
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828AF54C: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 828AF550: 48276201  bl 0x82b25750
	ctx.lr = 0x828AF554;
	sub_82B25750(ctx, base);
	// 828AF554: 389AFFFF  addi r4, r26, -1
	ctx.r[4].s64 = ctx.r[26].s64 + -1;
	// 828AF558: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF55C: 3BF90004  addi r31, r25, 4
	ctx.r[31].s64 = ctx.r[25].s64 + 4;
	// 828AF560: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF564: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF56C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828AF570: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828AF574: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828AF578: 419A0020  beq cr6, 0x828af598
	if ctx.cr[6].eq {
	pc = 0x828AF598; continue 'dispatch;
	}
	// 828AF57C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AF580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AF588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AF58C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF594: 4082FFE8  bne 0x828af57c
	if !ctx.cr[0].eq {
	pc = 0x828AF57C; continue 'dispatch;
	}
	// 828AF598: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 828AF59C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AF5A0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 828AF5A4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828AF5A8: 48000249  bl 0x828af7f0
	ctx.lr = 0x828AF5AC;
	sub_828AF7F0(ctx, base);
	// 828AF5AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF5B0: 4B908569  bl 0x821b7b18
	ctx.lr = 0x828AF5B4;
	sub_821B7B18(ctx, base);
	// 828AF5B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828AF5B8: 483F9E88  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF5C0 size=220
    let mut pc: u32 = 0x828AF5C0;
    'dispatch: loop {
        match pc {
            0x828AF5C0 => {
    //   block [0x828AF5C0..0x828AF69C)
	// 828AF5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF5C4: 483F9E3D  bl 0x82ca9400
	ctx.lr = 0x828AF5C8;
	sub_82CA93D0(ctx, base);
	// 828AF5C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF5CC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AF5D0: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 828AF5D4: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 828AF5D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828AF5DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AF5E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF5E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AF5E8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF5EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AF5F0: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF5F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF5F8: 99680000  stb r11, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF5FC: 4B978AFD  bl 0x822280f8
	ctx.lr = 0x828AF600;
	sub_822280F8(ctx, base);
	// 828AF600: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF604: 4B977F5D  bl 0x82227560
	ctx.lr = 0x828AF608;
	sub_82227560(ctx, base);
	// 828AF608: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828AF60C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF610: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF614: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF618: 4BF43059  bl 0x827f2670
	ctx.lr = 0x828AF61C;
	sub_827F2670(ctx, base);
	// 828AF61C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AF620: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF624: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AF628: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828AF62C: 4BF43045  bl 0x827f2670
	ctx.lr = 0x828AF630;
	sub_827F2670(ctx, base);
	// 828AF630: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AF634: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF638: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AF63C: 88610052  lbz r3, 0x52(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828AF640: 4BF43031  bl 0x827f2670
	ctx.lr = 0x828AF644;
	sub_827F2670(ctx, base);
	// 828AF644: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AF648: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AF64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF650: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828AF654: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828AF658: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828AF65C: 4E800421  bctrl
	ctx.lr = 0x828AF660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF660: 78670020  clrldi r7, r3, 0x20
	ctx.r[7].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828AF664: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF668: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AF66C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828AF670: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828AF674: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828AF678: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AF67C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828AF680: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828AF684: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828AF688: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF68C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828AF690: 909D0008  stw r4, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828AF694: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828AF698: 483F9DB8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF6A0 size=332
    let mut pc: u32 = 0x828AF6A0;
    'dispatch: loop {
        match pc {
            0x828AF6A0 => {
    //   block [0x828AF6A0..0x828AF7EC)
	// 828AF6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF6A4: 483F9D55  bl 0x82ca93f8
	ctx.lr = 0x828AF6A8;
	sub_82CA93D0(ctx, base);
	// 828AF6A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF6AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AF6B0: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 828AF6B4: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 828AF6B8: 38E10053  addi r7, r1, 0x53
	ctx.r[7].s64 = ctx.r[1].s64 + 83;
	// 828AF6BC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 828AF6C0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828AF6C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AF6C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AF6CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828AF6D0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF6D8: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF6DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AF6E0: 99680000  stb r11, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF6E4: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF6E8: 99660000  stb r11, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828AF6EC: 4B978A0D  bl 0x822280f8
	ctx.lr = 0x828AF6F0;
	sub_822280F8(ctx, base);
	// 828AF6F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF6F4: 4B977E6D  bl 0x82227560
	ctx.lr = 0x828AF6F8;
	sub_82227560(ctx, base);
	// 828AF6F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF6FC: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828AF700: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF704: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AF708: 4BF42F69  bl 0x827f2670
	ctx.lr = 0x828AF70C;
	sub_827F2670(ctx, base);
	// 828AF70C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF710: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 828AF714: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828AF718: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828AF71C: 4BA5277D  bl 0x82301e98
	ctx.lr = 0x828AF720;
	sub_82301E98(ctx, base);
	// 828AF720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF724: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828AF728: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AF72C: 88610052  lbz r3, 0x52(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828AF730: 4BF42F41  bl 0x827f2670
	ctx.lr = 0x828AF734;
	sub_827F2670(ctx, base);
	// 828AF734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF738: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828AF73C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AF740: 88610053  lbz r3, 0x53(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 828AF744: 4BA52755  bl 0x82301e98
	ctx.lr = 0x828AF748;
	sub_82301E98(ctx, base);
	// 828AF748: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828AF74C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF750: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828AF754: 88610054  lbz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AF758: 4BF42F19  bl 0x827f2670
	ctx.lr = 0x828AF75C;
	sub_827F2670(ctx, base);
	// 828AF75C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AF760: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AF764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AF768: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AF76C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828AF770: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 828AF774: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 828AF778: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828AF77C: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 828AF780: 4E800421  bctrl
	ctx.lr = 0x828AF784;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF784: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF788: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF78C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF790: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828AF794: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828AF798: 419A0020  beq cr6, 0x828af7b8
	if ctx.cr[6].eq {
	pc = 0x828AF7B8; continue 'dispatch;
	}
	// 828AF79C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AF7A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF7A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AF7A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AF7AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF7B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF7B4: 4082FFE8  bne 0x828af79c
	if !ctx.cr[0].eq {
	pc = 0x828AF79C; continue 'dispatch;
	}
	// 828AF7B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AF7BC: 4B90835D  bl 0x821b7b18
	ctx.lr = 0x828AF7C0;
	sub_821B7B18(ctx, base);
	// 828AF7C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AF7C4: 419A0014  beq cr6, 0x828af7d8
	if ctx.cr[6].eq {
	pc = 0x828AF7D8; continue 'dispatch;
	}
	// 828AF7C8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828AF7CC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF7D4: 4B979935  bl 0x82229108
	ctx.lr = 0x828AF7D8;
	sub_82229108(ctx, base);
	// 828AF7D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AF7DC: 4B90833D  bl 0x821b7b18
	ctx.lr = 0x828AF7E0;
	sub_821B7B18(ctx, base);
	// 828AF7E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AF7E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AF7E8: 483F9C60  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF7F0 size=232
    let mut pc: u32 = 0x828AF7F0;
    'dispatch: loop {
        match pc {
            0x828AF7F0 => {
    //   block [0x828AF7F0..0x828AF8D8)
	// 828AF7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF7F4: 483F9C15  bl 0x82ca9408
	ctx.lr = 0x828AF7F8;
	sub_82CA93D0(ctx, base);
	// 828AF7F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF7FC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828AF800: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 828AF804: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828AF808: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828AF80C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828AF810: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828AF814: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 828AF818: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828AF81C: 7FE90194  addze r31, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828AF820: 40980050  bge cr6, 0x828af870
	if !ctx.cr[6].lt {
	pc = 0x828AF870; continue 'dispatch;
	}
	// 828AF824: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF828: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF82C: 7D1F5214  add r8, r31, r10
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828AF830: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF834: 7C8AF214  add r4, r10, r30
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828AF838: 7CEAF02E  lwzx r7, r10, r30
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828AF83C: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AF840: 40980030  bge cr6, 0x828af870
	if !ctx.cr[6].lt {
	pc = 0x828AF870; continue 'dispatch;
	}
	// 828AF844: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF848: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AF84C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF850: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828AF854: 48275EFD  bl 0x82b25750
	ctx.lr = 0x828AF858;
	sub_82B25750(ctx, base);
	// 828AF858: 395FFFFF  addi r10, r31, -1
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	// 828AF85C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828AF860: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 828AF864: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828AF868: 7FE90194  addze r31, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828AF86C: 4198FFB8  blt cr6, 0x828af824
	if ctx.cr[6].lt {
	pc = 0x828AF824; continue 'dispatch;
	}
	// 828AF870: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828AF874: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF878: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 828AF87C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AF880: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AF884: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828AF888: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 828AF88C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AF890: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF894: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF898: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828AF89C: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF8A0: 419A0028  beq cr6, 0x828af8c8
	if ctx.cr[6].eq {
	pc = 0x828AF8C8; continue 'dispatch;
	}
	// 828AF8A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF8A8: 4B908271  bl 0x821b7b18
	ctx.lr = 0x828AF8AC;
	sub_821B7B18(ctx, base);
	// 828AF8AC: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828AF8B0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828AF8B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AF8B8: 419A0010  beq cr6, 0x828af8c8
	if ctx.cr[6].eq {
	pc = 0x828AF8C8; continue 'dispatch;
	}
	// 828AF8BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF8C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AF8C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AF8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF8CC: 4B90824D  bl 0x821b7b18
	ctx.lr = 0x828AF8D0;
	sub_821B7B18(ctx, base);
	// 828AF8D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AF8D4: 483F9B84  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF8D8 size=212
    let mut pc: u32 = 0x828AF8D8;
    'dispatch: loop {
        match pc {
            0x828AF8D8 => {
    //   block [0x828AF8D8..0x828AF9AC)
	// 828AF8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF8DC: 483F9B21  bl 0x82ca93fc
	ctx.lr = 0x828AF8E0;
	sub_82CA93D0(ctx, base);
	// 828AF8E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF8E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AF8E8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 828AF8EC: FB4100C0  std r26, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u64 ) };
	// 828AF8F0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 828AF8F4: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828AF8F8: 3BCBFFF4  addi r30, r11, -0xc
	ctx.r[30].s64 = ctx.r[11].s64 + -12;
	// 828AF8FC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828AF900: 83EA0008  lwz r31, 8(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AF904: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF908: 838A0004  lwz r28, 4(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF90C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AF910: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828AF914: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828AF918: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828AF91C: 419A0020  beq cr6, 0x828af93c
	if ctx.cr[6].eq {
	pc = 0x828AF93C; continue 'dispatch;
	}
	// 828AF920: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AF924: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF928: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AF92C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AF930: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF934: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF938: 4082FFE8  bne 0x828af920
	if !ctx.cr[0].eq {
	pc = 0x828AF920; continue 'dispatch;
	}
	// 828AF93C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828AF940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF944: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AF948: 48275E09  bl 0x82b25750
	ctx.lr = 0x828AF94C;
	sub_82B25750(ctx, base);
	// 828AF94C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828AF950: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828AF954: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AF958: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828AF95C: 419A0020  beq cr6, 0x828af97c
	if ctx.cr[6].eq {
	pc = 0x828AF97C; continue 'dispatch;
	}
	// 828AF960: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AF964: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF968: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AF96C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AF970: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF974: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF978: 4082FFE8  bne 0x828af960
	if !ctx.cr[0].eq {
	pc = 0x828AF960; continue 'dispatch;
	}
	// 828AF97C: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828AF980: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 828AF984: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828AF988: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AF98C: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 828AF990: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828AF994: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AF998: 4BFFFAB1  bl 0x828af448
	ctx.lr = 0x828AF99C;
	sub_828AF448(ctx, base);
	// 828AF99C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828AF9A0: 4B908179  bl 0x821b7b18
	ctx.lr = 0x828AF9A4;
	sub_821B7B18(ctx, base);
	// 828AF9A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828AF9A8: 483F9AA4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AF9B0 size=8
    let mut pc: u32 = 0x828AF9B0;
    'dispatch: loop {
        match pc {
            0x828AF9B0 => {
    //   block [0x828AF9B0..0x828AF9B8)
	// 828AF9B0: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 828AF9B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF9B8 size=60
    let mut pc: u32 = 0x828AF9B8;
    'dispatch: loop {
        match pc {
            0x828AF9B8 => {
    //   block [0x828AF9B8..0x828AF9F4)
	// 828AF9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AF9C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AF9C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF9C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828AF9CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828AF9D0: 388B99C0  addi r4, r11, -0x6640
	ctx.r[4].s64 = ctx.r[11].s64 + -26176;
	// 828AF9D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF9D8: 4B97D4F9  bl 0x8222ced0
	ctx.lr = 0x828AF9DC;
	sub_8222CED0(ctx, base);
	// 828AF9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AF9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AF9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AF9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AF9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AF9F8 size=96
    let mut pc: u32 = 0x828AF9F8;
    'dispatch: loop {
        match pc {
            0x828AF9F8 => {
    //   block [0x828AF9F8..0x828AFA58)
	// 828AF9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFA00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AFA04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFA08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFA0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFA10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AFA14: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828AFA18: 48000BD9  bl 0x828b05f0
	ctx.lr = 0x828AFA1C;
	sub_828B05F0(ctx, base);
	// 828AFA1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828AFA20: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828AFA24: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828AFA28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AFA2C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828AFA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFA34: 419A000C  beq cr6, 0x828afa40
	if ctx.cr[6].eq {
	pc = 0x828AFA40; continue 'dispatch;
	}
	// 828AFA38: 4B96C301  bl 0x8221bd38
	ctx.lr = 0x828AFA3C;
	sub_8221BD38(ctx, base);
	// 828AFA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFA40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFA44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFA48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFA4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AFA50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFA54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFA58 size=1232
    let mut pc: u32 = 0x828AFA58;
    'dispatch: loop {
        match pc {
            0x828AFA58 => {
    //   block [0x828AFA58..0x828AFF28)
	// 828AFA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFA5C: 483F9975  bl 0x82ca93d0
	ctx.lr = 0x828AFA60;
	sub_82CA93D0(ctx, base);
	// 828AFA60: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFA64: 90610174  stw r3, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[3].u32 ) };
	// 828AFA68: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AFA6C: 419A04B4  beq cr6, 0x828aff20
	if ctx.cr[6].eq {
	pc = 0x828AFF20; continue 'dispatch;
	}
	// 828AFA70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828AFA74: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828AFA78: 388B2970  addi r4, r11, 0x2970
	ctx.r[4].s64 = ctx.r[11].s64 + 10608;
	// 828AFA7C: 4B9F9F6D  bl 0x822a99e8
	ctx.lr = 0x828AFA80;
	sub_822A99E8(ctx, base);
	// 828AFA80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFA84: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828AFA88: 48150F09  bl 0x82a00990
	ctx.lr = 0x828AFA8C;
	sub_82A00990(ctx, base);
	// 828AFA8C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AFA90: 83E10090  lwz r31, 0x90(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AFA94: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AFA98: 419A0480  beq cr6, 0x828aff18
	if ctx.cr[6].eq {
	pc = 0x828AFF18; continue 'dispatch;
	}
	// 828AFA9C: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828AFAA0: 89E10050  lbz r15, 0x50(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AFAA4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828AFAA8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828AFAAC: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 828AFAB0: 3FC0811C  lis r30, -0x7ee4
	ctx.r[30].s64 = -2128871424;
	// 828AFAB4: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828AFAB8: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828AFABC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828AFAC0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828AFAC4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828AFAC8: 3884E460  addi r4, r4, -0x1ba0
	ctx.r[4].s64 = ctx.r[4].s64 + -7072;
	// 828AFACC: 394A2988  addi r10, r10, 0x2988
	ctx.r[10].s64 = ctx.r[10].s64 + 10632;
	// 828AFAD0: 396BD81C  addi r11, r11, -0x27e4
	ctx.r[11].s64 = ctx.r[11].s64 + -10212;
	// 828AFAD4: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 828AFAD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828AFADC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828AFAE0: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 828AFAE4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AFAE8: 63D99DC5  ori r25, r30, 0x9dc5
	ctx.r[25].u64 = ctx.r[30].u64 | 40389;
	// 828AFAEC: 3B857088  addi r28, r5, 0x7088
	ctx.r[28].s64 = ctx.r[5].s64 + 28808;
	// 828AFAF0: 3A8329DC  addi r20, r3, 0x29dc
	ctx.r[20].s64 = ctx.r[3].s64 + 10716;
	// 828AFAF4: 3A6629C8  addi r19, r6, 0x29c8
	ctx.r[19].s64 = ctx.r[6].s64 + 10696;
	// 828AFAF8: 3A4729B8  addi r18, r7, 0x29b8
	ctx.r[18].s64 = ctx.r[7].s64 + 10680;
	// 828AFAFC: 3A2829A8  addi r17, r8, 0x29a8
	ctx.r[17].s64 = ctx.r[8].s64 + 10664;
	// 828AFB00: 3A092998  addi r16, r9, 0x2998
	ctx.r[16].s64 = ctx.r[9].s64 + 10648;
	// 828AFB04: 48000008  b 0x828afb0c
	pc = 0x828AFB0C; continue 'dispatch;
	// 828AFB08: 83E10090  lwz r31, 0x90(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AFB0C: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AFB10: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828AFB14: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828AFB18: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AFB1C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828AFB20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AFB24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFB28: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828AFB2C: 419A0024  beq cr6, 0x828afb50
	if ctx.cr[6].eq {
	pc = 0x828AFB50; continue 'dispatch;
	}
	// 828AFB30: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828AFB34: 409A001C  bne cr6, 0x828afb50
	if !ctx.cr[6].eq {
	pc = 0x828AFB50; continue 'dispatch;
	}
	// 828AFB38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828AFB3C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFB40: 816BE454  lwz r11, -0x1bac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828AFB44: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AFB48: 409A0008  bne cr6, 0x828afb50
	if !ctx.cr[6].eq {
	pc = 0x828AFB50; continue 'dispatch;
	}
	// 828AFB4C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AFB50: 80776DA0  lwz r3, 0x6da0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828AFB54: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFB58: 4B9346F9  bl 0x821e4250
	ctx.lr = 0x828AFB5C;
	sub_821E4250(ctx, base);
	// 828AFB5C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828AFB60: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AFB64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AFB68: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828AFB6C: 4BAFD8FD  bl 0x823ad468
	ctx.lr = 0x828AFB70;
	sub_823AD468(ctx, base);
	// 828AFB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AFB74: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828AFB78: 4B9F9E71  bl 0x822a99e8
	ctx.lr = 0x828AFB7C;
	sub_822A99E8(ctx, base);
	// 828AFB7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFB80: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828AFB84: 48150E0D  bl 0x82a00990
	ctx.lr = 0x828AFB88;
	sub_82A00990(ctx, base);
	// 828AFB88: 830100A0  lwz r24, 0xa0(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828AFB8C: 81C1009C  lwz r14, 0x9c(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828AFB90: 82A10098  lwz r21, 0x98(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828AFB94: 7F187040  cmplw cr6, r24, r14
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[14].u32, &mut ctx.xer);
	// 828AFB98: 419A0360  beq cr6, 0x828afef8
	if ctx.cr[6].eq {
	pc = 0x828AFEF8; continue 'dispatch;
	}
	// 828AFB9C: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 828AFBA0: 3ACB000C  addi r22, r11, 0xc
	ctx.r[22].s64 = ctx.r[11].s64 + 12;
	// 828AFBA4: 570B083C  slwi r11, r24, 1
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AFBA8: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 828AFBAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828AFBB0: 7D6BAA14  add r11, r11, r21
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 828AFBB4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFBB8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AFBBC: 2F090006  cmpwi cr6, r9, 6
	ctx.cr[6].compare_i32(ctx.r[9].s32, 6, &mut ctx.xer);
	// 828AFBC0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828AFBC4: 419A0024  beq cr6, 0x828afbe8
	if ctx.cr[6].eq {
	pc = 0x828AFBE8; continue 'dispatch;
	}
	// 828AFBC8: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 828AFBCC: 409A001C  bne cr6, 0x828afbe8
	if !ctx.cr[6].eq {
	pc = 0x828AFBE8; continue 'dispatch;
	}
	// 828AFBD0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFBD4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828AFBD8: 814AE454  lwz r10, -0x1bac(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828AFBDC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AFBE0: 409A0008  bne cr6, 0x828afbe8
	if !ctx.cr[6].eq {
	pc = 0x828AFBE8; continue 'dispatch;
	}
	// 828AFBE4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AFBE8: 80776DA0  lwz r3, 0x6da0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828AFBEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFBF0: 4B934661  bl 0x821e4250
	ctx.lr = 0x828AFBF4;
	sub_821E4250(ctx, base);
	// 828AFBF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFBF8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828AFBFC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828AFC00: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AFC04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFC08: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AFC0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828AFC10: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFC14: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFC18: 4082FFE8  bne 0x828afc00
	if !ctx.cr[0].eq {
	pc = 0x828AFC00; continue 'dispatch;
	}
	// 828AFC1C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AFC20: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828AFC24: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828AFC28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFC2C: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828AFC30: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828AFC34: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFC38: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFC3C: 4082FFE8  bne 0x828afc24
	if !ctx.cr[0].eq {
	pc = 0x828AFC24; continue 'dispatch;
	}
	// 828AFC40: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828AFC44: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AFC48: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828AFC4C: 4B94410D  bl 0x821f3d58
	ctx.lr = 0x828AFC50;
	sub_821F3D58(ctx, base);
	// 828AFC50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFC54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFC58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AFC5C: 4BB00B5D  bl 0x823b07b8
	ctx.lr = 0x828AFC60;
	sub_823B07B8(ctx, base);
	// 828AFC60: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828AFC64: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AFC68: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 828AFC6C: 4B9440ED  bl 0x821f3d58
	ctx.lr = 0x828AFC70;
	sub_821F3D58(ctx, base);
	// 828AFC70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFC78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AFC7C: 4BB00B3D  bl 0x823b07b8
	ctx.lr = 0x828AFC80;
	sub_823B07B8(ctx, base);
	// 828AFC80: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828AFC84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AFC88: 3BC1006C  addi r30, r1, 0x6c
	ctx.r[30].s64 = ctx.r[1].s64 + 108;
	// 828AFC8C: 4B9440CD  bl 0x821f3d58
	ctx.lr = 0x828AFC90;
	sub_821F3D58(ctx, base);
	// 828AFC90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFC94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFC98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AFC9C: 48001DED  bl 0x828b1a88
	ctx.lr = 0x828AFCA0;
	sub_828B1A88(ctx, base);
	// 828AFCA0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828AFCA4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AFCA8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 828AFCAC: 4B9440AD  bl 0x821f3d58
	ctx.lr = 0x828AFCB0;
	sub_821F3D58(ctx, base);
	// 828AFCB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFCB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AFCBC: 48001DCD  bl 0x828b1a88
	ctx.lr = 0x828AFCC0;
	sub_828B1A88(ctx, base);
	// 828AFCC0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828AFCC4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AFCC8: 3BC10074  addi r30, r1, 0x74
	ctx.r[30].s64 = ctx.r[1].s64 + 116;
	// 828AFCCC: 4B94408D  bl 0x821f3d58
	ctx.lr = 0x828AFCD0;
	sub_821F3D58(ctx, base);
	// 828AFCD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AFCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFCD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AFCDC: 4B935D2D  bl 0x821e5a08
	ctx.lr = 0x828AFCE0;
	sub_821E5A08(ctx, base);
	// 828AFCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AFCE4: 419A0014  beq cr6, 0x828afcf8
	if ctx.cr[6].eq {
	pc = 0x828AFCF8; continue 'dispatch;
	}
	// 828AFCE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFCEC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828AFCF0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828AFCF4: 692F0001  xori r15, r9, 1
	ctx.r[15].u64 = ctx.r[9].u64 ^ 1;
	// 828AFCF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AFCFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828AFD00: 4B940541  bl 0x821f0240
	ctx.lr = 0x828AFD04;
	sub_821F0240(ctx, base);
	// 828AFD04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFD08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AFD0C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828AFD10: 4B940531  bl 0x821f0240
	ctx.lr = 0x828AFD14;
	sub_821F0240(ctx, base);
	// 828AFD14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AFD18: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828AFD1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AFD20: 4B940521  bl 0x821f0240
	ctx.lr = 0x828AFD24;
	sub_821F0240(ctx, base);
	// 828AFD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AFD28: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 828AFD2C: 4B940515  bl 0x821f0240
	ctx.lr = 0x828AFD30;
	sub_821F0240(ctx, base);
	// 828AFD30: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828AFD34: 83410070  lwz r26, 0x70(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AFD38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AFD3C: 99E100C0  stb r15, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[15].u8 ) };
	// 828AFD40: 936100B8  stw r27, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u32 ) };
	// 828AFD44: 934100BC  stw r26, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 828AFD48: 4B916A21  bl 0x821c6768
	ctx.lr = 0x828AFD4C;
	sub_821C6768(ctx, base);
	// 828AFD4C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828AFD50: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AFD54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD58: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AFD5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AFD60: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFD64: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD68: 4082FFE8  bne 0x828afd50
	if !ctx.cr[0].eq {
	pc = 0x828AFD50; continue 'dispatch;
	}
	// 828AFD6C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFD74: 4B9169F5  bl 0x821c6768
	ctx.lr = 0x828AFD78;
	sub_821C6768(ctx, base);
	// 828AFD78: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AFD7C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828AFD80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD84: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828AFD88: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828AFD8C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFD90: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD94: 4082FFE8  bne 0x828afd7c
	if !ctx.cr[0].eq {
	pc = 0x828AFD7C; continue 'dispatch;
	}
	// 828AFD98: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828AFD9C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AFDA0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828AFDA4: 48000715  bl 0x828b04b8
	ctx.lr = 0x828AFDA8;
	sub_828B04B8(ctx, base);
	// 828AFDA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AFDAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AFDB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AFDB4: 409A000C  bne cr6, 0x828afdc0
	if !ctx.cr[6].eq {
	pc = 0x828AFDC0; continue 'dispatch;
	}
	// 828AFDB8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828AFDBC: 48000014  b 0x828afdd0
	pc = 0x828AFDD0; continue 'dispatch;
	// 828AFDC0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828AFDC4: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 828AFDC8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828AFDCC: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 828AFDD0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AFDD4: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 828AFDD8: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828AFDDC: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 828AFDE0: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AFDE4: 4098003C  bge cr6, 0x828afe20
	if !ctx.cr[6].lt {
	pc = 0x828AFE20; continue 'dispatch;
	}
	// 828AFDE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828AFDEC: 419A0028  beq cr6, 0x828afe14
	if ctx.cr[6].eq {
	pc = 0x828AFE14; continue 'dispatch;
	}
	// 828AFDF0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828AFDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFDF8: 4B940449  bl 0x821f0240
	ctx.lr = 0x828AFDFC;
	sub_821F0240(ctx, base);
	// 828AFDFC: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 828AFE00: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AFE04: 4B94043D  bl 0x821f0240
	ctx.lr = 0x828AFE08;
	sub_821F0240(ctx, base);
	// 828AFE08: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828AFE0C: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 828AFE10: 99FF0010  stb r15, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[15].u8 ) };
	// 828AFE14: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 828AFE18: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828AFE1C: 48000020  b 0x828afe3c
	pc = 0x828AFE3C; continue 'dispatch;
	// 828AFE20: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828AFE24: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AFE28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828AFE2C: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828AFE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AFE34: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AFE38: 4BAB1E61  bl 0x82361c98
	ctx.lr = 0x828AFE3C;
	sub_82361C98(ctx, base);
	// 828AFE3C: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 828AFE40: 4B916929  bl 0x821c6768
	ctx.lr = 0x828AFE44;
	sub_821C6768(ctx, base);
	// 828AFE44: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828AFE48: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828AFE4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFE50: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828AFE54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AFE58: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFE5C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFE60: 4082FFE8  bne 0x828afe48
	if !ctx.cr[0].eq {
	pc = 0x828AFE48; continue 'dispatch;
	}
	// 828AFE64: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 828AFE68: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828AFE6C: 4B9168FD  bl 0x821c6768
	ctx.lr = 0x828AFE70;
	sub_821C6768(ctx, base);
	// 828AFE70: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AFE74: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828AFE78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFE7C: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828AFE80: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828AFE84: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFE88: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFE8C: 4082FFE8  bne 0x828afe74
	if !ctx.cr[0].eq {
	pc = 0x828AFE74; continue 'dispatch;
	}
	// 828AFE90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AFE94: 93A100B0  stw r29, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 828AFE98: 4B9168D1  bl 0x821c6768
	ctx.lr = 0x828AFE9C;
	sub_821C6768(ctx, base);
	// 828AFE9C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828AFEA0: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828AFEA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFEA8: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828AFEAC: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 828AFEB0: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFEB4: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFEB8: 4082FFE8  bne 0x828afea0
	if !ctx.cr[0].eq {
	pc = 0x828AFEA0; continue 'dispatch;
	}
	// 828AFEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AFEC0: 4B9168A9  bl 0x821c6768
	ctx.lr = 0x828AFEC4;
	sub_821C6768(ctx, base);
	// 828AFEC4: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828AFEC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AFECC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFED0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AFED4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828AFED8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFEDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFEE0: 4082FFE8  bne 0x828afec8
	if !ctx.cr[0].eq {
	pc = 0x828AFEC8; continue 'dispatch;
	}
	// 828AFEE4: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 828AFEE8: 7F187040  cmplw cr6, r24, r14
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[14].u32, &mut ctx.xer);
	// 828AFEEC: 409AFCB8  bne cr6, 0x828afba4
	if !ctx.cr[6].eq {
	pc = 0x828AFBA4; continue 'dispatch;
	}
	// 828AFEF0: 83E10090  lwz r31, 0x90(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828AFEF4: 930100A0  stw r24, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 828AFEF8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AFEFC: 4B96BE3D  bl 0x8221bd38
	ctx.lr = 0x828AFF00;
	sub_8221BD38(ctx, base);
	// 828AFF00: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AFF04: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 828AFF08: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 828AFF0C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828AFF10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828AFF14: 409AFBF4  bne cr6, 0x828afb08
	if !ctx.cr[6].eq {
	pc = 0x828AFB08; continue 'dispatch;
	}
	// 828AFF18: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828AFF1C: 4B96BE1D  bl 0x8221bd38
	ctx.lr = 0x828AFF20;
	sub_8221BD38(ctx, base);
	// 828AFF20: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828AFF24: 483F94FC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFF28 size=1420
    let mut pc: u32 = 0x828AFF28;
    'dispatch: loop {
        match pc {
            0x828AFF28 => {
    //   block [0x828AFF28..0x828B04B4)
	// 828AFF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFF2C: 483F94BD  bl 0x82ca93e8
	ctx.lr = 0x828AFF30;
	sub_82CA93D0(ctx, base);
	// 828AFF30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFF34: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828AFF38: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828AFF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFF40: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 828AFF44: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828AFF48: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 828AFF4C: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 828AFF50: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 828AFF54: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828AFF58: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828AFF5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828AFF60: 419A00F4  beq cr6, 0x828b0054
	if ctx.cr[6].eq {
	pc = 0x828B0054; continue 'dispatch;
	}
	// 828AFF64: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AFF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AFF6C: 419A0024  beq cr6, 0x828aff90
	if ctx.cr[6].eq {
	pc = 0x828AFF90; continue 'dispatch;
	}
	// 828AFF70: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 828AFF74: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AFF78: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828AFF7C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828AFF80: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AFF84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828AFF88: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828AFF8C: 480000CC  b 0x828b0058
	pc = 0x828B0058; continue 'dispatch;
	// 828AFF90: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828AFF94: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828AFF98: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828AFF9C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828AFFA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AFFA4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AFFA8: 40810054  ble 0x828afffc
	if !ctx.cr[0].gt {
	pc = 0x828AFFFC; continue 'dispatch;
	}
	// 828AFFAC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828AFFB0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828AFFB4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828AFFB8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFFBC: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 828AFFC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828AFFC4: 41980008  blt cr6, 0x828affcc
	if ctx.cr[6].lt {
	pc = 0x828AFFCC; continue 'dispatch;
	}
	// 828AFFC8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828AFFCC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828AFFD0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828AFFD4: 419A0014  beq cr6, 0x828affe8
	if ctx.cr[6].eq {
	pc = 0x828AFFE8; continue 'dispatch;
	}
	// 828AFFD8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828AFFDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828AFFE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828AFFE4: 4800000C  b 0x828afff0
	pc = 0x828AFFF0; continue 'dispatch;
	// 828AFFE8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828AFFEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828AFFF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AFFF4: 4199FFB8  bgt cr6, 0x828affac
	if ctx.cr[6].gt {
	pc = 0x828AFFAC; continue 'dispatch;
	}
	// 828AFFF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828AFFFC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B0000: 419A0040  beq cr6, 0x828b0040
	if ctx.cr[6].eq {
	pc = 0x828B0040; continue 'dispatch;
	}
	// 828B0004: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0008: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 828B000C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0010: 41990008  bgt cr6, 0x828b0018
	if ctx.cr[6].gt {
	pc = 0x828B0018; continue 'dispatch;
	}
	// 828B0014: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B0018: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B001C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0020: 409A0020  bne cr6, 0x828b0040
	if !ctx.cr[6].eq {
	pc = 0x828B0040; continue 'dispatch;
	}
	// 828B0024: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B0028: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828B002C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B0030: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0034: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B0038: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B003C: 4800001C  b 0x828b0058
	pc = 0x828B0058; continue 'dispatch;
	// 828B0040: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B0044: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0048: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B004C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0050: 48000008  b 0x828b0058
	pc = 0x828B0058; continue 'dispatch;
	// 828B0054: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B0058: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B005C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0060: 419A0448  beq cr6, 0x828b04a8
	if ctx.cr[6].eq {
	pc = 0x828B04A8; continue 'dispatch;
	}
	// 828B0064: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B0068: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828B006C: 5569A7FE  rlwinm r9, r11, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 828B0070: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B0074: 419A00F4  beq cr6, 0x828b0168
	if ctx.cr[6].eq {
	pc = 0x828B0168; continue 'dispatch;
	}
	// 828B0078: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B007C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0080: 419A0024  beq cr6, 0x828b00a4
	if ctx.cr[6].eq {
	pc = 0x828B00A4; continue 'dispatch;
	}
	// 828B0084: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0088: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B008C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B0090: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B0094: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0098: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B009C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B00A0: 480000CC  b 0x828b016c
	pc = 0x828B016C; continue 'dispatch;
	// 828B00A4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B00A8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B00AC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828B00B0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B00B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B00B8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B00BC: 40810054  ble 0x828b0110
	if !ctx.cr[0].gt {
	pc = 0x828B0110; continue 'dispatch;
	}
	// 828B00C0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B00C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B00C8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B00CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B00D0: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 828B00D4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B00D8: 41980008  blt cr6, 0x828b00e0
	if ctx.cr[6].lt {
	pc = 0x828B00E0; continue 'dispatch;
	}
	// 828B00DC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828B00E0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B00E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B00E8: 419A0014  beq cr6, 0x828b00fc
	if ctx.cr[6].eq {
	pc = 0x828B00FC; continue 'dispatch;
	}
	// 828B00EC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B00F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B00F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B00F8: 4800000C  b 0x828b0104
	pc = 0x828B0104; continue 'dispatch;
	// 828B00FC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B0100: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B0104: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0108: 4199FFB8  bgt cr6, 0x828b00c0
	if ctx.cr[6].gt {
	pc = 0x828B00C0; continue 'dispatch;
	}
	// 828B010C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B0110: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B0114: 419A0040  beq cr6, 0x828b0154
	if ctx.cr[6].eq {
	pc = 0x828B0154; continue 'dispatch;
	}
	// 828B0118: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B011C: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 828B0120: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0124: 41990008  bgt cr6, 0x828b012c
	if ctx.cr[6].gt {
	pc = 0x828B012C; continue 'dispatch;
	}
	// 828B0128: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B012C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B0130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0134: 409A0020  bne cr6, 0x828b0154
	if !ctx.cr[6].eq {
	pc = 0x828B0154; continue 'dispatch;
	}
	// 828B0138: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B013C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828B0140: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B0144: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0148: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B014C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0150: 4800001C  b 0x828b016c
	pc = 0x828B016C; continue 'dispatch;
	// 828B0154: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B0158: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B015C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B0160: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0164: 48000008  b 0x828b016c
	pc = 0x828B016C; continue 'dispatch;
	// 828B0168: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B016C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B0170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0174: 419A0334  beq cr6, 0x828b04a8
	if ctx.cr[6].eq {
	pc = 0x828B04A8; continue 'dispatch;
	}
	// 828B0178: 4B9128A1  bl 0x821c2a18
	ctx.lr = 0x828B017C;
	sub_821C2A18(ctx, base);
	// 828B017C: 81180000  lwz r8, 0(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0180: 836A000C  lwz r27, 0xc(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0184: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828B0188: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 828B018C: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 828B0190: 40980020  bge cr6, 0x828b01b0
	if !ctx.cr[6].lt {
	pc = 0x828B01B0; continue 'dispatch;
	}
	// 828B0194: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828B0198: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B019C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B01A0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B01A4: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828B01A8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828B01AC: 480000A4  b 0x828b0250
	pc = 0x828B0250; continue 'dispatch;
	// 828B01B0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B01B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B01B8: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B01BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B01C0: 409A0040  bne cr6, 0x828b0200
	if !ctx.cr[6].eq {
	pc = 0x828B0200; continue 'dispatch;
	}
	// 828B01C4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B01C8: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828B01CC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828B01D0: 41980008  blt cr6, 0x828b01d8
	if ctx.cr[6].lt {
	pc = 0x828B01D8; continue 'dispatch;
	}
	// 828B01D4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828B01D8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B01DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B01E0: 419A000C  beq cr6, 0x828b01ec
	if ctx.cr[6].eq {
	pc = 0x828B01EC; continue 'dispatch;
	}
	// 828B01E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B01E8: 4800000C  b 0x828b01f4
	pc = 0x828B01F4; continue 'dispatch;
	// 828B01EC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828B01F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B01F4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B01F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B01FC: 419AFFC8  beq cr6, 0x828b01c4
	if ctx.cr[6].eq {
	pc = 0x828B01C4; continue 'dispatch;
	}
	// 828B0200: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0204: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828B0208: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828B020C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0210: 419A002C  beq cr6, 0x828b023c
	if ctx.cr[6].eq {
	pc = 0x828B023C; continue 'dispatch;
	}
	// 828B0214: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0218: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B021C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B0220: 41980008  blt cr6, 0x828b0228
	if ctx.cr[6].lt {
	pc = 0x828B0228; continue 'dispatch;
	}
	// 828B0224: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B0228: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B022C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0230: 409A000C  bne cr6, 0x828b023c
	if !ctx.cr[6].eq {
	pc = 0x828B023C; continue 'dispatch;
	}
	// 828B0234: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828B0238: 48000010  b 0x828b0248
	pc = 0x828B0248; continue 'dispatch;
	// 828B023C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B0240: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B0244: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B0248: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828B024C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B0250: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828B0254: 4B96F005  bl 0x8221f258
	ctx.lr = 0x828B0258;
	sub_8221F258(ctx, base);
	// 828B0258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B025C: 419A0008  beq cr6, 0x828b0264
	if ctx.cr[6].eq {
	pc = 0x828B0264; continue 'dispatch;
	}
	// 828B0260: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 828B0264: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0268: 41820008  beq 0x828b0270
	if ctx.cr[0].eq {
	pc = 0x828B0270; continue 'dispatch;
	}
	// 828B026C: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 828B0270: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0274: 41820008  beq 0x828b027c
	if ctx.cr[0].eq {
	pc = 0x828B027C; continue 'dispatch;
	}
	// 828B0278: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 828B027C: 9BC30018  stb r30, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 828B0280: 9B230019  stb r25, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[25].u8 ) };
	// 828B0284: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 828B0288: 9BC30019  stb r30, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	// 828B028C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B0290: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B0294: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B0298: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B029C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B02A0: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B02A4: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 828B02A8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B02AC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B02B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B02B4: 419A000C  beq cr6, 0x828b02c0
	if ctx.cr[6].eq {
	pc = 0x828B02C0; continue 'dispatch;
	}
	// 828B02B8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B02BC: 419A0008  beq cr6, 0x828b02c4
	if ctx.cr[6].eq {
	pc = 0x828B02C4; continue 'dispatch;
	}
	// 828B02C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B02C4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B02C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B02CC: 419A00B0  beq cr6, 0x828b037c
	if ctx.cr[6].eq {
	pc = 0x828B037C; continue 'dispatch;
	}
	// 828B02D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B02D4: 409A0008  bne cr6, 0x828b02dc
	if !ctx.cr[6].eq {
	pc = 0x828B02DC; continue 'dispatch;
	}
	// 828B02D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B02DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B02E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B02E4: 409A0008  bne cr6, 0x828b02ec
	if !ctx.cr[6].eq {
	pc = 0x828B02EC; continue 'dispatch;
	}
	// 828B02E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B02EC: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B02F0: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828B02F4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B02F8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828B02FC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0300: 409A0008  bne cr6, 0x828b0308
	if !ctx.cr[6].eq {
	pc = 0x828B0308; continue 'dispatch;
	}
	// 828B0304: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0308: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B030C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0310: 419A0054  beq cr6, 0x828b0364
	if ctx.cr[6].eq {
	pc = 0x828B0364; continue 'dispatch;
	}
	// 828B0314: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0318: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828B031C: 419A000C  beq cr6, 0x828b0328
	if ctx.cr[6].eq {
	pc = 0x828B0328; continue 'dispatch;
	}
	// 828B0320: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 828B0324: 409A0038  bne cr6, 0x828b035c
	if !ctx.cr[6].eq {
	pc = 0x828B035C; continue 'dispatch;
	}
	// 828B0328: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B032C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B0330: 419A000C  beq cr6, 0x828b033c
	if ctx.cr[6].eq {
	pc = 0x828B033C; continue 'dispatch;
	}
	// 828B0334: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 828B0338: 409A0024  bne cr6, 0x828b035c
	if !ctx.cr[6].eq {
	pc = 0x828B035C; continue 'dispatch;
	}
	// 828B033C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0340: 409A0008  bne cr6, 0x828b0348
	if !ctx.cr[6].eq {
	pc = 0x828B0348; continue 'dispatch;
	}
	// 828B0344: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0348: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B034C: 829F000C  lwz r20, 0xc(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B0354: 48000305  bl 0x828b0658
	ctx.lr = 0x828B0358;
	sub_828B0658(ctx, base);
	// 828B0358: 92830000  stw r20, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 828B035C: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 828B0360: 4BFFFF94  b 0x828b02f4
	pc = 0x828B02F4; continue 'dispatch;
	// 828B0364: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0368: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B036C: 41990010  bgt cr6, 0x828b037c
	if ctx.cr[6].gt {
	pc = 0x828B037C; continue 'dispatch;
	}
	// 828B0370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0374: 4BA647B5  bl 0x82314b28
	ctx.lr = 0x828B0378;
	sub_82314B28(ctx, base);
	// 828B0378: 4BFFFF30  b 0x828b02a8
	pc = 0x828B02A8; continue 'dispatch;
	// 828B037C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B0380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0384: 419A011C  beq cr6, 0x828b04a0
	if ctx.cr[6].eq {
	pc = 0x828B04A0; continue 'dispatch;
	}
	// 828B0388: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B038C: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B0390: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B0394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0398: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828B039C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B03A0: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B03A4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B03A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B03AC: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B03B0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B03B4: 80CB0078  lwz r6, 0x78(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828B03B8: 1D2624A1  mulli r9, r6, 0x24a1
	ctx.r[9].s64 = ctx.r[6].s64 * 9377;
	// 828B03BC: 38A924DF  addi r5, r9, 0x24df
	ctx.r[5].s64 = ctx.r[9].s64 + 9439;
	// 828B03C0: 54A9983E  rotlwi r9, r5, 0x13
	ctx.r[9].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828B03C4: 912B0078  stw r9, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 828B03C8: 419A0014  beq cr6, 0x828b03dc
	if ctx.cr[6].eq {
	pc = 0x828B03DC; continue 'dispatch;
	}
	// 828B03CC: 7D695396  divwu r11, r9, r10
	ctx.r[11].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 828B03D0: 7D4B51D6  mullw r10, r11, r10
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 828B03D4: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828B03D8: 48000008  b 0x828b03e0
	pc = 0x828B03E0; continue 'dispatch;
	// 828B03DC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828B03E0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828B03E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B03E8: 40990028  ble cr6, 0x828b0410
	if !ctx.cr[6].gt {
	pc = 0x828B0410; continue 'dispatch;
	}
	// 828B03EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B03F0: 4BB8CA01  bl 0x8243cdf0
	ctx.lr = 0x828B03F4;
	sub_8243CDF0(ctx, base);
	// 828B03F4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B03F8: 4181FFF4  bgt 0x828b03ec
	if ctx.cr[0].gt {
	pc = 0x828B03EC; continue 'dispatch;
	}
	// 828B03FC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B0400: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B0404: 409A0008  bne cr6, 0x828b040c
	if !ctx.cr[6].eq {
	pc = 0x828B040C; continue 'dispatch;
	}
	// 828B0408: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B040C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0410: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0414: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0418: 409A0008  bne cr6, 0x828b0420
	if !ctx.cr[6].eq {
	pc = 0x828B0420; continue 'dispatch;
	}
	// 828B041C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0420: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828B0424: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0428: 4B9B4D79  bl 0x822651a0
	ctx.lr = 0x828B042C;
	sub_822651A0(ctx, base);
	// 828B042C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0430: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0434: 409A0008  bne cr6, 0x828b043c
	if !ctx.cr[6].eq {
	pc = 0x828B043C; continue 'dispatch;
	}
	// 828B0438: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B043C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0440: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828B0444: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828B0448: 4B9B4D59  bl 0x822651a0
	ctx.lr = 0x828B044C;
	sub_822651A0(ctx, base);
	// 828B044C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0450: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0454: 409A001C  bne cr6, 0x828b0470
	if !ctx.cr[6].eq {
	pc = 0x828B0470; continue 'dispatch;
	}
	// 828B0458: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B045C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0460: 409A0008  bne cr6, 0x828b0468
	if !ctx.cr[6].eq {
	pc = 0x828B0468; continue 'dispatch;
	}
	// 828B0464: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0468: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B046C: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B0470: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0474: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0478: 409A0008  bne cr6, 0x828b0480
	if !ctx.cr[6].eq {
	pc = 0x828B0480; continue 'dispatch;
	}
	// 828B047C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0480: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0484: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B0488: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B048C: 99550000  stb r10, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B0490: 4BE295C9  bl 0x826d9a58
	ctx.lr = 0x828B0494;
	sub_826D9A58(ctx, base);
	// 828B0494: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B0498: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B049C: 483F8F9C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 828B04A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B04A4: 4BE295B5  bl 0x826d9a58
	ctx.lr = 0x828B04A8;
	sub_826D9A58(ctx, base);
	// 828B04A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B04AC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B04B0: 483F8F88  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B04B8 size=312
    let mut pc: u32 = 0x828B04B8;
    'dispatch: loop {
        match pc {
            0x828B04B8 => {
    //   block [0x828B04B8..0x828B05F0)
	// 828B04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B04BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B04C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B04C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B04C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B04CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B04D0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B04D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B04D8: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B04DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B04E0: 409A0044  bne cr6, 0x828b0524
	if !ctx.cr[6].eq {
	pc = 0x828B0524; continue 'dispatch;
	}
	// 828B04E4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B04E8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B04EC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828B04F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B04F4: 41980008  blt cr6, 0x828b04fc
	if ctx.cr[6].lt {
	pc = 0x828B04FC; continue 'dispatch;
	}
	// 828B04F8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828B04FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B0500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0504: 419A000C  beq cr6, 0x828b0510
	if ctx.cr[6].eq {
	pc = 0x828B0510; continue 'dispatch;
	}
	// 828B0508: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B050C: 4800000C  b 0x828b0518
	pc = 0x828B0518; continue 'dispatch;
	// 828B0510: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828B0514: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0518: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B051C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0520: 419AFFC8  beq cr6, 0x828b04e8
	if ctx.cr[6].eq {
	pc = 0x828B04E8; continue 'dispatch;
	}
	// 828B0524: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0528: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828B052C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828B0530: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B0534: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0538: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B053C: 419A0028  beq cr6, 0x828b0564
	if ctx.cr[6].eq {
	pc = 0x828B0564; continue 'dispatch;
	}
	// 828B0540: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0544: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0548: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828B054C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B0550: 41980008  blt cr6, 0x828b0558
	if ctx.cr[6].lt {
	pc = 0x828B0558; continue 'dispatch;
	}
	// 828B0554: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828B0558: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B055C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0560: 419A005C  beq cr6, 0x828b05bc
	if ctx.cr[6].eq {
	pc = 0x828B05BC; continue 'dispatch;
	}
	// 828B0564: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0568: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B056C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 828B0570: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B0574: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 828B0578: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 828B057C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828B0580: 48000C61  bl 0x828b11e0
	ctx.lr = 0x828B0584;
	sub_828B11E0(ctx, base);
	// 828B0584: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828B0588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B058C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B0590: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0594: 48000255  bl 0x828b07e8
	ctx.lr = 0x828B0598;
	sub_828B07E8(ctx, base);
	// 828B0598: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828B059C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B05A0: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828B05A4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828B05A8: 480001E9  bl 0x828b0790
	ctx.lr = 0x828B05AC;
	sub_828B0790(ctx, base);
	// 828B05AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B05B0: 48000189  bl 0x828b0738
	ctx.lr = 0x828B05B4;
	sub_828B0738(ctx, base);
	// 828B05B4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B05B8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B05BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B05C0: 409A0008  bne cr6, 0x828b05c8
	if !ctx.cr[6].eq {
	pc = 0x828B05C8; continue 'dispatch;
	}
	// 828B05C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B05C8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B05CC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B05D0: 409A0008  bne cr6, 0x828b05d8
	if !ctx.cr[6].eq {
	pc = 0x828B05D8; continue 'dispatch;
	}
	// 828B05D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B05D8: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 828B05DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B05E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B05E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B05E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B05EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B05F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B05F0 size=104
    let mut pc: u32 = 0x828B05F0;
    'dispatch: loop {
        match pc {
            0x828B05F0 => {
    //   block [0x828B05F0..0x828B0658)
	// 828B05F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B05F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B05F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B05FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0604: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0608: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828B060C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0610: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B0614: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0618: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B061C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B0620: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B0624: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B0628: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828B062C: 4800082D  bl 0x828b0e58
	ctx.lr = 0x828B0630;
	sub_828B0E58(ctx, base);
	// 828B0630: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0634: 4B96B705  bl 0x8221bd38
	ctx.lr = 0x828B0638;
	sub_8221BD38(ctx, base);
	// 828B0638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B063C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B0640: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B0644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B0648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B064C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B0650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B0654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0658 size=220
    let mut pc: u32 = 0x828B0658;
    'dispatch: loop {
        match pc {
            0x828B0658 => {
    //   block [0x828B0658..0x828B0734)
	// 828B0658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B065C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0660: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0664: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828B0668: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B066C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0670: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B0674: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B0678: 409A0030  bne cr6, 0x828b06a8
	if !ctx.cr[6].eq {
	pc = 0x828B06A8; continue 'dispatch;
	}
	// 828B067C: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0680: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0684: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828B0688: 4098000C  bge cr6, 0x828b0694
	if !ctx.cr[6].lt {
	pc = 0x828B0694; continue 'dispatch;
	}
	// 828B068C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0690: 4800000C  b 0x828b069c
	pc = 0x828B069C; continue 'dispatch;
	// 828B0694: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B0698: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B069C: 88EB0019  lbz r7, 0x19(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B06A0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B06A4: 419AFFDC  beq cr6, 0x828b0680
	if ctx.cr[6].eq {
	pc = 0x828B0680; continue 'dispatch;
	}
	// 828B06A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B06AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828B06B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828B06B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B06B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828B06BC: 419A0014  beq cr6, 0x828b06d0
	if ctx.cr[6].eq {
	pc = 0x828B06D0; continue 'dispatch;
	}
	// 828B06C0: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B06C4: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B06C8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828B06CC: 40980038  bge cr6, 0x828b0704
	if !ctx.cr[6].lt {
	pc = 0x828B0704; continue 'dispatch;
	}
	// 828B06D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B06D4: E9640000  ld r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 828B06D8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828B06DC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B06E0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828B06E4: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 828B06E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B06EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828B06F0: 480003F1  bl 0x828b0ae0
	ctx.lr = 0x828B06F4;
	sub_828B0AE0(ctx, base);
	// 828B06F4: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828B06F8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828B06FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0700: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B0704: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B0708: 409A0008  bne cr6, 0x828b0710
	if !ctx.cr[6].eq {
	pc = 0x828B0710; continue 'dispatch;
	}
	// 828B070C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0710: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0714: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0718: 409A0008  bne cr6, 0x828b0720
	if !ctx.cr[6].eq {
	pc = 0x828B0720; continue 'dispatch;
	}
	// 828B071C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0720: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 828B0724: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B0728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B072C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B0730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0738 size=84
    let mut pc: u32 = 0x828B0738;
    'dispatch: loop {
        match pc {
            0x828B0738 => {
    //   block [0x828B0738..0x828B078C)
	// 828B0738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B073C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B0744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B074C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0750: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B0754: 419A0014  beq cr6, 0x828b0768
	if ctx.cr[6].eq {
	pc = 0x828B0768; continue 'dispatch;
	}
	// 828B0758: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B075C: 4800119D  bl 0x828b18f8
	ctx.lr = 0x828B0760;
	sub_828B18F8(ctx, base);
	// 828B0760: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0764: 4B96B5D5  bl 0x8221bd38
	ctx.lr = 0x828B0768;
	sub_8221BD38(ctx, base);
	// 828B0768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B076C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B0770: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B0774: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B0778: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B077C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B0780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B0784: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B0788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0790 size=88
    let mut pc: u32 = 0x828B0790;
    'dispatch: loop {
        match pc {
            0x828B0790 => {
    //   block [0x828B0790..0x828B07E8)
	// 828B0790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B079C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B07A0: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B07A4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828B07A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B07AC: 419A0018  beq cr6, 0x828b07c4
	if ctx.cr[6].eq {
	pc = 0x828B07C4; continue 'dispatch;
	}
	// 828B07B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B07B4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B07B8: 48001141  bl 0x828b18f8
	ctx.lr = 0x828B07BC;
	sub_828B18F8(ctx, base);
	// 828B07BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B07C0: 4B96B579  bl 0x8221bd38
	ctx.lr = 0x828B07C4;
	sub_8221BD38(ctx, base);
	// 828B07C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B07C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B07CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B07D0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B07D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B07D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B07DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B07E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B07E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B07E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B07E8 size=660
    let mut pc: u32 = 0x828B07E8;
    'dispatch: loop {
        match pc {
            0x828B07E8 => {
    //   block [0x828B07E8..0x828B0A7C)
	// 828B07E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B07EC: 483F8C15  bl 0x82ca9400
	ctx.lr = 0x828B07F0;
	sub_82CA93D0(ctx, base);
	// 828B07F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B07F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B07F8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828B07FC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828B0800: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B0804: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828B0808: FBE100C0  std r31, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u64 ) };
	// 828B080C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828B0810: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0814: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828B0818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B081C: 409A0020  bne cr6, 0x828b083c
	if !ctx.cr[6].eq {
	pc = 0x828B083C; continue 'dispatch;
	}
	// 828B0820: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B0824: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0828: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B082C: 4800073D  bl 0x828b0f68
	ctx.lr = 0x828B0830;
	sub_828B0F68(ctx, base);
	// 828B0830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0834: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0838: 483F8C18  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B083C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0840: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828B0844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0848: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B084C: 419A000C  beq cr6, 0x828b0858
	if ctx.cr[6].eq {
	pc = 0x828B0858; continue 'dispatch;
	}
	// 828B0850: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828B0854: 419A0008  beq cr6, 0x828b085c
	if ctx.cr[6].eq {
	pc = 0x828B085C; continue 'dispatch;
	}
	// 828B0858: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B085C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828B0860: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B0864: 409A004C  bne cr6, 0x828b08b0
	if !ctx.cr[6].eq {
	pc = 0x828B08B0; continue 'dispatch;
	}
	// 828B0868: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B086C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0870: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828B0874: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B0878: 41980008  blt cr6, 0x828b0880
	if ctx.cr[6].lt {
	pc = 0x828B0880; continue 'dispatch;
	}
	// 828B087C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828B0880: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B0884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0888: 419A01C4  beq cr6, 0x828b0a4c
	if ctx.cr[6].eq {
	pc = 0x828B0A4C; continue 'dispatch;
	}
	// 828B088C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B0890: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0894: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B0898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B089C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B08A0: 480006C9  bl 0x828b0f68
	ctx.lr = 0x828B08A4;
	sub_828B0F68(ctx, base);
	// 828B08A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B08A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B08AC: 483F8BA4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B08B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B08B4: 419A000C  beq cr6, 0x828b08c0
	if ctx.cr[6].eq {
	pc = 0x828B08C0; continue 'dispatch;
	}
	// 828B08B8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828B08BC: 419A0008  beq cr6, 0x828b08c4
	if ctx.cr[6].eq {
	pc = 0x828B08C4; continue 'dispatch;
	}
	// 828B08C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B08C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B08C8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B08CC: 409A0048  bne cr6, 0x828b0914
	if !ctx.cr[6].eq {
	pc = 0x828B0914; continue 'dispatch;
	}
	// 828B08D0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B08D4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B08D8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B08DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B08E0: 41980008  blt cr6, 0x828b08e8
	if ctx.cr[6].lt {
	pc = 0x828B08E8; continue 'dispatch;
	}
	// 828B08E4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828B08E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B08EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B08F0: 419A015C  beq cr6, 0x828b0a4c
	if ctx.cr[6].eq {
	pc = 0x828B0A4C; continue 'dispatch;
	}
	// 828B08F4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B08F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B08FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B0900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0904: 48000665  bl 0x828b0f68
	ctx.lr = 0x828B0908;
	sub_828B0F68(ctx, base);
	// 828B0908: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B090C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0910: 483F8B40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B0914: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0918: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828B091C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B0920: 41980008  blt cr6, 0x828b0928
	if ctx.cr[6].lt {
	pc = 0x828B0928; continue 'dispatch;
	}
	// 828B0924: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828B0928: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B092C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0930: 419A006C  beq cr6, 0x828b099c
	if ctx.cr[6].eq {
	pc = 0x828B099C; continue 'dispatch;
	}
	// 828B0934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0938: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 828B093C: 4BACDAA5  bl 0x8237e3e0
	ctx.lr = 0x828B0940;
	sub_8237E3E0(ctx, base);
	// 828B0940: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0944: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0948: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B094C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B0950: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B0954: 41980008  blt cr6, 0x828b095c
	if ctx.cr[6].lt {
	pc = 0x828B095C; continue 'dispatch;
	}
	// 828B0958: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828B095C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B0960: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0964: 419A0038  beq cr6, 0x828b099c
	if ctx.cr[6].eq {
	pc = 0x828B099C; continue 'dispatch;
	}
	// 828B0968: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B096C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B0970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B0974: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0978: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B097C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0980: 409A00B8  bne cr6, 0x828b0a38
	if !ctx.cr[6].eq {
	pc = 0x828B0A38; continue 'dispatch;
	}
	// 828B0984: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0988: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B098C: 480005DD  bl 0x828b0f68
	ctx.lr = 0x828B0990;
	sub_828B0F68(ctx, base);
	// 828B0990: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0994: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0998: 483F8AB8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B099C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B09A0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B09A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B09A8: 41980008  blt cr6, 0x828b09b0
	if ctx.cr[6].lt {
	pc = 0x828B09B0; continue 'dispatch;
	}
	// 828B09AC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828B09B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B09B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B09B8: 419A0094  beq cr6, 0x828b0a4c
	if ctx.cr[6].eq {
	pc = 0x828B0A4C; continue 'dispatch;
	}
	// 828B09BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B09C0: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 828B09C4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B09C8: 4BA64161  bl 0x82314b28
	ctx.lr = 0x828B09CC;
	sub_82314B28(ctx, base);
	// 828B09CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B09D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B09D4: 419A000C  beq cr6, 0x828b09e0
	if ctx.cr[6].eq {
	pc = 0x828B09E0; continue 'dispatch;
	}
	// 828B09D8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828B09DC: 419A0008  beq cr6, 0x828b09e4
	if ctx.cr[6].eq {
	pc = 0x828B09E4; continue 'dispatch;
	}
	// 828B09E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B09E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B09E8: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B09EC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B09F0: 419A0028  beq cr6, 0x828b0a18
	if ctx.cr[6].eq {
	pc = 0x828B0A18; continue 'dispatch;
	}
	// 828B09F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B09F8: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B09FC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828B0A00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B0A04: 41980008  blt cr6, 0x828b0a0c
	if ctx.cr[6].lt {
	pc = 0x828B0A0C; continue 'dispatch;
	}
	// 828B0A08: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828B0A0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B0A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0A14: 419A0038  beq cr6, 0x828b0a4c
	if ctx.cr[6].eq {
	pc = 0x828B0A4C; continue 'dispatch;
	}
	// 828B0A18: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0A1C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B0A20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B0A24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0A28: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B0A2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0A30: 419AFF58  beq cr6, 0x828b0988
	if ctx.cr[6].eq {
	pc = 0x828B0988; continue 'dispatch;
	}
	// 828B0A34: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0A38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B0A3C: 4800052D  bl 0x828b0f68
	ctx.lr = 0x828B0A40;
	sub_828B0F68(ctx, base);
	// 828B0A40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0A44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0A48: 483F8A08  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B0A4C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B0A50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B0A54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0A58: 480002A9  bl 0x828b0d00
	ctx.lr = 0x828B0A5C;
	sub_828B0D00(ctx, base);
	// 828B0A5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0A60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0A64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0A68: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B0A6C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0A70: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B0A74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0A78: 483F89D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0A80 size=96
    let mut pc: u32 = 0x828B0A80;
    'dispatch: loop {
        match pc {
            0x828B0A80 => {
    //   block [0x828B0A80..0x828B0AE0)
	// 828B0A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0A84: 483F8981  bl 0x82ca9404
	ctx.lr = 0x828B0A88;
	sub_82CA93D0(ctx, base);
	// 828B0A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0A8C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B0A90: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B0A94: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828B0A98: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828B0A9C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828B0AA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B0AA4: 419A0024  beq cr6, 0x828b0ac8
	if ctx.cr[6].eq {
	pc = 0x828B0AC8; continue 'dispatch;
	}
	// 828B0AA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B0AAC: 419A0010  beq cr6, 0x828b0abc
	if ctx.cr[6].eq {
	pc = 0x828B0ABC; continue 'dispatch;
	}
	// 828B0AB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B0AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0AB8: 48000921  bl 0x828b13d8
	ctx.lr = 0x828B0ABC;
	sub_828B13D8(ctx, base);
	// 828B0ABC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828B0AC0: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 828B0AC4: 4082FFE4  bne 0x828b0aa8
	if !ctx.cr[0].eq {
	pc = 0x828B0AA8; continue 'dispatch;
	}
	// 828B0AC8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B0ACC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828B0AD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B0AD4: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828B0AD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B0ADC: 483F8978  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0AE0 size=540
    let mut pc: u32 = 0x828B0AE0;
    'dispatch: loop {
        match pc {
            0x828B0AE0 => {
    //   block [0x828B0AE0..0x828B0CFC)
	// 828B0AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0AE4: 483F8921  bl 0x82ca9404
	ctx.lr = 0x828B0AE8;
	sub_82CA93D0(ctx, base);
	// 828B0AE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0AEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B0AF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B0AF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828B0AF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0AFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B0B00: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 828B0B04: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828B0B08: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0B0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B0B10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0B14: 409A0020  bne cr6, 0x828b0b34
	if !ctx.cr[6].eq {
	pc = 0x828B0B34; continue 'dispatch;
	}
	// 828B0B18: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B0B1C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0B20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B0B24: 4BABAA4D  bl 0x8236b570
	ctx.lr = 0x828B0B28;
	sub_8236B570(ctx, base);
	// 828B0B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0B2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0B30: 483F8924  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0B34: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0B38: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828B0B3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0B40: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0B44: 419A000C  beq cr6, 0x828b0b50
	if ctx.cr[6].eq {
	pc = 0x828B0B50; continue 'dispatch;
	}
	// 828B0B48: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B0B4C: 419A0008  beq cr6, 0x828b0b54
	if ctx.cr[6].eq {
	pc = 0x828B0B54; continue 'dispatch;
	}
	// 828B0B50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0B54: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828B0B58: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B0B5C: 409A0038  bne cr6, 0x828b0b94
	if !ctx.cr[6].eq {
	pc = 0x828B0B94; continue 'dispatch;
	}
	// 828B0B60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0B64: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0B68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0B6C: 40980160  bge cr6, 0x828b0ccc
	if !ctx.cr[6].lt {
	pc = 0x828B0CCC; continue 'dispatch;
	}
	// 828B0B70: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B0B74: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0B78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B0B7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0B80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0B84: 4BABA9ED  bl 0x8236b570
	ctx.lr = 0x828B0B88;
	sub_8236B570(ctx, base);
	// 828B0B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0B8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0B90: 483F88C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0B98: 419A000C  beq cr6, 0x828b0ba4
	if ctx.cr[6].eq {
	pc = 0x828B0BA4; continue 'dispatch;
	}
	// 828B0B9C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B0BA0: 419A0008  beq cr6, 0x828b0ba8
	if ctx.cr[6].eq {
	pc = 0x828B0BA8; continue 'dispatch;
	}
	// 828B0BA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0BA8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0BAC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0BB0: 409A0034  bne cr6, 0x828b0be4
	if !ctx.cr[6].eq {
	pc = 0x828B0BE4; continue 'dispatch;
	}
	// 828B0BB4: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0BB8: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0BBC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0BC0: 4098010C  bge cr6, 0x828b0ccc
	if !ctx.cr[6].lt {
	pc = 0x828B0CCC; continue 'dispatch;
	}
	// 828B0BC4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B0BC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B0BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0BD4: 4BABA99D  bl 0x8236b570
	ctx.lr = 0x828B0BD8;
	sub_8236B570(ctx, base);
	// 828B0BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0BDC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0BE0: 483F8874  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0BE4: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0BE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0BEC: 40980058  bge cr6, 0x828b0c44
	if !ctx.cr[6].lt {
	pc = 0x828B0C44; continue 'dispatch;
	}
	// 828B0BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0BF4: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828B0BF8: 4BDAF951  bl 0x82660548
	ctx.lr = 0x828B0BFC;
	sub_82660548(ctx, base);
	// 828B0BFC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0C00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0C04: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0C08: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0C0C: 40980038  bge cr6, 0x828b0c44
	if !ctx.cr[6].lt {
	pc = 0x828B0C44; continue 'dispatch;
	}
	// 828B0C10: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0C14: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B0C18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0C20: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B0C24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0C28: 409A0090  bne cr6, 0x828b0cb8
	if !ctx.cr[6].eq {
	pc = 0x828B0CB8; continue 'dispatch;
	}
	// 828B0C2C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0C30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B0C34: 4BABA93D  bl 0x8236b570
	ctx.lr = 0x828B0C38;
	sub_8236B570(ctx, base);
	// 828B0C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0C3C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0C40: 483F8814  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0C44: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0C48: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0C4C: 40980080  bge cr6, 0x828b0ccc
	if !ctx.cr[6].lt {
	pc = 0x828B0CCC; continue 'dispatch;
	}
	// 828B0C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0C54: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828B0C58: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0C5C: 4BB8C195  bl 0x8243cdf0
	ctx.lr = 0x828B0C60;
	sub_8243CDF0(ctx, base);
	// 828B0C60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0C68: 419A000C  beq cr6, 0x828b0c74
	if ctx.cr[6].eq {
	pc = 0x828B0C74; continue 'dispatch;
	}
	// 828B0C6C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B0C70: 419A0008  beq cr6, 0x828b0c78
	if ctx.cr[6].eq {
	pc = 0x828B0C78; continue 'dispatch;
	}
	// 828B0C74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0C78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0C7C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0C80: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B0C84: 419A0014  beq cr6, 0x828b0c98
	if ctx.cr[6].eq {
	pc = 0x828B0C98; continue 'dispatch;
	}
	// 828B0C88: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0C8C: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B0C90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0C94: 40980038  bge cr6, 0x828b0ccc
	if !ctx.cr[6].lt {
	pc = 0x828B0CCC; continue 'dispatch;
	}
	// 828B0C98: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0C9C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B0CA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0CA8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B0CAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0CB0: 419AFF80  beq cr6, 0x828b0c30
	if ctx.cr[6].eq {
	pc = 0x828B0C30; continue 'dispatch;
	}
	// 828B0CB4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B0CB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B0CBC: 4BABA8B5  bl 0x8236b570
	ctx.lr = 0x828B0CC0;
	sub_8236B570(ctx, base);
	// 828B0CC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0CC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0CC8: 483F878C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0CCC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B0CD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0CD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0CD8: 480005C1  bl 0x828b1298
	ctx.lr = 0x828B0CDC;
	sub_828B1298(ctx, base);
	// 828B0CDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0CE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0CE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0CE8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B0CEC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0CF0: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B0CF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0CF8: 483F875C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0D00 size=344
    let mut pc: u32 = 0x828B0D00;
    'dispatch: loop {
        match pc {
            0x828B0D00 => {
    //   block [0x828B0D00..0x828B0E58)
	// 828B0D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0D04: 483F86FD  bl 0x82ca9400
	ctx.lr = 0x828B0D08;
	sub_82CA93D0(ctx, base);
	// 828B0D08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0D0C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B0D10: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828B0D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0D18: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828B0D1C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828B0D20: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0D24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0D28: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B0D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0D30: 409A0044  bne cr6, 0x828b0d74
	if !ctx.cr[6].eq {
	pc = 0x828B0D74; continue 'dispatch;
	}
	// 828B0D34: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0D38: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0D3C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828B0D40: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828B0D44: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828B0D48: 41980008  blt cr6, 0x828b0d50
	if ctx.cr[6].lt {
	pc = 0x828B0D50; continue 'dispatch;
	}
	// 828B0D4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B0D50: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B0D54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B0D58: 419A000C  beq cr6, 0x828b0d64
	if ctx.cr[6].eq {
	pc = 0x828B0D64; continue 'dispatch;
	}
	// 828B0D5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0D60: 48000008  b 0x828b0d68
	pc = 0x828B0D68; continue 'dispatch;
	// 828B0D64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0D68: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B0D6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B0D70: 419AFFC8  beq cr6, 0x828b0d38
	if ctx.cr[6].eq {
	pc = 0x828B0D38; continue 'dispatch;
	}
	// 828B0D74: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828B0D78: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B0D7C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B0D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0D84: 419A0054  beq cr6, 0x828b0dd8
	if ctx.cr[6].eq {
	pc = 0x828B0DD8; continue 'dispatch;
	}
	// 828B0D88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0D90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0D94: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0D98: 409A003C  bne cr6, 0x828b0dd4
	if !ctx.cr[6].eq {
	pc = 0x828B0DD4; continue 'dispatch;
	}
	// 828B0D9C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828B0DA0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B0DA4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B0DA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B0DAC: 480001BD  bl 0x828b0f68
	ctx.lr = 0x828B0DB0;
	sub_828B0F68(ctx, base);
	// 828B0DB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0DB4: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828B0DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0DBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0DC0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0DC4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B0DC8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B0DCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0DD0: 483F8680  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B0DD4: 4BACD60D  bl 0x8237e3e0
	ctx.lr = 0x828B0DD8;
	sub_8237E3E0(ctx, base);
	// 828B0DD8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B0DDC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0DE0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B0DE4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828B0DE8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828B0DEC: 41980008  blt cr6, 0x828b0df4
	if ctx.cr[6].lt {
	pc = 0x828B0DF4; continue 'dispatch;
	}
	// 828B0DF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B0DF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B0DF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0DFC: 419A0040  beq cr6, 0x828b0e3c
	if ctx.cr[6].eq {
	pc = 0x828B0E3C; continue 'dispatch;
	}
	// 828B0E00: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828B0E04: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B0E08: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B0E0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B0E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0E14: 48000155  bl 0x828b0f68
	ctx.lr = 0x828B0E18;
	sub_828B0F68(ctx, base);
	// 828B0E18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0E1C: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828B0E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0E24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0E28: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0E2C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B0E30: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B0E34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0E38: 483F8618  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B0E3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B0E40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B0E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0E48: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828B0E4C: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B0E50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0E54: 483F85FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0E58 size=268
    let mut pc: u32 = 0x828B0E58;
    'dispatch: loop {
        match pc {
            0x828B0E58 => {
    //   block [0x828B0E58..0x828B0F64)
	// 828B0E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0E5C: 483F85A9  bl 0x82ca9404
	ctx.lr = 0x828B0E60;
	sub_82CA93D0(ctx, base);
	// 828B0E60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0E64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B0E68: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828B0E6C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828B0E70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B0E74: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828B0E78: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B0E7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0E80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0E84: 419A000C  beq cr6, 0x828b0e90
	if ctx.cr[6].eq {
	pc = 0x828B0E90; continue 'dispatch;
	}
	// 828B0E88: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B0E8C: 419A0008  beq cr6, 0x828b0e94
	if ctx.cr[6].eq {
	pc = 0x828B0E94; continue 'dispatch;
	}
	// 828B0E90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0E94: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828B0E98: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828B0E9C: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828B0EA0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B0EA4: 409A0068  bne cr6, 0x828b0f0c
	if !ctx.cr[6].eq {
	pc = 0x828B0F0C; continue 'dispatch;
	}
	// 828B0EA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B0EAC: 419A000C  beq cr6, 0x828b0eb8
	if ctx.cr[6].eq {
	pc = 0x828B0EB8; continue 'dispatch;
	}
	// 828B0EB0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B0EB4: 419A0008  beq cr6, 0x828b0ebc
	if ctx.cr[6].eq {
	pc = 0x828B0EBC; continue 'dispatch;
	}
	// 828B0EB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0EBC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B0EC0: 409A004C  bne cr6, 0x828b0f0c
	if !ctx.cr[6].eq {
	pc = 0x828B0F0C; continue 'dispatch;
	}
	// 828B0EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0EC8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0ECC: 48000AC5  bl 0x828b1990
	ctx.lr = 0x828B0ED0;
	sub_828B1990(ctx, base);
	// 828B0ED0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0ED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B0ED8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B0EDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0EE0: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B0EE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0EE8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B0EEC: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B0EF0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0EF4: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828B0EF8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0EFC: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0F00: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828B0F04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0F08: 483F854C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828B0F0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B0F10: 419A000C  beq cr6, 0x828b0f1c
	if ctx.cr[6].eq {
	pc = 0x828B0F1C; continue 'dispatch;
	}
	// 828B0F14: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828B0F18: 419A0008  beq cr6, 0x828b0f20
	if ctx.cr[6].eq {
	pc = 0x828B0F20; continue 'dispatch;
	}
	// 828B0F1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828B0F20: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828B0F24: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B0F28: 419A002C  beq cr6, 0x828b0f54
	if ctx.cr[6].eq {
	pc = 0x828B0F54; continue 'dispatch;
	}
	// 828B0F2C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828B0F30: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828B0F34: 4BA63BF5  bl 0x82314b28
	ctx.lr = 0x828B0F38;
	sub_82314B28(ctx, base);
	// 828B0F38: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828B0F3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0F44: 480004F5  bl 0x828b1438
	ctx.lr = 0x828B0F48;
	sub_828B1438(ctx, base);
	// 828B0F48: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 828B0F4C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828B0F50: 4BFFFFBC  b 0x828b0f0c
	pc = 0x828B0F0C; continue 'dispatch;
	// 828B0F54: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828B0F58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0F5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0F60: 483F84F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0F68 size=632
    let mut pc: u32 = 0x828B0F68;
    'dispatch: loop {
        match pc {
            0x828B0F68 => {
    //   block [0x828B0F68..0x828B11E0)
	// 828B0F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0F6C: 483F848D  bl 0x82ca93f8
	ctx.lr = 0x828B0F70;
	sub_82CA93D0(ctx, base);
	// 828B0F70: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0F74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B0F78: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 828B0F7C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828B0F80: 6169CCCB  ori r9, r11, 0xcccb
	ctx.r[9].u64 = ctx.r[11].u64 | 52427;
	// 828B0F84: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828B0F88: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B0F8C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828B0F90: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828B0F94: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B0F98: 41980048  blt cr6, 0x828b0fe0
	if ctx.cr[6].lt {
	pc = 0x828B0FE0; continue 'dispatch;
	}
	// 828B0F9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B0FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0FA4: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 828B0FA8: 4BA40F99  bl 0x822f1f40
	ctx.lr = 0x828B0FAC;
	sub_822F1F40(ctx, base);
	// 828B0FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B0FB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B0FB4: 4BA40DFD  bl 0x822f1db0
	ctx.lr = 0x828B0FB8;
	sub_822F1DB0(ctx, base);
	// 828B0FB8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828B0FBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B0FC0: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828B0FC4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B0FC8: 4BA40E59  bl 0x822f1e20
	ctx.lr = 0x828B0FCC;
	sub_822F1E20(ctx, base);
	// 828B0FCC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B0FD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B0FD4: 4BDCA80D  bl 0x8267b7e0
	ctx.lr = 0x828B0FD8;
	sub_8267B7E0(ctx, base);
	// 828B0FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0FDC: 4B8C0835  bl 0x82171810
	ctx.lr = 0x828B0FE0;
	sub_82171810(ctx, base);
	// 828B0FE0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 828B0FE4: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0FE8: 4B96E271  bl 0x8221f258
	ctx.lr = 0x828B0FEC;
	sub_8221F258(ctx, base);
	// 828B0FEC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B0FF0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828B0FF4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828B0FF8: 419A0030  beq cr6, 0x828b1028
	if ctx.cr[6].eq {
	pc = 0x828B1028; continue 'dispatch;
	}
	// 828B0FFC: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 828B1000: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B1004: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B1008: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 828B100C: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828B1010: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828B1014: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1018: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B101C: 480001C5  bl 0x828b11e0
	ctx.lr = 0x828B1020;
	sub_828B11E0(ctx, base);
	// 828B1020: 9B3B0020  stb r25, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828B1024: 9B3B0021  stb r25, 0x21(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	// 828B1028: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B102C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1030: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B1034: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B1038: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B103C: 409A001C  bne cr6, 0x828b1058
	if !ctx.cr[6].eq {
	pc = 0x828B1058; continue 'dispatch;
	}
	// 828B1040: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828B1044: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1048: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B104C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1050: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828B1054: 48000044  b 0x828b1098
	pc = 0x828B1098; continue 'dispatch;
	// 828B1058: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828B105C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1060: 419A0020  beq cr6, 0x828b1080
	if ctx.cr[6].eq {
	pc = 0x828B1080; continue 'dispatch;
	}
	// 828B1064: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B1068: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B106C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1070: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B1074: 409A0024  bne cr6, 0x828b1098
	if !ctx.cr[6].eq {
	pc = 0x828B1098; continue 'dispatch;
	}
	// 828B1078: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B107C: 4800001C  b 0x828b1098
	pc = 0x828B1098; continue 'dispatch;
	// 828B1080: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828B1084: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1088: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B108C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B1090: 409A0008  bne cr6, 0x828b1098
	if !ctx.cr[6].eq {
	pc = 0x828B1098; continue 'dispatch;
	}
	// 828B1094: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828B1098: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B109C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828B10A0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828B10A4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B10A8: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B10AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B10B0: 409A0110  bne cr6, 0x828b11c0
	if !ctx.cr[6].eq {
	pc = 0x828B11C0; continue 'dispatch;
	}
	// 828B10B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B10B8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B10BC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B10C0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B10C4: 409A0078  bne cr6, 0x828b113c
	if !ctx.cr[6].eq {
	pc = 0x828B113C; continue 'dispatch;
	}
	// 828B10C8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B10CC: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B10D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B10D4: 409A0028  bne cr6, 0x828b10fc
	if !ctx.cr[6].eq {
	pc = 0x828B10FC; continue 'dispatch;
	}
	// 828B10D8: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828B10DC: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B10E0: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B10E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B10E8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B10EC: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828B10F0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B10F4: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B10F8: 480000B4  b 0x828b11ac
	pc = 0x828B11AC; continue 'dispatch;
	// 828B10FC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1100: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B1104: 409A0010  bne cr6, 0x828b1114
	if !ctx.cr[6].eq {
	pc = 0x828B1114; continue 'dispatch;
	}
	// 828B1108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B110C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1110: 48000771  bl 0x828b1880
	ctx.lr = 0x828B1114;
	sub_828B1880(ctx, base);
	// 828B1114: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1118: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B111C: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1120: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1124: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1128: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828B112C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1130: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1134: 4BA629C5  bl 0x82313af8
	ctx.lr = 0x828B1138;
	sub_82313AF8(ctx, base);
	// 828B1138: 48000074  b 0x828b11ac
	pc = 0x828B11AC; continue 'dispatch;
	// 828B113C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1140: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B1148: 409A0028  bne cr6, 0x828b1170
	if !ctx.cr[6].eq {
	pc = 0x828B1170; continue 'dispatch;
	}
	// 828B114C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1150: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1154: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1158: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B115C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1160: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828B1164: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1168: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B116C: 48000040  b 0x828b11ac
	pc = 0x828B11AC; continue 'dispatch;
	// 828B1170: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1174: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B1178: 409A0010  bne cr6, 0x828b1188
	if !ctx.cr[6].eq {
	pc = 0x828B1188; continue 'dispatch;
	}
	// 828B117C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B1180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1184: 4BA62975  bl 0x82313af8
	ctx.lr = 0x828B1188;
	sub_82313AF8(ctx, base);
	// 828B1188: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B118C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B1190: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1194: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1198: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B119C: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828B11A0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B11A4: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B11A8: 480006D9  bl 0x828b1880
	ctx.lr = 0x828B11AC;
	sub_828B1880(ctx, base);
	// 828B11AC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B11B0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828B11B4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B11B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B11BC: 419AFEF8  beq cr6, 0x828b10b4
	if ctx.cr[6].eq {
	pc = 0x828B10B4; continue 'dispatch;
	}
	// 828B11C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B11C4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B11C8: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828B11CC: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B11D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B11D4: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B11D8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B11DC: 483F826C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B11E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B11E0 size=180
    let mut pc: u32 = 0x828B11E0;
    'dispatch: loop {
        match pc {
            0x828B11E0 => {
    //   block [0x828B11E0..0x828B1294)
	// 828B11E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B11E4: 483F8225  bl 0x82ca9408
	ctx.lr = 0x828B11E8;
	sub_82CA93D0(ctx, base);
	// 828B11E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B11EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B11F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B11F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B11F8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828B11FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1200: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1204: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B1208: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B120C: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828B1210: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828B1214: 7C8853D7  divw. r4, r8, r10
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828B1218: 4082000C  bne 0x828b1224
	if !ctx.cr[0].eq {
	pc = 0x828B1224; continue 'dispatch;
	}
	// 828B121C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1220: 4800000C  b 0x828b122c
	pc = 0x828B122C; continue 'dispatch;
	// 828B1224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B1228: 4BB66F79  bl 0x824181a0
	ctx.lr = 0x828B122C;
	sub_824181A0(ctx, base);
	// 828B122C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B1230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1234: 419A0054  beq cr6, 0x828b1288
	if ctx.cr[6].eq {
	pc = 0x828B1288; continue 'dispatch;
	}
	// 828B1238: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B123C: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1240: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B1244: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1248: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B124C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B1250: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B1254: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B1258: 419A002C  beq cr6, 0x828b1284
	if ctx.cr[6].eq {
	pc = 0x828B1284; continue 'dispatch;
	}
	// 828B125C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B1260: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1264: 419A0010  beq cr6, 0x828b1274
	if ctx.cr[6].eq {
	pc = 0x828B1274; continue 'dispatch;
	}
	// 828B1268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B126C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1270: 48000169  bl 0x828b13d8
	ctx.lr = 0x828B1274;
	sub_828B13D8(ctx, base);
	// 828B1274: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 828B1278: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 828B127C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1280: 409AFFE0  bne cr6, 0x828b1260
	if !ctx.cr[6].eq {
	pc = 0x828B1260; continue 'dispatch;
	}
	// 828B1284: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828B1288: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B128C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1290: 483F81C8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B1298 size=316
    let mut pc: u32 = 0x828B1298;
    'dispatch: loop {
        match pc {
            0x828B1298 => {
    //   block [0x828B1298..0x828B13D4)
	// 828B1298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B129C: 483F8165  bl 0x82ca9400
	ctx.lr = 0x828B12A0;
	sub_82CA93D0(ctx, base);
	// 828B12A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B12A4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B12A8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828B12AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B12B0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828B12B4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828B12B8: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B12BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B12C0: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B12C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B12C8: 409A003C  bne cr6, 0x828b1304
	if !ctx.cr[6].eq {
	pc = 0x828B1304; continue 'dispatch;
	}
	// 828B12CC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B12D0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B12D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B12D8: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828B12DC: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 828B12E0: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 828B12E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B12E8: 419A000C  beq cr6, 0x828b12f4
	if ctx.cr[6].eq {
	pc = 0x828B12F4; continue 'dispatch;
	}
	// 828B12EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B12F0: 48000008  b 0x828b12f8
	pc = 0x828B12F8; continue 'dispatch;
	// 828B12F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B12F8: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828B12FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B1300: 419AFFD0  beq cr6, 0x828b12d0
	if ctx.cr[6].eq {
	pc = 0x828B12D0; continue 'dispatch;
	}
	// 828B1304: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828B1308: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B130C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B1310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1314: 419A0054  beq cr6, 0x828b1368
	if ctx.cr[6].eq {
	pc = 0x828B1368; continue 'dispatch;
	}
	// 828B1318: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B131C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1320: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1324: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B1328: 409A003C  bne cr6, 0x828b1364
	if !ctx.cr[6].eq {
	pc = 0x828B1364; continue 'dispatch;
	}
	// 828B132C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828B1330: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B1334: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1338: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B133C: 4BABA235  bl 0x8236b570
	ctx.lr = 0x828B1340;
	sub_8236B570(ctx, base);
	// 828B1340: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B1344: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828B1348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B134C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1350: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1354: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B1358: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B135C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B1360: 483F80F0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B1364: 4BDAF1E5  bl 0x82660548
	ctx.lr = 0x828B1368;
	sub_82660548(ctx, base);
	// 828B1368: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B136C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1370: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B1374: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B1378: 40980040  bge cr6, 0x828b13b8
	if !ctx.cr[6].lt {
	pc = 0x828B13B8; continue 'dispatch;
	}
	// 828B137C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828B1380: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B1384: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B1388: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B138C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1390: 4BABA1E1  bl 0x8236b570
	ctx.lr = 0x828B1394;
	sub_8236B570(ctx, base);
	// 828B1394: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B1398: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828B139C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B13A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B13A4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B13A8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B13AC: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B13B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B13B4: 483F809C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828B13B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B13BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B13C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B13C4: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828B13C8: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B13CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B13D0: 483F8080  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B13D8 size=96
    let mut pc: u32 = 0x828B13D8;
    'dispatch: loop {
        match pc {
            0x828B13D8 => {
    //   block [0x828B13D8..0x828B1438)
	// 828B13D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B13DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B13E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B13E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B13E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B13EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B13F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B13F4: 4B93EE4D  bl 0x821f0240
	ctx.lr = 0x828B13F8;
	sub_821F0240(ctx, base);
	// 828B13F8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828B13FC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828B1400: 4B93EE41  bl 0x821f0240
	ctx.lr = 0x828B1404;
	sub_821F0240(ctx, base);
	// 828B1404: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B140C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B1410: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B1414: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828B1418: 893E0010  lbz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B141C: 993F0010  stb r9, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 828B1420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B142C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1438 size=1096
    let mut pc: u32 = 0x828B1438;
    'dispatch: loop {
        match pc {
            0x828B1438 => {
    //   block [0x828B1438..0x828B1880)
	// 828B1438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B143C: 483F7FC1  bl 0x82ca93fc
	ctx.lr = 0x828B1440;
	sub_82CA93D0(ctx, base);
	// 828B1440: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1444: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 828B1448: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B144C: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828B1450: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828B1454: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B145C: 419A0048  beq cr6, 0x828b14a4
	if ctx.cr[6].eq {
	pc = 0x828B14A4; continue 'dispatch;
	}
	// 828B1460: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B1464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1468: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 828B146C: 4BA40AD5  bl 0x822f1f40
	ctx.lr = 0x828B1470;
	sub_822F1F40(ctx, base);
	// 828B1470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B1478: 4BA40939  bl 0x822f1db0
	ctx.lr = 0x828B147C;
	sub_822F1DB0(ctx, base);
	// 828B147C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828B1480: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B1484: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828B1488: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B148C: 4BA40995  bl 0x822f1e20
	ctx.lr = 0x828B1490;
	sub_822F1E20(ctx, base);
	// 828B1490: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B1494: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B1498: 4BDCA349  bl 0x8267b7e0
	ctx.lr = 0x828B149C;
	sub_8267B7E0(ctx, base);
	// 828B149C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B14A0: 4B8C0371  bl 0x82171810
	ctx.lr = 0x828B14A4;
	sub_82171810(ctx, base);
	// 828B14A4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828B14A8: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 828B14AC: 4BA6367D  bl 0x82314b28
	ctx.lr = 0x828B14B0;
	sub_82314B28(ctx, base);
	// 828B14B0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B14B4: 896A0021  lbz r11, 0x21(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B14B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B14BC: 419A000C  beq cr6, 0x828b14c8
	if ctx.cr[6].eq {
	pc = 0x828B14C8; continue 'dispatch;
	}
	// 828B14C0: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B14C4: 4800002C  b 0x828b14f0
	pc = 0x828B14F0; continue 'dispatch;
	// 828B14C8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B14CC: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B14D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B14D4: 419A000C  beq cr6, 0x828b14e0
	if ctx.cr[6].eq {
	pc = 0x828B14E0; continue 'dispatch;
	}
	// 828B14D8: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 828B14DC: 48000014  b 0x828b14f0
	pc = 0x828B14F0; continue 'dispatch;
	// 828B14E0: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828B14E4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B14E8: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B14EC: 409A00F0  bne cr6, 0x828b15dc
	if !ctx.cr[6].eq {
	pc = 0x828B15DC; continue 'dispatch;
	}
	// 828B14F0: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B14F4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B14F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B14FC: 409A0008  bne cr6, 0x828b1504
	if !ctx.cr[6].eq {
	pc = 0x828B1504; continue 'dispatch;
	}
	// 828B1500: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B1504: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1508: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B150C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1510: 409A000C  bne cr6, 0x828b151c
	if !ctx.cr[6].eq {
	pc = 0x828B151C; continue 'dispatch;
	}
	// 828B1514: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828B1518: 4800001C  b 0x828b1534
	pc = 0x828B1534; continue 'dispatch;
	// 828B151C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1520: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1524: 409A000C  bne cr6, 0x828b1530
	if !ctx.cr[6].eq {
	pc = 0x828B1530; continue 'dispatch;
	}
	// 828B1528: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828B152C: 48000008  b 0x828b1534
	pc = 0x828B1534; continue 'dispatch;
	// 828B1530: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828B1534: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1538: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B153C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1540: 409A0044  bne cr6, 0x828b1584
	if !ctx.cr[6].eq {
	pc = 0x828B1584; continue 'dispatch;
	}
	// 828B1544: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B154C: 419A000C  beq cr6, 0x828b1558
	if ctx.cr[6].eq {
	pc = 0x828B1558; continue 'dispatch;
	}
	// 828B1550: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828B1554: 4800002C  b 0x828b1580
	pc = 0x828B1580; continue 'dispatch;
	// 828B1558: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B155C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828B1560: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1564: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B1568: 409A0018  bne cr6, 0x828b1580
	if !ctx.cr[6].eq {
	pc = 0x828B1580; continue 'dispatch;
	}
	// 828B156C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B1570: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1574: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1578: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B157C: 419AFFF0  beq cr6, 0x828b156c
	if ctx.cr[6].eq {
	pc = 0x828B156C; continue 'dispatch;
	}
	// 828B1580: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B1584: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1588: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B158C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1590: 409A00E0  bne cr6, 0x828b1670
	if !ctx.cr[6].eq {
	pc = 0x828B1670; continue 'dispatch;
	}
	// 828B1594: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B159C: 419A0010  beq cr6, 0x828b15ac
	if ctx.cr[6].eq {
	pc = 0x828B15AC; continue 'dispatch;
	}
	// 828B15A0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828B15A4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B15A8: 480000C8  b 0x828b1670
	pc = 0x828B1670; continue 'dispatch;
	// 828B15AC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B15B0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828B15B4: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B15B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B15BC: 409A0018  bne cr6, 0x828b15d4
	if !ctx.cr[6].eq {
	pc = 0x828B15D4; continue 'dispatch;
	}
	// 828B15C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828B15C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B15C8: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B15CC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B15D0: 419AFFF0  beq cr6, 0x828b15c0
	if ctx.cr[6].eq {
	pc = 0x828B15C0; continue 'dispatch;
	}
	// 828B15D4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B15D8: 48000098  b 0x828b1670
	pc = 0x828B1670; continue 'dispatch;
	// 828B15DC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B15E0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B15E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B15E8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B15EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B15F0: 409A000C  bne cr6, 0x828b15fc
	if !ctx.cr[6].eq {
	pc = 0x828B15FC; continue 'dispatch;
	}
	// 828B15F4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B15F8: 4800002C  b 0x828b1624
	pc = 0x828B1624; continue 'dispatch;
	// 828B15FC: 895C0021  lbz r10, 0x21(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1600: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1604: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B1608: 409A0008  bne cr6, 0x828b1610
	if !ctx.cr[6].eq {
	pc = 0x828B1610; continue 'dispatch;
	}
	// 828B160C: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B1610: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828B1614: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1618: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B161C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1620: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B1624: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1628: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B162C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1630: 409A000C  bne cr6, 0x828b163c
	if !ctx.cr[6].eq {
	pc = 0x828B163C; continue 'dispatch;
	}
	// 828B1634: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B1638: 48000020  b 0x828b1658
	pc = 0x828B1658; continue 'dispatch;
	// 828B163C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1640: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1644: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828B1648: 409A000C  bne cr6, 0x828b1654
	if !ctx.cr[6].eq {
	pc = 0x828B1654; continue 'dispatch;
	}
	// 828B164C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B1650: 48000008  b 0x828b1658
	pc = 0x828B1658; continue 'dispatch;
	// 828B1654: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B1658: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B165C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B1660: 890B0020  lbz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1664: 893A0020  lbz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1668: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 828B166C: 991A0020  stb r8, 0x20(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[8].u8 ) };
	// 828B1670: 897A0020  lbz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1674: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B1678: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828B167C: 409A0194  bne cr6, 0x828b1810
	if !ctx.cr[6].eq {
	pc = 0x828B1810; continue 'dispatch;
	}
	// 828B1680: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1684: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828B1688: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B168C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B1690: 419A017C  beq cr6, 0x828b180c
	if ctx.cr[6].eq {
	pc = 0x828B180C; continue 'dispatch;
	}
	// 828B1694: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1698: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828B169C: 409A0170  bne cr6, 0x828b180c
	if !ctx.cr[6].eq {
	pc = 0x828B180C; continue 'dispatch;
	}
	// 828B16A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B16A4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828B16A8: 409A00A8  bne cr6, 0x828b1750
	if !ctx.cr[6].eq {
	pc = 0x828B1750; continue 'dispatch;
	}
	// 828B16AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B16B0: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B16B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B16B8: 409A001C  bne cr6, 0x828b16d4
	if !ctx.cr[6].eq {
	pc = 0x828B16D4; continue 'dispatch;
	}
	// 828B16BC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B16C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B16C4: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B16C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B16CC: 480001B5  bl 0x828b1880
	ctx.lr = 0x828B16D0;
	sub_828B1880(ctx, base);
	// 828B16D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B16D4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B16D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B16DC: 409A00C8  bne cr6, 0x828b17a4
	if !ctx.cr[6].eq {
	pc = 0x828B17A4; continue 'dispatch;
	}
	// 828B16E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B16E4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B16E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B16EC: 409A0014  bne cr6, 0x828b1700
	if !ctx.cr[6].eq {
	pc = 0x828B1700; continue 'dispatch;
	}
	// 828B16F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B16F4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B16F8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B16FC: 419A00A4  beq cr6, 0x828b17a0
	if ctx.cr[6].eq {
	pc = 0x828B17A0; continue 'dispatch;
	}
	// 828B1700: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1704: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1708: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B170C: 409A0020  bne cr6, 0x828b172c
	if !ctx.cr[6].eq {
	pc = 0x828B172C; continue 'dispatch;
	}
	// 828B1710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1714: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828B1718: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B171C: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1720: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1724: 4BA623D5  bl 0x82313af8
	ctx.lr = 0x828B1728;
	sub_82313AF8(ctx, base);
	// 828B1728: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B172C: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B1734: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B1738: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 828B173C: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1740: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1744: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1748: 48000139  bl 0x828b1880
	ctx.lr = 0x828B174C;
	sub_828B1880(ctx, base);
	// 828B174C: 480000C0  b 0x828b180c
	pc = 0x828B180C; continue 'dispatch;
	// 828B1750: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1754: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B1758: 409A001C  bne cr6, 0x828b1774
	if !ctx.cr[6].eq {
	pc = 0x828B1774; continue 'dispatch;
	}
	// 828B175C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B1764: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B1768: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B176C: 4BA6238D  bl 0x82313af8
	ctx.lr = 0x828B1770;
	sub_82313AF8(ctx, base);
	// 828B1770: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1774: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1778: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B177C: 409A0028  bne cr6, 0x828b17a4
	if !ctx.cr[6].eq {
	pc = 0x828B17A4; continue 'dispatch;
	}
	// 828B1780: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1784: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1788: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B178C: 409A0034  bne cr6, 0x828b17c0
	if !ctx.cr[6].eq {
	pc = 0x828B17C0; continue 'dispatch;
	}
	// 828B1790: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1794: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B1798: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B179C: 409A0024  bne cr6, 0x828b17c0
	if !ctx.cr[6].eq {
	pc = 0x828B17C0; continue 'dispatch;
	}
	// 828B17A0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B17A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B17A8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828B17AC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B17B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B17B4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B17B8: 409AFEDC  bne cr6, 0x828b1694
	if !ctx.cr[6].eq {
	pc = 0x828B1694; continue 'dispatch;
	}
	// 828B17BC: 48000050  b 0x828b180c
	pc = 0x828B180C; continue 'dispatch;
	// 828B17C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B17C4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B17C8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828B17CC: 409A0020  bne cr6, 0x828b17ec
	if !ctx.cr[6].eq {
	pc = 0x828B17EC; continue 'dispatch;
	}
	// 828B17D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B17D4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828B17D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B17DC: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B17E0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828B17E4: 4800009D  bl 0x828b1880
	ctx.lr = 0x828B17E8;
	sub_828B1880(ctx, base);
	// 828B17E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B17EC: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B17F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B17F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B17F8: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 828B17FC: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1800: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1804: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1808: 4BA622F1  bl 0x82313af8
	ctx.lr = 0x828B180C;
	sub_82313AF8(ctx, base);
	// 828B180C: 9BBC0020  stb r29, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828B1810: 809A0014  lwz r4, 0x14(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B1814: 3BFA0010  addi r31, r26, 0x10
	ctx.r[31].s64 = ctx.r[26].s64 + 16;
	// 828B1818: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B181C: 419A0018  beq cr6, 0x828b1834
	if ctx.cr[6].eq {
	pc = 0x828B1834; continue 'dispatch;
	}
	// 828B1820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1824: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1828: 480000D1  bl 0x828b18f8
	ctx.lr = 0x828B182C;
	sub_828B18F8(ctx, base);
	// 828B182C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1830: 4B96A509  bl 0x8221bd38
	ctx.lr = 0x828B1834;
	sub_8221BD38(ctx, base);
	// 828B1834: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B1838: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B183C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828B1840: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828B1844: 4B96A4F5  bl 0x8221bd38
	ctx.lr = 0x828B1848;
	sub_8221BD38(ctx, base);
	// 828B1848: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B184C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B1850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1854: 419A001C  beq cr6, 0x828b1870
	if ctx.cr[6].eq {
	pc = 0x828B1870; continue 'dispatch;
	}
	// 828B1858: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828B185C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 828B1860: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828B1864: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828B1868: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B186C: 483F7BE0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828B1870: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828B1874: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B1878: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B187C: 483F7BD0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1880 size=72
    let mut pc: u32 = 0x828B1880;
    'dispatch: loop {
        match pc {
            0x828B1880 => {
    //   block [0x828B1880..0x828B18C8)
	// 828B1880: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1884: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1888: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B188C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1890: 892A0021  lbz r9, 0x21(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1894: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B1898: 409A0008  bne cr6, 0x828b18a0
	if !ctx.cr[6].eq {
	pc = 0x828B18A0; continue 'dispatch;
	}
	// 828B189C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828B18A0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B18A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B18A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B18AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B18B0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B18B4: 409A0014  bne cr6, 0x828b18c8
	if !ctx.cr[6].eq {
		sub_828B18C8(ctx, base);
		return;
	}
	// 828B18B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B18BC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828B18C0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B18C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B18C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B18C8 size=32
    let mut pc: u32 = 0x828B18C8;
    'dispatch: loop {
        match pc {
            0x828B18C8 => {
    //   block [0x828B18C8..0x828B18E8)
	// 828B18C8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B18CC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B18D0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B18D4: 409A0014  bne cr6, 0x828b18e8
	if !ctx.cr[6].eq {
		sub_828B18E8(ctx, base);
		return;
	}
	// 828B18D8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B18DC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828B18E0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B18E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B18E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B18E8 size=16
    let mut pc: u32 = 0x828B18E8;
    'dispatch: loop {
        match pc {
            0x828B18E8 => {
    //   block [0x828B18E8..0x828B18F8)
	// 828B18E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B18EC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828B18F0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B18F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B18F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B18F8 size=148
    let mut pc: u32 = 0x828B18F8;
    'dispatch: loop {
        match pc {
            0x828B18F8 => {
    //   block [0x828B18F8..0x828B198C)
	// 828B18F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B18FC: 483F7B0D  bl 0x82ca9408
	ctx.lr = 0x828B1900;
	sub_82CA93D0(ctx, base);
	// 828B1900: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1904: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828B1908: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B190C: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1910: 419A0074  beq cr6, 0x828b1984
	if ctx.cr[6].eq {
	pc = 0x828B1984; continue 'dispatch;
	}
	// 828B1914: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B1918: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B191C: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 828B1920: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828B1924: 4B914E45  bl 0x821c6768
	ctx.lr = 0x828B1928;
	sub_821C6768(ctx, base);
	// 828B1928: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828B192C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B1930: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1934: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B1938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B193C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B1940: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1944: 4082FFE8  bne 0x828b192c
	if !ctx.cr[0].eq {
	pc = 0x828B192C; continue 'dispatch;
	}
	// 828B1948: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828B194C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1950: 4B914E19  bl 0x821c6768
	ctx.lr = 0x828B1954;
	sub_821C6768(ctx, base);
	// 828B1954: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B1958: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B195C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1960: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B1964: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828B1968: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B196C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1970: 4082FFE8  bne 0x828b1958
	if !ctx.cr[0].eq {
	pc = 0x828B1958; continue 'dispatch;
	}
	// 828B1974: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B1978: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 828B197C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1980: 409AFFA0  bne cr6, 0x828b1920
	if !ctx.cr[6].eq {
	pc = 0x828B1920; continue 'dispatch;
	}
	// 828B1984: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1988: 483F7AD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1990 size=136
    let mut pc: u32 = 0x828B1990;
    'dispatch: loop {
        match pc {
            0x828B1990 => {
    //   block [0x828B1990..0x828B1A18)
	// 828B1990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1994: 483F7A71  bl 0x82ca9404
	ctx.lr = 0x828B1998;
	sub_82CA93D0(ctx, base);
	// 828B1998: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B199C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B19A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B19A4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828B19A8: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B19AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B19B0: 409A0060  bne cr6, 0x828b1a10
	if !ctx.cr[6].eq {
	pc = 0x828B1A10; continue 'dispatch;
	}
	// 828B19B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B19B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B19BC: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B19C0: 4BFFFFD1  bl 0x828b1990
	ctx.lr = 0x828B19C4;
	sub_828B1990(ctx, base);
	// 828B19C4: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B19C8: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 828B19CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B19D0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B19D4: 419A0018  beq cr6, 0x828b19ec
	if ctx.cr[6].eq {
	pc = 0x828B19EC; continue 'dispatch;
	}
	// 828B19D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B19DC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B19E0: 4BFFFF19  bl 0x828b18f8
	ctx.lr = 0x828B19E4;
	sub_828B18F8(ctx, base);
	// 828B19E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B19E8: 4B96A351  bl 0x8221bd38
	ctx.lr = 0x828B19EC;
	sub_8221BD38(ctx, base);
	// 828B19EC: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828B19F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B19F4: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828B19F8: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 828B19FC: 4B96A33D  bl 0x8221bd38
	ctx.lr = 0x828B1A00;
	sub_8221BD38(ctx, base);
	// 828B1A00: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 828B1A04: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828B1A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1A0C: 419AFFAC  beq cr6, 0x828b19b8
	if ctx.cr[6].eq {
	pc = 0x828B19B8; continue 'dispatch;
	}
	// 828B1A10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1A14: 483F7A40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1A18 size=108
    let mut pc: u32 = 0x828B1A18;
    'dispatch: loop {
        match pc {
            0x828B1A18 => {
    //   block [0x828B1A18..0x828B1A84)
	// 828B1A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1A1C: 483F79ED  bl 0x82ca9408
	ctx.lr = 0x828B1A20;
	sub_82CA93D0(ctx, base);
	// 828B1A20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1A24: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B1A28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B1A2C: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1A30: 419A004C  beq cr6, 0x828b1a7c
	if ctx.cr[6].eq {
	pc = 0x828B1A7C; continue 'dispatch;
	}
	// 828B1A34: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828B1A38: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 828B1A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1A40: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 828B1A44: 4B9B375D  bl 0x822651a0
	ctx.lr = 0x828B1A48;
	sub_822651A0(ctx, base);
	// 828B1A48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B1A4C: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 828B1A50: 4B9B3751  bl 0x822651a0
	ctx.lr = 0x828B1A54;
	sub_822651A0(ctx, base);
	// 828B1A54: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1A58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B1A5C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B1A60: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B1A64: 893E0010  lbz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B1A68: 993F0008  stb r9, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 828B1A6C: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 828B1A70: 391FFFF8  addi r8, r31, -8
	ctx.r[8].s64 = ctx.r[31].s64 + -8;
	// 828B1A74: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828B1A78: 409AFFC4  bne cr6, 0x828b1a3c
	if !ctx.cr[6].eq {
	pc = 0x828B1A3C; continue 'dispatch;
	}
	// 828B1A7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1A80: 483F79D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1A88 size=120
    let mut pc: u32 = 0x828B1A88;
    'dispatch: loop {
        match pc {
            0x828B1A88 => {
    //   block [0x828B1A88..0x828B1B00)
	// 828B1A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1A94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1A98: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828B1A9C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828B1AA0: 4814EC29  bl 0x82a006c8
	ctx.lr = 0x828B1AA4;
	sub_82A006C8(ctx, base);
	// 828B1AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B1AA8: 419A0010  beq cr6, 0x828b1ab8
	if ctx.cr[6].eq {
	pc = 0x828B1AB8; continue 'dispatch;
	}
	// 828B1AAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1AB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1AB4: 4800000C  b 0x828b1ac0
	pc = 0x828B1AC0; continue 'dispatch;
	// 828B1AB8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B1ABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B1AC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B1AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1AC8: 419A0020  beq cr6, 0x828b1ae8
	if ctx.cr[6].eq {
	pc = 0x828B1AE8; continue 'dispatch;
	}
	// 828B1ACC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B1AD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B1AD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1AD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1ADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1AE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1AE4: 4E800020  blr
	return;
	// 828B1AE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B1AEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1AF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1B00 size=8
    let mut pc: u32 = 0x828B1B00;
    'dispatch: loop {
        match pc {
            0x828B1B00 => {
    //   block [0x828B1B00..0x828B1B08)
	// 828B1B00: 3860008F  li r3, 0x8f
	ctx.r[3].s64 = 143;
	// 828B1B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1B08 size=60
    let mut pc: u32 = 0x828B1B08;
    'dispatch: loop {
        match pc {
            0x828B1B08 => {
    //   block [0x828B1B08..0x828B1B44)
	// 828B1B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1B18: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828B1B1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B1B20: 388BBA4C  addi r4, r11, -0x45b4
	ctx.r[4].s64 = ctx.r[11].s64 + -17844;
	// 828B1B24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1B28: 4B97B3A9  bl 0x8222ced0
	ctx.lr = 0x828B1B2C;
	sub_8222CED0(ctx, base);
	// 828B1B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1B30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B1B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1B3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1B40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B1B48 size=152
    let mut pc: u32 = 0x828B1B48;
    'dispatch: loop {
        match pc {
            0x828B1B48 => {
    //   block [0x828B1B48..0x828B1BE0)
	// 828B1B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1B5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1B60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1B64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1B68: 419A0060  beq cr6, 0x828b1bc8
	if ctx.cr[6].eq {
	pc = 0x828B1BC8; continue 'dispatch;
	}
	// 828B1B6C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B1B70: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828B1B74: 388B2A38  addi r4, r11, 0x2a38
	ctx.r[4].s64 = ctx.r[11].s64 + 10808;
	// 828B1B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1B7C: 4BAFB875  bl 0x823ad3f0
	ctx.lr = 0x828B1B80;
	sub_823AD3F0(ctx, base);
	// 828B1B80: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B1B84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B1B88: 388A2A44  addi r4, r10, 0x2a44
	ctx.r[4].s64 = ctx.r[10].s64 + 10820;
	// 828B1B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1B90: 4BAFB7B1  bl 0x823ad340
	ctx.lr = 0x828B1B94;
	sub_823AD340(ctx, base);
	// 828B1B94: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828B1B98: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B1B9C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B1BA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B1BA4: C8099660  lfd f0, -0x69a0(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 828B1BA8: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 828B1BAC: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 828B1BB0: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 828B1BB4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B1BB8: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B1BBC: 409A0008  bne cr6, 0x828b1bc4
	if !ctx.cr[6].eq {
	pc = 0x828B1BC4; continue 'dispatch;
	}
	// 828B1BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B1BC4: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828B1BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1BD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1BD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1BE0 size=708
    let mut pc: u32 = 0x828B1BE0;
    'dispatch: loop {
        match pc {
            0x828B1BE0 => {
    //   block [0x828B1BE0..0x828B1EA4)
	// 828B1BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1BF8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B1BFC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828B1C00: 4099028C  ble cr6, 0x828b1e8c
	if !ctx.cr[6].gt {
	pc = 0x828B1E8C; continue 'dispatch;
	}
	// 828B1C04: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B1C08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B1C0C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B1C10: 4099014C  ble cr6, 0x828b1d5c
	if !ctx.cr[6].gt {
	pc = 0x828B1D5C; continue 'dispatch;
	}
	// 828B1C14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1C1C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B1C20: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828B1C24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B1C28: 419A00F4  beq cr6, 0x828b1d1c
	if ctx.cr[6].eq {
	pc = 0x828B1D1C; continue 'dispatch;
	}
	// 828B1C2C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B1C30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B1C34: 419A0024  beq cr6, 0x828b1c58
	if ctx.cr[6].eq {
	pc = 0x828B1C58; continue 'dispatch;
	}
	// 828B1C38: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B1C3C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B1C40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B1C44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B1C48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1C4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B1C50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1C54: 480000CC  b 0x828b1d20
	pc = 0x828B1D20; continue 'dispatch;
	// 828B1C58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B1C5C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B1C60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B1C64: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B1C68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B1C6C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1C70: 40810054  ble 0x828b1cc4
	if !ctx.cr[0].gt {
	pc = 0x828B1CC4; continue 'dispatch;
	}
	// 828B1C74: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B1C78: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B1C7C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B1C80: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1C84: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B1C88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B1C8C: 41980008  blt cr6, 0x828b1c94
	if ctx.cr[6].lt {
	pc = 0x828B1C94; continue 'dispatch;
	}
	// 828B1C90: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B1C94: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B1C98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B1C9C: 419A0014  beq cr6, 0x828b1cb0
	if ctx.cr[6].eq {
	pc = 0x828B1CB0; continue 'dispatch;
	}
	// 828B1CA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B1CA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B1CA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B1CAC: 4800000C  b 0x828b1cb8
	pc = 0x828B1CB8; continue 'dispatch;
	// 828B1CB0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B1CB4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B1CB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1CBC: 4199FFB8  bgt cr6, 0x828b1c74
	if ctx.cr[6].gt {
	pc = 0x828B1C74; continue 'dispatch;
	}
	// 828B1CC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B1CC4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B1CC8: 419A0040  beq cr6, 0x828b1d08
	if ctx.cr[6].eq {
	pc = 0x828B1D08; continue 'dispatch;
	}
	// 828B1CCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1CD0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B1CD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1CD8: 41990008  bgt cr6, 0x828b1ce0
	if ctx.cr[6].gt {
	pc = 0x828B1CE0; continue 'dispatch;
	}
	// 828B1CDC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B1CE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B1CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1CE8: 409A0020  bne cr6, 0x828b1d08
	if !ctx.cr[6].eq {
	pc = 0x828B1D08; continue 'dispatch;
	}
	// 828B1CEC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B1CF0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B1CF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B1CF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1CFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B1D00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1D04: 4800001C  b 0x828b1d20
	pc = 0x828B1D20; continue 'dispatch;
	// 828B1D08: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B1D0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1D10: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B1D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1D18: 48000008  b 0x828b1d20
	pc = 0x828B1D20; continue 'dispatch;
	// 828B1D1C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B1D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B1D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1D28: 419A0034  beq cr6, 0x828b1d5c
	if ctx.cr[6].eq {
	pc = 0x828B1D5C; continue 'dispatch;
	}
	// 828B1D2C: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 828B1D30: 7C8A07B4  extsw r10, r4
	ctx.r[10].s64 = ctx.r[4].s32 as i64;
	// 828B1D34: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B1D38: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B1D3C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828B1D40: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B1D44: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 828B1D48: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 828B1D4C: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 828B1D50: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 828B1D54: EC2A4824  fdivs f1, f10, f9
	ctx.f[1].f64 = ((ctx.f[10].f64 / ctx.f[9].f64) as f32) as f64;
	// 828B1D58: 4BCC14C9  bl 0x82573220
	ctx.lr = 0x828B1D5C;
	sub_82573220(ctx, base);
	// 828B1D5C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B1D60: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1D64: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B1D68: 40820124  bne 0x828b1e8c
	if !ctx.cr[0].eq {
	pc = 0x828B1E8C; continue 'dispatch;
	}
	// 828B1D6C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1D70: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B1D74: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B1D78: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828B1D7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B1D80: 419A00E4  beq cr6, 0x828b1e64
	if ctx.cr[6].eq {
	pc = 0x828B1E64; continue 'dispatch;
	}
	// 828B1D84: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B1D88: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B1D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1D90: 419A001C  beq cr6, 0x828b1dac
	if ctx.cr[6].eq {
	pc = 0x828B1DAC; continue 'dispatch;
	}
	// 828B1D94: 896B0025  lbz r11, 0x25(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 828B1D98: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B1D9C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B1DA0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1DA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B1DA8: 480000C0  b 0x828b1e68
	pc = 0x828B1E68; continue 'dispatch;
	// 828B1DAC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B1DB0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B1DB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B1DB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B1DBC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1DC0: 40810054  ble 0x828b1e14
	if !ctx.cr[0].gt {
	pc = 0x828B1E14; continue 'dispatch;
	}
	// 828B1DC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B1DC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B1DCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B1DD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1DD4: 2F070025  cmpwi cr6, r7, 0x25
	ctx.cr[6].compare_i32(ctx.r[7].s32, 37, &mut ctx.xer);
	// 828B1DD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B1DDC: 41980008  blt cr6, 0x828b1de4
	if ctx.cr[6].lt {
	pc = 0x828B1DE4; continue 'dispatch;
	}
	// 828B1DE0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B1DE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B1DE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B1DEC: 419A0014  beq cr6, 0x828b1e00
	if ctx.cr[6].eq {
	pc = 0x828B1E00; continue 'dispatch;
	}
	// 828B1DF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B1DF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B1DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B1DFC: 4800000C  b 0x828b1e08
	pc = 0x828B1E08; continue 'dispatch;
	// 828B1E00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B1E04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B1E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1E0C: 4199FFB8  bgt cr6, 0x828b1dc4
	if ctx.cr[6].gt {
	pc = 0x828B1DC4; continue 'dispatch;
	}
	// 828B1E10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B1E14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B1E18: 419A003C  beq cr6, 0x828b1e54
	if ctx.cr[6].eq {
	pc = 0x828B1E54; continue 'dispatch;
	}
	// 828B1E1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1E20: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 828B1E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1E28: 41990008  bgt cr6, 0x828b1e30
	if ctx.cr[6].gt {
	pc = 0x828B1E30; continue 'dispatch;
	}
	// 828B1E2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B1E30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B1E34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1E38: 409A001C  bne cr6, 0x828b1e54
	if !ctx.cr[6].eq {
	pc = 0x828B1E54; continue 'dispatch;
	}
	// 828B1E3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B1E40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B1E44: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B1E48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B1E4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1E50: 48000018  b 0x828b1e68
	pc = 0x828B1E68; continue 'dispatch;
	// 828B1E54: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B1E58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B1E5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1E60: 48000008  b 0x828b1e68
	pc = 0x828B1E68; continue 'dispatch;
	// 828B1E64: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828B1E68: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B1E6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B1E70: 419A0018  beq cr6, 0x828b1e88
	if ctx.cr[6].eq {
	pc = 0x828B1E88; continue 'dispatch;
	}
	// 828B1E74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B1E78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B1E7C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B1E80: 4BCD5B89  bl 0x82587a08
	ctx.lr = 0x828B1E84;
	sub_82587A08(ctx, base);
	// 828B1E84: 48000008  b 0x828b1e8c
	pc = 0x828B1E8C; continue 'dispatch;
	// 828B1E88: 4BADB9A1  bl 0x8238d828
	ctx.lr = 0x828B1E8C;
	sub_8238D828(ctx, base);
	// 828B1E8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1E98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1E9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B1EA8 size=488
    let mut pc: u32 = 0x828B1EA8;
    'dispatch: loop {
        match pc {
            0x828B1EA8 => {
    //   block [0x828B1EA8..0x828B2090)
	// 828B1EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1EAC: 483F7535  bl 0x82ca93e0
	ctx.lr = 0x828B1EB0;
	sub_82CA93D0(ctx, base);
	// 828B1EB0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1EB4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B1EB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B1EBC: 3BAB10E0  addi r29, r11, 0x10e0
	ctx.r[29].s64 = ctx.r[11].s64 + 4320;
	// 828B1EC0: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 828B1EC4: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 828B1EC8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828B1ECC: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 828B1ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B1ED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1ED8: 483F75A9  bl 0x82ca9480
	ctx.lr = 0x828B1EDC;
	sub_82CA9480(ctx, base);
	// 828B1EDC: 3BFF005C  addi r31, r31, 0x5c
	ctx.r[31].s64 = ctx.r[31].s64 + 92;
	// 828B1EE0: 397D01CC  addi r11, r29, 0x1cc
	ctx.r[11].s64 = ctx.r[29].s64 + 460;
	// 828B1EE4: 3BDE005C  addi r30, r30, 0x5c
	ctx.r[30].s64 = ctx.r[30].s64 + 92;
	// 828B1EE8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B1EEC: 4198FFE0  blt cr6, 0x828b1ecc
	if ctx.cr[6].lt {
	pc = 0x828B1ECC; continue 'dispatch;
	}
	// 828B1EF0: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828B1EF4: 419A0194  beq cr6, 0x828b2088
	if ctx.cr[6].eq {
	pc = 0x828B2088; continue 'dispatch;
	}
	// 828B1EF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B1EFC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B1F00: 3A6B8BB8  addi r19, r11, -0x7448
	ctx.r[19].s64 = ctx.r[11].s64 + -29768;
	// 828B1F04: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B1F08: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828B1F0C: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828B1F10: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828B1F14: 828AE454  lwz r20, -0x1bac(r10)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828B1F18: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828B1F1C: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828B1F20: 82CB6DA0  lwz r22, 0x6da0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828B1F24: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828B1F28: 82E9C818  lwz r23, -0x37e8(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 828B1F2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B1F30: 8308C814  lwz r24, -0x37ec(r8)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14316 as u32) ) } as u64;
	// 828B1F34: 3BDC0084  addi r30, r28, 0x84
	ctx.r[30].s64 = ctx.r[28].s64 + 132;
	// 828B1F38: 8327C810  lwz r25, -0x37f0(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14320 as u32) ) } as u64;
	// 828B1F3C: 8346C80C  lwz r26, -0x37f4(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14324 as u32) ) } as u64;
	// 828B1F40: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	// 828B1F44: 8365C808  lwz r27, -0x37f8(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14328 as u32) ) } as u64;
	// 828B1F48: 3AABE460  addi r21, r11, -0x1ba0
	ctx.r[21].s64 = ctx.r[11].s64 + -7072;
	// 828B1F4C: 8384C804  lwz r28, -0x37fc(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-14332 as u32) ) } as u64;
	// 828B1F50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B1F54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F58: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828B1F5C: 4B933AAD  bl 0x821e5a08
	ctx.lr = 0x828B1F60;
	sub_821E5A08(ctx, base);
	// 828B1F60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B1F64: 419A0034  beq cr6, 0x828b1f98
	if ctx.cr[6].eq {
	pc = 0x828B1F98; continue 'dispatch;
	}
	// 828B1F68: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B1F6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B1F70: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 828B1F74: 419A001C  beq cr6, 0x828b1f90
	if ctx.cr[6].eq {
	pc = 0x828B1F90; continue 'dispatch;
	}
	// 828B1F78: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828B1F7C: 409A0014  bne cr6, 0x828b1f90
	if !ctx.cr[6].eq {
	pc = 0x828B1F90; continue 'dispatch;
	}
	// 828B1F80: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F84: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 828B1F88: 409A0008  bne cr6, 0x828b1f90
	if !ctx.cr[6].eq {
	pc = 0x828B1F90; continue 'dispatch;
	}
	// 828B1F8C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828B1F90: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F94: 48000008  b 0x828b1f9c
	pc = 0x828B1F9C; continue 'dispatch;
	// 828B1F98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B1F9C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B1FA0: 419A00D4  beq cr6, 0x828b2074
	if ctx.cr[6].eq {
	pc = 0x828B2074; continue 'dispatch;
	}
	// 828B1FA4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828B1FA8: 4B9322A9  bl 0x821e4250
	ctx.lr = 0x828B1FAC;
	sub_821E4250(ctx, base);
	// 828B1FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1FB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1FB4: 419A00C0  beq cr6, 0x828b2074
	if ctx.cr[6].eq {
	pc = 0x828B2074; continue 'dispatch;
	}
	// 828B1FB8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B1FBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B1FC0: 4814E709  bl 0x82a006c8
	ctx.lr = 0x828B1FC4;
	sub_82A006C8(ctx, base);
	// 828B1FC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B1FC8: 419A000C  beq cr6, 0x828b1fd4
	if ctx.cr[6].eq {
	pc = 0x828B1FD4; continue 'dispatch;
	}
	// 828B1FCC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B1FD0: D01EFFFC  stfs f0, -4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 828B1FD4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B1FD8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B1FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1FE0: 4814E6E9  bl 0x82a006c8
	ctx.lr = 0x828B1FE4;
	sub_82A006C8(ctx, base);
	// 828B1FE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B1FE8: 419A000C  beq cr6, 0x828b1ff4
	if ctx.cr[6].eq {
	pc = 0x828B1FF4; continue 'dispatch;
	}
	// 828B1FEC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B1FF0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B1FF4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B1FF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B1FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2000: 4814E6C9  bl 0x82a006c8
	ctx.lr = 0x828B2004;
	sub_82A006C8(ctx, base);
	// 828B2004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2008: 419A000C  beq cr6, 0x828b2014
	if ctx.cr[6].eq {
	pc = 0x828B2014; continue 'dispatch;
	}
	// 828B200C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2010: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B2014: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B2018: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B201C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2020: 4814E6A9  bl 0x82a006c8
	ctx.lr = 0x828B2024;
	sub_82A006C8(ctx, base);
	// 828B2024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2028: 419A000C  beq cr6, 0x828b2034
	if ctx.cr[6].eq {
	pc = 0x828B2034; continue 'dispatch;
	}
	// 828B202C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2030: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B2034: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2038: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B203C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2040: 4814E689  bl 0x82a006c8
	ctx.lr = 0x828B2044;
	sub_82A006C8(ctx, base);
	// 828B2044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2048: 419A000C  beq cr6, 0x828b2054
	if ctx.cr[6].eq {
	pc = 0x828B2054; continue 'dispatch;
	}
	// 828B204C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2050: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828B2054: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2058: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B205C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2060: 4814E669  bl 0x82a006c8
	ctx.lr = 0x828B2064;
	sub_82A006C8(ctx, base);
	// 828B2064: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2068: 419A000C  beq cr6, 0x828b2074
	if ctx.cr[6].eq {
	pc = 0x828B2074; continue 'dispatch;
	}
	// 828B206C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2070: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B2074: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828B2078: 39730014  addi r11, r19, 0x14
	ctx.r[11].s64 = ctx.r[19].s64 + 20;
	// 828B207C: 3BDE005C  addi r30, r30, 0x5c
	ctx.r[30].s64 = ctx.r[30].s64 + 92;
	// 828B2080: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B2084: 4198FECC  blt cr6, 0x828b1f50
	if ctx.cr[6].lt {
	pc = 0x828B1F50; continue 'dispatch;
	}
	// 828B2088: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828B208C: 483F73A4  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2090 size=60
    let mut pc: u32 = 0x828B2090;
    'dispatch: loop {
        match pc {
            0x828B2090 => {
    //   block [0x828B2090..0x828B20CC)
	// 828B2090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B209C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B20A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B20A4: 48033A2D  bl 0x828e5ad0
	ctx.lr = 0x828B20A8;
	sub_828E5AD0(ctx, base);
	// 828B20A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B20AC: 48000025  bl 0x828b20d0
	ctx.lr = 0x828B20B0;
	sub_828B20D0(ctx, base);
	// 828B20B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B20B4: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828B20B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B20BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B20C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B20C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B20C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B20D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B20D0 size=920
    let mut pc: u32 = 0x828B20D0;
    'dispatch: loop {
        match pc {
            0x828B20D0 => {
    //   block [0x828B20D0..0x828B2468)
	// 828B20D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B20D4: 483F7325  bl 0x82ca93f8
	ctx.lr = 0x828B20D8;
	sub_82CA93D0(ctx, base);
	// 828B20D8: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 828B20DC: 483FBBF9  bl 0x82cadcd4
	ctx.lr = 0x828B20E0;
	sub_82CADCA0(ctx, base);
	// 828B20E0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B2468 size=568
    let mut pc: u32 = 0x828B2468;
    'dispatch: loop {
        match pc {
            0x828B2468 => {
    //   block [0x828B2468..0x828B26A0)
	// 828B2468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B246C: 483F6F71  bl 0x82ca93dc
	ctx.lr = 0x828B2470;
	sub_82CA93D0(ctx, base);
	// 828B2470: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2474: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B2478: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 828B247C: 3BAB12B0  addi r29, r11, 0x12b0
	ctx.r[29].s64 = ctx.r[11].s64 + 4784;
	// 828B2480: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 828B2484: 3BD20060  addi r30, r18, 0x60
	ctx.r[30].s64 = ctx.r[18].s64 + 96;
	// 828B2488: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828B248C: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 828B2490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B2494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2498: 483F6FE9  bl 0x82ca9480
	ctx.lr = 0x828B249C;
	sub_82CA9480(ctx, base);
	// 828B249C: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 828B24A0: 397D012C  addi r11, r29, 0x12c
	ctx.r[11].s64 = ctx.r[29].s64 + 300;
	// 828B24A4: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 828B24A8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B24AC: 4198FFE0  blt cr6, 0x828b248c
	if ctx.cr[6].lt {
	pc = 0x828B248C; continue 'dispatch;
	}
	// 828B24B0: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828B24B4: 419A0194  beq cr6, 0x828b2648
	if ctx.cr[6].eq {
	pc = 0x828B2648; continue 'dispatch;
	}
	// 828B24B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B24BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B24C0: 3A6B8BB8  addi r19, r11, -0x7448
	ctx.r[19].s64 = ctx.r[11].s64 + -29768;
	// 828B24C4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B24C8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828B24CC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828B24D0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828B24D4: 828AE454  lwz r20, -0x1bac(r10)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828B24D8: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828B24DC: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828B24E0: 82CB6DA0  lwz r22, 0x6da0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828B24E4: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828B24E8: 82E9C818  lwz r23, -0x37e8(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 828B24EC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B24F0: 8308C814  lwz r24, -0x37ec(r8)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14316 as u32) ) } as u64;
	// 828B24F4: 8327C810  lwz r25, -0x37f0(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14320 as u32) ) } as u64;
	// 828B24F8: 3BD20064  addi r30, r18, 0x64
	ctx.r[30].s64 = ctx.r[18].s64 + 100;
	// 828B24FC: 8346C80C  lwz r26, -0x37f4(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14324 as u32) ) } as u64;
	// 828B2500: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	// 828B2504: 8365C808  lwz r27, -0x37f8(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14328 as u32) ) } as u64;
	// 828B2508: 3AABE460  addi r21, r11, -0x1ba0
	ctx.r[21].s64 = ctx.r[11].s64 + -7072;
	// 828B250C: 8384C804  lwz r28, -0x37fc(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-14332 as u32) ) } as u64;
	// 828B2510: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B2514: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2518: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828B251C: 4B9334ED  bl 0x821e5a08
	ctx.lr = 0x828B2520;
	sub_821E5A08(ctx, base);
	// 828B2520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2524: 419A0034  beq cr6, 0x828b2558
	if ctx.cr[6].eq {
	pc = 0x828B2558; continue 'dispatch;
	}
	// 828B2528: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B252C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2530: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 828B2534: 419A001C  beq cr6, 0x828b2550
	if ctx.cr[6].eq {
	pc = 0x828B2550; continue 'dispatch;
	}
	// 828B2538: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828B253C: 409A0014  bne cr6, 0x828b2550
	if !ctx.cr[6].eq {
	pc = 0x828B2550; continue 'dispatch;
	}
	// 828B2540: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2544: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 828B2548: 409A0008  bne cr6, 0x828b2550
	if !ctx.cr[6].eq {
	pc = 0x828B2550; continue 'dispatch;
	}
	// 828B254C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828B2550: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2554: 48000008  b 0x828b255c
	pc = 0x828B255C; continue 'dispatch;
	// 828B2558: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B255C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B2560: 419A00D4  beq cr6, 0x828b2634
	if ctx.cr[6].eq {
	pc = 0x828B2634; continue 'dispatch;
	}
	// 828B2564: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828B2568: 4B931CE9  bl 0x821e4250
	ctx.lr = 0x828B256C;
	sub_821E4250(ctx, base);
	// 828B256C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B2570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2574: 419A00C0  beq cr6, 0x828b2634
	if ctx.cr[6].eq {
	pc = 0x828B2634; continue 'dispatch;
	}
	// 828B2578: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B257C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B2580: 4814E149  bl 0x82a006c8
	ctx.lr = 0x828B2584;
	sub_82A006C8(ctx, base);
	// 828B2584: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2588: 419A000C  beq cr6, 0x828b2594
	if ctx.cr[6].eq {
	pc = 0x828B2594; continue 'dispatch;
	}
	// 828B258C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2590: D01EFFFC  stfs f0, -4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 828B2594: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2598: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B259C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B25A0: 4814E129  bl 0x82a006c8
	ctx.lr = 0x828B25A4;
	sub_82A006C8(ctx, base);
	// 828B25A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B25A8: 419A000C  beq cr6, 0x828b25b4
	if ctx.cr[6].eq {
	pc = 0x828B25B4; continue 'dispatch;
	}
	// 828B25AC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B25B0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B25B4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B25B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B25BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B25C0: 4814E109  bl 0x82a006c8
	ctx.lr = 0x828B25C4;
	sub_82A006C8(ctx, base);
	// 828B25C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B25C8: 419A000C  beq cr6, 0x828b25d4
	if ctx.cr[6].eq {
	pc = 0x828B25D4; continue 'dispatch;
	}
	// 828B25CC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B25D0: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B25D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B25D8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B25DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B25E0: 4814E0E9  bl 0x82a006c8
	ctx.lr = 0x828B25E4;
	sub_82A006C8(ctx, base);
	// 828B25E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B25E8: 419A000C  beq cr6, 0x828b25f4
	if ctx.cr[6].eq {
	pc = 0x828B25F4; continue 'dispatch;
	}
	// 828B25EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B25F0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B25F4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B25F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B25FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2600: 4814E0C9  bl 0x82a006c8
	ctx.lr = 0x828B2604;
	sub_82A006C8(ctx, base);
	// 828B2604: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2608: 419A000C  beq cr6, 0x828b2614
	if ctx.cr[6].eq {
	pc = 0x828B2614; continue 'dispatch;
	}
	// 828B260C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2610: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828B2614: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2618: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2620: 4814E0A9  bl 0x82a006c8
	ctx.lr = 0x828B2624;
	sub_82A006C8(ctx, base);
	// 828B2624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2628: 419A000C  beq cr6, 0x828b2634
	if ctx.cr[6].eq {
	pc = 0x828B2634; continue 'dispatch;
	}
	// 828B262C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2630: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B2634: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828B2638: 39730014  addi r11, r19, 0x14
	ctx.r[11].s64 = ctx.r[19].s64 + 20;
	// 828B263C: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 828B2640: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B2644: 4198FECC  blt cr6, 0x828b2510
	if ctx.cr[6].lt {
	pc = 0x828B2510; continue 'dispatch;
	}
	// 828B2648: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828B264C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2650: 3909B7A4  addi r8, r9, -0x485c
	ctx.r[8].s64 = ctx.r[9].s64 + -18524;
	// 828B2654: 39520078  addi r10, r18, 0x78
	ctx.r[10].s64 = ctx.r[18].s64 + 120;
	// 828B2658: C189B7A4  lfs f12, -0x485c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-18524 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B265C: C1A8FCDC  lfs f13, -0x324(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-804 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B2660: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 828B2664: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B2668: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828B266C: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B2670: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 828B2674: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 828B2678: EC08637A  fmadds f0, f8, f13, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 828B267C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 828B2680: 40980008  bge cr6, 0x828b2688
	if !ctx.cr[6].lt {
	pc = 0x828B2688; continue 'dispatch;
	}
	// 828B2684: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B2688: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B268C: 394A003C  addi r10, r10, 0x3c
	ctx.r[10].s64 = ctx.r[10].s64 + 60;
	// 828B2690: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828B2694: 4198FFCC  blt cr6, 0x828b2660
	if ctx.cr[6].lt {
	pc = 0x828B2660; continue 'dispatch;
	}
	// 828B2698: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B269C: 483F6D90  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B26A0 size=112
    let mut pc: u32 = 0x828B26A0;
    'dispatch: loop {
        match pc {
            0x828B26A0 => {
    //   block [0x828B26A0..0x828B2710)
	// 828B26A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B26A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B26A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B26AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B26B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B26B4: 480334ED  bl 0x828e5ba0
	ctx.lr = 0x828B26B8;
	sub_828E5BA0(ctx, base);
	// 828B26B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B26BC: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B26C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828B26C4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828B26C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B26CC: 39099150  addi r8, r9, -0x6eb0
	ctx.r[8].s64 = ctx.r[9].s64 + -28336;
	// 828B26D0: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B26D4: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B2710 size=800
    let mut pc: u32 = 0x828B2710;
    'dispatch: loop {
        match pc {
            0x828B2710 => {
    //   block [0x828B2710..0x828B2A30)
	// 828B2710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2714: 483F6CED  bl 0x82ca9400
	ctx.lr = 0x828B2718;
	sub_82CA93D0(ctx, base);
	// 828B2718: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 828B271C: 483FB5B9  bl 0x82cadcd4
	ctx.lr = 0x828B2720;
	sub_82CADCA0(ctx, base);
	// 828B2720: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B2A30 size=660
    let mut pc: u32 = 0x828B2A30;
    'dispatch: loop {
        match pc {
            0x828B2A30 => {
    //   block [0x828B2A30..0x828B2CC4)
	// 828B2A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2A34: 483F699D  bl 0x82ca93d0
	ctx.lr = 0x828B2A38;
	sub_82CA93D0(ctx, base);
	// 828B2A38: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2A3C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B2A40: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B2A44: 3BAB13E0  addi r29, r11, 0x13e0
	ctx.r[29].s64 = ctx.r[11].s64 + 5088;
	// 828B2A48: 7C8E2378  mr r14, r4
	ctx.r[14].u64 = ctx.r[4].u64;
	// 828B2A4C: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 828B2A50: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828B2A54: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 828B2A58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B2A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2A60: 483F6A21  bl 0x82ca9480
	ctx.lr = 0x828B2A64;
	sub_82CA9480(ctx, base);
	// 828B2A64: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 828B2A68: 397D00F0  addi r11, r29, 0xf0
	ctx.r[11].s64 = ctx.r[29].s64 + 240;
	// 828B2A6C: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 828B2A70: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B2A74: 4198FFE0  blt cr6, 0x828b2a54
	if ctx.cr[6].lt {
	pc = 0x828B2A54; continue 'dispatch;
	}
	// 828B2A78: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828B2A7C: 419A0240  beq cr6, 0x828b2cbc
	if ctx.cr[6].eq {
	pc = 0x828B2CBC; continue 'dispatch;
	}
	// 828B2A80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B2A84: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B2A88: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828B2A8C: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828B2A90: 39EB8BB8  addi r15, r11, -0x7448
	ctx.r[15].s64 = ctx.r[11].s64 + -29768;
	// 828B2A94: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B2A98: 820AE454  lwz r16, -0x1bac(r10)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828B2A9C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828B2AA0: 8289C838  lwz r20, -0x37c8(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14280 as u32) ) } as u64;
	// 828B2AA4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828B2AA8: 82A8C834  lwz r21, -0x37cc(r8)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14284 as u32) ) } as u64;
	// 828B2AAC: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828B2AB0: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828B2AB4: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 828B2AB8: 826B6DA0  lwz r19, 0x6da0(r11)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828B2ABC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B2AC0: 82C7C840  lwz r22, -0x37c0(r7)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14272 as u32) ) } as u64;
	// 828B2AC4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828B2AC8: 82E6C83C  lwz r23, -0x37c4(r6)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14276 as u32) ) } as u64;
	// 828B2ACC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828B2AD0: 8305C830  lwz r24, -0x37d0(r5)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14288 as u32) ) } as u64;
	// 828B2AD4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B2AD8: 8324C82C  lwz r25, -0x37d4(r4)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-14292 as u32) ) } as u64;
	// 828B2ADC: 3BDC0084  addi r30, r28, 0x84
	ctx.r[30].s64 = ctx.r[28].s64 + 132;
	// 828B2AE0: 8343C828  lwz r26, -0x37d8(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-14296 as u32) ) } as u64;
	// 828B2AE4: 836AC824  lwz r27, -0x37dc(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14300 as u32) ) } as u64;
	// 828B2AE8: 7DF27B78  mr r18, r15
	ctx.r[18].u64 = ctx.r[15].u64;
	// 828B2AEC: 8389C820  lwz r28, -0x37e0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14304 as u32) ) } as u64;
	// 828B2AF0: 3A2BE460  addi r17, r11, -0x1ba0
	ctx.r[17].s64 = ctx.r[11].s64 + -7072;
	// 828B2AF4: 83A8C81C  lwz r29, -0x37e4(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14308 as u32) ) } as u64;
	// 828B2AF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B2AFC: 80920000  lwz r4, 0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2B00: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 828B2B04: 4B932F05  bl 0x821e5a08
	ctx.lr = 0x828B2B08;
	sub_821E5A08(ctx, base);
	// 828B2B08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2B0C: 419A0034  beq cr6, 0x828b2b40
	if ctx.cr[6].eq {
	pc = 0x828B2B40; continue 'dispatch;
	}
	// 828B2B10: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B2B14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2B18: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 828B2B1C: 419A001C  beq cr6, 0x828b2b38
	if ctx.cr[6].eq {
	pc = 0x828B2B38; continue 'dispatch;
	}
	// 828B2B20: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828B2B24: 409A0014  bne cr6, 0x828b2b38
	if !ctx.cr[6].eq {
	pc = 0x828B2B38; continue 'dispatch;
	}
	// 828B2B28: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2B2C: 7F0A8040  cmplw cr6, r10, r16
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[16].u32, &mut ctx.xer);
	// 828B2B30: 409A0008  bne cr6, 0x828b2b38
	if !ctx.cr[6].eq {
	pc = 0x828B2B38; continue 'dispatch;
	}
	// 828B2B34: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828B2B38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2B3C: 48000008  b 0x828b2b44
	pc = 0x828B2B44; continue 'dispatch;
	// 828B2B40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B2B44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B2B48: 419A0160  beq cr6, 0x828b2ca8
	if ctx.cr[6].eq {
	pc = 0x828B2CA8; continue 'dispatch;
	}
	// 828B2B4C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828B2B50: 4B931701  bl 0x821e4250
	ctx.lr = 0x828B2B54;
	sub_821E4250(ctx, base);
	// 828B2B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B2B58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2B5C: 419A014C  beq cr6, 0x828b2ca8
	if ctx.cr[6].eq {
	pc = 0x828B2CA8; continue 'dispatch;
	}
	// 828B2B60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B2B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B2B68: 4814DB61  bl 0x82a006c8
	ctx.lr = 0x828B2B6C;
	sub_82A006C8(ctx, base);
	// 828B2B6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2B70: 419A0018  beq cr6, 0x828b2b88
	if ctx.cr[6].eq {
	pc = 0x828B2B88; continue 'dispatch;
	}
	// 828B2B74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2B78: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828B2B7C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828B2B80: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 828B2B84: 991EFFFC  stb r8, -4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[8].u8 ) };
	// 828B2B88: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2B8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B2B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2B94: 4814DB35  bl 0x82a006c8
	ctx.lr = 0x828B2B98;
	sub_82A006C8(ctx, base);
	// 828B2B98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2B9C: 419A000C  beq cr6, 0x828b2ba8
	if ctx.cr[6].eq {
	pc = 0x828B2BA8; continue 'dispatch;
	}
	// 828B2BA0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2BA4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B2BA8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2BAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B2BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2BB4: 4814DB15  bl 0x82a006c8
	ctx.lr = 0x828B2BB8;
	sub_82A006C8(ctx, base);
	// 828B2BB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2BBC: 419A000C  beq cr6, 0x828b2bc8
	if ctx.cr[6].eq {
	pc = 0x828B2BC8; continue 'dispatch;
	}
	// 828B2BC0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2BC4: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828B2BC8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2BCC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B2BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2BD4: 4814DAF5  bl 0x82a006c8
	ctx.lr = 0x828B2BD8;
	sub_82A006C8(ctx, base);
	// 828B2BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2BDC: 419A000C  beq cr6, 0x828b2be8
	if ctx.cr[6].eq {
	pc = 0x828B2BE8; continue 'dispatch;
	}
	// 828B2BE0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2BE4: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B2BE8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2BEC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B2BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2BF4: 4814DAD5  bl 0x82a006c8
	ctx.lr = 0x828B2BF8;
	sub_82A006C8(ctx, base);
	// 828B2BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2BFC: 419A000C  beq cr6, 0x828b2c08
	if ctx.cr[6].eq {
	pc = 0x828B2C08; continue 'dispatch;
	}
	// 828B2C00: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2C04: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B2C08: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2C0C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B2C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2C14: 4814DAB5  bl 0x82a006c8
	ctx.lr = 0x828B2C18;
	sub_82A006C8(ctx, base);
	// 828B2C18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2C1C: 419A000C  beq cr6, 0x828b2c28
	if ctx.cr[6].eq {
	pc = 0x828B2C28; continue 'dispatch;
	}
	// 828B2C20: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2C24: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828B2C28: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2C2C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B2C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2C34: 4814DA95  bl 0x82a006c8
	ctx.lr = 0x828B2C38;
	sub_82A006C8(ctx, base);
	// 828B2C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2C3C: 419A000C  beq cr6, 0x828b2c48
	if ctx.cr[6].eq {
	pc = 0x828B2C48; continue 'dispatch;
	}
	// 828B2C40: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2C44: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B2C48: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2C4C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828B2C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2C54: 4814DA75  bl 0x82a006c8
	ctx.lr = 0x828B2C58;
	sub_82A006C8(ctx, base);
	// 828B2C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2C5C: 419A000C  beq cr6, 0x828b2c68
	if ctx.cr[6].eq {
	pc = 0x828B2C68; continue 'dispatch;
	}
	// 828B2C60: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2C64: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828B2C68: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2C6C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828B2C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2C74: 4814DA55  bl 0x82a006c8
	ctx.lr = 0x828B2C78;
	sub_82A006C8(ctx, base);
	// 828B2C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2C7C: 419A000C  beq cr6, 0x828b2c88
	if ctx.cr[6].eq {
	pc = 0x828B2C88; continue 'dispatch;
	}
	// 828B2C80: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2C84: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828B2C88: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B2C8C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828B2C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2C94: 4814DA35  bl 0x82a006c8
	ctx.lr = 0x828B2C98;
	sub_82A006C8(ctx, base);
	// 828B2C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B2C9C: 419A000C  beq cr6, 0x828b2ca8
	if ctx.cr[6].eq {
	pc = 0x828B2CA8; continue 'dispatch;
	}
	// 828B2CA0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B2CA4: D01E0028  stfs f0, 0x28(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828B2CA8: 3A520004  addi r18, r18, 4
	ctx.r[18].s64 = ctx.r[18].s64 + 4;
	// 828B2CAC: 396F0014  addi r11, r15, 0x14
	ctx.r[11].s64 = ctx.r[15].s64 + 20;
	// 828B2CB0: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 828B2CB4: 7F125800  cmpw cr6, r18, r11
	ctx.cr[6].compare_i32(ctx.r[18].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B2CB8: 4198FE40  blt cr6, 0x828b2af8
	if ctx.cr[6].lt {
	pc = 0x828B2AF8; continue 'dispatch;
	}
	// 828B2CBC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828B2CC0: 483F6760  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B2CC8 size=560
    let mut pc: u32 = 0x828B2CC8;
    'dispatch: loop {
        match pc {
            0x828B2CC8 => {
    //   block [0x828B2CC8..0x828B2EF8)
	// 828B2CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2CCC: 483F673D  bl 0x82ca9408
	ctx.lr = 0x828B2CD0;
	sub_82CA93D0(ctx, base);
	// 828B2CD0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B2CD4: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B2EF8 size=1796
    let mut pc: u32 = 0x828B2EF8;
    'dispatch: loop {
        match pc {
            0x828B2EF8 => {
    //   block [0x828B2EF8..0x828B35FC)
	// 828B2EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2EFC: 483F64F5  bl 0x82ca93f0
	ctx.lr = 0x828B2F00;
	sub_82CA93D0(ctx, base);
	// 828B2F00: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 828B2F04: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 828B2F08: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 828B2F0C: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 828B2F10: 48753AC5  bl 0x830069d4
	ctx.lr = 0x828B2F14;
	sub_83006760(ctx, base);
	// 828B2F14: 9421FB50  stwu r1, -0x4b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B2F1C: 480324D5  bl 0x828e53f0
	ctx.lr = 0x828B2F20;
	sub_828E53F0(ctx, base);
	// 828B2F20: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B2F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2F28: 409A06B8  bne cr6, 0x828b35e0
	if !ctx.cr[6].eq {
	pc = 0x828B35E0; continue 'dispatch;
	}
	// 828B2F2C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828B2F30: C3FF004C  lfs f31, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B2F34: 3AFF0180  addi r23, r31, 0x180
	ctx.r[23].s64 = ctx.r[31].s64 + 384;
	// 828B2F38: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828B2F3C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828B2F40: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3600 size=168
    let mut pc: u32 = 0x828B3600;
    'dispatch: loop {
        match pc {
            0x828B3600 => {
    //   block [0x828B3600..0x828B36A8)
	// 828B3600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B360C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3614: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3618: 3BFE01A0  addi r31, r30, 0x1a0
	ctx.r[31].s64 = ctx.r[30].s64 + 416;
	// 828B361C: 817E01A4  lwz r11, 0x1a4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(420 as u32) ) } as u64;
	// 828B3620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3624: 419A0020  beq cr6, 0x828b3644
	if ctx.cr[6].eq {
	pc = 0x828B3644; continue 'dispatch;
	}
	// 828B3628: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B362C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B3630: 419A000C  beq cr6, 0x828b363c
	if ctx.cr[6].eq {
	pc = 0x828B363C; continue 'dispatch;
	}
	// 828B3634: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828B3638: 48000010  b 0x828b3648
	pc = 0x828B3648; continue 'dispatch;
	// 828B363C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3640: 4B8E07F9  bl 0x82193e38
	ctx.lr = 0x828B3644;
	sub_82193E38(ctx, base);
	// 828B3644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B3648: 4BD44C71  bl 0x825f82b8
	ctx.lr = 0x828B364C;
	sub_825F82B8(ctx, base);
	// 828B364C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B3650: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B3654: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828B3658: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B365C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3660: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828B3664: 4B8E07D5  bl 0x82193e38
	ctx.lr = 0x828B3668;
	sub_82193E38(ctx, base);
	// 828B3668: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B366C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3670: 4BC1E859  bl 0x824d1ec8
	ctx.lr = 0x828B3674;
	sub_824D1EC8(ctx, base);
	// 828B3674: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828B3678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B367C: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828B3680: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828B3684: 4B8E07B5  bl 0x82193e38
	ctx.lr = 0x828B3688;
	sub_82193E38(ctx, base);
	// 828B3688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B368C: 48031C55  bl 0x828e52e0
	ctx.lr = 0x828B3690;
	sub_828E52E0(ctx, base);
	// 828B3690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B3694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B369C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B36A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B36A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B36A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B36A8 size=336
    let mut pc: u32 = 0x828B36A8;
    'dispatch: loop {
        match pc {
            0x828B36A8 => {
    //   block [0x828B36A8..0x828B37F8)
	// 828B36A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B36AC: 483F5D61  bl 0x82ca940c
	ctx.lr = 0x828B36B0;
	sub_82CA93D0(ctx, base);
	// 828B36B0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B37F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B37F8 size=284
    let mut pc: u32 = 0x828B37F8;
    'dispatch: loop {
        match pc {
            0x828B37F8 => {
    //   block [0x828B37F8..0x828B3914)
	// 828B37F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B37FC: 483F5C01  bl 0x82ca93fc
	ctx.lr = 0x828B3800;
	sub_82CA93D0(ctx, base);
	// 828B3800: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3804: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 828B3808: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B380C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3810: 48031811  bl 0x828e5020
	ctx.lr = 0x828B3814;
	sub_828E5020(ctx, base);
	// 828B3814: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B3818: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B381C: 392A2BC4  addi r9, r10, 0x2bc4
	ctx.r[9].s64 = ctx.r[10].s64 + 11204;
	// 828B3820: 3B6B0B7C  addi r27, r11, 0xb7c
	ctx.r[27].s64 = ctx.r[11].s64 + 2940;
	// 828B3824: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B3828: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B382C: 937F0170  stw r27, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[27].u32 ) };
	// 828B3830: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 828B3834: 93BF0174  stw r29, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[29].u32 ) };
	// 828B3838: 4BD6F399  bl 0x82622bd0
	ctx.lr = 0x828B383C;
	sub_82622BD0(ctx, base);
	// 828B383C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828B3840: 393F019C  addi r9, r31, 0x19c
	ctx.r[9].s64 = ctx.r[31].s64 + 412;
	// 828B3844: 93BF018C  stw r29, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[29].u32 ) };
	// 828B3848: 93BF0190  stw r29, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[29].u32 ) };
	// 828B384C: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 828B3850: 93BF0194  stw r29, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[29].u32 ) };
	// 828B3854: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B3858: 991F0198  stb r8, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[8].u8 ) };
	// 828B385C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B3860: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B3864: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828B3868: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828B386C: 4080FFF0  bge 0x828b385c
	if !ctx.cr[0].lt {
	pc = 0x828B385C; continue 'dispatch;
	}
	// 828B3870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B3874: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 828B3878: 3B400008  li r26, 8
	ctx.r[26].s64 = 8;
	// 828B387C: 3B2B0B7C  addi r25, r11, 0xb7c
	ctx.r[25].s64 = ctx.r[11].s64 + 2940;
	// 828B3880: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828B3884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3888: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828B388C: 4B8E05AD  bl 0x82193e38
	ctx.lr = 0x828B3890;
	sub_82193E38(ctx, base);
	// 828B3890: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B3894: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B3898: 419A0024  beq cr6, 0x828b38bc
	if ctx.cr[6].eq {
	pc = 0x828B38BC; continue 'dispatch;
	}
	// 828B389C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B38A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B38A4: 419A000C  beq cr6, 0x828b38b0
	if ctx.cr[6].eq {
	pc = 0x828B38B0; continue 'dispatch;
	}
	// 828B38A8: 5564003E  slwi r4, r11, 0
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828B38AC: 48000014  b 0x828b38c0
	pc = 0x828B38C0; continue 'dispatch;
	// 828B38B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B38B4: 4B8E0585  bl 0x82193e38
	ctx.lr = 0x828B38B8;
	sub_82193E38(ctx, base);
	// 828B38B8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B38BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B38C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B38C4: 4B960FD5  bl 0x82214898
	ctx.lr = 0x828B38C8;
	sub_82214898(ctx, base);
	// 828B38C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B38CC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828B38D0: 419A0028  beq cr6, 0x828b38f8
	if ctx.cr[6].eq {
	pc = 0x828B38F8; continue 'dispatch;
	}
	// 828B38D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B38D8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B38DC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828B38E0: 40820018  bne 0x828b38f8
	if !ctx.cr[0].eq {
	pc = 0x828B38F8; continue 'dispatch;
	}
	// 828B38E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B38E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B38EC: 409A000C  bne cr6, 0x828b38f8
	if !ctx.cr[6].eq {
	pc = 0x828B38F8; continue 'dispatch;
	}
	// 828B38F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B38F4: 4B968445  bl 0x8221bd38
	ctx.lr = 0x828B38F8;
	sub_8221BD38(ctx, base);
	// 828B38F8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828B38FC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828B3900: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 828B3904: 4082FF7C  bne 0x828b3880
	if !ctx.cr[0].eq {
	pc = 0x828B3880; continue 'dispatch;
	}
	// 828B3908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B390C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B3910: 483F5B3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3918 size=596
    let mut pc: u32 = 0x828B3918;
    'dispatch: loop {
        match pc {
            0x828B3918 => {
    //   block [0x828B3918..0x828B3B6C)
	// 828B3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B391C: 483F5ABD  bl 0x82ca93d8
	ctx.lr = 0x828B3920;
	sub_82CA93D0(ctx, base);
	// 828B3920: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3924: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B3928: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 828B392C: 38CB14D0  addi r6, r11, 0x14d0
	ctx.r[6].s64 = ctx.r[11].s64 + 5328;
	// 828B3930: 38E30060  addi r7, r3, 0x60
	ctx.r[7].s64 = ctx.r[3].s64 + 96;
	// 828B3934: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 828B3938: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B393C: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828B3940: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828B3944: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B3948: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B394C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B3950: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B3954: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B3958: 4200FFF0  bdnz 0x828b3948
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828B3948; continue 'dispatch;
	}
	// 828B395C: 39290028  addi r9, r9, 0x28
	ctx.r[9].s64 = ctx.r[9].s64 + 40;
	// 828B3960: 396600C8  addi r11, r6, 0xc8
	ctx.r[11].s64 = ctx.r[6].s64 + 200;
	// 828B3964: 38E70028  addi r7, r7, 0x28
	ctx.r[7].s64 = ctx.r[7].s64 + 40;
	// 828B3968: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B396C: 4198FFCC  blt cr6, 0x828b3938
	if ctx.cr[6].lt {
	pc = 0x828B3938; continue 'dispatch;
	}
	// 828B3970: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 828B3974: 419A01F0  beq cr6, 0x828b3b64
	if ctx.cr[6].eq {
	pc = 0x828B3B64; continue 'dispatch;
	}
	// 828B3978: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B397C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B3980: 3A2B8BB8  addi r17, r11, -0x7448
	ctx.r[17].s64 = ctx.r[11].s64 + -29768;
	// 828B3984: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B3988: 3BC30064  addi r30, r3, 0x64
	ctx.r[30].s64 = ctx.r[3].s64 + 100;
	// 828B398C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828B3990: 824AE454  lwz r18, -0x1bac(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828B3994: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828B3998: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828B399C: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828B39A0: 828B6DA0  lwz r20, 0x6da0(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828B39A4: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828B39A8: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828B39AC: 82A9C840  lwz r21, -0x37c0(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14272 as u32) ) } as u64;
	// 828B39B0: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 828B39B4: 82C8C83C  lwz r22, -0x37c4(r8)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14276 as u32) ) } as u64;
	// 828B39B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828B39BC: 82E7C830  lwz r23, -0x37d0(r7)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14288 as u32) ) } as u64;
	// 828B39C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B39C4: 8306C82C  lwz r24, -0x37d4(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14292 as u32) ) } as u64;
	// 828B39C8: 8325C828  lwz r25, -0x37d8(r5)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14296 as u32) ) } as u64;
	// 828B39CC: 7E3D8B78  mr r29, r17
	ctx.r[29].u64 = ctx.r[17].u64;
	// 828B39D0: 8344C824  lwz r26, -0x37dc(r4)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-14300 as u32) ) } as u64;
	// 828B39D4: 3A6BE460  addi r19, r11, -0x1ba0
	ctx.r[19].s64 = ctx.r[11].s64 + -7072;
	// 828B39D8: 8363C820  lwz r27, -0x37e0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-14304 as u32) ) } as u64;
	// 828B39DC: 838AC81C  lwz r28, -0x37e4(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14308 as u32) ) } as u64;
	// 828B39E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B39E4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B39E8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828B39EC: 4B93201D  bl 0x821e5a08
	ctx.lr = 0x828B39F0;
	sub_821E5A08(ctx, base);
	// 828B39F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B39F4: 419A0034  beq cr6, 0x828b3a28
	if ctx.cr[6].eq {
	pc = 0x828B3A28; continue 'dispatch;
	}
	// 828B39F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B39FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B3A00: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 828B3A04: 419A001C  beq cr6, 0x828b3a20
	if ctx.cr[6].eq {
	pc = 0x828B3A20; continue 'dispatch;
	}
	// 828B3A08: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828B3A0C: 409A0014  bne cr6, 0x828b3a20
	if !ctx.cr[6].eq {
	pc = 0x828B3A20; continue 'dispatch;
	}
	// 828B3A10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3A14: 7F0A9040  cmplw cr6, r10, r18
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[18].u32, &mut ctx.xer);
	// 828B3A18: 409A0008  bne cr6, 0x828b3a20
	if !ctx.cr[6].eq {
	pc = 0x828B3A20; continue 'dispatch;
	}
	// 828B3A1C: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 828B3A20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3A24: 48000008  b 0x828b3a2c
	pc = 0x828B3A2C; continue 'dispatch;
	// 828B3A28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B3A2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B3A30: 419A0120  beq cr6, 0x828b3b50
	if ctx.cr[6].eq {
	pc = 0x828B3B50; continue 'dispatch;
	}
	// 828B3A34: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828B3A38: 4B930819  bl 0x821e4250
	ctx.lr = 0x828B3A3C;
	sub_821E4250(ctx, base);
	// 828B3A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3A40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B3A44: 419A010C  beq cr6, 0x828b3b50
	if ctx.cr[6].eq {
	pc = 0x828B3B50; continue 'dispatch;
	}
	// 828B3A48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B3A4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B3A50: 4814CC79  bl 0x82a006c8
	ctx.lr = 0x828B3A54;
	sub_82A006C8(ctx, base);
	// 828B3A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3A58: 419A0018  beq cr6, 0x828b3a70
	if ctx.cr[6].eq {
	pc = 0x828B3A70; continue 'dispatch;
	}
	// 828B3A5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3A60: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828B3A64: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828B3A68: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 828B3A6C: 991EFFFC  stb r8, -4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[8].u8 ) };
	// 828B3A70: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3A74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B3A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3A7C: 4814CC4D  bl 0x82a006c8
	ctx.lr = 0x828B3A80;
	sub_82A006C8(ctx, base);
	// 828B3A80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3A84: 419A000C  beq cr6, 0x828b3a90
	if ctx.cr[6].eq {
	pc = 0x828B3A90; continue 'dispatch;
	}
	// 828B3A88: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3A8C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B3A90: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3A94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B3A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3A9C: 4814CC2D  bl 0x82a006c8
	ctx.lr = 0x828B3AA0;
	sub_82A006C8(ctx, base);
	// 828B3AA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3AA4: 419A000C  beq cr6, 0x828b3ab0
	if ctx.cr[6].eq {
	pc = 0x828B3AB0; continue 'dispatch;
	}
	// 828B3AA8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3AAC: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828B3AB0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3AB4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828B3AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3ABC: 4814CC0D  bl 0x82a006c8
	ctx.lr = 0x828B3AC0;
	sub_82A006C8(ctx, base);
	// 828B3AC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3AC4: 419A000C  beq cr6, 0x828b3ad0
	if ctx.cr[6].eq {
	pc = 0x828B3AD0; continue 'dispatch;
	}
	// 828B3AC8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3ACC: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B3AD0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3AD4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B3AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3ADC: 4814CBED  bl 0x82a006c8
	ctx.lr = 0x828B3AE0;
	sub_82A006C8(ctx, base);
	// 828B3AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3AE4: 419A000C  beq cr6, 0x828b3af0
	if ctx.cr[6].eq {
	pc = 0x828B3AF0; continue 'dispatch;
	}
	// 828B3AE8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3AEC: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B3AF0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3AF4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B3AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3AFC: 4814CBCD  bl 0x82a006c8
	ctx.lr = 0x828B3B00;
	sub_82A006C8(ctx, base);
	// 828B3B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3B04: 419A000C  beq cr6, 0x828b3b10
	if ctx.cr[6].eq {
	pc = 0x828B3B10; continue 'dispatch;
	}
	// 828B3B08: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3B0C: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828B3B10: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3B14: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828B3B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3B1C: 4814CBAD  bl 0x82a006c8
	ctx.lr = 0x828B3B20;
	sub_82A006C8(ctx, base);
	// 828B3B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3B24: 419A000C  beq cr6, 0x828b3b30
	if ctx.cr[6].eq {
	pc = 0x828B3B30; continue 'dispatch;
	}
	// 828B3B28: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3B2C: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B3B30: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 828B3B34: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828B3B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3B3C: 4814CB8D  bl 0x82a006c8
	ctx.lr = 0x828B3B40;
	sub_82A006C8(ctx, base);
	// 828B3B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3B44: 419A000C  beq cr6, 0x828b3b50
	if ctx.cr[6].eq {
	pc = 0x828B3B50; continue 'dispatch;
	}
	// 828B3B48: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3B4C: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828B3B50: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828B3B54: 39710014  addi r11, r17, 0x14
	ctx.r[11].s64 = ctx.r[17].s64 + 20;
	// 828B3B58: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 828B3B5C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B3B60: 4198FE80  blt cr6, 0x828b39e0
	if ctx.cr[6].lt {
	pc = 0x828B39E0; continue 'dispatch;
	}
	// 828B3B64: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B3B68: 483F58C0  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3B70 size=328
    let mut pc: u32 = 0x828B3B70;
    'dispatch: loop {
        match pc {
            0x828B3B70 => {
    //   block [0x828B3B70..0x828B3CB8)
	// 828B3B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3B74: 483F5899  bl 0x82ca940c
	ctx.lr = 0x828B3B78;
	sub_82CA93D0(ctx, base);
	// 828B3B78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3B7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3B80: 48032021  bl 0x828e5ba0
	ctx.lr = 0x828B3B84;
	sub_828E5BA0(ctx, base);
	// 828B3B84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B3B88: 811F0040  lwz r8, 0x40(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B3B8C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828B3B90: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 828B3B94: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 828B3B98: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828B3B9C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 828B3BA0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B3BA4: C16A1804  lfs f11, 0x1804(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B3BA8: C01DFFF4  lfs f0, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3BAC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 828B3BB0: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 828B3BB4: C1BD2974  lfs f13, 0x2974(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(10612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B3BB8: D1BF0054  stfs f13, 0x54(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B3BBC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B3BC0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828B3BC4: FD406818  frsp f10, f13
	ctx.f[10].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828B3BC8: C19D1FF0  lfs f12, 0x1ff0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B3BCC: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B3BD0: ED2A5B3A  fmadds f9, f10, f12, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 828B3BD4: D13F0180  stfs f9, 0x180(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 828B3BD8: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B3BDC: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B3BE0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3BE4: 80630034  lwz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B3BE8: 4BD6EF09  bl 0x82622af0
	ctx.lr = 0x828B3BEC;
	sub_82622AF0(ctx, base);
	// 828B3BEC: 3BDF0130  addi r30, r31, 0x130
	ctx.r[30].s64 = ctx.r[31].s64 + 304;
	// 828B3BF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3BF4: 4BD6EFDD  bl 0x82622bd0
	ctx.lr = 0x828B3BF8;
	sub_82622BD0(ctx, base);
	// 828B3BF8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B3BFC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828B3C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3C04: 419A001C  beq cr6, 0x828b3c20
	if ctx.cr[6].eq {
	pc = 0x828B3C20; continue 'dispatch;
	}
	// 828B3C08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3C0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B3C10: 419A000C  beq cr6, 0x828b3c1c
	if ctx.cr[6].eq {
	pc = 0x828B3C1C; continue 'dispatch;
	}
	// 828B3C14: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828B3C18: 4800000C  b 0x828b3c24
	pc = 0x828B3C24; continue 'dispatch;
	// 828B3C1C: 4B8E021D  bl 0x82193e38
	ctx.lr = 0x828B3C20;
	sub_82193E38(ctx, base);
	// 828B3C20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B3C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3C28: 4BD6F051  bl 0x82622c78
	ctx.lr = 0x828B3C2C;
	sub_82622C78(ctx, base);
	// 828B3C2C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 828B3C30: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B3C34: C01D22D0  lfs f0, 0x22d0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B3C38: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 828B3C3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B3C40: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 828B3C44: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 828B3C48: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828B3C4C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B3C50: 90FE0004  stw r7, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828B3C54: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828B3C58: C1A90A54  lfs f13, 0xa54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B3C5C: 90DE0000  stw r6, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B3CB8 size=560
    let mut pc: u32 = 0x828B3CB8;
    'dispatch: loop {
        match pc {
            0x828B3CB8 => {
    //   block [0x828B3CB8..0x828B3EE8)
	// 828B3CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3CBC: 483F5751  bl 0x82ca940c
	ctx.lr = 0x828B3CC0;
	sub_82CA93D0(ctx, base);
	// 828B3CC0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B3EE8 size=1892
    let mut pc: u32 = 0x828B3EE8;
    'dispatch: loop {
        match pc {
            0x828B3EE8 => {
    //   block [0x828B3EE8..0x828B464C)
	// 828B3EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3EEC: 483F54F1  bl 0x82ca93dc
	ctx.lr = 0x828B3EF0;
	sub_82CA93D0(ctx, base);
	// 828B3EF0: DBA1FF68  stfd f29, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[29].u64 ) };
	// 828B3EF4: DBC1FF70  stfd f30, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 828B3EF8: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 828B3EFC: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B4650 size=1076
    let mut pc: u32 = 0x828B4650;
    'dispatch: loop {
        match pc {
            0x828B4650 => {
    //   block [0x828B4650..0x828B4A84)
	// 828B4650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4654: 483F4D91  bl 0x82ca93e4
	ctx.lr = 0x828B4658;
	sub_82CA93D0(ctx, base);
	// 828B4658: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 828B465C: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 828B4660: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 828B4664: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B4A88 size=672
    let mut pc: u32 = 0x828B4A88;
    'dispatch: loop {
        match pc {
            0x828B4A88 => {
    //   block [0x828B4A88..0x828B4D28)
	// 828B4A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4A8C: 483F4969  bl 0x82ca93f4
	ctx.lr = 0x828B4A90;
	sub_82CA93D0(ctx, base);
	// 828B4A90: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4D28 size=532
    let mut pc: u32 = 0x828B4D28;
    'dispatch: loop {
        match pc {
            0x828B4D28 => {
    //   block [0x828B4D28..0x828B4F3C)
	// 828B4D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4D2C: 483F46CD  bl 0x82ca93f8
	ctx.lr = 0x828B4D30;
	sub_82CA93D0(ctx, base);
	// 828B4D30: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 828B4D34: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828B4D38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4D3C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828B4D40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B4D44: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828B4D48: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 828B4D4C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828B4D50: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828B4D54: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828B4D58: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B4D5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B4D60: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4D64: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828B4D68: 4BD4C681  bl 0x826013e8
	ctx.lr = 0x828B4D6C;
	sub_826013E8(ctx, base);
	// 828B4D6C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B4D70: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828B4D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B4D78: 419A01B0  beq cr6, 0x828b4f28
	if ctx.cr[6].eq {
	pc = 0x828B4F28; continue 'dispatch;
	}
	// 828B4D7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B4D80: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B4D84: 3B8B9490  addi r28, r11, -0x6b70
	ctx.r[28].s64 = ctx.r[11].s64 + -27504;
	// 828B4D88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B4D8C: C3DCFFF4  lfs f30, -0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B4D90: D3DB0000  stfs f30, 0(r27)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4D94: 419A0194  beq cr6, 0x828b4f28
	if ctx.cr[6].eq {
	pc = 0x828B4F28; continue 'dispatch;
	}
	// 828B4D98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4D9C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DA4: 48031385  bl 0x828e6128
	ctx.lr = 0x828B4DA8;
	sub_828E6128(ctx, base);
	// 828B4DA8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4DAC: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828B4DB0: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828B4DB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DB8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DC0: 48031441  bl 0x828e6200
	ctx.lr = 0x828B4DC4;
	sub_828E6200(ctx, base);
	// 828B4DC4: D03B0000  stfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4DC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DCC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DD4: 480313BD  bl 0x828e6190
	ctx.lr = 0x828B4DD8;
	sub_828E6190(ctx, base);
	// 828B4DD8: C19F0018  lfs f12, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B4DDC: ED610332  fmuls f11, f1, f12
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 828B4DE0: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828B4DE4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4DE8: C3FC0000  lfs f31, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B4DEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DF0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4DF4: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DFC: 838BC8B0  lwz r28, -0x3750(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14160 as u32) ) } as u64;
	// 828B4E00: 48031289  bl 0x828e6088
	ctx.lr = 0x828B4E04;
	sub_828E6088(ctx, base);
	// 828B4E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E08: 419A0010  beq cr6, 0x828b4e18
	if ctx.cr[6].eq {
	pc = 0x828B4E18; continue 'dispatch;
	}
	// 828B4E0C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E14: 4B930A65  bl 0x821e5878
	ctx.lr = 0x828B4E18;
	sub_821E5878(ctx, base);
	// 828B4E18: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E1C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4E20: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4E28: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4E2C: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B4E30: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4E34: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4E38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4E3C: 838BC8A8  lwz r28, -0x3758(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14168 as u32) ) } as u64;
	// 828B4E40: 48031249  bl 0x828e6088
	ctx.lr = 0x828B4E44;
	sub_828E6088(ctx, base);
	// 828B4E44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E48: 419A0010  beq cr6, 0x828b4e58
	if ctx.cr[6].eq {
	pc = 0x828B4E58; continue 'dispatch;
	}
	// 828B4E4C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E54: 4B930A25  bl 0x821e5878
	ctx.lr = 0x828B4E58;
	sub_821E5878(ctx, base);
	// 828B4E58: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4E60: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4E64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4E68: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4E6C: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B4E70: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4E74: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4E7C: 838BC8AC  lwz r28, -0x3754(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14164 as u32) ) } as u64;
	// 828B4E80: 48031209  bl 0x828e6088
	ctx.lr = 0x828B4E84;
	sub_828E6088(ctx, base);
	// 828B4E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E88: 419A0010  beq cr6, 0x828b4e98
	if ctx.cr[6].eq {
	pc = 0x828B4E98; continue 'dispatch;
	}
	// 828B4E8C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E94: 4B9309E5  bl 0x821e5878
	ctx.lr = 0x828B4E98;
	sub_821E5878(ctx, base);
	// 828B4E98: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E9C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4EA0: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4EA4: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4EA8: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B4EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B4EB0: 419A003C  beq cr6, 0x828b4eec
	if ctx.cr[6].eq {
	pc = 0x828B4EEC; continue 'dispatch;
	}
	// 828B4EB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4EB8: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 828B4EBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4EC0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4EC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4EC8: 83CBC8A0  lwz r30, -0x3760(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14176 as u32) ) } as u64;
	// 828B4ECC: 480311BD  bl 0x828e6088
	ctx.lr = 0x828B4ED0;
	sub_828E6088(ctx, base);
	// 828B4ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4ED4: 419A0010  beq cr6, 0x828b4ee4
	if ctx.cr[6].eq {
	pc = 0x828B4EE4; continue 'dispatch;
	}
	// 828B4ED8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B4EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B4EE0: 4814B4D1  bl 0x82a003b0
	ctx.lr = 0x828B4EE4;
	sub_82A003B0(ctx, base);
	// 828B4EE4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B4EE8: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828B4EEC: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 828B4EF0: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 828B4EF4: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 828B4EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B4EFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B4F00: 4BD48529  bl 0x825fd428
	ctx.lr = 0x828B4F04;
	sub_825FD428(ctx, base);
	// 828B4F04: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B4F08: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B4F0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B4F10: 419A001C  beq cr6, 0x828b4f2c
	if ctx.cr[6].eq {
	pc = 0x828B4F2C; continue 'dispatch;
	}
	// 828B4F14: D3DB0000  stfs f30, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4F18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B4F1C: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828B4F20: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828B4F24: 483F4524  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828B4F28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B4F2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B4F30: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828B4F34: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828B4F38: 483F4510  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4F40 size=456
    let mut pc: u32 = 0x828B4F40;
    'dispatch: loop {
        match pc {
            0x828B4F40 => {
    //   block [0x828B4F40..0x828B5108)
	// 828B4F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4F44: 483F448D  bl 0x82ca93d0
	ctx.lr = 0x828B4F48;
	sub_82CA93D0(ctx, base);
	// 828B4F48: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4F4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F50: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B4F54: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828B4F58: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828B4F5C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828B4F60: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B4F64: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F68: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828B4F6C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828B4F70: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828B4F74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B4F78: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B4F7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B4F80: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B4F84: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828B4F88: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828B4F8C: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828B4F90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B4F94: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F98: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828B4F9C: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B4FA0: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828B4FA4: 4B9B0A85  bl 0x82265a28
	ctx.lr = 0x828B4FA8;
	sub_82265A28(ctx, base);
	// 828B4FA8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B4FAC: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828B4FB0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B4FB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B4FB8: 40990148  ble cr6, 0x828b5100
	if !ctx.cr[6].gt {
	pc = 0x828B5100; continue 'dispatch;
	}
	// 828B4FBC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B4FC0: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828B4FC4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B4FC8: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828B4FCC: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B4FD0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B4FD4: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828B4FD8: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	// 828B4FDC: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828B4FE0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B4FE4: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B4FE8: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828B4FEC: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828B4FF0: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828B4FF4: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828B4FF8: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828B4FFC: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828B5000: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828B5004: 418200E0  beq 0x828b50e4
	if ctx.cr[0].eq {
	pc = 0x828B50E4; continue 'dispatch;
	}
	// 828B5008: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B500C: 418200D8  beq 0x828b50e4
	if ctx.cr[0].eq {
	pc = 0x828B50E4; continue 'dispatch;
	}
	// 828B5010: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828B5014: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B5018: 409800CC  bge cr6, 0x828b50e4
	if !ctx.cr[6].lt {
	pc = 0x828B50E4; continue 'dispatch;
	}
	// 828B501C: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5020: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828B5024: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B5028: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828B502C: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828B5030: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5034: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5038: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[23].s32 as i64);
	// 828B503C: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828B5040: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B5044: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B5048: 40980088  bge cr6, 0x828b50d0
	if !ctx.cr[6].lt {
	pc = 0x828B50D0; continue 'dispatch;
	}
	// 828B504C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 828B5050: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5054: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5058: 419A006C  beq cr6, 0x828b50c4
	if ctx.cr[6].eq {
	pc = 0x828B50C4; continue 'dispatch;
	}
	// 828B505C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5060: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B5064: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B5068: 40980050  bge cr6, 0x828b50b8
	if !ctx.cr[6].lt {
	pc = 0x828B50B8; continue 'dispatch;
	}
	// 828B506C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828B5070: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5074: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B507C: 4B94E565  bl 0x822035e0
	ctx.lr = 0x828B5080;
	sub_822035E0(ctx, base);
	// 828B5080: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5088: 419A002C  beq cr6, 0x828b50b4
	if ctx.cr[6].eq {
	pc = 0x828B50B4; continue 'dispatch;
	}
	// 828B508C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5090: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5094: 4BFFEC25  bl 0x828b3cb8
	ctx.lr = 0x828B5098;
	sub_828B3CB8(ctx, base);
	// 828B5098: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B509C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B50A0: 419A0014  beq cr6, 0x828b50b4
	if ctx.cr[6].eq {
	pc = 0x828B50B4; continue 'dispatch;
	}
	// 828B50A4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B50A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B50AC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B50B0: 482946A1  bl 0x82b49750
	ctx.lr = 0x828B50B4;
	sub_82B49750(ctx, base);
	// 828B50B4: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B50B8: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B50BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B50C0: 409AFF9C  bne cr6, 0x828b505c
	if !ctx.cr[6].eq {
	pc = 0x828B505C; continue 'dispatch;
	}
	// 828B50C4: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828B50C8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B50CC: 4082FF84  bne 0x828b5050
	if !ctx.cr[0].eq {
	pc = 0x828B5050; continue 'dispatch;
	}
	// 828B50D0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828B50D4: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B50D8: 4198FF44  blt cr6, 0x828b501c
	if ctx.cr[6].lt {
	pc = 0x828B501C; continue 'dispatch;
	}
	// 828B50DC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B50E0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B50E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B50E8: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828B50EC: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828B50F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B50F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B50F8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828B50FC: 4198FEE0  blt cr6, 0x828b4fdc
	if ctx.cr[6].lt {
	pc = 0x828B4FDC; continue 'dispatch;
	}
	// 828B5100: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828B5104: 483F431C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B5108 size=456
    let mut pc: u32 = 0x828B5108;
    'dispatch: loop {
        match pc {
            0x828B5108 => {
    //   block [0x828B5108..0x828B52D0)
	// 828B5108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B510C: 483F42C5  bl 0x82ca93d0
	ctx.lr = 0x828B5110;
	sub_82CA93D0(ctx, base);
	// 828B5110: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5114: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5118: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B511C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828B5120: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828B5124: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828B5128: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B512C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5130: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828B5134: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828B5138: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828B513C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5140: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B5144: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5148: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B514C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828B5150: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828B5154: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828B5158: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B515C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5160: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828B5164: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5168: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828B516C: 4B9B08BD  bl 0x82265a28
	ctx.lr = 0x828B5170;
	sub_82265A28(ctx, base);
	// 828B5170: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5174: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828B5178: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B517C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B5180: 40990148  ble cr6, 0x828b52c8
	if !ctx.cr[6].gt {
	pc = 0x828B52C8; continue 'dispatch;
	}
	// 828B5184: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B5188: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828B518C: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B5190: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828B5194: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5198: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B519C: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828B51A0: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	// 828B51A4: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828B51A8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B51AC: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B51B0: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828B51B4: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828B51B8: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828B51BC: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828B51C0: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828B51C4: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828B51C8: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828B51CC: 418200E0  beq 0x828b52ac
	if ctx.cr[0].eq {
	pc = 0x828B52AC; continue 'dispatch;
	}
	// 828B51D0: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B51D4: 418200D8  beq 0x828b52ac
	if ctx.cr[0].eq {
	pc = 0x828B52AC; continue 'dispatch;
	}
	// 828B51D8: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828B51DC: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B51E0: 409800CC  bge cr6, 0x828b52ac
	if !ctx.cr[6].lt {
	pc = 0x828B52AC; continue 'dispatch;
	}
	// 828B51E4: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B51E8: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828B51EC: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B51F0: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828B51F4: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828B51F8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B51FC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5200: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[23].s32 as i64);
	// 828B5204: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828B5208: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B520C: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B5210: 40980088  bge cr6, 0x828b5298
	if !ctx.cr[6].lt {
	pc = 0x828B5298; continue 'dispatch;
	}
	// 828B5214: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 828B5218: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B521C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5220: 419A006C  beq cr6, 0x828b528c
	if ctx.cr[6].eq {
	pc = 0x828B528C; continue 'dispatch;
	}
	// 828B5224: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5228: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B522C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B5230: 40980050  bge cr6, 0x828b5280
	if !ctx.cr[6].lt {
	pc = 0x828B5280; continue 'dispatch;
	}
	// 828B5234: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828B5238: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B523C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5244: 4B94E39D  bl 0x822035e0
	ctx.lr = 0x828B5248;
	sub_822035E0(ctx, base);
	// 828B5248: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B524C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5250: 419A002C  beq cr6, 0x828b527c
	if ctx.cr[6].eq {
	pc = 0x828B527C; continue 'dispatch;
	}
	// 828B5254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5258: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B525C: 4BFFE44D  bl 0x828b36a8
	ctx.lr = 0x828B5260;
	sub_828B36A8(ctx, base);
	// 828B5260: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5268: 419A0014  beq cr6, 0x828b527c
	if ctx.cr[6].eq {
	pc = 0x828B527C; continue 'dispatch;
	}
	// 828B526C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B5270: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B5274: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5278: 482944D9  bl 0x82b49750
	ctx.lr = 0x828B527C;
	sub_82B49750(ctx, base);
	// 828B527C: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B5280: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5284: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5288: 409AFF9C  bne cr6, 0x828b5224
	if !ctx.cr[6].eq {
	pc = 0x828B5224; continue 'dispatch;
	}
	// 828B528C: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828B5290: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B5294: 4082FF84  bne 0x828b5218
	if !ctx.cr[0].eq {
	pc = 0x828B5218; continue 'dispatch;
	}
	// 828B5298: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828B529C: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B52A0: 4198FF44  blt cr6, 0x828b51e4
	if ctx.cr[6].lt {
	pc = 0x828B51E4; continue 'dispatch;
	}
	// 828B52A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B52A8: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B52AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B52B0: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828B52B4: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828B52B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B52BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B52C0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828B52C4: 4198FEE0  blt cr6, 0x828b51a4
	if ctx.cr[6].lt {
	pc = 0x828B51A4; continue 'dispatch;
	}
	// 828B52C8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828B52CC: 483F4154  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B52D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B52D0 size=236
    let mut pc: u32 = 0x828B52D0;
    'dispatch: loop {
        match pc {
            0x828B52D0 => {
    //   block [0x828B52D0..0x828B53BC)
	// 828B52D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B52D4: 483F412D  bl 0x82ca9400
	ctx.lr = 0x828B52D8;
	sub_82CA93D0(ctx, base);
	// 828B52D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B52DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B52E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B52E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B52E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B52EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B52F0: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828B52F4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B52F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828B52FC: 390A53C0  addi r8, r10, 0x53c0
	ctx.r[8].s64 = ctx.r[10].s64 + 21440;
	// 828B5300: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828B5304: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 828B5308: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828B530C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828B5310: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828B5314: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 828B5318: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828B531C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828B5320: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 828B5324: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 828B5328: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B532C: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5330: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5334: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828B5338: 4E800421  bctrl
	ctx.lr = 0x828B533C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B533C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828B5340: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828B5344: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B5348: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 828B534C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 828B5350: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B5354: 38800160  li r4, 0x160
	ctx.r[4].s64 = 352;
	// 828B5358: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B535C: 7C63582E  lwzx r3, r3, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B5360: 4849FEE9  bl 0x82d55248
	ctx.lr = 0x828B5364;
	sub_82D55248(ctx, base);
	// 828B5364: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B5368: 39400160  li r10, 0x160
	ctx.r[10].s64 = 352;
	// 828B536C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B5370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5374: 535D801E  rlwimi r29, r26, 0x10, 0, 0xf
	ctx.r[29].u64 = (((ctx.r[26].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[29].u64 & 0xFFFFFFFF0000FFFF);
	// 828B5378: B15E0004  sth r10, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 828B537C: 4B9E5EFD  bl 0x8229b278
	ctx.lr = 0x828B5380;
	sub_8229B278(ctx, base);
	// 828B5380: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5384: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B5388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B538C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B5390: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B5394: 4E800421  bctrl
	ctx.lr = 0x828B5398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B539C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B53A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828B53A4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828B53A8: 484CA691  bl 0x82d7fa38
	ctx.lr = 0x828B53AC;
	sub_82D7FA38(ctx, base);
	// 828B53AC: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 828B53B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B53B4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828B53B8: 483F4098  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B53C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B53C0 size=80
    let mut pc: u32 = 0x828B53C0;
    'dispatch: loop {
        match pc {
            0x828B53C0 => {
    //   block [0x828B53C0..0x828B5410)
	// 828B53C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B53C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B53C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B53CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B53D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B53D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B53D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B53DC: 48000035  bl 0x828b5410
	ctx.lr = 0x828B53E0;
	sub_828B5410(ctx, base);
	// 828B53E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828B53E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B53E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B53EC: 419A000C  beq cr6, 0x828b53f8
	if ctx.cr[6].eq {
	pc = 0x828B53F8; continue 'dispatch;
	}
	// 828B53F0: 4B966949  bl 0x8221bd38
	ctx.lr = 0x828B53F4;
	sub_8221BD38(ctx, base);
	// 828B53F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B53F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B53FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5404: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B540C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5410 size=104
    let mut pc: u32 = 0x828B5410;
    'dispatch: loop {
        match pc {
            0x828B5410 => {
    //   block [0x828B5410..0x828B5478)
	// 828B5410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B541C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B5420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B542C: 394B53C0  addi r10, r11, 0x53c0
	ctx.r[10].s64 = ctx.r[11].s64 + 21440;
	// 828B5430: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B5434: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B5438: 484CAFA9  bl 0x82d803e0
	ctx.lr = 0x828B543C;
	sub_82D803E0(ctx, base);
	// 828B543C: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 828B5440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5444: 4B9026D5  bl 0x821b7b18
	ctx.lr = 0x828B5448;
	sub_821B7B18(ctx, base);
	// 828B5448: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B544C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5450: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 828B5454: 4B9026C5  bl 0x821b7b18
	ctx.lr = 0x828B5458;
	sub_821B7B18(ctx, base);
	// 828B5458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B545C: 4BB66B65  bl 0x8241bfc0
	ctx.lr = 0x828B5460;
	sub_8241BFC0(ctx, base);
	// 828B5460: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B546C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828B5478 size=48
    let mut pc: u32 = 0x828B5478;
    'dispatch: loop {
        match pc {
            0x828B5478 => {
    //   block [0x828B5478..0x828B54A8)
	// 828B5478: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B547C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 828B5480: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828B5484: 39099160  addi r8, r9, -0x6ea0
	ctx.r[8].s64 = ctx.r[9].s64 + -28320;
	// 828B5488: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B548C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54A8 size=20
    let mut pc: u32 = 0x828B54A8;
    'dispatch: loop {
        match pc {
            0x828B54A8 => {
    //   block [0x828B54A8..0x828B54BC)
	// 828B54A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B54AC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B54B0: 908B0010  stw r4, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 828B54B4: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B54B8: 484C3FA0  b 0x82d79458
	sub_82D79458(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54C0 size=24
    let mut pc: u32 = 0x828B54C0;
    'dispatch: loop {
        match pc {
            0x828B54C0 => {
    //   block [0x828B54C0..0x828B54D8)
	// 828B54C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B54C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B54C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B54CC: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B54D0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828B54D4: 484C2AC4  b 0x82d77f98
	sub_82D77F98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54D8 size=8
    let mut pc: u32 = 0x828B54D8;
    'dispatch: loop {
        match pc {
            0x828B54D8 => {
    //   block [0x828B54D8..0x828B54E0)
	// 828B54D8: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 828B54DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B54E0 size=60
    let mut pc: u32 = 0x828B54E0;
    'dispatch: loop {
        match pc {
            0x828B54E0 => {
    //   block [0x828B54E0..0x828B551C)
	// 828B54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B54E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B54E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B54EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B54F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B54F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B54F8: 388B9484  addi r4, r11, -0x6b7c
	ctx.r[4].s64 = ctx.r[11].s64 + -27516;
	// 828B54FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5500: 4B9779D1  bl 0x8222ced0
	ctx.lr = 0x828B5504;
	sub_8222CED0(ctx, base);
	// 828B5504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5508: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B550C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5520 size=104
    let mut pc: u32 = 0x828B5520;
    'dispatch: loop {
        match pc {
            0x828B5520 => {
    //   block [0x828B5520..0x828B5588)
	// 828B5520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5524: 483F3EE9  bl 0x82ca940c
	ctx.lr = 0x828B5528;
	sub_82CA93D0(ctx, base);
	// 828B5528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B552C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5530: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B5534: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 828B5538: 4B9025E1  bl 0x821b7b18
	ctx.lr = 0x828B553C;
	sub_821B7B18(ctx, base);
	// 828B553C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5540: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 828B5544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5548: 419A000C  beq cr6, 0x828b5554
	if ctx.cr[6].eq {
	pc = 0x828B5554; continue 'dispatch;
	}
	// 828B554C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5550: 4BEAF871  bl 0x82764dc0
	ctx.lr = 0x828B5554;
	sub_82764DC0(ctx, base);
	// 828B5554: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B5558: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B555C: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828B5560: 57A807FE  clrlwi r8, r29, 0x1f
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828B5564: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B5568: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B556C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B5574: 419A000C  beq cr6, 0x828b5580
	if ctx.cr[6].eq {
	pc = 0x828B5580; continue 'dispatch;
	}
	// 828B5578: 4B9667C1  bl 0x8221bd38
	ctx.lr = 0x828B557C;
	sub_8221BD38(ctx, base);
	// 828B557C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5580: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5584: 483F3ED8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5588 size=760
    let mut pc: u32 = 0x828B5588;
    'dispatch: loop {
        match pc {
            0x828B5588 => {
    //   block [0x828B5588..0x828B5880)
	// 828B5588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B558C: 483F3E79  bl 0x82ca9404
	ctx.lr = 0x828B5590;
	sub_82CA93D0(ctx, base);
	// 828B5590: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5594: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B5598: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B559C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B55A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B55A4: 388A2BE0  addi r4, r10, 0x2be0
	ctx.r[4].s64 = ctx.r[10].s64 + 11232;
	// 828B55A8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B55AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55B0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828B55B4: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828B55B8: 3BBB000C  addi r29, r27, 0xc
	ctx.r[29].s64 = ctx.r[27].s64 + 12;
	// 828B55BC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828B55C0: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 828B55C4: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 828B55C8: 4B977909  bl 0x8222ced0
	ctx.lr = 0x828B55CC;
	sub_8222CED0(ctx, base);
	// 828B55CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B55D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B55D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55D8: 48167871  bl 0x82a1ce48
	ctx.lr = 0x828B55DC;
	sub_82A1CE48(ctx, base);
	// 828B55DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55E0: 4B95F7F9  bl 0x82214dd8
	ctx.lr = 0x828B55E4;
	sub_82214DD8(ctx, base);
	// 828B55E4: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B55E8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828B55EC: 419A028C  beq cr6, 0x828b5878
	if ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B55F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B55F4: 57FF063E  clrlwi r31, r31, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828B55F8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828B55FC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828B5600: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B5604: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B5608: 419A0188  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B560C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5610: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828B5614: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5618: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B561C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5620: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5624: E8E80014  ld r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	// 828B5628: F8E10060  std r7, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u64 ) };
	// 828B562C: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5630: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B5634: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5638: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B563C: 4B9AEE4D  bl 0x82264488
	ctx.lr = 0x828B5640;
	sub_82264488(ctx, base);
	// 828B5640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B5644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5648: 419A0018  beq cr6, 0x828b5660
	if ctx.cr[6].eq {
	pc = 0x828B5660; continue 'dispatch;
	}
	// 828B564C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5650: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828B5654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B5658: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B565C: 409A0008  bne cr6, 0x828b5664
	if !ctx.cr[6].eq {
	pc = 0x828B5664; continue 'dispatch;
	}
	// 828B5660: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828B5664: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B5668: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B566C: 419A0124  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B5670: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B5674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5678: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 828B567C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B5680: 419A00F4  beq cr6, 0x828b5774
	if ctx.cr[6].eq {
	pc = 0x828B5774; continue 'dispatch;
	}
	// 828B5684: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5688: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B568C: 419A0024  beq cr6, 0x828b56b0
	if ctx.cr[6].eq {
	pc = 0x828B56B0; continue 'dispatch;
	}
	// 828B5690: 894A000D  lbz r10, 0xd(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(13 as u32) ) } as u64;
	// 828B5694: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5698: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B569C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B56A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B56A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B56A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B56AC: 480000CC  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
	// 828B56B0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B56B4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B56B8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828B56BC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B56C0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B56C4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B56C8: 40810054  ble 0x828b571c
	if !ctx.cr[0].gt {
	pc = 0x828B571C; continue 'dispatch;
	}
	// 828B56CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B56D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B56D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B56D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B56DC: 2F07000D  cmpwi cr6, r7, 0xd
	ctx.cr[6].compare_i32(ctx.r[7].s32, 13, &mut ctx.xer);
	// 828B56E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B56E4: 41980008  blt cr6, 0x828b56ec
	if ctx.cr[6].lt {
	pc = 0x828B56EC; continue 'dispatch;
	}
	// 828B56E8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B56EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B56F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B56F4: 419A0014  beq cr6, 0x828b5708
	if ctx.cr[6].eq {
	pc = 0x828B5708; continue 'dispatch;
	}
	// 828B56F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B56FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5700: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5704: 4800000C  b 0x828b5710
	pc = 0x828B5710; continue 'dispatch;
	// 828B5708: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B570C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B5710: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5714: 4199FFB8  bgt cr6, 0x828b56cc
	if ctx.cr[6].gt {
	pc = 0x828B56CC; continue 'dispatch;
	}
	// 828B5718: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B571C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5720: 419A0040  beq cr6, 0x828b5760
	if ctx.cr[6].eq {
	pc = 0x828B5760; continue 'dispatch;
	}
	// 828B5724: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5728: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 828B572C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5730: 41990008  bgt cr6, 0x828b5738
	if ctx.cr[6].gt {
	pc = 0x828B5738; continue 'dispatch;
	}
	// 828B5734: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B5738: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B573C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5740: 409A0020  bne cr6, 0x828b5760
	if !ctx.cr[6].eq {
	pc = 0x828B5760; continue 'dispatch;
	}
	// 828B5744: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828B5748: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828B574C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B5750: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5754: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B5758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B575C: 4800001C  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
	// 828B5760: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B5764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5768: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B576C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5770: 48000008  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
	// 828B5774: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B5778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B577C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5780: 419A0010  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B5784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B5788: 4BC3EBD9  bl 0x824f4360
	ctx.lr = 0x828B578C;
	sub_824F4360(ctx, base);
	// 828B578C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828B5790: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5794: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B5798: 388B2BE8  addi r4, r11, 0x2be8
	ctx.r[4].s64 = ctx.r[11].s64 + 11240;
	// 828B579C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57A0: 4B977731  bl 0x8222ced0
	ctx.lr = 0x828B57A4;
	sub_8222CED0(ctx, base);
	// 828B57A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B57A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B57AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B57B0: 4BBFD009  bl 0x824b27b8
	ctx.lr = 0x828B57B4;
	sub_824B27B8(ctx, base);
	// 828B57B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57B8: 4B95F621  bl 0x82214dd8
	ctx.lr = 0x828B57BC;
	sub_82214DD8(ctx, base);
	// 828B57BC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828B57C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B57C4: 388AD81C  addi r4, r10, -0x27e4
	ctx.r[4].s64 = ctx.r[10].s64 + -10212;
	// 828B57C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57CC: 4B977705  bl 0x8222ced0
	ctx.lr = 0x828B57D0;
	sub_8222CED0(ctx, base);
	// 828B57D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B57D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B57D8: 409A0010  bne cr6, 0x828b57e8
	if !ctx.cr[6].eq {
	pc = 0x828B57E8; continue 'dispatch;
	}
	// 828B57DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B57E0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 828B57E4: 48000008  b 0x828b57ec
	pc = 0x828B57EC; continue 'dispatch;
	// 828B57E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B57EC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B57F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B57F4: 4BBCAFD5  bl 0x824807c8
	ctx.lr = 0x828B57F8;
	sub_824807C8(ctx, base);
	// 828B57F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57FC: 4B95F5DD  bl 0x82214dd8
	ctx.lr = 0x828B5800;
	sub_82214DD8(ctx, base);
	// 828B5800: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B5804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5808: 409A0014  bne cr6, 0x828b581c
	if !ctx.cr[6].eq {
	pc = 0x828B581C; continue 'dispatch;
	}
	// 828B580C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5814: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B5818: 419A0008  beq cr6, 0x828b5820
	if ctx.cr[6].eq {
	pc = 0x828B5820; continue 'dispatch;
	}
	// 828B581C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5820: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5828: 419A0050  beq cr6, 0x828b5878
	if ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B582C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B5830: 409A0048  bne cr6, 0x828b5878
	if !ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B5834: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B5838: 4B969A21  bl 0x8221f258
	ctx.lr = 0x828B583C;
	sub_8221F258(ctx, base);
	// 828B583C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5840: 419A0014  beq cr6, 0x828b5854
	if ctx.cr[6].eq {
	pc = 0x828B5854; continue 'dispatch;
	}
	// 828B5844: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B5848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B584C: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B5850: 48000008  b 0x828b5858
	pc = 0x828B5858; continue 'dispatch;
	// 828B5854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5858: 387B001C  addi r3, r27, 0x1c
	ctx.r[3].s64 = ctx.r[27].s64 + 28;
	// 828B585C: 4BE5C8AD  bl 0x82712108
	ctx.lr = 0x828B5860;
	sub_82712108(ctx, base);
	// 828B5860: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5864: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B5868: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828B586C: 811B001C  lwz r8, 0x1c(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5870: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B5874: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828B5878: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B587C: 483F3BD8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5880 size=496
    let mut pc: u32 = 0x828B5880;
    'dispatch: loop {
        match pc {
            0x828B5880 => {
    //   block [0x828B5880..0x828B5A70)
	// 828B5880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5884: 483F3B85  bl 0x82ca9408
	ctx.lr = 0x828B5888;
	sub_82CA93D0(ctx, base);
	// 828B5888: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B588C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5890: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 828B5894: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5898: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B589C: 419A01CC  beq cr6, 0x828b5a68
	if ctx.cr[6].eq {
	pc = 0x828B5A68; continue 'dispatch;
	}
	// 828B58A0: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 828B58A4: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B58A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B58AC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B58B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B58B4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B58B8: 4B9AEBD1  bl 0x82264488
	ctx.lr = 0x828B58BC;
	sub_82264488(ctx, base);
	// 828B58BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B58C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B58C4: 419A0018  beq cr6, 0x828b58dc
	if ctx.cr[6].eq {
	pc = 0x828B58DC; continue 'dispatch;
	}
	// 828B58C8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B58CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B58D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B58D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B58D8: 409A0008  bne cr6, 0x828b58e0
	if !ctx.cr[6].eq {
	pc = 0x828B58E0; continue 'dispatch;
	}
	// 828B58DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B58E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B58E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B58E8: 419A0174  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B58EC: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B58F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B58F4: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 828B58F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B58FC: 419A00E4  beq cr6, 0x828b59e0
	if ctx.cr[6].eq {
	pc = 0x828B59E0; continue 'dispatch;
	}
	// 828B5900: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5904: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B590C: 419A001C  beq cr6, 0x828b5928
	if ctx.cr[6].eq {
	pc = 0x828B5928; continue 'dispatch;
	}
	// 828B5910: 896B000D  lbz r11, 0xd(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(13 as u32) ) } as u64;
	// 828B5914: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B5918: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B591C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5920: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B5924: 480000C0  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
	// 828B5928: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B592C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B5930: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B5934: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B5938: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B593C: 40810054  ble 0x828b5990
	if !ctx.cr[0].gt {
	pc = 0x828B5990; continue 'dispatch;
	}
	// 828B5940: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5944: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5948: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B594C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5950: 2F07000D  cmpwi cr6, r7, 0xd
	ctx.cr[6].compare_i32(ctx.r[7].s32, 13, &mut ctx.xer);
	// 828B5954: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5958: 41980008  blt cr6, 0x828b5960
	if ctx.cr[6].lt {
	pc = 0x828B5960; continue 'dispatch;
	}
	// 828B595C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B5960: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5968: 419A0014  beq cr6, 0x828b597c
	if ctx.cr[6].eq {
	pc = 0x828B597C; continue 'dispatch;
	}
	// 828B596C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B5970: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5974: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5978: 4800000C  b 0x828b5984
	pc = 0x828B5984; continue 'dispatch;
	// 828B597C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B5980: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B5984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5988: 4199FFB8  bgt cr6, 0x828b5940
	if ctx.cr[6].gt {
	pc = 0x828B5940; continue 'dispatch;
	}
	// 828B598C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B5990: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5994: 419A003C  beq cr6, 0x828b59d0
	if ctx.cr[6].eq {
	pc = 0x828B59D0; continue 'dispatch;
	}
	// 828B5998: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B599C: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 828B59A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B59A4: 41990008  bgt cr6, 0x828b59ac
	if ctx.cr[6].gt {
	pc = 0x828B59AC; continue 'dispatch;
	}
	// 828B59A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B59AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B59B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B59B4: 409A001C  bne cr6, 0x828b59d0
	if !ctx.cr[6].eq {
	pc = 0x828B59D0; continue 'dispatch;
	}
	// 828B59B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B59BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B59C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B59C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B59C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B59CC: 48000018  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
	// 828B59D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B59D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B59D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B59DC: 48000008  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
	// 828B59E0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828B59E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B59E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B59EC: 419A0070  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B59F0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B59F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B59F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828B59FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5A00: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5A04: 4BC3C34D  bl 0x824f1d50
	ctx.lr = 0x828B5A08;
	sub_824F1D50(ctx, base);
	// 828B5A08: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828B5A0C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828B5A10: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B5A14: 419A0010  beq cr6, 0x828b5a24
	if ctx.cr[6].eq {
	pc = 0x828B5A24; continue 'dispatch;
	}
	// 828B5A18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5A20: 4B8D8519  bl 0x8218df38
	ctx.lr = 0x828B5A24;
	sub_8218DF38(ctx, base);
	// 828B5A24: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B5A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5A2C: 419A000C  beq cr6, 0x828b5a38
	if ctx.cr[6].eq {
	pc = 0x828B5A38; continue 'dispatch;
	}
	// 828B5A30: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5A34: 4BEAF38D  bl 0x82764dc0
	ctx.lr = 0x828B5A38;
	sub_82764DC0(ctx, base);
	// 828B5A38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5A3C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828B5A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5A44: 419A0018  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B5A48: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5A50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5A54: 806B0078  lwz r3, 0x78(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828B5A58: 4BBAB209  bl 0x82460c60
	ctx.lr = 0x828B5A5C;
	sub_82460C60(ctx, base);
	// 828B5A5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B5A60: 4B9020B9  bl 0x821b7b18
	ctx.lr = 0x828B5A64;
	sub_821B7B18(ctx, base);
	// 828B5A64: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B5A68: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B5A6C: 483F39EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5A70 size=396
    let mut pc: u32 = 0x828B5A70;
    'dispatch: loop {
        match pc {
            0x828B5A70 => {
    //   block [0x828B5A70..0x828B5BFC)
	// 828B5A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5A74: 483F3995  bl 0x82ca9408
	ctx.lr = 0x828B5A78;
	sub_82CA93D0(ctx, base);
	// 828B5A78: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B5A7C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B5C00 size=552
    let mut pc: u32 = 0x828B5C00;
    'dispatch: loop {
        match pc {
            0x828B5C00 => {
    //   block [0x828B5C00..0x828B5E28)
	// 828B5C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5C04: 483F3809  bl 0x82ca940c
	ctx.lr = 0x828B5C08;
	sub_82CA93D0(ctx, base);
	// 828B5C08: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828B5C0C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B5C10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5C18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B5C1C: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 828B5C20: 895F0098  lbz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828B5C24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B5C28: C3FE000C  lfs f31, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B5C2C: 409A01E8  bne cr6, 0x828b5e14
	if !ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C30: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 828B5C34: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828B5C38: 419A01DC  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5C40: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5C44: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5C48: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B5C4C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5C50: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5C54: 4B8BE815  bl 0x82174468
	ctx.lr = 0x828B5C58;
	sub_82174468(ctx, base);
	// 828B5C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5C5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B5C60: 4B97CB19  bl 0x82232778
	ctx.lr = 0x828B5C64;
	sub_82232778(ctx, base);
	// 828B5C64: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5C68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5C6C: 409A01A8  bne cr6, 0x828b5e14
	if !ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C70: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B5C74: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828B5C78: 80DF001C  lwz r6, 0x1c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5C7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B5C80: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 828B5C84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B5C88: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828B5C8C: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5C90: 4081005C  ble 0x828b5cec
	if !ctx.cr[0].gt {
	pc = 0x828B5CEC; continue 'dispatch;
	}
	// 828B5C94: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5C98: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5C9C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B5CA0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5CA4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 828B5CA8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5CAC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 828B5CB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5CB4: 41980008  blt cr6, 0x828b5cbc
	if ctx.cr[6].lt {
	pc = 0x828B5CBC; continue 'dispatch;
	}
	// 828B5CB8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B5CBC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5CC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5CC4: 419A0014  beq cr6, 0x828b5cd8
	if ctx.cr[6].eq {
	pc = 0x828B5CD8; continue 'dispatch;
	}
	// 828B5CC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828B5CCC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 828B5CD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5CD4: 4800000C  b 0x828b5ce0
	pc = 0x828B5CE0; continue 'dispatch;
	// 828B5CD8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828B5CDC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828B5CE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5CE4: 4199FFB0  bgt cr6, 0x828b5c94
	if ctx.cr[6].gt {
	pc = 0x828B5C94; continue 'dispatch;
	}
	// 828B5CE8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828B5CEC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5CF0: 419A0034  beq cr6, 0x828b5d24
	if ctx.cr[6].eq {
	pc = 0x828B5D24; continue 'dispatch;
	}
	// 828B5CF4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5CF8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828B5CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5D00: 41990008  bgt cr6, 0x828b5d08
	if ctx.cr[6].gt {
	pc = 0x828B5D08; continue 'dispatch;
	}
	// 828B5D04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5D08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5D10: 409A0014  bne cr6, 0x828b5d24
	if !ctx.cr[6].eq {
	pc = 0x828B5D24; continue 'dispatch;
	}
	// 828B5D14: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B5D18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B5D1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B5D20: 48000008  b 0x828b5d28
	pc = 0x828B5D28; continue 'dispatch;
	// 828B5D24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B5D28: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5D2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B5D30: 419A000C  beq cr6, 0x828b5d3c
	if ctx.cr[6].eq {
	pc = 0x828B5D3C; continue 'dispatch;
	}
	// 828B5D34: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5D38: 48000008  b 0x828b5d40
	pc = 0x828B5D40; continue 'dispatch;
	// 828B5D3C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B5D40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5D44: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B5D48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B5D4C: 4E800421  bctrl
	ctx.lr = 0x828B5D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5D50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5D54: 419A00C0  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D58: 4BEAB2E1  bl 0x82761038
	ctx.lr = 0x828B5D5C;
	sub_82761038(ctx, base);
	// 828B5D5C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828B5D60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B5D64: C00B9A80  lfs f0, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5D68: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 828B5D6C: 409900A8  ble cr6, 0x828b5e14
	if !ctx.cr[6].gt {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D70: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5D74: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828B5D78: 419A009C  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D7C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5D80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5D84: 41980014  blt cr6, 0x828b5d98
	if ctx.cr[6].lt {
	pc = 0x828B5D98; continue 'dispatch;
	}
	// 828B5D88: 4B9E29B1  bl 0x82298738
	ctx.lr = 0x828B5D8C;
	sub_82298738(ctx, base);
	// 828B5D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5D94: 409A0008  bne cr6, 0x828b5d9c
	if !ctx.cr[6].eq {
	pc = 0x828B5D9C; continue 'dispatch;
	}
	// 828B5D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B5D9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5DA4: 419A0070  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B5DAC: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5DB0: 4BCF68A9  bl 0x825ac658
	ctx.lr = 0x828B5DB4;
	sub_825AC658(ctx, base);
	// 828B5DB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5DBC: 419A0058  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DC0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B5DC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5DC8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B5DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B5DD0: 4E800421  bctrl
	ctx.lr = 0x828B5DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5DD4: 4BEAB265  bl 0x82761038
	ctx.lr = 0x828B5DD8;
	sub_82761038(ctx, base);
	// 828B5DD8: C01E21CC  lfs f0, 0x21cc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5DDC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828B5DE0: 40990034  ble cr6, 0x828b5e14
	if !ctx.cr[6].gt {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DE4: EDA1F024  fdivs f13, f1, f30
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[30].f64) as f32) as f64;
	// 828B5DE8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5DEC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 828B5DF0: 394B0E68  addi r10, r11, 0xe68
	ctx.r[10].s64 = ctx.r[11].s64 + 3688;
	// 828B5DF4: ED8DF828  fsubs f12, f13, f31
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 828B5DF8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 828B5DFC: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828B5E00: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828B5E04: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 828B5E08: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 828B5E0C: 7D6A342E  lfsx f11, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B5E10: FFEB6FEE  fsel f31, f11, f31, f13
	ctx.f[31].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[13].f64 };
	// 828B5E14: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B5E18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B5E1C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828B5E20: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B5E24: 483F3638  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5E28 size=132
    let mut pc: u32 = 0x828B5E28;
    'dispatch: loop {
        match pc {
            0x828B5E28 => {
    //   block [0x828B5E28..0x828B5E58)
	// 828B5E28: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 828B5E2C: 41990080  bgt cr6, 0x828b5eac
	if ctx.cr[6].gt {
		sub_828B5EAC(ctx, base);
		return;
	}
	// 828B5E30: 3D80828B  lis r12, -0x7d75
	ctx.r[12].s64 = -2104819712;
	// 828B5E34: 398C5E48  addi r12, r12, 0x5e48
	ctx.r[12].s64 = ctx.r[12].s64 + 24136;
	// 828B5E38: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828B5E3C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828B5E40: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828B5E44: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x828B5E58; continue 'dispatch;
		},
		1 => {
	pc = 0x828B5E64; continue 'dispatch;
		},
		2 => {
	pc = 0x828B5E70; continue 'dispatch;
		},
		3 => {
	pc = 0x828B5E94; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 828B5E48: 828B5E58  lwz r20, 0x5e58(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24152 as u32) ) } as u64;
	// 828B5E4C: 828B5E64  lwz r20, 0x5e64(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24164 as u32) ) } as u64;
	// 828B5E50: 828B5E70  lwz r20, 0x5e70(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24176 as u32) ) } as u64;
	// 828B5E54: 828B5E94  lwz r20, 0x5e94(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24212 as u32) ) } as u64;
            }
            0x828B5E58 => {
    //   block [0x828B5E58..0x828B5E64)
	// 828B5E58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B5E5C: 386B0D7C  addi r3, r11, 0xd7c
	ctx.r[3].s64 = ctx.r[11].s64 + 3452;
	// 828B5E60: 4E800020  blr
	return;
            }
            0x828B5E64 => {
    //   block [0x828B5E64..0x828B5E70)
	// 828B5E64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B5E68: 386B115C  addi r3, r11, 0x115c
	ctx.r[3].s64 = ctx.r[11].s64 + 4444;
	// 828B5E6C: 4E800020  blr
	return;
            }
            0x828B5E70 => {
    //   block [0x828B5E70..0x828B5E94)
	// 828B5E70: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828B5E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5E78: 419A0010  beq cr6, 0x828b5e88
	if ctx.cr[6].eq {
	pc = 0x828B5E88; continue 'dispatch;
	}
	// 828B5E7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B5E80: 386BBCD0  addi r3, r11, -0x4330
	ctx.r[3].s64 = ctx.r[11].s64 + -17200;
	// 828B5E84: 4E800020  blr
	return;
	// 828B5E88: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5E8C: 386B2BFC  addi r3, r11, 0x2bfc
	ctx.r[3].s64 = ctx.r[11].s64 + 11260;
	// 828B5E90: 4E800020  blr
	return;
            }
            0x828B5E94 => {
    //   block [0x828B5E94..0x828B5EAC)
	// 828B5E94: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828B5E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5E9C: 409AFFE0  bne cr6, 0x828b5e7c
	if !ctx.cr[6].eq {
	pc = 0x828B5E7C; continue 'dispatch;
	}
	// 828B5EA0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5EA4: 386B2C08  addi r3, r11, 0x2c08
	ctx.r[3].s64 = ctx.r[11].s64 + 11272;
	// 828B5EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5EAC size=12
    let mut pc: u32 = 0x828B5EAC;
    'dispatch: loop {
        match pc {
            0x828B5EAC => {
    //   block [0x828B5EAC..0x828B5EB8)
	// 828B5EAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B5EB0: 386B0CA0  addi r3, r11, 0xca0
	ctx.r[3].s64 = ctx.r[11].s64 + 3232;
	// 828B5EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5EB8 size=888
    let mut pc: u32 = 0x828B5EB8;
    'dispatch: loop {
        match pc {
            0x828B5EB8 => {
    //   block [0x828B5EB8..0x828B6230)
	// 828B5EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5EBC: 483F3539  bl 0x82ca93f4
	ctx.lr = 0x828B5EC0;
	sub_82CA93D0(ctx, base);
	// 828B5EC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5EC4: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B5EC8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828B5ECC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B5ED0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828B5ED4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828B5ED8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 828B5EDC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 828B5EE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B5EE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B5EE8: 419A00E8  beq cr6, 0x828b5fd0
	if ctx.cr[6].eq {
	pc = 0x828B5FD0; continue 'dispatch;
	}
	// 828B5EEC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5EF4: 419A0020  beq cr6, 0x828b5f14
	if ctx.cr[6].eq {
	pc = 0x828B5F14; continue 'dispatch;
	}
	// 828B5EF8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B5EFC: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5F00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B5F04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B5F08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5F0C: 83A90004  lwz r29, 4(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5F10: 480000C4  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
	// 828B5F14: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5F18: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B5F1C: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 828B5F20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B5F24: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828B5F28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5F2C: 40810054  ble 0x828b5f80
	if !ctx.cr[0].gt {
	pc = 0x828B5F80; continue 'dispatch;
	}
	// 828B5F30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5F34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5F38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B5F3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5F40: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828B5F44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5F48: 41980008  blt cr6, 0x828b5f50
	if ctx.cr[6].lt {
	pc = 0x828B5F50; continue 'dispatch;
	}
	// 828B5F4C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828B5F50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5F54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5F58: 419A0014  beq cr6, 0x828b5f6c
	if ctx.cr[6].eq {
	pc = 0x828B5F6C; continue 'dispatch;
	}
	// 828B5F5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B5F60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5F64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5F68: 4800000C  b 0x828b5f74
	pc = 0x828B5F74; continue 'dispatch;
	// 828B5F6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B5F70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B5F74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5F78: 4199FFB8  bgt cr6, 0x828b5f30
	if ctx.cr[6].gt {
	pc = 0x828B5F30; continue 'dispatch;
	}
	// 828B5F7C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828B5F80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5F84: 419A003C  beq cr6, 0x828b5fc0
	if ctx.cr[6].eq {
	pc = 0x828B5FC0; continue 'dispatch;
	}
	// 828B5F88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5F8C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828B5F90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5F94: 41990008  bgt cr6, 0x828b5f9c
	if ctx.cr[6].gt {
	pc = 0x828B5F9C; continue 'dispatch;
	}
	// 828B5F98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828B5F9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5FA4: 409A001C  bne cr6, 0x828b5fc0
	if !ctx.cr[6].eq {
	pc = 0x828B5FC0; continue 'dispatch;
	}
	// 828B5FA8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B5FAC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828B5FB0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5FB4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5FB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5FBC: 48000018  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
	// 828B5FC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B5FC4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5FC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5FCC: 48000008  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
	// 828B5FD0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828B5FD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5FDC: 419A0248  beq cr6, 0x828b6224
	if ctx.cr[6].eq {
	pc = 0x828B6224; continue 'dispatch;
	}
	// 828B5FE0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5FE4: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828B5FE8: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828B5FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B5FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5FF4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B5FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B5FFC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B6000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B6004: 4082FFE8  bne 0x828b5fec
	if !ctx.cr[0].eq {
	pc = 0x828B5FEC; continue 'dispatch;
	}
	// 828B6008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B600C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828B6010: 3B8BEF80  addi r28, r11, -0x1080
	ctx.r[28].s64 = ctx.r[11].s64 + -4224;
	// 828B6014: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 828B6018: 3B6AEF7C  addi r27, r10, -0x1084
	ctx.r[27].s64 = ctx.r[10].s64 + -4228;
	// 828B601C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828B6020: 419A0008  beq cr6, 0x828b6028
	if ctx.cr[6].eq {
	pc = 0x828B6028; continue 'dispatch;
	}
	// 828B6024: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B6028: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B602C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B6030: 4BFFFDF9  bl 0x828b5e28
	ctx.lr = 0x828B6034;
	sub_828B5E28(ctx, base);
	// 828B6034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6038: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B603C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6040: 4B93A201  bl 0x821f0240
	ctx.lr = 0x828B6044;
	sub_821F0240(ctx, base);
	// 828B6044: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6048: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B604C: 4B924975  bl 0x821da9c0
	ctx.lr = 0x828B6050;
	sub_821DA9C0(ctx, base);
	// 828B6050: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B6058: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B605C: 4B976E75  bl 0x8222ced0
	ctx.lr = 0x828B6060;
	sub_8222CED0(ctx, base);
	// 828B6060: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B6064: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6068: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B606C: 4B92D09D  bl 0x821e3108
	ctx.lr = 0x828B6070;
	sub_821E3108(ctx, base);
	// 828B6070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6078: 4B9AF129  bl 0x822651a0
	ctx.lr = 0x828B607C;
	sub_822651A0(ctx, base);
	// 828B607C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6080: 4B95ED59  bl 0x82214dd8
	ctx.lr = 0x828B6084;
	sub_82214DD8(ctx, base);
	// 828B6084: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6088: 4B95ED51  bl 0x82214dd8
	ctx.lr = 0x828B608C;
	sub_82214DD8(ctx, base);
	// 828B608C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6090: 4B95ED49  bl 0x82214dd8
	ctx.lr = 0x828B6094;
	sub_82214DD8(ctx, base);
	// 828B6094: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6098: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B609C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B60A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B60A4: 4B9231CD  bl 0x821d9270
	ctx.lr = 0x828B60A8;
	sub_821D9270(ctx, base);
	// 828B60A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B60AC: 419A0024  beq cr6, 0x828b60d0
	if ctx.cr[6].eq {
	pc = 0x828B60D0; continue 'dispatch;
	}
	// 828B60B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B60B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828B60B8: 4B9AF0E9  bl 0x822651a0
	ctx.lr = 0x828B60BC;
	sub_822651A0(ctx, base);
	// 828B60BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B60C0: 4B95ED19  bl 0x82214dd8
	ctx.lr = 0x828B60C4;
	sub_82214DD8(ctx, base);
	// 828B60C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B60C8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828B60CC: 483F3378  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828B60D0: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 828B60D4: 419A0008  beq cr6, 0x828b60dc
	if ctx.cr[6].eq {
	pc = 0x828B60DC; continue 'dispatch;
	}
	// 828B60D8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 828B60DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B60E0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B60E4: 4BFFFD45  bl 0x828b5e28
	ctx.lr = 0x828B60E8;
	sub_828B5E28(ctx, base);
	// 828B60E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B60EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B60F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B60F4: 4B93A14D  bl 0x821f0240
	ctx.lr = 0x828B60F8;
	sub_821F0240(ctx, base);
	// 828B60F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B60FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6100: 4B9248C1  bl 0x821da9c0
	ctx.lr = 0x828B6104;
	sub_821DA9C0(ctx, base);
	// 828B6104: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6108: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B610C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6110: 4B976DC1  bl 0x8222ced0
	ctx.lr = 0x828B6114;
	sub_8222CED0(ctx, base);
	// 828B6114: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B6118: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B611C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6120: 4B92CFE9  bl 0x821e3108
	ctx.lr = 0x828B6124;
	sub_821E3108(ctx, base);
	// 828B6124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B612C: 4B9AF075  bl 0x822651a0
	ctx.lr = 0x828B6130;
	sub_822651A0(ctx, base);
	// 828B6130: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6134: 4B95ECA5  bl 0x82214dd8
	ctx.lr = 0x828B6138;
	sub_82214DD8(ctx, base);
	// 828B6138: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B613C: 4B95EC9D  bl 0x82214dd8
	ctx.lr = 0x828B6140;
	sub_82214DD8(ctx, base);
	// 828B6140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6144: 4B95EC95  bl 0x82214dd8
	ctx.lr = 0x828B6148;
	sub_82214DD8(ctx, base);
	// 828B6148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B614C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6158: 4B923119  bl 0x821d9270
	ctx.lr = 0x828B615C;
	sub_821D9270(ctx, base);
	// 828B615C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B6160: 409AFF50  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B6164: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B6168: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B616C: 4B93A0D5  bl 0x821f0240
	ctx.lr = 0x828B6170;
	sub_821F0240(ctx, base);
	// 828B6170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6174: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6178: 4B924849  bl 0x821da9c0
	ctx.lr = 0x828B617C;
	sub_821DA9C0(ctx, base);
	// 828B617C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6184: 4B9AF01D  bl 0x822651a0
	ctx.lr = 0x828B6188;
	sub_822651A0(ctx, base);
	// 828B6188: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B618C: 4B95EC4D  bl 0x82214dd8
	ctx.lr = 0x828B6190;
	sub_82214DD8(ctx, base);
	// 828B6190: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6198: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B619C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B61A0: 4B9230D1  bl 0x821d9270
	ctx.lr = 0x828B61A4;
	sub_821D9270(ctx, base);
	// 828B61A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B61A8: 409AFF08  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B61AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B61B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61B4: 4B93A08D  bl 0x821f0240
	ctx.lr = 0x828B61B8;
	sub_821F0240(ctx, base);
	// 828B61B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B61BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61C0: 4B924801  bl 0x821da9c0
	ctx.lr = 0x828B61C4;
	sub_821DA9C0(ctx, base);
	// 828B61C4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B61C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B61CC: 4B9AEFD5  bl 0x822651a0
	ctx.lr = 0x828B61D0;
	sub_822651A0(ctx, base);
	// 828B61D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61D4: 4B95EC05  bl 0x82214dd8
	ctx.lr = 0x828B61D8;
	sub_82214DD8(ctx, base);
	// 828B61D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B61DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B61E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B61E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B61E8: 4B923089  bl 0x821d9270
	ctx.lr = 0x828B61EC;
	sub_821D9270(ctx, base);
	// 828B61EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B61F0: 409AFEC0  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B61F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B61F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B61FC: 4B9AEFA5  bl 0x822651a0
	ctx.lr = 0x828B6200;
	sub_822651A0(ctx, base);
	// 828B6200: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6204: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B620C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6210: 4B923061  bl 0x821d9270
	ctx.lr = 0x828B6214;
	sub_821D9270(ctx, base);
	// 828B6214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B6218: 409AFE98  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B621C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6220: 4B95EBB9  bl 0x82214dd8
	ctx.lr = 0x828B6224;
	sub_82214DD8(ctx, base);
	// 828B6224: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B6228: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828B622C: 483F3218  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B6230 size=2352
    let mut pc: u32 = 0x828B6230;
    'dispatch: loop {
        match pc {
            0x828B6230 => {
    //   block [0x828B6230..0x828B6B60)
	// 828B6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6234: 483F31C5  bl 0x82ca93f8
	ctx.lr = 0x828B6238;
	sub_82CA93D0(ctx, base);
	// 828B6238: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 828B623C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828B6240: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B6B60 size=560
    let mut pc: u32 = 0x828B6B60;
    'dispatch: loop {
        match pc {
            0x828B6B60 => {
    //   block [0x828B6B60..0x828B6D90)
	// 828B6B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6B64: 483F28A9  bl 0x82ca940c
	ctx.lr = 0x828B6B68;
	sub_82CA93D0(ctx, base);
	// 828B6B68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B6B70: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 828B6B74: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B6B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6B7C: 419A0020  beq cr6, 0x828b6b9c
	if ctx.cr[6].eq {
	pc = 0x828B6B9C; continue 'dispatch;
	}
	// 828B6B80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6B88: 419A000C  beq cr6, 0x828b6b94
	if ctx.cr[6].eq {
	pc = 0x828B6B94; continue 'dispatch;
	}
	// 828B6B8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B6B90: 48000010  b 0x828b6ba0
	pc = 0x828B6BA0; continue 'dispatch;
	// 828B6B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6B98: 4B8DD2A1  bl 0x82193e38
	ctx.lr = 0x828B6B9C;
	sub_82193E38(ctx, base);
	// 828B6B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6BA0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828B6BA4: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828B6BA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B6BAC: 419A00EC  beq cr6, 0x828b6c98
	if ctx.cr[6].eq {
	pc = 0x828B6C98; continue 'dispatch;
	}
	// 828B6BB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B6BB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6BB8: 419A0020  beq cr6, 0x828b6bd8
	if ctx.cr[6].eq {
	pc = 0x828B6BD8; continue 'dispatch;
	}
	// 828B6BBC: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 828B6BC0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B6BC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B6BC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B6BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6BD0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6BD4: 480000CC  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
	// 828B6BD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B6BDC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B6BE0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B6BE4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828B6BE8: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B6BEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B6BF0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6BF4: 40810054  ble 0x828b6c48
	if !ctx.cr[0].gt {
	pc = 0x828B6C48; continue 'dispatch;
	}
	// 828B6BF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B6BFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B6C00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B6C04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C08: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828B6C0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B6C10: 41980008  blt cr6, 0x828b6c18
	if ctx.cr[6].lt {
	pc = 0x828B6C18; continue 'dispatch;
	}
	// 828B6C14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B6C18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B6C1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B6C20: 419A0014  beq cr6, 0x828b6c34
	if ctx.cr[6].eq {
	pc = 0x828B6C34; continue 'dispatch;
	}
	// 828B6C24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B6C28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B6C2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B6C30: 4800000C  b 0x828b6c3c
	pc = 0x828B6C3C; continue 'dispatch;
	// 828B6C34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B6C38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B6C3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6C40: 4199FFB8  bgt cr6, 0x828b6bf8
	if ctx.cr[6].gt {
	pc = 0x828B6BF8; continue 'dispatch;
	}
	// 828B6C44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B6C48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B6C4C: 419A003C  beq cr6, 0x828b6c88
	if ctx.cr[6].eq {
	pc = 0x828B6C88; continue 'dispatch;
	}
	// 828B6C50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C54: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828B6C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B6C5C: 41990008  bgt cr6, 0x828b6c64
	if ctx.cr[6].gt {
	pc = 0x828B6C64; continue 'dispatch;
	}
	// 828B6C60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6C64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B6C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6C6C: 409A001C  bne cr6, 0x828b6c88
	if !ctx.cr[6].eq {
	pc = 0x828B6C88; continue 'dispatch;
	}
	// 828B6C70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B6C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6C78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B6C7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B6C80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6C84: 4800001C  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
	// 828B6C88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B6C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6C90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6C94: 4800000C  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
	// 828B6C98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B6C9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B6CA0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B6CA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6CA8: 419A0014  beq cr6, 0x828b6cbc
	if ctx.cr[6].eq {
	pc = 0x828B6CBC; continue 'dispatch;
	}
	// 828B6CAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828B6CB0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B6CB4: C02AB478  lfs f1, -0x4b88(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B6CB8: 4B9FCFF9  bl 0x822b3cb0
	ctx.lr = 0x828B6CBC;
	sub_822B3CB0(ctx, base);
	// 828B6CBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6CC4: 419A0020  beq cr6, 0x828b6ce4
	if ctx.cr[6].eq {
	pc = 0x828B6CE4; continue 'dispatch;
	}
	// 828B6CC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6CD0: 419A000C  beq cr6, 0x828b6cdc
	if ctx.cr[6].eq {
	pc = 0x828B6CDC; continue 'dispatch;
	}
	// 828B6CD4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B6CD8: 48000010  b 0x828b6ce8
	pc = 0x828B6CE8; continue 'dispatch;
	// 828B6CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6CE0: 4B8DD159  bl 0x82193e38
	ctx.lr = 0x828B6CE4;
	sub_82193E38(ctx, base);
	// 828B6CE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6CE8: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B6CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6CF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CF8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B6CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B6D00: 4E800421  bctrl
	ctx.lr = 0x828B6D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B6D04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6D0C: 409A0044  bne cr6, 0x828b6d50
	if !ctx.cr[6].eq {
	pc = 0x828B6D50; continue 'dispatch;
	}
	// 828B6D10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B6D14: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828B6D18: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 828B6D1C: 3969936C  addi r11, r9, -0x6c94
	ctx.r[11].s64 = ctx.r[9].s64 + -27796;
	// 828B6D20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B6D2C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828B6D30: 419A0014  beq cr6, 0x828b6d44
	if ctx.cr[6].eq {
	pc = 0x828B6D44; continue 'dispatch;
	}
	// 828B6D34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B6D38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B6D3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B6D40: 419AFFE0  beq cr6, 0x828b6d20
	if ctx.cr[6].eq {
	pc = 0x828B6D20; continue 'dispatch;
	}
	// 828B6D44: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828B6D48: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828B6D4C: 4800001C  b 0x828b6d68
	pc = 0x828B6D68; continue 'dispatch;
	// 828B6D50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828B6D54: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D58: 388A936C  addi r4, r10, -0x6c94
	ctx.r[4].s64 = ctx.r[10].s64 + -27796;
	// 828B6D5C: 4B9B6A9D  bl 0x8226d7f8
	ctx.lr = 0x828B6D60;
	sub_8226D7F8(ctx, base);
	// 828B6D60: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828B6D64: 553FDFFE  rlwinm r31, r9, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828B6D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D6C: 4B95E06D  bl 0x82214dd8
	ctx.lr = 0x828B6D70;
	sub_82214DD8(ctx, base);
	// 828B6D70: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828B6D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6D78: 419A0010  beq cr6, 0x828b6d88
	if ctx.cr[6].eq {
	pc = 0x828B6D88; continue 'dispatch;
	}
	// 828B6D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6D80: 889D0164  lbz r4, 0x164(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 828B6D84: 4B9E7CBD  bl 0x8229ea40
	ctx.lr = 0x828B6D88;
	sub_8229EA40(ctx, base);
	// 828B6D88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B6D8C: 483F26D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B6D90 size=424
    let mut pc: u32 = 0x828B6D90;
    'dispatch: loop {
        match pc {
            0x828B6D90 => {
    //   block [0x828B6D90..0x828B6F38)
	// 828B6D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B6D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B6D9C: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6F38 size=160
    let mut pc: u32 = 0x828B6F38;
    'dispatch: loop {
        match pc {
            0x828B6F38 => {
    //   block [0x828B6F38..0x828B6FD8)
	// 828B6F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6F3C: 483F24D1  bl 0x82ca940c
	ctx.lr = 0x828B6F40;
	sub_82CA93D0(ctx, base);
	// 828B6F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6F44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B6F48: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828B6F4C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B6F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6F54: 4BF94945  bl 0x8284b898
	ctx.lr = 0x828B6F58;
	sub_8284B898(ctx, base);
	// 828B6F58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B6F5C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 828B6F60: 394B5028  addi r10, r11, 0x5028
	ctx.r[10].s64 = ctx.r[11].s64 + 20520;
	// 828B6F64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6F68: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B6F6C: 4BD10235  bl 0x825c71a0
	ctx.lr = 0x828B6F70;
	sub_825C71A0(ctx, base);
	// 828B6F70: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B6F74: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 828B6F78: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6F7C: 38892BF4  addi r4, r9, 0x2bf4
	ctx.r[4].s64 = ctx.r[9].s64 + 11252;
	// 828B6F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6F84: 4B975F4D  bl 0x8222ced0
	ctx.lr = 0x828B6F88;
	sub_8222CED0(ctx, base);
	// 828B6F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6F8C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828B6F90: 997F0164  stb r11, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 828B6F94: 3BBF0140  addi r29, r31, 0x140
	ctx.r[29].s64 = ctx.r[31].s64 + 320;
	// 828B6F98: 997F0165  stb r11, 0x165(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(357 as u32), ctx.r[11].u8 ) };
	// 828B6F9C: 38880CA0  addi r4, r8, 0xca0
	ctx.r[4].s64 = ctx.r[8].s64 + 3232;
	// 828B6FA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6FA4: 4B9E4215  bl 0x8229b1b8
	ctx.lr = 0x828B6FA8;
	sub_8229B1B8(ctx, base);
	// 828B6FA8: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B6FAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B6FB0: 419A0010  beq cr6, 0x828b6fc0
	if ctx.cr[6].eq {
	pc = 0x828B6FC0; continue 'dispatch;
	}
	// 828B6FB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B6FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6FBC: 4B9AE1E5  bl 0x822651a0
	ctx.lr = 0x828B6FC0;
	sub_822651A0(ctx, base);
	// 828B6FC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B6FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6FC8: 394B5770  addi r10, r11, 0x5770
	ctx.r[10].s64 = ctx.r[11].s64 + 22384;
	// 828B6FCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B6FD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B6FD4: 483F2488  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6FD8 size=56
    let mut pc: u32 = 0x828B6FD8;
    'dispatch: loop {
        match pc {
            0x828B6FD8 => {
    //   block [0x828B6FD8..0x828B7010)
	// 828B6FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B6FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B6FE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6FEC: 4BFFF245  bl 0x828b6230
	ctx.lr = 0x828B6FF0;
	sub_828B6230(ctx, base);
	// 828B6FF0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828B6FF4: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 828B6FF8: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 828B6FFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B700C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7010 size=1400
    let mut pc: u32 = 0x828B7010;
    'dispatch: loop {
        match pc {
            0x828B7010 => {
    //   block [0x828B7010..0x828B7588)
	// 828B7010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7014: 483F23F9  bl 0x82ca940c
	ctx.lr = 0x828B7018;
	sub_82CA93D0(ctx, base);
	// 828B7018: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B701C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7020: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B7024: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828B7028: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B702C: 386B2090  addi r3, r11, 0x2090
	ctx.r[3].s64 = ctx.r[11].s64 + 8336;
	// 828B7030: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828B7034: 4B93CD25  bl 0x821f3d58
	ctx.lr = 0x828B7038;
	sub_821F3D58(ctx, base);
	// 828B7038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B703C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B7040: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7044: 4B92336D  bl 0x821da3b0
	ctx.lr = 0x828B7048;
	sub_821DA3B0(ctx, base);
	// 828B7048: 4B8FB4B1  bl 0x821b24f8
	ctx.lr = 0x828B704C;
	sub_821B24F8(ctx, base);
	// 828B704C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B7050: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B7054: 48149675  bl 0x82a006c8
	ctx.lr = 0x828B7058;
	sub_82A006C8(ctx, base);
	// 828B7058: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B705C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B7060: 419A000C  beq cr6, 0x828b706c
	if ctx.cr[6].eq {
	pc = 0x828B706C; continue 'dispatch;
	}
	// 828B7064: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7068: 48000008  b 0x828b7070
	pc = 0x828B7070; continue 'dispatch;
	// 828B706C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B7070: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B7074: 419A0398  beq cr6, 0x828b740c
	if ctx.cr[6].eq {
	pc = 0x828B740C; continue 'dispatch;
	}
	// 828B7078: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B707C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B7080: 388B2C28  addi r4, r11, 0x2c28
	ctx.r[4].s64 = ctx.r[11].s64 + 11304;
	// 828B7084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7088: 4B975E49  bl 0x8222ced0
	ctx.lr = 0x828B708C;
	sub_8222CED0(ctx, base);
	// 828B708C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7094: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B7098: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B709C: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B70A0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B70A4: 4E800421  bctrl
	ctx.lr = 0x828B70A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B70A8: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 828B70AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B70B0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828B70B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B70B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B70BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B70C0: 81646AB8  lwz r11, 0x6ab8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B70C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7588 size=136
    let mut pc: u32 = 0x828B7588;
    'dispatch: loop {
        match pc {
            0x828B7588 => {
    //   block [0x828B7588..0x828B7610)
	// 828B7588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B758C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B759C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B75A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B75A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75A8: 419A0034  beq cr6, 0x828b75dc
	if ctx.cr[6].eq {
	pc = 0x828B75DC; continue 'dispatch;
	}
	// 828B75AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B75B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B75B4: 419A0054  beq cr6, 0x828b7608
	if ctx.cr[6].eq {
	pc = 0x828B7608; continue 'dispatch;
	}
	// 828B75B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B75BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75C0: 419A001C  beq cr6, 0x828b75dc
	if ctx.cr[6].eq {
	pc = 0x828B75DC; continue 'dispatch;
	}
	// 828B75C4: 4B8BC875  bl 0x82173e38
	ctx.lr = 0x828B75C8;
	sub_82173E38(ctx, base);
	// 828B75C8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B75CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B75D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B75D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B75D8: 409A0008  bne cr6, 0x828b75e0
	if !ctx.cr[6].eq {
	pc = 0x828B75E0; continue 'dispatch;
	}
	// 828B75DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B75E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B75E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75E8: 409A000C  bne cr6, 0x828b75f4
	if !ctx.cr[6].eq {
	pc = 0x828B75F4; continue 'dispatch;
	}
	// 828B75EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B75F0: 48000331  bl 0x828b7920
	ctx.lr = 0x828B75F4;
	sub_828B7920(ctx, base);
	// 828B75F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B75F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B75FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7604: 4E800020  blr
	return;
	// 828B7608: 4B8DC831  bl 0x82193e38
	ctx.lr = 0x828B760C;
	sub_82193E38(ctx, base);
	// 828B760C: 4BFFFFD0  b 0x828b75dc
	pc = 0x828B75DC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7610 size=784
    let mut pc: u32 = 0x828B7610;
    'dispatch: loop {
        match pc {
            0x828B7610 => {
    //   block [0x828B7610..0x828B7920)
	// 828B7610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7614: 483F1DF5  bl 0x82ca9408
	ctx.lr = 0x828B7618;
	sub_82CA93D0(ctx, base);
	// 828B7618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B761C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B7620: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B7624: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 828B7628: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B762C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7630: 419A0038  beq cr6, 0x828b7668
	if ctx.cr[6].eq {
	pc = 0x828B7668; continue 'dispatch;
	}
	// 828B7634: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B763C: 419A0080  beq cr6, 0x828b76bc
	if ctx.cr[6].eq {
	pc = 0x828B76BC; continue 'dispatch;
	}
	// 828B7640: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B7644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7648: 419A0020  beq cr6, 0x828b7668
	if ctx.cr[6].eq {
	pc = 0x828B7668; continue 'dispatch;
	}
	// 828B764C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7650: 4B8BC7E9  bl 0x82173e38
	ctx.lr = 0x828B7654;
	sub_82173E38(ctx, base);
	// 828B7654: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7658: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B765C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7664: 409A0008  bne cr6, 0x828b766c
	if !ctx.cr[6].eq {
	pc = 0x828B766C; continue 'dispatch;
	}
	// 828B7668: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828B766C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7674: 419A0188  beq cr6, 0x828b77fc
	if ctx.cr[6].eq {
	pc = 0x828B77FC; continue 'dispatch;
	}
	// 828B7678: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B767C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828B7680: 386B2C40  addi r3, r11, 0x2c40
	ctx.r[3].s64 = ctx.r[11].s64 + 11328;
	// 828B7684: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828B7688: 4B93C6D1  bl 0x821f3d58
	ctx.lr = 0x828B768C;
	sub_821F3D58(ctx, base);
	// 828B768C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B7694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7698: 4B922D19  bl 0x821da3b0
	ctx.lr = 0x828B769C;
	sub_821DA3B0(ctx, base);
	// 828B769C: 4B8FAE5D  bl 0x821b24f8
	ctx.lr = 0x828B76A0;
	sub_821B24F8(ctx, base);
	// 828B76A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B76A4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B76A8: 48149021  bl 0x82a006c8
	ctx.lr = 0x828B76AC;
	sub_82A006C8(ctx, base);
	// 828B76AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B76B0: 419A0018  beq cr6, 0x828b76c8
	if ctx.cr[6].eq {
	pc = 0x828B76C8; continue 'dispatch;
	}
	// 828B76B4: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B76B8: 48000014  b 0x828b76cc
	pc = 0x828B76CC; continue 'dispatch;
	// 828B76BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B76C0: 4B8DC779  bl 0x82193e38
	ctx.lr = 0x828B76C4;
	sub_82193E38(ctx, base);
	// 828B76C4: 4BFFFFA4  b 0x828b7668
	pc = 0x828B7668; continue 'dispatch;
	// 828B76C8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828B76CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B76D0: 419A00E8  beq cr6, 0x828b77b8
	if ctx.cr[6].eq {
	pc = 0x828B77B8; continue 'dispatch;
	}
	// 828B76D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B76D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B76DC: 388B2C50  addi r4, r11, 0x2c50
	ctx.r[4].s64 = ctx.r[11].s64 + 11344;
	// 828B76E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B76E4: 4B9757ED  bl 0x8222ced0
	ctx.lr = 0x828B76E8;
	sub_8222CED0(ctx, base);
	// 828B76E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B76EC: 4B8BC74D  bl 0x82173e38
	ctx.lr = 0x828B76F0;
	sub_82173E38(ctx, base);
	// 828B76F0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828B76F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B76F8: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B76FC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7700: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B7704: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B7708: 4E800421  bctrl
	ctx.lr = 0x828B770C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B770C: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 828B7710: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B7714: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828B7718: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B771C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B7720: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B7724: 81646AB8  lwz r11, 0x6ab8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B7728: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B7920 size=640
    let mut pc: u32 = 0x828B7920;
    'dispatch: loop {
        match pc {
            0x828B7920 => {
    //   block [0x828B7920..0x828B7BA0)
	// 828B7920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B792C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7934: 388000DF  li r4, 0xdf
	ctx.r[4].s64 = 223;
	// 828B7938: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B793C: 4BAD523D  bl 0x8238cb78
	ctx.lr = 0x828B7940;
	sub_8238CB78(ctx, base);
	// 828B7940: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7944: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B7948: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B794C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B7950: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828B7954: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7958: 419A00F4  beq cr6, 0x828b7a4c
	if ctx.cr[6].eq {
	pc = 0x828B7A4C; continue 'dispatch;
	}
	// 828B795C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7964: 419A0024  beq cr6, 0x828b7988
	if ctx.cr[6].eq {
	pc = 0x828B7988; continue 'dispatch;
	}
	// 828B7968: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B796C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7970: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B7974: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B7978: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B797C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7984: 480000CC  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
	// 828B7988: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B798C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7990: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828B7994: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828B7998: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B799C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B79A0: 40810054  ble 0x828b79f4
	if !ctx.cr[0].gt {
	pc = 0x828B79F4; continue 'dispatch;
	}
	// 828B79A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B79A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B79AC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B79B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B79B4: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828B79B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B79BC: 41980008  blt cr6, 0x828b79c4
	if ctx.cr[6].lt {
	pc = 0x828B79C4; continue 'dispatch;
	}
	// 828B79C0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828B79C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B79C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B79CC: 419A0014  beq cr6, 0x828b79e0
	if ctx.cr[6].eq {
	pc = 0x828B79E0; continue 'dispatch;
	}
	// 828B79D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B79D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B79D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B79DC: 4800000C  b 0x828b79e8
	pc = 0x828B79E8; continue 'dispatch;
	// 828B79E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B79E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B79E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B79EC: 4199FFB8  bgt cr6, 0x828b79a4
	if ctx.cr[6].gt {
	pc = 0x828B79A4; continue 'dispatch;
	}
	// 828B79F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B79F4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828B79F8: 419A0040  beq cr6, 0x828b7a38
	if ctx.cr[6].eq {
	pc = 0x828B7A38; continue 'dispatch;
	}
	// 828B79FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7A00: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828B7A04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A08: 41990008  bgt cr6, 0x828b7a10
	if ctx.cr[6].gt {
	pc = 0x828B7A10; continue 'dispatch;
	}
	// 828B7A0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828B7A10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A18: 409A0020  bne cr6, 0x828b7a38
	if !ctx.cr[6].eq {
	pc = 0x828B7A38; continue 'dispatch;
	}
	// 828B7A1C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B7A20: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B7A24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B7A28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7A30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A34: 4800001C  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
	// 828B7A38: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828B7A3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A40: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7A44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A48: 48000008  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
	// 828B7A4C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828B7A50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A58: 419A0134  beq cr6, 0x828b7b8c
	if ctx.cr[6].eq {
	pc = 0x828B7B8C; continue 'dispatch;
	}
	// 828B7A5C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B7A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A64: 419A0128  beq cr6, 0x828b7b8c
	if ctx.cr[6].eq {
	pc = 0x828B7B8C; continue 'dispatch;
	}
	// 828B7A68: 81460028  lwz r10, 0x28(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B7A6C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828B7A70: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 828B7A74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7A78: 419A00E4  beq cr6, 0x828b7b5c
	if ctx.cr[6].eq {
	pc = 0x828B7B5C; continue 'dispatch;
	}
	// 828B7A7C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7A80: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A88: 419A001C  beq cr6, 0x828b7aa4
	if ctx.cr[6].eq {
	pc = 0x828B7AA4; continue 'dispatch;
	}
	// 828B7A8C: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B7A90: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B7A94: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B7A98: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7AA0: 480000C0  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
	// 828B7AA4: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7AA8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828B7AAC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B7AB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B7AB4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7AB8: 40810054  ble 0x828b7b0c
	if !ctx.cr[0].gt {
	pc = 0x828B7B0C; continue 'dispatch;
	}
	// 828B7ABC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B7AC0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B7AC4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B7AC8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7ACC: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 828B7AD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B7AD4: 41980008  blt cr6, 0x828b7adc
	if ctx.cr[6].lt {
	pc = 0x828B7ADC; continue 'dispatch;
	}
	// 828B7AD8: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828B7ADC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B7AE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B7AE4: 419A0014  beq cr6, 0x828b7af8
	if ctx.cr[6].eq {
	pc = 0x828B7AF8; continue 'dispatch;
	}
	// 828B7AE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B7AEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B7AF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B7AF4: 4800000C  b 0x828b7b00
	pc = 0x828B7B00; continue 'dispatch;
	// 828B7AF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B7AFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B7B00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7B04: 4199FFB8  bgt cr6, 0x828b7abc
	if ctx.cr[6].gt {
	pc = 0x828B7ABC; continue 'dispatch;
	}
	// 828B7B08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B7B0C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B7B10: 419A003C  beq cr6, 0x828b7b4c
	if ctx.cr[6].eq {
	pc = 0x828B7B4C; continue 'dispatch;
	}
	// 828B7B14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7B18: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 828B7B1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7B20: 41990008  bgt cr6, 0x828b7b28
	if ctx.cr[6].gt {
	pc = 0x828B7B28; continue 'dispatch;
	}
	// 828B7B24: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828B7B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7B30: 409A001C  bne cr6, 0x828b7b4c
	if !ctx.cr[6].eq {
	pc = 0x828B7B4C; continue 'dispatch;
	}
	// 828B7B34: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B7B38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7B3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B7B40: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B7B44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7B48: 48000018  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
	// 828B7B4C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B7B50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7B54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7B58: 48000008  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
	// 828B7B5C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 828B7B60: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B7B64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7B68: 419A0018  beq cr6, 0x828b7b80
	if ctx.cr[6].eq {
	pc = 0x828B7B80; continue 'dispatch;
	}
	// 828B7B6C: C00B001C  lfs f0, 0x1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7B70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B7B74: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B7B78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B7B7C: 4BC166FD  bl 0x824ce278
	ctx.lr = 0x828B7B80;
	sub_824CE278(ctx, base);
	// 828B7B80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B7B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7B88: 4BAEFD41  bl 0x823a78c8
	ctx.lr = 0x828B7B8C;
	sub_823A78C8(ctx, base);
	// 828B7B8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B7B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7BA0 size=80
    let mut pc: u32 = 0x828B7BA0;
    'dispatch: loop {
        match pc {
            0x828B7BA0 => {
    //   block [0x828B7BA0..0x828B7BF0)
	// 828B7BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7BAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7BB0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7BB8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B7BBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7BC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B7BC4: 4E800421  bctrl
	ctx.lr = 0x828B7BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7BC8: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 828B7BCC: 409A0010  bne cr6, 0x828b7bdc
	if !ctx.cr[6].eq {
	pc = 0x828B7BDC; continue 'dispatch;
	}
	// 828B7BD0: 388000DF  li r4, 0xdf
	ctx.r[4].s64 = 223;
	// 828B7BD4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7BD8: 4BAD4FA1  bl 0x8238cb78
	ctx.lr = 0x828B7BDC;
	sub_8238CB78(ctx, base);
	// 828B7BDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7BE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7BEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7BF0 size=584
    let mut pc: u32 = 0x828B7BF0;
    'dispatch: loop {
        match pc {
            0x828B7BF0 => {
    //   block [0x828B7BF0..0x828B7E38)
	// 828B7BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7BF4: 483F180D  bl 0x82ca9400
	ctx.lr = 0x828B7BF8;
	sub_82CA93D0(ctx, base);
	// 828B7BF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7BFC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B7C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7C08: 409A0010  bne cr6, 0x828b7c18
	if !ctx.cr[6].eq {
	pc = 0x828B7C18; continue 'dispatch;
	}
	// 828B7C0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B7C10: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828B7C14: 48000008  b 0x828b7c1c
	pc = 0x828B7C1C; continue 'dispatch;
	// 828B7C18: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C1C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7C24: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C28: 4BB16999  bl 0x823ce5c0
	ctx.lr = 0x828B7C2C;
	sub_823CE5C0(ctx, base);
	// 828B7C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7C34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7C38: 4BB165C9  bl 0x823ce200
	ctx.lr = 0x828B7C3C;
	sub_823CE200(ctx, base);
	// 828B7C3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7C40: 4B8FFED9  bl 0x821b7b18
	ctx.lr = 0x828B7C44;
	sub_821B7B18(ctx, base);
	// 828B7C44: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B7C48: 4B967611  bl 0x8221f258
	ctx.lr = 0x828B7C4C;
	sub_8221F258(ctx, base);
	// 828B7C4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B7C50: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B7C54: 419A0040  beq cr6, 0x828b7c94
	if ctx.cr[6].eq {
	pc = 0x828B7C94; continue 'dispatch;
	}
	// 828B7C58: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828B7C5C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B7C60: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828B7C64: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B7C68: 4B9675F1  bl 0x8221f258
	ctx.lr = 0x828B7C6C;
	sub_8221F258(ctx, base);
	// 828B7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B7C70: 419A0028  beq cr6, 0x828b7c98
	if ctx.cr[6].eq {
	pc = 0x828B7C98; continue 'dispatch;
	}
	// 828B7C74: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B7C78: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B7C7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7C80: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B7C84: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B7C88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B7C8C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B7C90: 4800000C  b 0x828b7c9c
	pc = 0x828B7C9C; continue 'dispatch;
	// 828B7C94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B7C98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B7C9C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B7CA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B7CA4: 419A00FC  beq cr6, 0x828b7da0
	if ctx.cr[6].eq {
	pc = 0x828B7DA0; continue 'dispatch;
	}
	// 828B7CA8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7CAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B7CB0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7CB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CB8: 4B971451  bl 0x82229108
	ctx.lr = 0x828B7CBC;
	sub_82229108(ctx, base);
	// 828B7CBC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7CC0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B7CC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CC8: 3BCB7E38  addi r30, r11, 0x7e38
	ctx.r[30].s64 = ctx.r[11].s64 + 32312;
	// 828B7CCC: 4B96FBB5  bl 0x82227880
	ctx.lr = 0x828B7CD0;
	sub_82227880(ctx, base);
	// 828B7CD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B7CD4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828B7CD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B7CDC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828B7CE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CE4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B7CE8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B7CEC: 4B8E2D95  bl 0x8219aa80
	ctx.lr = 0x828B7CF0;
	sub_8219AA80(ctx, base);
	// 828B7CF0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828B7CF4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B7CF8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828B7CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7D00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B7D04: 4BB1671D  bl 0x823ce420
	ctx.lr = 0x828B7D08;
	sub_823CE420(ctx, base);
	// 828B7D08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B7D0C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B7D10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7D14: 4816C9B5  bl 0x82a246c8
	ctx.lr = 0x828B7D18;
	sub_82A246C8(ctx, base);
	// 828B7D18: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7D1C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B7D20: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828B7D24: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828B7D28: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7D2C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D34: 4B9713D5  bl 0x82229108
	ctx.lr = 0x828B7D38;
	sub_82229108(ctx, base);
	// 828B7D38: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7D3C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B7D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D44: 3BEB7E78  addi r31, r11, 0x7e78
	ctx.r[31].s64 = ctx.r[11].s64 + 32376;
	// 828B7D48: 4B96FB39  bl 0x82227880
	ctx.lr = 0x828B7D4C;
	sub_82227880(ctx, base);
	// 828B7D4C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B7D50: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828B7D54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B7D58: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828B7D5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D60: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B7D64: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B7D68: 4B8E2D19  bl 0x8219aa80
	ctx.lr = 0x828B7D6C;
	sub_8219AA80(ctx, base);
	// 828B7D6C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828B7D70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B7D74: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828B7D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7D7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7D80: 4BB166A1  bl 0x823ce420
	ctx.lr = 0x828B7D84;
	sub_823CE420(ctx, base);
	// 828B7D84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7D88: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B7D8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D90: 4816C939  bl 0x82a246c8
	ctx.lr = 0x828B7D94;
	sub_82A246C8(ctx, base);
	// 828B7D94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7D98: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828B7D9C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828B7DA0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828B7DA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B7DA8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828B7DAC: 419A0020  beq cr6, 0x828b7dcc
	if ctx.cr[6].eq {
	pc = 0x828B7DCC; continue 'dispatch;
	}
	// 828B7DB0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B7DB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DB8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B7DBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B7DC0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B7DC4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DC8: 4082FFE8  bne 0x828b7db0
	if !ctx.cr[0].eq {
	pc = 0x828B7DB0; continue 'dispatch;
	}
	// 828B7DCC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7DD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B7DD4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B7DD8: 4BA3DB71  bl 0x822f5948
	ctx.lr = 0x828B7DDC;
	sub_822F5948(ctx, base);
	// 828B7DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7DE0: 4B8FFD39  bl 0x821b7b18
	ctx.lr = 0x828B7DE4;
	sub_821B7B18(ctx, base);
	// 828B7DE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B7DE8: 419A0040  beq cr6, 0x828b7e28
	if ctx.cr[6].eq {
	pc = 0x828B7E28; continue 'dispatch;
	}
	// 828B7DEC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B7DF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DF4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B7DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B7DFC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B7E00: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7E04: 4082FFE8  bne 0x828b7dec
	if !ctx.cr[0].eq {
	pc = 0x828B7DEC; continue 'dispatch;
	}
	// 828B7E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7E0C: 409A001C  bne cr6, 0x828b7e28
	if !ctx.cr[6].eq {
	pc = 0x828B7E28; continue 'dispatch;
	}
	// 828B7E10: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7E14: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7E18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7E1C: 4E800421  bctrl
	ctx.lr = 0x828B7E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7E20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B7E24: 4B963F15  bl 0x8221bd38
	ctx.lr = 0x828B7E28;
	sub_8221BD38(ctx, base);
	// 828B7E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7E2C: 4B8FFCED  bl 0x821b7b18
	ctx.lr = 0x828B7E30;
	sub_821B7B18(ctx, base);
	// 828B7E30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B7E34: 483F161C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E38 size=56
    let mut pc: u32 = 0x828B7E38;
    'dispatch: loop {
        match pc {
            0x828B7E38 => {
    //   block [0x828B7E38..0x828B7E70)
	// 828B7E38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B7E3C: 419A0018  beq cr6, 0x828b7e54
	if ctx.cr[6].eq {
	pc = 0x828B7E54; continue 'dispatch;
	}
	// 828B7E40: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7E44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B7E48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7E4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7E50: 409A0008  bne cr6, 0x828b7e58
	if !ctx.cr[6].eq {
	pc = 0x828B7E58; continue 'dispatch;
	}
	// 828B7E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B7E58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7E60: 419A0010  beq cr6, 0x828b7e70
	if ctx.cr[6].eq {
		sub_828B7E70(ctx, base);
		return;
	}
	// 828B7E64: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828B7E68: 55630FFE  srwi r3, r11, 0x1f
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828B7E6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E70 size=8
    let mut pc: u32 = 0x828B7E70;
    'dispatch: loop {
        match pc {
            0x828B7E70 => {
    //   block [0x828B7E70..0x828B7E78)
	// 828B7E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B7E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E78 size=8
    let mut pc: u32 = 0x828B7E78;
    'dispatch: loop {
        match pc {
            0x828B7E78 => {
    //   block [0x828B7E78..0x828B7E80)
	// 828B7E78: 386000DF  li r3, 0xdf
	ctx.r[3].s64 = 223;
	// 828B7E7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7E80 size=60
    let mut pc: u32 = 0x828B7E80;
    'dispatch: loop {
        match pc {
            0x828B7E80 => {
    //   block [0x828B7E80..0x828B7EBC)
	// 828B7E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7E88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7E8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7E90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B7E94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B7E98: 388B9498  addi r4, r11, -0x6b68
	ctx.r[4].s64 = ctx.r[11].s64 + -27496;
	// 828B7E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7EA0: 4B975031  bl 0x8222ced0
	ctx.lr = 0x828B7EA4;
	sub_8222CED0(ctx, base);
	// 828B7EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7EA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7EC0 size=124
    let mut pc: u32 = 0x828B7EC0;
    'dispatch: loop {
        match pc {
            0x828B7EC0 => {
    //   block [0x828B7EC0..0x828B7F3C)
	// 828B7EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7EC4: 483F1545  bl 0x82ca9408
	ctx.lr = 0x828B7EC8;
	sub_82CA93D0(ctx, base);
	// 828B7EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7ED0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B7ED4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828B7ED8: 4B95CF01  bl 0x82214dd8
	ctx.lr = 0x828B7EDC;
	sub_82214DD8(ctx, base);
	// 828B7EDC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 828B7EE0: 4B95CEF9  bl 0x82214dd8
	ctx.lr = 0x828B7EE4;
	sub_82214DD8(ctx, base);
	// 828B7EE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B7EE8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828B7EEC: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 828B7EF0: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 828B7EF4: 4B8DBF45  bl 0x82193e38
	ctx.lr = 0x828B7EF8;
	sub_82193E38(ctx, base);
	// 828B7EF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B7EFC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B7F00: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828B7F04: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 828B7F08: 4B8DBF31  bl 0x82193e38
	ctx.lr = 0x828B7F0C;
	sub_82193E38(ctx, base);
	// 828B7F0C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828B7F10: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828B7F14: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828B7F18: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 828B7F1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7F20: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B7F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F28: 419A000C  beq cr6, 0x828b7f34
	if ctx.cr[6].eq {
	pc = 0x828B7F34; continue 'dispatch;
	}
	// 828B7F2C: 4B963E0D  bl 0x8221bd38
	ctx.lr = 0x828B7F30;
	sub_8221BD38(ctx, base);
	// 828B7F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B7F38: 483F1520  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7F40 size=88
    let mut pc: u32 = 0x828B7F40;
    'dispatch: loop {
        match pc {
            0x828B7F40 => {
    //   block [0x828B7F40..0x828B7F98)
	// 828B7F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7F48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7F4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7F54: 4805D12D  bl 0x82915080
	ctx.lr = 0x828B7F58;
	sub_82915080(ctx, base);
	// 828B7F58: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B7F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7F60: 419A0020  beq cr6, 0x828b7f80
	if ctx.cr[6].eq {
	pc = 0x828B7F80; continue 'dispatch;
	}
	// 828B7F64: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B7F68: 4B8BBED1  bl 0x82173e38
	ctx.lr = 0x828B7F6C;
	sub_82173E38(ctx, base);
	// 828B7F6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7F7C: 4E800020  blr
	return;
	// 828B7F80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B7F84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7F88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7F8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7F90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7F98 size=164
    let mut pc: u32 = 0x828B7F98;
    'dispatch: loop {
        match pc {
            0x828B7F98 => {
    //   block [0x828B7F98..0x828B803C)
	// 828B7F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7FA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7FA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7FA8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B7FAC: 3BE30014  addi r31, r3, 0x14
	ctx.r[31].s64 = ctx.r[3].s64 + 20;
	// 828B7FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FB4: 419A0038  beq cr6, 0x828b7fec
	if ctx.cr[6].eq {
	pc = 0x828B7FEC; continue 'dispatch;
	}
	// 828B7FB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7FC0: 419A0058  beq cr6, 0x828b8018
	if ctx.cr[6].eq {
	pc = 0x828B8018; continue 'dispatch;
	}
	// 828B7FC4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B7FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FCC: 419A0020  beq cr6, 0x828b7fec
	if ctx.cr[6].eq {
	pc = 0x828B7FEC; continue 'dispatch;
	}
	// 828B7FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7FD4: 4B8BBE65  bl 0x82173e38
	ctx.lr = 0x828B7FD8;
	sub_82173E38(ctx, base);
	// 828B7FD8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7FDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B7FE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7FE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7FE8: 409A0008  bne cr6, 0x828b7ff0
	if !ctx.cr[6].eq {
	pc = 0x828B7FF0; continue 'dispatch;
	}
	// 828B7FEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B7FF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FF8: 419A002C  beq cr6, 0x828b8024
	if ctx.cr[6].eq {
	pc = 0x828B8024; continue 'dispatch;
	}
	// 828B7FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8000: 4B8BBE39  bl 0x82173e38
	ctx.lr = 0x828B8004;
	sub_82173E38(ctx, base);
	// 828B8004: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B800C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8014: 4E800020  blr
	return;
	// 828B8018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B801C: 4B8DBE1D  bl 0x82193e38
	ctx.lr = 0x828B8020;
	sub_82193E38(ctx, base);
	// 828B8020: 4BFFFFCC  b 0x828b7fec
	pc = 0x828B7FEC; continue 'dispatch;
	// 828B8024: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8028: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B802C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8040 size=484
    let mut pc: u32 = 0x828B8040;
    'dispatch: loop {
        match pc {
            0x828B8040 => {
    //   block [0x828B8040..0x828B8224)
	// 828B8040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B804C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B8058: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B805C: 4BFFFEE5  bl 0x828b7f40
	ctx.lr = 0x828B8060;
	sub_828B7F40(ctx, base);
	// 828B8060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8064: 419A0018  beq cr6, 0x828b807c
	if ctx.cr[6].eq {
	pc = 0x828B807C; continue 'dispatch;
	}
	// 828B8068: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B806C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8074: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8078: 409A0008  bne cr6, 0x828b8080
	if !ctx.cr[6].eq {
	pc = 0x828B8080; continue 'dispatch;
	}
	// 828B807C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B8080: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8088: 419A0180  beq cr6, 0x828b8208
	if ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B808C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8090: 4BFFFEB1  bl 0x828b7f40
	ctx.lr = 0x828B8094;
	sub_828B7F40(ctx, base);
	// 828B8094: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B8098: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 828B809C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B80A0: 419A00F4  beq cr6, 0x828b8194
	if ctx.cr[6].eq {
	pc = 0x828B8194; continue 'dispatch;
	}
	// 828B80A4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B80A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B80AC: 419A0024  beq cr6, 0x828b80d0
	if ctx.cr[6].eq {
	pc = 0x828B80D0; continue 'dispatch;
	}
	// 828B80B0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 828B80B4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B80B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B80BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B80C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B80C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B80C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B80CC: 480000CC  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
	// 828B80D0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B80D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B80D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B80DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B80E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B80E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B80E8: 40810054  ble 0x828b813c
	if !ctx.cr[0].gt {
	pc = 0x828B813C; continue 'dispatch;
	}
	// 828B80EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B80F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B80F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B80F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B80FC: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828B8100: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B8104: 41980008  blt cr6, 0x828b810c
	if ctx.cr[6].lt {
	pc = 0x828B810C; continue 'dispatch;
	}
	// 828B8108: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B810C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B8110: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B8114: 419A0014  beq cr6, 0x828b8128
	if ctx.cr[6].eq {
	pc = 0x828B8128; continue 'dispatch;
	}
	// 828B8118: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B811C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B8120: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8124: 4800000C  b 0x828b8130
	pc = 0x828B8130; continue 'dispatch;
	// 828B8128: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B812C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B8130: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8134: 4199FFB8  bgt cr6, 0x828b80ec
	if ctx.cr[6].gt {
	pc = 0x828B80EC; continue 'dispatch;
	}
	// 828B8138: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B813C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8140: 419A0040  beq cr6, 0x828b8180
	if ctx.cr[6].eq {
	pc = 0x828B8180; continue 'dispatch;
	}
	// 828B8144: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8148: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828B814C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8150: 41990008  bgt cr6, 0x828b8158
	if ctx.cr[6].gt {
	pc = 0x828B8158; continue 'dispatch;
	}
	// 828B8154: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B8158: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8160: 409A0020  bne cr6, 0x828b8180
	if !ctx.cr[6].eq {
	pc = 0x828B8180; continue 'dispatch;
	}
	// 828B8164: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8168: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B816C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8170: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8174: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B8178: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B817C: 4800001C  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
	// 828B8180: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8184: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8188: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B818C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8190: 48000008  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
	// 828B8194: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B8198: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B81A0: 419A0068  beq cr6, 0x828b8208
	if ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B81A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B81A8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B81AC: 4BC2D305  bl 0x824e54b0
	ctx.lr = 0x828B81B0;
	sub_824E54B0(ctx, base);
	// 828B81B0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B81B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B81B8: 409A0050  bne cr6, 0x828b8208
	if !ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B81BC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B81C0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828B81C4: 3BEB3C38  addi r31, r11, 0x3c38
	ctx.r[31].s64 = ctx.r[11].s64 + 15416;
	// 828B81C8: 816A3C3C  lwz r11, 0x3c3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15420 as u32) ) } as u64;
	// 828B81CC: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828B81D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B81D4: 409A002C  bne cr6, 0x828b8200
	if !ctx.cr[6].eq {
	pc = 0x828B8200; continue 'dispatch;
	}
	// 828B81D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B81DC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B81E0: 916A3C3C  stw r11, 0x3c3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15420 as u32), ctx.r[11].u32 ) };
	// 828B81E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B81E8: 38892C68  addi r4, r9, 0x2c68
	ctx.r[4].s64 = ctx.r[9].s64 + 11368;
	// 828B81EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B81F0: 4B974CE1  bl 0x8222ced0
	ctx.lr = 0x828B81F4;
	sub_8222CED0(ctx, base);
	// 828B81F4: 3D00832B  lis r8, -0x7cd5
	ctx.r[8].s64 = -2094333952;
	// 828B81F8: 3868EB08  addi r3, r8, -0x14f8
	ctx.r[3].s64 = ctx.r[8].s64 + -5368;
	// 828B81FC: 483F1D25  bl 0x82ca9f20
	ctx.lr = 0x828B8200;
	sub_82CA9F20(ctx, base);
	// 828B8200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8204: 48000008  b 0x828b820c
	pc = 0x828B820C; continue 'dispatch;
	// 828B8208: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 828B820C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B8210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B821C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8228 size=180
    let mut pc: u32 = 0x828B8228;
    'dispatch: loop {
        match pc {
            0x828B8228 => {
    //   block [0x828B8228..0x828B82DC)
	// 828B8228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B822C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B8234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B823C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B8240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B8244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B8248: 419A007C  beq cr6, 0x828b82c4
	if ctx.cr[6].eq {
	pc = 0x828B82C4; continue 'dispatch;
	}
	// 828B824C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B8250: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 828B8254: 388B2C74  addi r4, r11, 0x2c74
	ctx.r[4].s64 = ctx.r[11].s64 + 11380;
	// 828B8258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B825C: 4BAF513D  bl 0x823ad398
	ctx.lr = 0x828B8260;
	sub_823AD398(ctx, base);
	// 828B8260: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B8264: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 828B8268: 388A2C88  addi r4, r10, 0x2c88
	ctx.r[4].s64 = ctx.r[10].s64 + 11400;
	// 828B826C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8270: 4BAF5129  bl 0x823ad398
	ctx.lr = 0x828B8274;
	sub_823AD398(ctx, base);
	// 828B8274: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B8278: 38BE0024  addi r5, r30, 0x24
	ctx.r[5].s64 = ctx.r[30].s64 + 36;
	// 828B827C: 38892CA4  addi r4, r9, 0x2ca4
	ctx.r[4].s64 = ctx.r[9].s64 + 11428;
	// 828B8280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8284: 4BAF50BD  bl 0x823ad340
	ctx.lr = 0x828B8288;
	sub_823AD340(ctx, base);
	// 828B8288: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828B828C: 38BE0025  addi r5, r30, 0x25
	ctx.r[5].s64 = ctx.r[30].s64 + 37;
	// 828B8290: 38882CB4  addi r4, r8, 0x2cb4
	ctx.r[4].s64 = ctx.r[8].s64 + 11444;
	// 828B8294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8298: 4BAF50A9  bl 0x823ad340
	ctx.lr = 0x828B829C;
	sub_823AD340(ctx, base);
	// 828B829C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828B82A0: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 828B82A4: 38872CCC  addi r4, r7, 0x2ccc
	ctx.r[4].s64 = ctx.r[7].s64 + 11468;
	// 828B82A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B82AC: 4BAF5145  bl 0x823ad3f0
	ctx.lr = 0x828B82B0;
	sub_823AD3F0(ctx, base);
	// 828B82B0: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828B82B4: 38BE002C  addi r5, r30, 0x2c
	ctx.r[5].s64 = ctx.r[30].s64 + 44;
	// 828B82B8: 38862CEC  addi r4, r6, 0x2cec
	ctx.r[4].s64 = ctx.r[6].s64 + 11500;
	// 828B82BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B82C0: 4BAF5131  bl 0x823ad3f0
	ctx.lr = 0x828B82C4;
	sub_823AD3F0(ctx, base);
	// 828B82C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B82C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B82CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B82D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B82D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B82D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B82E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B82E0 size=1244
    let mut pc: u32 = 0x828B82E0;
    'dispatch: loop {
        match pc {
            0x828B82E0 => {
    //   block [0x828B82E0..0x828B87BC)
	// 828B82E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B82E4: 483F1125  bl 0x82ca9408
	ctx.lr = 0x828B82E8;
	sub_82CA93D0(ctx, base);
	// 828B82E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B82EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B82F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B82F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B82F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B82FC: 419A02A4  beq cr6, 0x828b85a0
	if ctx.cr[6].eq {
	pc = 0x828B85A0; continue 'dispatch;
	}
	// 828B8300: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B8304: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B8308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B830C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828B8310: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B8314: 4B95C585  bl 0x82214898
	ctx.lr = 0x828B8318;
	sub_82214898(ctx, base);
	// 828B8318: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B831C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B8320: 4BC19BA9  bl 0x824d1ec8
	ctx.lr = 0x828B8324;
	sub_824D1EC8(ctx, base);
	// 828B8324: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B8328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B832C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828B8330: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B8334: 4B8DBB05  bl 0x82193e38
	ctx.lr = 0x828B8338;
	sub_82193E38(ctx, base);
	// 828B8338: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B833C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 828B8340: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B8344: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8348: 54E6EFFE  rlwinm r6, r7, 0x1d, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 828B834C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828B8350: 419A00F4  beq cr6, 0x828b8444
	if ctx.cr[6].eq {
	pc = 0x828B8444; continue 'dispatch;
	}
	// 828B8354: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B835C: 419A0024  beq cr6, 0x828b8380
	if ctx.cr[6].eq {
	pc = 0x828B8380; continue 'dispatch;
	}
	// 828B8360: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B8364: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8368: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B836C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8370: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8374: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B8378: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B837C: 480000CC  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
	// 828B8380: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8384: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8388: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B838C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8390: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8394: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8398: 40810054  ble 0x828b83ec
	if !ctx.cr[0].gt {
	pc = 0x828B83EC; continue 'dispatch;
	}
	// 828B839C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B83A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B83A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B83A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B83AC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B83B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B83B4: 41980008  blt cr6, 0x828b83bc
	if ctx.cr[6].lt {
	pc = 0x828B83BC; continue 'dispatch;
	}
	// 828B83B8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B83BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B83C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B83C4: 419A0014  beq cr6, 0x828b83d8
	if ctx.cr[6].eq {
	pc = 0x828B83D8; continue 'dispatch;
	}
	// 828B83C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B83CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B83D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B83D4: 4800000C  b 0x828b83e0
	pc = 0x828B83E0; continue 'dispatch;
	// 828B83D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B83DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B83E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B83E4: 4199FFB8  bgt cr6, 0x828b839c
	if ctx.cr[6].gt {
	pc = 0x828B839C; continue 'dispatch;
	}
	// 828B83E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B83EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B83F0: 419A0040  beq cr6, 0x828b8430
	if ctx.cr[6].eq {
	pc = 0x828B8430; continue 'dispatch;
	}
	// 828B83F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B83F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B83FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8400: 41990008  bgt cr6, 0x828b8408
	if ctx.cr[6].gt {
	pc = 0x828B8408; continue 'dispatch;
	}
	// 828B8404: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B840C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8410: 409A0020  bne cr6, 0x828b8430
	if !ctx.cr[6].eq {
	pc = 0x828B8430; continue 'dispatch;
	}
	// 828B8414: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8418: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B841C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8424: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B8428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B842C: 4800001C  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
	// 828B8430: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8438: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B843C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8440: 48000008  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
	// 828B8444: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B844C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8450: 419A0364  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8454: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8458: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828B845C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8460: 419A00F4  beq cr6, 0x828b8554
	if ctx.cr[6].eq {
	pc = 0x828B8554; continue 'dispatch;
	}
	// 828B8464: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B846C: 419A0024  beq cr6, 0x828b8490
	if ctx.cr[6].eq {
	pc = 0x828B8490; continue 'dispatch;
	}
	// 828B8470: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B8474: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8478: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B847C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8480: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8484: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B8488: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B848C: 480000CC  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
	// 828B8490: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8494: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8498: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B849C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B84A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B84A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B84A8: 40810054  ble 0x828b84fc
	if !ctx.cr[0].gt {
	pc = 0x828B84FC; continue 'dispatch;
	}
	// 828B84AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B84B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B84B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B84B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B84BC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B84C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B84C4: 41980008  blt cr6, 0x828b84cc
	if ctx.cr[6].lt {
	pc = 0x828B84CC; continue 'dispatch;
	}
	// 828B84C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B84CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B84D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B84D4: 419A0014  beq cr6, 0x828b84e8
	if ctx.cr[6].eq {
	pc = 0x828B84E8; continue 'dispatch;
	}
	// 828B84D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B84DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B84E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B84E4: 4800000C  b 0x828b84f0
	pc = 0x828B84F0; continue 'dispatch;
	// 828B84E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B84EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B84F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B84F4: 4199FFB8  bgt cr6, 0x828b84ac
	if ctx.cr[6].gt {
	pc = 0x828B84AC; continue 'dispatch;
	}
	// 828B84F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B84FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8500: 419A0040  beq cr6, 0x828b8540
	if ctx.cr[6].eq {
	pc = 0x828B8540; continue 'dispatch;
	}
	// 828B8504: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8508: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B850C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8510: 41990008  bgt cr6, 0x828b8518
	if ctx.cr[6].gt {
	pc = 0x828B8518; continue 'dispatch;
	}
	// 828B8514: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B851C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8520: 409A0020  bne cr6, 0x828b8540
	if !ctx.cr[6].eq {
	pc = 0x828B8540; continue 'dispatch;
	}
	// 828B8524: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8528: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B852C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8530: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8534: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B8538: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B853C: 4800001C  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
	// 828B8540: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8544: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8548: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B854C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8550: 48000008  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
	// 828B8554: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8558: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B855C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8560: 419A0254  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8564: 83FC0090  lwz r31, 0x90(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8568: C0050028  lfs f0, 0x28(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B856C: D01C0028  stfs f0, 0x28(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828B8570: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8578: 409A000C  bne cr6, 0x828b8584
	if !ctx.cr[6].eq {
	pc = 0x828B8584; continue 'dispatch;
	}
	// 828B857C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8580: 4BCBA369  bl 0x825728e8
	ctx.lr = 0x828B8584;
	sub_825728E8(ctx, base);
	// 828B8584: 817C0090  lwz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8588: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B858C: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828B8590: 915C0090  stw r10, 0x90(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828B8594: 409A0220  bne cr6, 0x828b87b4
	if !ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8598: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B859C: 480001FC  b 0x828b8798
	pc = 0x828B8798; continue 'dispatch;
	// 828B85A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B85A4: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 828B85A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85AC: 419A0038  beq cr6, 0x828b85e4
	if ctx.cr[6].eq {
	pc = 0x828B85E4; continue 'dispatch;
	}
	// 828B85B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B85B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B85B8: 419A00BC  beq cr6, 0x828b8674
	if ctx.cr[6].eq {
	pc = 0x828B8674; continue 'dispatch;
	}
	// 828B85BC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B85C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85C4: 419A0020  beq cr6, 0x828b85e4
	if ctx.cr[6].eq {
	pc = 0x828B85E4; continue 'dispatch;
	}
	// 828B85C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B85CC: 4B8BB86D  bl 0x82173e38
	ctx.lr = 0x828B85D0;
	sub_82173E38(ctx, base);
	// 828B85D0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B85D4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B85D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B85DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B85E0: 409A0008  bne cr6, 0x828b85e8
	if !ctx.cr[6].eq {
	pc = 0x828B85E8; continue 'dispatch;
	}
	// 828B85E4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B85E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B85EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85F0: 419A01C4  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B85F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B85F8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828B85FC: 4BC198CD  bl 0x824d1ec8
	ctx.lr = 0x828B8600;
	sub_824D1EC8(ctx, base);
	// 828B8600: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B8604: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B8608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B860C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828B8610: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B8614: 4B8DB825  bl 0x82193e38
	ctx.lr = 0x828B8618;
	sub_82193E38(ctx, base);
	// 828B8618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B861C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8620: 4BC198A9  bl 0x824d1ec8
	ctx.lr = 0x828B8624;
	sub_824D1EC8(ctx, base);
	// 828B8624: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B8628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B862C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828B8630: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B8634: 4B8DB805  bl 0x82193e38
	ctx.lr = 0x828B8638;
	sub_82193E38(ctx, base);
	// 828B8638: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B863C: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8640: 54E6EFFE  rlwinm r6, r7, 0x1d, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 828B8644: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828B8648: 419A00F4  beq cr6, 0x828b873c
	if ctx.cr[6].eq {
	pc = 0x828B873C; continue 'dispatch;
	}
	// 828B864C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8654: 419A002C  beq cr6, 0x828b8680
	if ctx.cr[6].eq {
	pc = 0x828B8680; continue 'dispatch;
	}
	// 828B8658: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B865C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8660: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B8664: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8668: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B866C: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8670: 480000D0  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
	// 828B8674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8678: 4B8DB7C1  bl 0x82193e38
	ctx.lr = 0x828B867C;
	sub_82193E38(ctx, base);
	// 828B867C: 4BFFFF68  b 0x828b85e4
	pc = 0x828B85E4; continue 'dispatch;
	// 828B8680: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8684: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8688: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B868C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8690: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8694: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8698: 40810054  ble 0x828b86ec
	if !ctx.cr[0].gt {
	pc = 0x828B86EC; continue 'dispatch;
	}
	// 828B869C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B86A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B86A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B86A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B86AC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B86B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B86B4: 41980008  blt cr6, 0x828b86bc
	if ctx.cr[6].lt {
	pc = 0x828B86BC; continue 'dispatch;
	}
	// 828B86B8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B86BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B86C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B86C4: 419A0014  beq cr6, 0x828b86d8
	if ctx.cr[6].eq {
	pc = 0x828B86D8; continue 'dispatch;
	}
	// 828B86C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B86CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B86D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B86D4: 4800000C  b 0x828b86e0
	pc = 0x828B86E0; continue 'dispatch;
	// 828B86D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B86DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B86E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B86E4: 4199FFB8  bgt cr6, 0x828b869c
	if ctx.cr[6].gt {
	pc = 0x828B869C; continue 'dispatch;
	}
	// 828B86E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B86EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B86F0: 419A003C  beq cr6, 0x828b872c
	if ctx.cr[6].eq {
	pc = 0x828B872C; continue 'dispatch;
	}
	// 828B86F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B86F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B86FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8700: 41990008  bgt cr6, 0x828b8708
	if ctx.cr[6].gt {
	pc = 0x828B8708; continue 'dispatch;
	}
	// 828B8704: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8708: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B870C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8710: 409A001C  bne cr6, 0x828b872c
	if !ctx.cr[6].eq {
	pc = 0x828B872C; continue 'dispatch;
	}
	// 828B8714: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8718: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B871C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8720: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8728: 48000018  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
	// 828B872C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8730: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8738: 48000008  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
	// 828B873C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B8740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8748: 419A006C  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B874C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8754: 4B921C5D  bl 0x821da3b0
	ctx.lr = 0x828B8758;
	sub_821DA3B0(ctx, base);
	// 828B8758: 4B8F9DA1  bl 0x821b24f8
	ctx.lr = 0x828B875C;
	sub_821B24F8(ctx, base);
	// 828B875C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B8760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8764: 4BCB9CD5  bl 0x82572438
	ctx.lr = 0x828B8768;
	sub_82572438(ctx, base);
	// 828B8768: 83FE0090  lwz r31, 0x90(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B876C: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8774: 409A000C  bne cr6, 0x828b8780
	if !ctx.cr[6].eq {
	pc = 0x828B8780; continue 'dispatch;
	}
	// 828B8778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B877C: 4BCBA16D  bl 0x825728e8
	ctx.lr = 0x828B8780;
	sub_825728E8(ctx, base);
	// 828B8780: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8784: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B8788: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828B878C: 915E0090  stw r10, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828B8790: 409A0024  bne cr6, 0x828b87b4
	if !ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8794: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8798: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B879C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B87A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B87A4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B87A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B87AC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B87B0: 4B958869  bl 0x82211018
	ctx.lr = 0x828B87B4;
	sub_82211018(ctx, base);
	// 828B87B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B87B8: 483F0CA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B87C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B87C0 size=244
    let mut pc: u32 = 0x828B87C0;
    'dispatch: loop {
        match pc {
            0x828B87C0 => {
    //   block [0x828B87C0..0x828B88B4)
	// 828B87C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B87C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B87C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B87CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B87D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B87D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B87D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B87DC: 3BCB2D0C  addi r30, r11, 0x2d0c
	ctx.r[30].s64 = ctx.r[11].s64 + 11532;
	// 828B87E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B87E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B87E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B87EC: 4B9746E5  bl 0x8222ced0
	ctx.lr = 0x828B87F0;
	sub_8222CED0(ctx, base);
	// 828B87F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B87F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B87F8: 480000C1  bl 0x828b88b8
	ctx.lr = 0x828B87FC;
	sub_828B88B8(ctx, base);
	// 828B87FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8800: 4B95C5D9  bl 0x82214dd8
	ctx.lr = 0x828B8804;
	sub_82214DD8(ctx, base);
	// 828B8804: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B8808: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B880C: 388A2D14  addi r4, r10, 0x2d14
	ctx.r[4].s64 = ctx.r[10].s64 + 11540;
	// 828B8810: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8814: 4B9746BD  bl 0x8222ced0
	ctx.lr = 0x828B8818;
	sub_8222CED0(ctx, base);
	// 828B8818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B881C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B8820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8824: 4B9746AD  bl 0x8222ced0
	ctx.lr = 0x828B8828;
	sub_8222CED0(ctx, base);
	// 828B8828: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828B882C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8830: 38C97F40  addi r6, r9, 0x7f40
	ctx.r[6].s64 = ctx.r[9].s64 + 32576;
	// 828B8834: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B883C: 480002C5  bl 0x828b8b00
	ctx.lr = 0x828B8840;
	sub_828B8B00(ctx, base);
	// 828B8840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8844: 4B95C595  bl 0x82214dd8
	ctx.lr = 0x828B8848;
	sub_82214DD8(ctx, base);
	// 828B8848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B884C: 4B95C58D  bl 0x82214dd8
	ctx.lr = 0x828B8850;
	sub_82214DD8(ctx, base);
	// 828B8850: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828B8854: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B8858: 38882D28  addi r4, r8, 0x2d28
	ctx.r[4].s64 = ctx.r[8].s64 + 11560;
	// 828B885C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8860: 4B974671  bl 0x8222ced0
	ctx.lr = 0x828B8864;
	sub_8222CED0(ctx, base);
	// 828B8864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8868: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B886C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8870: 4B974661  bl 0x8222ced0
	ctx.lr = 0x828B8874;
	sub_8222CED0(ctx, base);
	// 828B8874: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828B8878: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B887C: 38C77F98  addi r6, r7, 0x7f98
	ctx.r[6].s64 = ctx.r[7].s64 + 32664;
	// 828B8880: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B8884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8888: 48000279  bl 0x828b8b00
	ctx.lr = 0x828B888C;
	sub_828B8B00(ctx, base);
	// 828B888C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8890: 4B95C549  bl 0x82214dd8
	ctx.lr = 0x828B8894;
	sub_82214DD8(ctx, base);
	// 828B8894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8898: 4B95C541  bl 0x82214dd8
	ctx.lr = 0x828B889C;
	sub_82214DD8(ctx, base);
	// 828B889C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B88A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B88A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B88A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B88AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B88B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B88B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B88B8 size=584
    let mut pc: u32 = 0x828B88B8;
    'dispatch: loop {
        match pc {
            0x828B88B8 => {
    //   block [0x828B88B8..0x828B8B00)
	// 828B88B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B88BC: 483F0B45  bl 0x82ca9400
	ctx.lr = 0x828B88C0;
	sub_82CA93D0(ctx, base);
	// 828B88C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B88C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B88C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B88CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B88D0: 409A0010  bne cr6, 0x828b88e0
	if !ctx.cr[6].eq {
	pc = 0x828B88E0; continue 'dispatch;
	}
	// 828B88D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B88D8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828B88DC: 48000008  b 0x828b88e4
	pc = 0x828B88E4; continue 'dispatch;
	// 828B88E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B88E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B88E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B88EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B88F0: 4BB15CD1  bl 0x823ce5c0
	ctx.lr = 0x828B88F4;
	sub_823CE5C0(ctx, base);
	// 828B88F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B88F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B88FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8900: 4BB15901  bl 0x823ce200
	ctx.lr = 0x828B8904;
	sub_823CE200(ctx, base);
	// 828B8904: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8908: 4B8FF211  bl 0x821b7b18
	ctx.lr = 0x828B890C;
	sub_821B7B18(ctx, base);
	// 828B890C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B8910: 4B966949  bl 0x8221f258
	ctx.lr = 0x828B8914;
	sub_8221F258(ctx, base);
	// 828B8914: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8918: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B891C: 419A0040  beq cr6, 0x828b895c
	if ctx.cr[6].eq {
	pc = 0x828B895C; continue 'dispatch;
	}
	// 828B8920: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828B8924: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B8928: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828B892C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8930: 4B966929  bl 0x8221f258
	ctx.lr = 0x828B8934;
	sub_8221F258(ctx, base);
	// 828B8934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8938: 419A0028  beq cr6, 0x828b8960
	if ctx.cr[6].eq {
	pc = 0x828B8960; continue 'dispatch;
	}
	// 828B893C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B8940: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B8944: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8948: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B894C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8950: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B8954: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B8958: 4800000C  b 0x828b8964
	pc = 0x828B8964; continue 'dispatch;
	// 828B895C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B8960: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B8964: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B8968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B896C: 419A00FC  beq cr6, 0x828b8a68
	if ctx.cr[6].eq {
	pc = 0x828B8A68; continue 'dispatch;
	}
	// 828B8970: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8974: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B8978: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B897C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B8980: 4B970789  bl 0x82229108
	ctx.lr = 0x828B8984;
	sub_82229108(ctx, base);
	// 828B8984: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828B8988: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B898C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B8990: 3BCB8D00  addi r30, r11, -0x7300
	ctx.r[30].s64 = ctx.r[11].s64 + -29440;
	// 828B8994: 4B96EEED  bl 0x82227880
	ctx.lr = 0x828B8998;
	sub_82227880(ctx, base);
	// 828B8998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B899C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828B89A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B89A4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828B89A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B89AC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B89B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B89B4: 4B8E20CD  bl 0x8219aa80
	ctx.lr = 0x828B89B8;
	sub_8219AA80(ctx, base);
	// 828B89B8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828B89BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B89C0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828B89C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B89C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B89CC: 4BB15A55  bl 0x823ce420
	ctx.lr = 0x828B89D0;
	sub_823CE420(ctx, base);
	// 828B89D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B89D4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B89D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B89DC: 4816BCED  bl 0x82a246c8
	ctx.lr = 0x828B89E0;
	sub_82A246C8(ctx, base);
	// 828B89E0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B89E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B89E8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828B89EC: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828B89F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B89F4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B89F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B89FC: 4B97070D  bl 0x82229108
	ctx.lr = 0x828B8A00;
	sub_82229108(ctx, base);
	// 828B8A00: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828B8A04: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B8A08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A0C: 3BEB6B48  addi r31, r11, 0x6b48
	ctx.r[31].s64 = ctx.r[11].s64 + 27464;
	// 828B8A10: 4B96EE71  bl 0x82227880
	ctx.lr = 0x828B8A14;
	sub_82227880(ctx, base);
	// 828B8A14: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B8A18: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828B8A1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B8A20: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828B8A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B8A2C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B8A30: 4B8E2051  bl 0x8219aa80
	ctx.lr = 0x828B8A34;
	sub_8219AA80(ctx, base);
	// 828B8A34: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828B8A38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8A3C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828B8A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8A44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8A48: 4BB159D9  bl 0x823ce420
	ctx.lr = 0x828B8A4C;
	sub_823CE420(ctx, base);
	// 828B8A4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8A50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B8A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A58: 4816BC71  bl 0x82a246c8
	ctx.lr = 0x828B8A5C;
	sub_82A246C8(ctx, base);
	// 828B8A5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8A60: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828B8A64: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828B8A68: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828B8A6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B8A70: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828B8A74: 419A0020  beq cr6, 0x828b8a94
	if ctx.cr[6].eq {
	pc = 0x828B8A94; continue 'dispatch;
	}
	// 828B8A78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8A7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8A80: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8A84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8A88: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8A8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8A90: 4082FFE8  bne 0x828b8a78
	if !ctx.cr[0].eq {
	pc = 0x828B8A78; continue 'dispatch;
	}
	// 828B8A94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8A98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B8A9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B8AA0: 4BA3CEA9  bl 0x822f5948
	ctx.lr = 0x828B8AA4;
	sub_822F5948(ctx, base);
	// 828B8AA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8AA8: 4B8FF071  bl 0x821b7b18
	ctx.lr = 0x828B8AAC;
	sub_821B7B18(ctx, base);
	// 828B8AAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B8AB0: 419A0040  beq cr6, 0x828b8af0
	if ctx.cr[6].eq {
	pc = 0x828B8AF0; continue 'dispatch;
	}
	// 828B8AB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8AB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8ABC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8AC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8AC4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8AC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8ACC: 4082FFE8  bne 0x828b8ab4
	if !ctx.cr[0].eq {
	pc = 0x828B8AB4; continue 'dispatch;
	}
	// 828B8AD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8AD4: 409A001C  bne cr6, 0x828b8af0
	if !ctx.cr[6].eq {
	pc = 0x828B8AF0; continue 'dispatch;
	}
	// 828B8AD8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8ADC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8AE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8AE4: 4E800421  bctrl
	ctx.lr = 0x828B8AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8AE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8AEC: 4B96324D  bl 0x8221bd38
	ctx.lr = 0x828B8AF0;
	sub_8221BD38(ctx, base);
	// 828B8AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8AF4: 4B8FF025  bl 0x821b7b18
	ctx.lr = 0x828B8AF8;
	sub_821B7B18(ctx, base);
	// 828B8AF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B8AFC: 483F0954  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8B00 size=512
    let mut pc: u32 = 0x828B8B00;
    'dispatch: loop {
        match pc {
            0x828B8B00 => {
    //   block [0x828B8B00..0x828B8D00)
	// 828B8B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8B04: 483F08F9  bl 0x82ca93fc
	ctx.lr = 0x828B8B08;
	sub_82CA93D0(ctx, base);
	// 828B8B08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8B0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8B10: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B8B14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B8B18: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828B8B1C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828B8B20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828B8B28: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B8B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8B30: 419A0008  beq cr6, 0x828b8b38
	if ctx.cr[6].eq {
	pc = 0x828B8B38; continue 'dispatch;
	}
	// 828B8B34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B38: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8B3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8B40: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B44: 4BB15A7D  bl 0x823ce5c0
	ctx.lr = 0x828B8B48;
	sub_823CE5C0(ctx, base);
	// 828B8B48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B8B4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8B50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8B54: 4BB155BD  bl 0x823ce110
	ctx.lr = 0x828B8B58;
	sub_823CE110(ctx, base);
	// 828B8B58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8B5C: 4B8FEFBD  bl 0x821b7b18
	ctx.lr = 0x828B8B60;
	sub_821B7B18(ctx, base);
	// 828B8B60: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B8B64: 4B9666F5  bl 0x8221f258
	ctx.lr = 0x828B8B68;
	sub_8221F258(ctx, base);
	// 828B8B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8B6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B8B70: 419A005C  beq cr6, 0x828b8bcc
	if ctx.cr[6].eq {
	pc = 0x828B8BCC; continue 'dispatch;
	}
	// 828B8B74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B8B78: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828B8B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B8B80: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828B8B84: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B8B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8B8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B8B90: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B8B94: 4B9376AD  bl 0x821f0240
	ctx.lr = 0x828B8B98;
	sub_821F0240(ctx, base);
	// 828B8B98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B8B9C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828B8BA0: 4B9666B9  bl 0x8221f258
	ctx.lr = 0x828B8BA4;
	sub_8221F258(ctx, base);
	// 828B8BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8BA8: 419A0028  beq cr6, 0x828b8bd0
	if ctx.cr[6].eq {
	pc = 0x828B8BD0; continue 'dispatch;
	}
	// 828B8BAC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B8BB0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828B8BB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8BB8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B8BBC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8BC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8BC4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B8BC8: 4800000C  b 0x828b8bd4
	pc = 0x828B8BD4; continue 'dispatch;
	// 828B8BCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B8BD0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B8BD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8BD8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B8BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8BE0: 419A0008  beq cr6, 0x828b8be8
	if ctx.cr[6].eq {
	pc = 0x828B8BE8; continue 'dispatch;
	}
	// 828B8BE4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8BE8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B8BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8BF0: 419A0078  beq cr6, 0x828b8c68
	if ctx.cr[6].eq {
	pc = 0x828B8C68; continue 'dispatch;
	}
	// 828B8BF4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8BF8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B8BFC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8C00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C04: 4B970505  bl 0x82229108
	ctx.lr = 0x828B8C08;
	sub_82229108(ctx, base);
	// 828B8C08: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828B8C0C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B8C10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C14: 3BCB8D40  addi r30, r11, -0x72c0
	ctx.r[30].s64 = ctx.r[11].s64 + -29376;
	// 828B8C18: 4B96EC69  bl 0x82227880
	ctx.lr = 0x828B8C1C;
	sub_82227880(ctx, base);
	// 828B8C1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8C20: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828B8C24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B8C28: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828B8C2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C30: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828B8C34: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B8C38: 4B8E1E49  bl 0x8219aa80
	ctx.lr = 0x828B8C3C;
	sub_8219AA80(ctx, base);
	// 828B8C3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8C40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B8C44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8C48: 4BB157D9  bl 0x823ce420
	ctx.lr = 0x828B8C4C;
	sub_823CE420(ctx, base);
	// 828B8C4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8C50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B8C54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C58: 4816BA71  bl 0x82a246c8
	ctx.lr = 0x828B8C5C;
	sub_82A246C8(ctx, base);
	// 828B8C5C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8C60: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828B8C64: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828B8C68: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B8C6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8C70: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828B8C74: 419A0020  beq cr6, 0x828b8c94
	if ctx.cr[6].eq {
	pc = 0x828B8C94; continue 'dispatch;
	}
	// 828B8C78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8C7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8C80: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8C88: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8C8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8C90: 4082FFE8  bne 0x828b8c78
	if !ctx.cr[0].eq {
	pc = 0x828B8C78; continue 'dispatch;
	}
	// 828B8C94: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B8C9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B8CA0: 4BA3CCA9  bl 0x822f5948
	ctx.lr = 0x828B8CA4;
	sub_822F5948(ctx, base);
	// 828B8CA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8CA8: 4B8FEE71  bl 0x821b7b18
	ctx.lr = 0x828B8CAC;
	sub_821B7B18(ctx, base);
	// 828B8CAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8CB0: 419A0040  beq cr6, 0x828b8cf0
	if ctx.cr[6].eq {
	pc = 0x828B8CF0; continue 'dispatch;
	}
	// 828B8CB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8CB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8CBC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8CC4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8CC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8CCC: 4082FFE8  bne 0x828b8cb4
	if !ctx.cr[0].eq {
	pc = 0x828B8CB4; continue 'dispatch;
	}
	// 828B8CD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8CD4: 409A001C  bne cr6, 0x828b8cf0
	if !ctx.cr[6].eq {
	pc = 0x828B8CF0; continue 'dispatch;
	}
	// 828B8CD8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8CDC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8CE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8CE4: 4E800421  bctrl
	ctx.lr = 0x828B8CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8CE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8CEC: 4B96304D  bl 0x8221bd38
	ctx.lr = 0x828B8CF0;
	sub_8221BD38(ctx, base);
	// 828B8CF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8CF4: 4B8FEE25  bl 0x821b7b18
	ctx.lr = 0x828B8CF8;
	sub_821B7B18(ctx, base);
	// 828B8CF8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B8CFC: 483F0750  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D00 size=56
    let mut pc: u32 = 0x828B8D00;
    'dispatch: loop {
        match pc {
            0x828B8D00 => {
    //   block [0x828B8D00..0x828B8D38)
	// 828B8D00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B8D04: 419A0018  beq cr6, 0x828b8d1c
	if ctx.cr[6].eq {
	pc = 0x828B8D1C; continue 'dispatch;
	}
	// 828B8D08: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8D0C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8D14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8D18: 409A0008  bne cr6, 0x828b8d20
	if !ctx.cr[6].eq {
	pc = 0x828B8D20; continue 'dispatch;
	}
	// 828B8D1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D28: 419A0010  beq cr6, 0x828b8d38
	if ctx.cr[6].eq {
		sub_828B8D38(ctx, base);
		return;
	}
	// 828B8D2C: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828B8D30: 55636FFE  rlwinm r3, r11, 0xd, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828B8D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D38 size=8
    let mut pc: u32 = 0x828B8D38;
    'dispatch: loop {
        match pc {
            0x828B8D38 => {
    //   block [0x828B8D38..0x828B8D40)
	// 828B8D38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8D40 size=372
    let mut pc: u32 = 0x828B8D40;
    'dispatch: loop {
        match pc {
            0x828B8D40 => {
    //   block [0x828B8D40..0x828B8EB4)
	// 828B8D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8D48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8D4C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B8D50: 419A0018  beq cr6, 0x828b8d68
	if ctx.cr[6].eq {
	pc = 0x828B8D68; continue 'dispatch;
	}
	// 828B8D54: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8D58: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8D5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8D60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8D64: 409A0008  bne cr6, 0x828b8d6c
	if !ctx.cr[6].eq {
	pc = 0x828B8D6C; continue 'dispatch;
	}
	// 828B8D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D74: 419A012C  beq cr6, 0x828b8ea0
	if ctx.cr[6].eq {
	pc = 0x828B8EA0; continue 'dispatch;
	}
	// 828B8D78: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828B8D7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D80: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828B8D84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B8D88: 419A00E8  beq cr6, 0x828b8e70
	if ctx.cr[6].eq {
	pc = 0x828B8E70; continue 'dispatch;
	}
	// 828B8D8C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8D90: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D98: 419A001C  beq cr6, 0x828b8db4
	if ctx.cr[6].eq {
	pc = 0x828B8DB4; continue 'dispatch;
	}
	// 828B8D9C: 896B0053  lbz r11, 0x53(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(83 as u32) ) } as u64;
	// 828B8DA0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B8DA4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B8DA8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8DB0: 480000C4  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
	// 828B8DB4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8DBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8DC0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8DC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B8DC8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8DCC: 40810054  ble 0x828b8e20
	if !ctx.cr[0].gt {
	pc = 0x828B8E20; continue 'dispatch;
	}
	// 828B8DD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B8DD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B8DD8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B8DDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8DE0: 2F070053  cmpwi cr6, r7, 0x53
	ctx.cr[6].compare_i32(ctx.r[7].s32, 83, &mut ctx.xer);
	// 828B8DE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B8DE8: 41980008  blt cr6, 0x828b8df0
	if ctx.cr[6].lt {
	pc = 0x828B8DF0; continue 'dispatch;
	}
	// 828B8DEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B8DF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B8DF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B8DF8: 419A0014  beq cr6, 0x828b8e0c
	if ctx.cr[6].eq {
	pc = 0x828B8E0C; continue 'dispatch;
	}
	// 828B8DFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B8E00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B8E04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8E08: 4800000C  b 0x828b8e14
	pc = 0x828B8E14; continue 'dispatch;
	// 828B8E0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B8E10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B8E14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8E18: 4199FFB8  bgt cr6, 0x828b8dd0
	if ctx.cr[6].gt {
	pc = 0x828B8DD0; continue 'dispatch;
	}
	// 828B8E1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8E20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8E24: 419A003C  beq cr6, 0x828b8e60
	if ctx.cr[6].eq {
	pc = 0x828B8E60; continue 'dispatch;
	}
	// 828B8E28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8E2C: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 828B8E30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8E34: 41990008  bgt cr6, 0x828b8e3c
	if ctx.cr[6].gt {
	pc = 0x828B8E3C; continue 'dispatch;
	}
	// 828B8E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8E3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8E44: 409A001C  bne cr6, 0x828b8e60
	if !ctx.cr[6].eq {
	pc = 0x828B8E60; continue 'dispatch;
	}
	// 828B8E48: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8E4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8E50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B8E54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8E58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E5C: 48000018  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
	// 828B8E60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8E64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8E68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E6C: 48000008  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
	// 828B8E70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B8E74: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B8E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8E7C: 419A0024  beq cr6, 0x828b8ea0
	if ctx.cr[6].eq {
	pc = 0x828B8EA0; continue 'dispatch;
	}
	// 828B8E80: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B8E88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B8E8C: 4E800421  bctrl
	ctx.lr = 0x828B8E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8E90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8E9C: 4E800020  blr
	return;
	// 828B8EA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8EA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8EB8 size=256
    let mut pc: u32 = 0x828B8EB8;
    'dispatch: loop {
        match pc {
            0x828B8EB8 => {
    //   block [0x828B8EB8..0x828B8FB8)
	// 828B8EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8EC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8EC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8ECC: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 828B8ED0: 38C3000C  addi r6, r3, 0xc
	ctx.r[6].s64 = ctx.r[3].s64 + 12;
	// 828B8ED4: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 828B8ED8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828B8EDC: 99430016  stb r10, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[10].u8 ) };
	// 828B8EE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B8EE4: 99430017  stb r10, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[10].u8 ) };
	// 828B8EE8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 828B8EEC: 99430018  stb r10, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 828B8EF0: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 828B8EF4: 9943001A  stb r10, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[10].u8 ) };
	// 828B8EF8: 9943001B  stb r10, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[10].u8 ) };
	// 828B8EFC: 394300C9  addi r10, r3, 0xc9
	ctx.r[10].s64 = ctx.r[3].s64 + 201;
	// 828B8F00: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828B8F04: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828B8F08: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828B8F0C: 992B0001  stb r9, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[9].u8 ) };
	// 828B8F10: 992B0002  stb r9, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 828B8F14: 992B0003  stb r9, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 828B8F18: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 828B8F1C: 98EAFFC8  stb r7, -0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-56 as u32), ctx.r[7].u8 ) };
	// 828B8F20: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B8F24: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B8F2C: 4082FFF0  bne 0x828b8f1c
	if !ctx.cr[0].eq {
	pc = 0x828B8F1C; continue 'dispatch;
	}
	// 828B8F30: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B8F34: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 828B8F38: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 828B8F3C: 4082FFC4  bne 0x828b8f00
	if !ctx.cr[0].eq {
	pc = 0x828B8F00; continue 'dispatch;
	}
	// 828B8F40: 396300A4  addi r11, r3, 0xa4
	ctx.r[11].s64 = ctx.r[3].s64 + 164;
	// 828B8F44: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 828B8F48: 90EBFFC8  stw r7, -0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[7].u32 ) };
	// 828B8F4C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F50: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828B8F54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B8F58: 4082FFF0  bne 0x828b8f48
	if !ctx.cr[0].eq {
	pc = 0x828B8F48; continue 'dispatch;
	}
	// 828B8F5C: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 828B8F60: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 828B8F64: 98EBFFC8  stb r7, -0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[7].u8 ) };
	// 828B8F68: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F6C: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8F74: 4082FFF0  bne 0x828b8f64
	if !ctx.cr[0].eq {
	pc = 0x828B8F64; continue 'dispatch;
	}
	// 828B8F78: 39630044  addi r11, r3, 0x44
	ctx.r[11].s64 = ctx.r[3].s64 + 68;
	// 828B8F7C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828B8F80: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 828B8F84: 98EBFFD8  stb r7, -0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-40 as u32), ctx.r[7].u8 ) };
	// 828B8F88: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F8C: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8F94: 4082FFF0  bne 0x828b8f84
	if !ctx.cr[0].eq {
	pc = 0x828B8F84; continue 'dispatch;
	}
	// 828B8F98: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8F9C: 4082FFE4  bne 0x828b8f80
	if !ctx.cr[0].eq {
	pc = 0x828B8F80; continue 'dispatch;
	}
	// 828B8FA0: 48000019  bl 0x828b8fb8
	ctx.lr = 0x828B8FA4;
	sub_828B8FB8(ctx, base);
	// 828B8FA4: 480000AD  bl 0x828b9050
	ctx.lr = 0x828B8FA8;
	sub_828B9050(ctx, base);
	// 828B8FA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8FB8 size=152
    let mut pc: u32 = 0x828B8FB8;
    'dispatch: loop {
        match pc {
            0x828B8FB8 => {
    //   block [0x828B8FB8..0x828B9050)
	// 828B8FB8: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 828B8FBC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828B8FC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8FC4: 994BFFC8  stb r10, -0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[10].u8 ) };
	// 828B8FC8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8FCC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B8FD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8FD4: 4082FFF0  bne 0x828b8fc4
	if !ctx.cr[0].eq {
	pc = 0x828B8FC4; continue 'dispatch;
	}
	// 828B8FD8: 396300A4  addi r11, r3, 0xa4
	ctx.r[11].s64 = ctx.r[3].s64 + 164;
	// 828B8FDC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828B8FE0: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828B8FE4: 910BFFC8  stw r8, -0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[8].u32 ) };
	// 828B8FE8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8FEC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B8FF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B8FF4: 4082FFF0  bne 0x828b8fe4
	if !ctx.cr[0].eq {
	pc = 0x828B8FE4; continue 'dispatch;
	}
	// 828B8FF8: 39630099  addi r11, r3, 0x99
	ctx.r[11].s64 = ctx.r[3].s64 + 153;
	// 828B8FFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828B9000: 994BFFF8  stb r10, -8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u8 ) };
	// 828B9004: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B9008: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B900C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9010: 4082FFF0  bne 0x828b9000
	if !ctx.cr[0].eq {
	pc = 0x828B9000; continue 'dispatch;
	}
	// 828B9014: 392300D1  addi r9, r3, 0xd1
	ctx.r[9].s64 = ctx.r[3].s64 + 209;
	// 828B9018: 3963001C  addi r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 + 28;
	// 828B901C: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828B9020: 9949FFF8  stb r10, -8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8 as u32), ctx.r[10].u8 ) };
	// 828B9024: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B9028: 99490000  stb r10, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B902C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9030: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B9034: 994B0001  stb r10, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 828B9038: 994B0002  stb r10, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 828B903C: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 828B9040: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 828B9044: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 828B9048: 4082FFD8  bne 0x828b9020
	if !ctx.cr[0].eq {
	pc = 0x828B9020; continue 'dispatch;
	}
	// 828B904C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9050 size=720
    let mut pc: u32 = 0x828B9050;
    'dispatch: loop {
        match pc {
            0x828B9050 => {
    //   block [0x828B9050..0x828B9320)
	// 828B9050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9054: 483F03B1  bl 0x82ca9404
	ctx.lr = 0x828B9058;
	sub_82CA93D0(ctx, base);
	// 828B9058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B905C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828B9060: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828B9064: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828B9068: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828B906C: 3943008C  addi r10, r3, 0x8c
	ctx.r[10].s64 = ctx.r[3].s64 + 140;
	// 828B9070: 7D2A58AE  lbzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B9074: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9078: 419A0024  beq cr6, 0x828b909c
	if ctx.cr[6].eq {
	pc = 0x828B909C; continue 'dispatch;
	}
	// 828B907C: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B9080: 890900C4  lbz r8, 0xc4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(196 as u32) ) } as u64;
	// 828B9084: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B9088: 419A0014  beq cr6, 0x828b909c
	if ctx.cr[6].eq {
	pc = 0x828B909C; continue 'dispatch;
	}
	// 828B908C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828B9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9094: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828B9098: 4198FFD8  blt cr6, 0x828b9070
	if ctx.cr[6].lt {
	pc = 0x828B9070; continue 'dispatch;
	}
	// 828B909C: 38A300C9  addi r5, r3, 0xc9
	ctx.r[5].s64 = ctx.r[3].s64 + 201;
	// 828B90A0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B90A4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828B90A8: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 828B90AC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 828B90B0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B90B4: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 828B90B8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828B90BC: 7F08E800  cmpw cr6, r8, r29
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828B90C0: 419900C0  bgt cr6, 0x828b9180
	if ctx.cr[6].gt {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90C4: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 828B90C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B90CC: 409A00B4  bne cr6, 0x828b9180
	if !ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90D0: 7D6740AE  lbzx r11, r7, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828B90D4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 828B90D8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828B90DC: 419A00A4  beq cr6, 0x828b9180
	if ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90E0: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B90E4: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B90E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B90EC: 409A0008  bne cr6, 0x828b90f4
	if !ctx.cr[6].eq {
	pc = 0x828B90F4; continue 'dispatch;
	}
	// 828B90F0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828B90F4: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B90F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B90FC: 409A0024  bne cr6, 0x828b9120
	if !ctx.cr[6].eq {
	pc = 0x828B9120; continue 'dispatch;
	}
	// 828B9100: 7D445A14  add r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828B9104: 894AFFC8  lbz r10, -0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B910C: 419A0010  beq cr6, 0x828b911c
	if ctx.cr[6].eq {
	pc = 0x828B911C; continue 'dispatch;
	}
	// 828B9110: 7D4458AE  lbzx r10, r4, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B9114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9118: 409A0008  bne cr6, 0x828b9120
	if !ctx.cr[6].eq {
	pc = 0x828B9120; continue 'dispatch;
	}
	// 828B911C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828B9120: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B9124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9128: 409A0030  bne cr6, 0x828b9158
	if !ctx.cr[6].eq {
	pc = 0x828B9158; continue 'dispatch;
	}
	// 828B912C: 394B001B  addi r10, r11, 0x1b
	ctx.r[10].s64 = ctx.r[11].s64 + 27;
	// 828B9130: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B9134: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 828B9138: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828B913C: 41980018  blt cr6, 0x828b9154
	if ctx.cr[6].lt {
	pc = 0x828B9154; continue 'dispatch;
	}
	// 828B9140: 394B0029  addi r10, r11, 0x29
	ctx.r[10].s64 = ctx.r[11].s64 + 41;
	// 828B9144: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B9148: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 828B914C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828B9150: 40980008  bge cr6, 0x828b9158
	if !ctx.cr[6].lt {
	pc = 0x828B9158; continue 'dispatch;
	}
	// 828B9154: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828B9158: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B915C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B9160: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828B9164: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B9168: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B916C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9170: 419A0010  beq cr6, 0x828b9180
	if ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B9174: 896B0044  lbz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828B9178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B917C: 409A0008  bne cr6, 0x828b9184
	if !ctx.cr[6].eq {
	pc = 0x828B9184; continue 'dispatch;
	}
	// 828B9180: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828B9184: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B9188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B918C: 419A000C  beq cr6, 0x828b9198
	if ctx.cr[6].eq {
	pc = 0x828B9198; continue 'dispatch;
	}
	// 828B9190: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828B9194: 7FE741AE  stbx r31, r7, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32), ctx.r[31].u8) };
	// 828B9198: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B919C: 2F080005  cmpwi cr6, r8, 5
	ctx.cr[6].compare_i32(ctx.r[8].s32, 5, &mut ctx.xer);
	// 828B91A0: 4198FF18  blt cr6, 0x828b90b8
	if ctx.cr[6].lt {
	pc = 0x828B90B8; continue 'dispatch;
	}
	// 828B91A4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B91A8: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 828B91AC: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 828B91B0: 4082FF00  bne 0x828b90b0
	if !ctx.cr[0].eq {
	pc = 0x828B90B0; continue 'dispatch;
	}
	// 828B91B4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B91B8: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 828B91BC: 409A0008  bne cr6, 0x828b91c4
	if !ctx.cr[6].eq {
	pc = 0x828B91C4; continue 'dispatch;
	}
	// 828B91C0: 4BFFFDF9  bl 0x828b8fb8
	ctx.lr = 0x828B91C4;
	sub_828B8FB8(ctx, base);
	// 828B91C4: 3BC30044  addi r30, r3, 0x44
	ctx.r[30].s64 = ctx.r[3].s64 + 68;
	// 828B91C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B91CC: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 828B91D0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B91D4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B91D8: 7D6430AE  lbzx r11, r4, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 828B91DC: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 828B91E0: 409A0088  bne cr6, 0x828b9268
	if !ctx.cr[6].eq {
	pc = 0x828B9268; continue 'dispatch;
	}
	// 828B91E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828B91E8: 394300A4  addi r10, r3, 0xa4
	ctx.r[10].s64 = ctx.r[3].s64 + 164;
	// 828B91EC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 828B91F0: 39030014  addi r8, r3, 0x14
	ctx.r[8].s64 = ctx.r[3].s64 + 20;
	// 828B91F4: 7FA858AE  lbzx r29, r8, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B91F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B91FC: 419A0050  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9200: 8BA9FFD8  lbz r29, -0x28(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-40 as u32) ) } as u64;
	// 828B9204: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9208: 419A0044  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B920C: 8BA90000  lbz r29, 0(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9214: 419A0038  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9218: 7FA55A14  add r29, r5, r11
	ctx.r[29].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 828B921C: 8BBDFFC8  lbz r29, -0x38(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9220: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9224: 419A0028  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9228: 7FA558AE  lbzx r29, r5, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B922C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9230: 419A001C  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9234: 83AAFFC8  lwz r29, -0x38(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9238: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828B923C: 41980010  blt cr6, 0x828b924c
	if ctx.cr[6].lt {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9240: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9244: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828B9248: 4098001C  bge cr6, 0x828b9264
	if !ctx.cr[6].lt {
	pc = 0x828B9264; continue 'dispatch;
	}
	// 828B924C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9250: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9254: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 828B9258: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828B925C: 4198FF98  blt cr6, 0x828b91f4
	if ctx.cr[6].lt {
	pc = 0x828B91F4; continue 'dispatch;
	}
	// 828B9260: 48000008  b 0x828b9268
	pc = 0x828B9268; continue 'dispatch;
	// 828B9264: 7D6431AE  stbx r11, r4, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u8) };
	// 828B9268: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 828B926C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828B9270: 2F060005  cmpwi cr6, r6, 5
	ctx.cr[6].compare_i32(ctx.r[6].s32, 5, &mut ctx.xer);
	// 828B9274: 4198FF64  blt cr6, 0x828b91d8
	if ctx.cr[6].lt {
	pc = 0x828B91D8; continue 'dispatch;
	}
	// 828B9278: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B927C: 38840005  addi r4, r4, 5
	ctx.r[4].s64 = ctx.r[4].s64 + 5;
	// 828B9280: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 828B9284: 4082FF4C  bne 0x828b91d0
	if !ctx.cr[0].eq {
	pc = 0x828B91D0; continue 'dispatch;
	}
	// 828B9288: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 828B928C: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	// 828B9290: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 828B9294: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B9298: 892AFFFE  lbz r9, -2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-2 as u32) ) } as u64;
	// 828B929C: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92A0: 419A0008  beq cr6, 0x828b92a8
	if ctx.cr[6].eq {
	pc = 0x828B92A8; continue 'dispatch;
	}
	// 828B92A4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828B92A8: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 828B92AC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92B0: 419A0010  beq cr6, 0x828b92c0
	if ctx.cr[6].eq {
	pc = 0x828B92C0; continue 'dispatch;
	}
	// 828B92B4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92B8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92BC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B92C0: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92C4: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92C8: 419A0010  beq cr6, 0x828b92d8
	if ctx.cr[6].eq {
	pc = 0x828B92D8; continue 'dispatch;
	}
	// 828B92CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92D4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B92D8: 892A0001  lbz r9, 1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 828B92DC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92E0: 419A0010  beq cr6, 0x828b92f0
	if ctx.cr[6].eq {
	pc = 0x828B92F0; continue 'dispatch;
	}
	// 828B92E4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92EC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B92F0: 892A0002  lbz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 828B92F4: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92F8: 419A0010  beq cr6, 0x828b9308
	if ctx.cr[6].eq {
	pc = 0x828B9308; continue 'dispatch;
	}
	// 828B92FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9300: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9304: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B9308: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B930C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9310: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 828B9314: 4082FF80  bne 0x828b9294
	if !ctx.cr[0].eq {
	pc = 0x828B9294; continue 'dispatch;
	}
	// 828B9318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B931C: 483F0138  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


