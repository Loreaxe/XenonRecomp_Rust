pub fn sub_828E31C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E31C8 size=360
    let mut pc: u32 = 0x828E31C8;
    'dispatch: loop {
        match pc {
            0x828E31C8 => {
    //   block [0x828E31C8..0x828E3330)
	// 828E31C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E31CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E31D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E31D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E31D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E31DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E31E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E31E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E31E8: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E31EC: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828E31F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E31F4: 419A00E8  beq cr6, 0x828e32dc
	if ctx.cr[6].eq {
	pc = 0x828E32DC; continue 'dispatch;
	}
	// 828E31F8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E31FC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3204: 419A001C  beq cr6, 0x828e3220
	if ctx.cr[6].eq {
	pc = 0x828E3220; continue 'dispatch;
	}
	// 828E3208: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828E320C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E3210: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E3214: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3218: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E321C: 480000C4  b 0x828e32e0
	pc = 0x828E32E0; continue 'dispatch;
	// 828E3220: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3224: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3228: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E322C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E3230: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E3234: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3238: 40810054  ble 0x828e328c
	if !ctx.cr[0].gt {
	pc = 0x828E328C; continue 'dispatch;
	}
	// 828E323C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E3240: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E3244: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E3248: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E324C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828E3250: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E3254: 41980008  blt cr6, 0x828e325c
	if ctx.cr[6].lt {
	pc = 0x828E325C; continue 'dispatch;
	}
	// 828E3258: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E325C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E3260: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E3264: 419A0014  beq cr6, 0x828e3278
	if ctx.cr[6].eq {
	pc = 0x828E3278; continue 'dispatch;
	}
	// 828E3268: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E326C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E3270: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E3274: 4800000C  b 0x828e3280
	pc = 0x828E3280; continue 'dispatch;
	// 828E3278: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E327C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E3280: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3284: 4199FFB8  bgt cr6, 0x828e323c
	if ctx.cr[6].gt {
	pc = 0x828E323C; continue 'dispatch;
	}
	// 828E3288: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E328C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E3290: 419A003C  beq cr6, 0x828e32cc
	if ctx.cr[6].eq {
	pc = 0x828E32CC; continue 'dispatch;
	}
	// 828E3294: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3298: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828E329C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E32A0: 41990008  bgt cr6, 0x828e32a8
	if ctx.cr[6].gt {
	pc = 0x828E32A8; continue 'dispatch;
	}
	// 828E32A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E32A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E32AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E32B0: 409A001C  bne cr6, 0x828e32cc
	if !ctx.cr[6].eq {
	pc = 0x828E32CC; continue 'dispatch;
	}
	// 828E32B4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E32B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E32BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E32C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E32C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E32C8: 48000018  b 0x828e32e0
	pc = 0x828E32E0; continue 'dispatch;
	// 828E32CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E32D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E32D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E32D8: 48000008  b 0x828e32e0
	pc = 0x828E32E0; continue 'dispatch;
	// 828E32DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E32E0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E32E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E32E8: 419A0020  beq cr6, 0x828e3308
	if ctx.cr[6].eq {
	pc = 0x828E3308; continue 'dispatch;
	}
	// 828E32EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E32F0: 4BB3EA39  bl 0x82421d28
	ctx.lr = 0x828E32F4;
	sub_82421D28(ctx, base);
	// 828E32F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E32F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E32FC: 409A000C  bne cr6, 0x828e3308
	if !ctx.cr[6].eq {
	pc = 0x828E3308; continue 'dispatch;
	}
	// 828E3300: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E3304: 48000014  b 0x828e3318
	pc = 0x828E3318; continue 'dispatch;
	// 828E3308: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E330C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E3310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3314: 4BFFF39D  bl 0x828e26b0
	ctx.lr = 0x828E3318;
	sub_828E26B0(ctx, base);
	// 828E3318: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E331C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3324: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3328: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E332C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3330 size=136
    let mut pc: u32 = 0x828E3330;
    'dispatch: loop {
        match pc {
            0x828E3330 => {
    //   block [0x828E3330..0x828E33B8)
	// 828E3330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E333C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3344: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E3348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E334C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E3350: 816B6AF0  lwz r11, 0x6af0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27376 as u32) ) } as u64;
	// 828E3354: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828E3358: 409A0038  bne cr6, 0x828e3390
	if !ctx.cr[6].eq {
	pc = 0x828E3390; continue 'dispatch;
	}
	// 828E335C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E3360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E3364: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E3368: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E336C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E3370: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3374: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3378: 4B94F401  bl 0x82232778
	ctx.lr = 0x828E337C;
	sub_82232778(ctx, base);
	// 828E337C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E3380: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E3384: 409A000C  bne cr6, 0x828e3390
	if !ctx.cr[6].eq {
	pc = 0x828E3390; continue 'dispatch;
	}
	// 828E3388: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E338C: 48000014  b 0x828e33a0
	pc = 0x828E33A0; continue 'dispatch;
	// 828E3390: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E3394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E3398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E339C: 4BFFF315  bl 0x828e26b0
	ctx.lr = 0x828E33A0;
	sub_828E26B0(ctx, base);
	// 828E33A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E33A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E33A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E33AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E33B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E33B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E33B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E33B8 size=76
    let mut pc: u32 = 0x828E33B8;
    'dispatch: loop {
        match pc {
            0x828E33B8 => {
    //   block [0x828E33B8..0x828E3404)
	// 828E33B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E33BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E33C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E33C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E33C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E33CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E33D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E33D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E33D8: 4BD1C589  bl 0x825ff960
	ctx.lr = 0x828E33DC;
	sub_825FF960(ctx, base);
	// 828E33DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E33E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E33E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E33E8: 4BD1C6F1  bl 0x825ffad8
	ctx.lr = 0x828E33EC;
	sub_825FFAD8(ctx, base);
	// 828E33EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E33F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E33F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E33F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E33FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3408 size=1168
    let mut pc: u32 = 0x828E3408;
    'dispatch: loop {
        match pc {
            0x828E3408 => {
    //   block [0x828E3408..0x828E3898)
	// 828E3408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E340C: 483C5FFD  bl 0x82ca9408
	ctx.lr = 0x828E3410;
	sub_82CA93D0(ctx, base);
	// 828E3410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E3418: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E341C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E3420: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E3424: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 828E3428: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E342C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3430: 419A00E8  beq cr6, 0x828e3518
	if ctx.cr[6].eq {
	pc = 0x828E3518; continue 'dispatch;
	}
	// 828E3434: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E3438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E343C: 419A0020  beq cr6, 0x828e345c
	if ctx.cr[6].eq {
	pc = 0x828E345C; continue 'dispatch;
	}
	// 828E3440: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 828E3444: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3448: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E344C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E3450: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3454: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3458: 480000C4  b 0x828e351c
	pc = 0x828E351C; continue 'dispatch;
	// 828E345C: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3460: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3464: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E3468: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E346C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E3470: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3474: 40810054  ble 0x828e34c8
	if !ctx.cr[0].gt {
	pc = 0x828E34C8; continue 'dispatch;
	}
	// 828E3478: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E347C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E3480: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E3484: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3488: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 828E348C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E3490: 41980008  blt cr6, 0x828e3498
	if ctx.cr[6].lt {
	pc = 0x828E3498; continue 'dispatch;
	}
	// 828E3494: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E3498: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E349C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E34A0: 419A0014  beq cr6, 0x828e34b4
	if ctx.cr[6].eq {
	pc = 0x828E34B4; continue 'dispatch;
	}
	// 828E34A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E34A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E34AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E34B0: 4800000C  b 0x828e34bc
	pc = 0x828E34BC; continue 'dispatch;
	// 828E34B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E34B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E34BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E34C0: 4199FFB8  bgt cr6, 0x828e3478
	if ctx.cr[6].gt {
	pc = 0x828E3478; continue 'dispatch;
	}
	// 828E34C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E34C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E34CC: 419A003C  beq cr6, 0x828e3508
	if ctx.cr[6].eq {
	pc = 0x828E3508; continue 'dispatch;
	}
	// 828E34D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E34D4: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 828E34D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E34DC: 41990008  bgt cr6, 0x828e34e4
	if ctx.cr[6].gt {
	pc = 0x828E34E4; continue 'dispatch;
	}
	// 828E34E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E34E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E34E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E34EC: 409A001C  bne cr6, 0x828e3508
	if !ctx.cr[6].eq {
	pc = 0x828E3508; continue 'dispatch;
	}
	// 828E34F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E34F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E34F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E34FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E3500: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3504: 48000018  b 0x828e351c
	pc = 0x828E351C; continue 'dispatch;
	// 828E3508: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E350C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3514: 48000008  b 0x828e351c
	pc = 0x828E351C; continue 'dispatch;
	// 828E3518: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E351C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E3520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3524: 419A0368  beq cr6, 0x828e388c
	if ctx.cr[6].eq {
	pc = 0x828E388C; continue 'dispatch;
	}
	// 828E3528: 896B0025  lbz r11, 0x25(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 828E352C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3530: 419A035C  beq cr6, 0x828e388c
	if ctx.cr[6].eq {
	pc = 0x828E388C; continue 'dispatch;
	}
	// 828E3534: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E3538: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E353C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828E3540: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E3544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E3548: 419A00E4  beq cr6, 0x828e362c
	if ctx.cr[6].eq {
	pc = 0x828E362C; continue 'dispatch;
	}
	// 828E354C: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E3550: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3558: 419A001C  beq cr6, 0x828e3574
	if ctx.cr[6].eq {
	pc = 0x828E3574; continue 'dispatch;
	}
	// 828E355C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E3560: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E3564: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E3568: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E356C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3570: 480000C0  b 0x828e3630
	pc = 0x828E3630; continue 'dispatch;
	// 828E3574: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3578: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E357C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E3580: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E3584: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3588: 40810054  ble 0x828e35dc
	if !ctx.cr[0].gt {
	pc = 0x828E35DC; continue 'dispatch;
	}
	// 828E358C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E3590: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E3594: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E3598: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E359C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E35A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E35A4: 41980008  blt cr6, 0x828e35ac
	if ctx.cr[6].lt {
	pc = 0x828E35AC; continue 'dispatch;
	}
	// 828E35A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E35AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E35B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E35B4: 419A0014  beq cr6, 0x828e35c8
	if ctx.cr[6].eq {
	pc = 0x828E35C8; continue 'dispatch;
	}
	// 828E35B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E35BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E35C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E35C4: 4800000C  b 0x828e35d0
	pc = 0x828E35D0; continue 'dispatch;
	// 828E35C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E35CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E35D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E35D4: 4199FFB8  bgt cr6, 0x828e358c
	if ctx.cr[6].gt {
	pc = 0x828E358C; continue 'dispatch;
	}
	// 828E35D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E35DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E35E0: 419A003C  beq cr6, 0x828e361c
	if ctx.cr[6].eq {
	pc = 0x828E361C; continue 'dispatch;
	}
	// 828E35E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E35E8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E35EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E35F0: 41990008  bgt cr6, 0x828e35f8
	if ctx.cr[6].gt {
	pc = 0x828E35F8; continue 'dispatch;
	}
	// 828E35F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E35F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E35FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3600: 409A001C  bne cr6, 0x828e361c
	if !ctx.cr[6].eq {
	pc = 0x828E361C; continue 'dispatch;
	}
	// 828E3604: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E3608: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E360C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E3610: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E3614: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3618: 48000018  b 0x828e3630
	pc = 0x828E3630; continue 'dispatch;
	// 828E361C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E3620: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3624: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3628: 48000008  b 0x828e3630
	pc = 0x828E3630; continue 'dispatch;
	// 828E362C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E3630: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E3634: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3638: 419A0008  beq cr6, 0x828e3640
	if ctx.cr[6].eq {
	pc = 0x828E3640; continue 'dispatch;
	}
	// 828E363C: 8BEB008D  lbz r31, 0x8d(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 828E3640: 815C0034  lwz r10, 0x34(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E3644: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E3648: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828E364C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E3650: 419A00E4  beq cr6, 0x828e3734
	if ctx.cr[6].eq {
	pc = 0x828E3734; continue 'dispatch;
	}
	// 828E3654: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E3658: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E365C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3660: 419A001C  beq cr6, 0x828e367c
	if ctx.cr[6].eq {
	pc = 0x828E367C; continue 'dispatch;
	}
	// 828E3664: 896B0085  lbz r11, 0x85(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 828E3668: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E366C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E3670: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3674: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3678: 480000C0  b 0x828e3738
	pc = 0x828E3738; continue 'dispatch;
	// 828E367C: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3680: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E3684: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E3688: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E368C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3690: 40810054  ble 0x828e36e4
	if !ctx.cr[0].gt {
	pc = 0x828E36E4; continue 'dispatch;
	}
	// 828E3694: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E3698: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E369C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E36A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E36A4: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828E36A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E36AC: 41980008  blt cr6, 0x828e36b4
	if ctx.cr[6].lt {
	pc = 0x828E36B4; continue 'dispatch;
	}
	// 828E36B0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E36B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E36B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E36BC: 419A0014  beq cr6, 0x828e36d0
	if ctx.cr[6].eq {
	pc = 0x828E36D0; continue 'dispatch;
	}
	// 828E36C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E36C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E36C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E36CC: 4800000C  b 0x828e36d8
	pc = 0x828E36D8; continue 'dispatch;
	// 828E36D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E36D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E36D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E36DC: 4199FFB8  bgt cr6, 0x828e3694
	if ctx.cr[6].gt {
	pc = 0x828E3694; continue 'dispatch;
	}
	// 828E36E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E36E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E36E8: 419A003C  beq cr6, 0x828e3724
	if ctx.cr[6].eq {
	pc = 0x828E3724; continue 'dispatch;
	}
	// 828E36EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E36F0: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828E36F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E36F8: 41990008  bgt cr6, 0x828e3700
	if ctx.cr[6].gt {
	pc = 0x828E3700; continue 'dispatch;
	}
	// 828E36FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E3700: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3708: 409A001C  bne cr6, 0x828e3724
	if !ctx.cr[6].eq {
	pc = 0x828E3724; continue 'dispatch;
	}
	// 828E370C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E3710: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3714: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E3718: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E371C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3720: 48000018  b 0x828e3738
	pc = 0x828E3738; continue 'dispatch;
	// 828E3724: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E3728: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E372C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3730: 48000008  b 0x828e3738
	pc = 0x828E3738; continue 'dispatch;
	// 828E3734: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E3738: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E373C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3740: 419A0140  beq cr6, 0x828e3880
	if ctx.cr[6].eq {
	pc = 0x828E3880; continue 'dispatch;
	}
	// 828E3744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E3748: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E374C: 4B92084D  bl 0x82203f98
	ctx.lr = 0x828E3750;
	sub_82203F98(ctx, base);
	// 828E3750: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 828E3754: 419A012C  beq cr6, 0x828e3880
	if ctx.cr[6].eq {
	pc = 0x828E3880; continue 'dispatch;
	}
	// 828E3758: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828E375C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3760: 409A012C  bne cr6, 0x828e388c
	if !ctx.cr[6].eq {
	pc = 0x828E388C; continue 'dispatch;
	}
	// 828E3764: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 828E3768: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E376C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E3770: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E3774: 419A00E4  beq cr6, 0x828e3858
	if ctx.cr[6].eq {
	pc = 0x828E3858; continue 'dispatch;
	}
	// 828E3778: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E377C: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3784: 419A001C  beq cr6, 0x828e37a0
	if ctx.cr[6].eq {
	pc = 0x828E37A0; continue 'dispatch;
	}
	// 828E3788: 896B0061  lbz r11, 0x61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 828E378C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E3790: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E3794: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3798: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E379C: 480000C0  b 0x828e385c
	pc = 0x828E385C; continue 'dispatch;
	// 828E37A0: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E37A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E37A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E37AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E37B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E37B4: 40810054  ble 0x828e3808
	if !ctx.cr[0].gt {
	pc = 0x828E3808; continue 'dispatch;
	}
	// 828E37B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E37BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E37C0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E37C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E37C8: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 828E37CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E37D0: 41980008  blt cr6, 0x828e37d8
	if ctx.cr[6].lt {
	pc = 0x828E37D8; continue 'dispatch;
	}
	// 828E37D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E37D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E37DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E37E0: 419A0014  beq cr6, 0x828e37f4
	if ctx.cr[6].eq {
	pc = 0x828E37F4; continue 'dispatch;
	}
	// 828E37E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E37E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E37EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E37F0: 4800000C  b 0x828e37fc
	pc = 0x828E37FC; continue 'dispatch;
	// 828E37F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E37F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E37FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3800: 4199FFB8  bgt cr6, 0x828e37b8
	if ctx.cr[6].gt {
	pc = 0x828E37B8; continue 'dispatch;
	}
	// 828E3804: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E3808: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E380C: 419A003C  beq cr6, 0x828e3848
	if ctx.cr[6].eq {
	pc = 0x828E3848; continue 'dispatch;
	}
	// 828E3810: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3814: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 828E3818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E381C: 41990008  bgt cr6, 0x828e3824
	if ctx.cr[6].gt {
	pc = 0x828E3824; continue 'dispatch;
	}
	// 828E3820: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E3824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E382C: 409A001C  bne cr6, 0x828e3848
	if !ctx.cr[6].eq {
	pc = 0x828E3848; continue 'dispatch;
	}
	// 828E3830: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E3834: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3838: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E383C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E3840: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3844: 48000018  b 0x828e385c
	pc = 0x828E385C; continue 'dispatch;
	// 828E3848: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E384C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3854: 48000008  b 0x828e385c
	pc = 0x828E385C; continue 'dispatch;
	// 828E3858: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E385C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E3860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3864: 419A001C  beq cr6, 0x828e3880
	if ctx.cr[6].eq {
	pc = 0x828E3880; continue 'dispatch;
	}
	// 828E3868: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E386C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E3870: 4BF30B29  bl 0x82814398
	ctx.lr = 0x828E3874;
	sub_82814398(ctx, base);
	// 828E3874: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E3878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E387C: 419A0010  beq cr6, 0x828e388c
	if ctx.cr[6].eq {
	pc = 0x828E388C; continue 'dispatch;
	}
	// 828E3880: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E3884: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E3888: 483C5BD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828E388C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E3890: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E3894: 483C5BC4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E3898 size=2388
    let mut pc: u32 = 0x828E3898;
    'dispatch: loop {
        match pc {
            0x828E3898 => {
    //   block [0x828E3898..0x828E41EC)
	// 828E3898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E389C: 483C5B3D  bl 0x82ca93d8
	ctx.lr = 0x828E38A0;
	sub_82CA93D0(ctx, base);
	// 828E38A0: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 828E38A4: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E38A8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828E38AC: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 828E38B0: 7E90A378  mr r16, r20
	ctx.r[16].u64 = ctx.r[20].u64;
	// 828E38B4: 92810088  stw r20, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[20].u32 ) };
	// 828E38B8: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 828E38BC: 9281008C  stw r20, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[20].u32 ) };
	// 828E38C0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828E38C4: 92010084  stw r16, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[16].u32 ) };
	// 828E38C8: 419A0014  beq cr6, 0x828e38dc
	if ctx.cr[6].eq {
	pc = 0x828E38DC; continue 'dispatch;
	}
	// 828E38CC: 3885000C  addi r4, r5, 0xc
	ctx.r[4].s64 = ctx.r[5].s64 + 12;
	// 828E38D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E38D4: 4800151D  bl 0x828e4df0
	ctx.lr = 0x828E38D8;
	sub_828E4DF0(ctx, base);
	// 828E38D8: 82010084  lwz r16, 0x84(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E38DC: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E38E0: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 828E38E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E38E8: 419A0038  beq cr6, 0x828e3920
	if ctx.cr[6].eq {
	pc = 0x828E3920; continue 'dispatch;
	}
	// 828E38EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E38F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E38F4: 419A0080  beq cr6, 0x828e3974
	if ctx.cr[6].eq {
	pc = 0x828E3974; continue 'dispatch;
	}
	// 828E38F8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E38FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3900: 419A0020  beq cr6, 0x828e3920
	if ctx.cr[6].eq {
	pc = 0x828E3920; continue 'dispatch;
	}
	// 828E3904: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828E3908: 4B890531  bl 0x82173e38
	ctx.lr = 0x828E390C;
	sub_82173E38(ctx, base);
	// 828E390C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E3910: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E3914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3918: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E391C: 409A0008  bne cr6, 0x828e3924
	if !ctx.cr[6].eq {
	pc = 0x828E3924; continue 'dispatch;
	}
	// 828E3920: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3924: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E392C: 419A0138  beq cr6, 0x828e3a64
	if ctx.cr[6].eq {
	pc = 0x828E3A64; continue 'dispatch;
	}
	// 828E3930: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828E3934: 4B890505  bl 0x82173e38
	ctx.lr = 0x828E3938;
	sub_82173E38(ctx, base);
	// 828E3938: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E393C: 556A8FFE  rlwinm r10, r11, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 828E3940: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3944: 419A0100  beq cr6, 0x828e3a44
	if ctx.cr[6].eq {
	pc = 0x828E3A44; continue 'dispatch;
	}
	// 828E3948: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E394C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3950: 419A0030  beq cr6, 0x828e3980
	if ctx.cr[6].eq {
	pc = 0x828E3980; continue 'dispatch;
	}
	// 828E3954: 894B000F  lbz r10, 0xf(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 828E3958: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E395C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E3960: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E3964: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3968: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E396C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3970: 480000D8  b 0x828e3a48
	pc = 0x828E3A48; continue 'dispatch;
	// 828E3974: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828E3978: 4B8B04C1  bl 0x82193e38
	ctx.lr = 0x828E397C;
	sub_82193E38(ctx, base);
	// 828E397C: 4BFFFFA4  b 0x828e3920
	pc = 0x828E3920; continue 'dispatch;
	// 828E3980: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3984: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3988: 92810058  stw r20, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 828E398C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E3990: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E3994: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3998: 40810054  ble 0x828e39ec
	if !ctx.cr[0].gt {
	pc = 0x828E39EC; continue 'dispatch;
	}
	// 828E399C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E39A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E39A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E39A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E39AC: 2F07000F  cmpwi cr6, r7, 0xf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 15, &mut ctx.xer);
	// 828E39B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E39B4: 41980008  blt cr6, 0x828e39bc
	if ctx.cr[6].lt {
	pc = 0x828E39BC; continue 'dispatch;
	}
	// 828E39B8: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 828E39BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E39C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E39C4: 419A0014  beq cr6, 0x828e39d8
	if ctx.cr[6].eq {
	pc = 0x828E39D8; continue 'dispatch;
	}
	// 828E39C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E39CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E39D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E39D4: 4800000C  b 0x828e39e0
	pc = 0x828E39E0; continue 'dispatch;
	// 828E39D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E39DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E39E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E39E4: 4199FFB8  bgt cr6, 0x828e399c
	if ctx.cr[6].gt {
	pc = 0x828E399C; continue 'dispatch;
	}
	// 828E39E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E39EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E39F0: 419A0040  beq cr6, 0x828e3a30
	if ctx.cr[6].eq {
	pc = 0x828E3A30; continue 'dispatch;
	}
	// 828E39F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E39F8: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 828E39FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3A00: 41990008  bgt cr6, 0x828e3a08
	if ctx.cr[6].gt {
	pc = 0x828E3A08; continue 'dispatch;
	}
	// 828E3A04: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3A08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3A10: 409A0020  bne cr6, 0x828e3a30
	if !ctx.cr[6].eq {
	pc = 0x828E3A30; continue 'dispatch;
	}
	// 828E3A14: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E3A18: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E3A1C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E3A20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3A24: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E3A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3A2C: 4800001C  b 0x828e3a48
	pc = 0x828E3A48; continue 'dispatch;
	// 828E3A30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E3A34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3A38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E3A3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3A40: 48000008  b 0x828e3a48
	pc = 0x828E3A48; continue 'dispatch;
	// 828E3A44: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3A48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3A50: 419A0014  beq cr6, 0x828e3a64
	if ctx.cr[6].eq {
	pc = 0x828E3A64; continue 'dispatch;
	}
	// 828E3A54: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828E3A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3A5C: 4BBE0BF5  bl 0x824c4650
	ctx.lr = 0x828E3A60;
	sub_824C4650(ctx, base);
	// 828E3A60: 82010084  lwz r16, 0x84(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E3A64: 81720024  lwz r11, 0x24(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E3A68: 7E93A378  mr r19, r20
	ctx.r[19].u64 = ctx.r[20].u64;
	// 828E3A6C: 7E95A378  mr r21, r20
	ctx.r[21].u64 = ctx.r[20].u64;
	// 828E3A70: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828E3A74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3A78: 419A00F4  beq cr6, 0x828e3b6c
	if ctx.cr[6].eq {
	pc = 0x828E3B6C; continue 'dispatch;
	}
	// 828E3A7C: 8172008C  lwz r11, 0x8c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E3A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3A84: 419A0024  beq cr6, 0x828e3aa8
	if ctx.cr[6].eq {
	pc = 0x828E3AA8; continue 'dispatch;
	}
	// 828E3A88: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E3A8C: 81720048  lwz r11, 0x48(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3A90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E3A94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E3A98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3A9C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E3AA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3AA4: 480000CC  b 0x828e3b70
	pc = 0x828E3B70; continue 'dispatch;
	// 828E3AA8: 81520048  lwz r10, 0x48(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E3AAC: 80D2004C  lwz r6, 0x4c(r18)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E3AB0: 92810058  stw r20, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 828E3AB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E3AB8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E3ABC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3AC0: 40810054  ble 0x828e3b14
	if !ctx.cr[0].gt {
	pc = 0x828E3B14; continue 'dispatch;
	}
	// 828E3AC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E3AC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E3ACC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E3AD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3AD4: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828E3AD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E3ADC: 41980008  blt cr6, 0x828e3ae4
	if ctx.cr[6].lt {
	pc = 0x828E3AE4; continue 'dispatch;
	}
	// 828E3AE0: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 828E3AE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E3AE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E3AEC: 419A0014  beq cr6, 0x828e3b00
	if ctx.cr[6].eq {
	pc = 0x828E3B00; continue 'dispatch;
	}
	// 828E3AF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E3AF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E3AF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E3AFC: 4800000C  b 0x828e3b08
	pc = 0x828E3B08; continue 'dispatch;
	// 828E3B00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E3B04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E3B08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3B0C: 4199FFB8  bgt cr6, 0x828e3ac4
	if ctx.cr[6].gt {
	pc = 0x828E3AC4; continue 'dispatch;
	}
	// 828E3B10: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E3B14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E3B18: 419A0040  beq cr6, 0x828e3b58
	if ctx.cr[6].eq {
	pc = 0x828E3B58; continue 'dispatch;
	}
	// 828E3B1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3B20: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828E3B24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3B28: 41990008  bgt cr6, 0x828e3b30
	if ctx.cr[6].gt {
	pc = 0x828E3B30; continue 'dispatch;
	}
	// 828E3B2C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3B30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3B38: 409A0020  bne cr6, 0x828e3b58
	if !ctx.cr[6].eq {
	pc = 0x828E3B58; continue 'dispatch;
	}
	// 828E3B3C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E3B40: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E3B44: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E3B48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3B4C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E3B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3B54: 4800001C  b 0x828e3b70
	pc = 0x828E3B70; continue 'dispatch;
	// 828E3B58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E3B5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3B60: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E3B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3B68: 48000008  b 0x828e3b70
	pc = 0x828E3B70; continue 'dispatch;
	// 828E3B6C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3B70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3B78: 419A0008  beq cr6, 0x828e3b80
	if ctx.cr[6].eq {
	pc = 0x828E3B80; continue 'dispatch;
	}
	// 828E3B7C: 82750028  lwz r19, 0x28(r21)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E3B80: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828E3B84: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 828E3B88: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 828E3B8C: 7D505850  subf r10, r16, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[16].s64;
	// 828E3B90: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828E3B94: 7D4B2671  srawi. r11, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3B98: 4182036C  beq 0x828e3f04
	if ctx.cr[0].eq {
	pc = 0x828E3F04; continue 'dispatch;
	}
	// 828E3B9C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828E3BA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3BA4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828E3BA8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828E3BAC: 7E1D8378  mr r29, r16
	ctx.r[29].u64 = ctx.r[16].u64;
	// 828E3BB0: 3B8B0EBC  addi r28, r11, 0xebc
	ctx.r[28].s64 = ctx.r[11].s64 + 3772;
	// 828E3BB4: 3B4A24C8  addi r26, r10, 0x24c8
	ctx.r[26].s64 = ctx.r[10].s64 + 9416;
	// 828E3BB8: 3B293E48  addi r25, r9, 0x3e48
	ctx.r[25].s64 = ctx.r[9].s64 + 15944;
	// 828E3BBC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3BC0: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 828E3BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3BC8: 419A0010  beq cr6, 0x828e3bd8
	if ctx.cr[6].eq {
	pc = 0x828E3BD8; continue 'dispatch;
	}
	// 828E3BCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3BD0: 4BCDFD09  bl 0x825c38d8
	ctx.lr = 0x828E3BD4;
	sub_825C38D8(ctx, base);
	// 828E3BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3BD8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E3BDC: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 828E3BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3BE4: 419A0010  beq cr6, 0x828e3bf4
	if ctx.cr[6].eq {
	pc = 0x828E3BF4; continue 'dispatch;
	}
	// 828E3BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3BEC: 4BCDFCED  bl 0x825c38d8
	ctx.lr = 0x828E3BF0;
	sub_825C38D8(ctx, base);
	// 828E3BF0: 7C7FFB78  or r31, r3, r31
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[31].u64;
	// 828E3BF4: 81710040  lwz r11, 0x40(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(64 as u32) ) } as u64;
	// 828E3BF8: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3BFC: 7D6AFB78  or r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 828E3C00: 91510040  stw r10, 0x40(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 828E3C04: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3C08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E3C0C: 419A0040  beq cr6, 0x828e3c4c
	if ctx.cr[6].eq {
	pc = 0x828E3C4C; continue 'dispatch;
	}
	// 828E3C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3C14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3C18: 4B8CE8E1  bl 0x821b24f8
	ctx.lr = 0x828E3C1C;
	sub_821B24F8(ctx, base);
	// 828E3C1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3C20: 4BB8EBE1  bl 0x82472800
	ctx.lr = 0x828E3C24;
	sub_82472800(ctx, base);
	// 828E3C24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3C28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3C2C: 419A0020  beq cr6, 0x828e3c4c
	if ctx.cr[6].eq {
	pc = 0x828E3C4C; continue 'dispatch;
	}
	// 828E3C30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3C34: 4BCBC745  bl 0x825a0378
	ctx.lr = 0x828E3C38;
	sub_825A0378(ctx, base);
	// 828E3C38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828E3C3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3C40: 38910028  addi r4, r17, 0x28
	ctx.r[4].s64 = ctx.r[17].s64 + 40;
	// 828E3C44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E3C48: 4BB8FC59  bl 0x824738a0
	ctx.lr = 0x828E3C4C;
	sub_824738A0(ctx, base);
	// 828E3C4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3C50: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3C58: 419A0054  beq cr6, 0x828e3cac
	if ctx.cr[6].eq {
	pc = 0x828E3CAC; continue 'dispatch;
	}
	// 828E3C5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3C60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3C64: 4B8CE895  bl 0x821b24f8
	ctx.lr = 0x828E3C68;
	sub_821B24F8(ctx, base);
	// 828E3C68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3C6C: 4BB8EB95  bl 0x82472800
	ctx.lr = 0x828E3C70;
	sub_82472800(ctx, base);
	// 828E3C70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3C74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3C78: 419A0034  beq cr6, 0x828e3cac
	if ctx.cr[6].eq {
	pc = 0x828E3CAC; continue 'dispatch;
	}
	// 828E3C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3C80: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3C84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3C88: 4B8CE871  bl 0x821b24f8
	ctx.lr = 0x828E3C8C;
	sub_821B24F8(ctx, base);
	// 828E3C8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3C90: 4BB8EB71  bl 0x82472800
	ctx.lr = 0x828E3C94;
	sub_82472800(ctx, base);
	// 828E3C94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3C98: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E3C9C: 38910028  addi r4, r17, 0x28
	ctx.r[4].s64 = ctx.r[17].s64 + 40;
	// 828E3CA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E3CA4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E3CA8: 4BB8FBF9  bl 0x824738a0
	ctx.lr = 0x828E3CAC;
	sub_824738A0(ctx, base);
	// 828E3CAC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3CB0: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3CB8: 419A0024  beq cr6, 0x828e3cdc
	if ctx.cr[6].eq {
	pc = 0x828E3CDC; continue 'dispatch;
	}
	// 828E3CBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3CC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3CC4: 4B8CE835  bl 0x821b24f8
	ctx.lr = 0x828E3CC8;
	sub_821B24F8(ctx, base);
	// 828E3CC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3CCC: 4BB8EB35  bl 0x82472800
	ctx.lr = 0x828E3CD0;
	sub_82472800(ctx, base);
	// 828E3CD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3CD4: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 828E3CD8: 419A003C  beq cr6, 0x828e3d14
	if ctx.cr[6].eq {
	pc = 0x828E3D14; continue 'dispatch;
	}
	// 828E3CDC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3CE0: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3CE8: 419A0024  beq cr6, 0x828e3d0c
	if ctx.cr[6].eq {
	pc = 0x828E3D0C; continue 'dispatch;
	}
	// 828E3CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3CF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3CF4: 4B8CE805  bl 0x821b24f8
	ctx.lr = 0x828E3CF8;
	sub_821B24F8(ctx, base);
	// 828E3CF8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3CFC: 4BB8EB05  bl 0x82472800
	ctx.lr = 0x828E3D00;
	sub_82472800(ctx, base);
	// 828E3D00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3D04: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 828E3D08: 419A000C  beq cr6, 0x828e3d14
	if ctx.cr[6].eq {
	pc = 0x828E3D14; continue 'dispatch;
	}
	// 828E3D0C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3D10: 48000008  b 0x828e3d18
	pc = 0x828E3D18; continue 'dispatch;
	// 828E3D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3D18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3D20: 419A006C  beq cr6, 0x828e3d8c
	if ctx.cr[6].eq {
	pc = 0x828E3D8C; continue 'dispatch;
	}
	// 828E3D24: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 828E3D28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E3D2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E3D30: 4BCBC701  bl 0x825a0430
	ctx.lr = 0x828E3D34;
	sub_825A0430(ctx, base);
	// 828E3D34: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828E3D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3D3C: 419A0050  beq cr6, 0x828e3d8c
	if ctx.cr[6].eq {
	pc = 0x828E3D8C; continue 'dispatch;
	}
	// 828E3D40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E3D44: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3D48: 4B8CE7B1  bl 0x821b24f8
	ctx.lr = 0x828E3D4C;
	sub_821B24F8(ctx, base);
	// 828E3D4C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828E3D50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3D54: 4BCAF685  bl 0x825933d8
	ctx.lr = 0x828E3D58;
	sub_825933D8(ctx, base);
	// 828E3D58: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E3D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3D60: 419A002C  beq cr6, 0x828e3d8c
	if ctx.cr[6].eq {
	pc = 0x828E3D8C; continue 'dispatch;
	}
	// 828E3D64: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3D68: 7F0B9800  cmpw cr6, r11, r19
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[19].s32, &mut ctx.xer);
	// 828E3D6C: 409A0020  bne cr6, 0x828e3d8c
	if !ctx.cr[6].eq {
	pc = 0x828E3D8C; continue 'dispatch;
	}
	// 828E3D70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E3D74: 4B8CE785  bl 0x821b24f8
	ctx.lr = 0x828E3D78;
	sub_821B24F8(ctx, base);
	// 828E3D78: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E3D7C: 4B8B2E05  bl 0x82196b80
	ctx.lr = 0x828E3D80;
	sub_82196B80(ctx, base);
	// 828E3D80: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E3D84: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E3D88: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E3D8C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3D90: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3D94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3D98: 419A0024  beq cr6, 0x828e3dbc
	if ctx.cr[6].eq {
	pc = 0x828E3DBC; continue 'dispatch;
	}
	// 828E3D9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3DA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3DA4: 4B8CE755  bl 0x821b24f8
	ctx.lr = 0x828E3DA8;
	sub_821B24F8(ctx, base);
	// 828E3DA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3DAC: 4BB8EA55  bl 0x82472800
	ctx.lr = 0x828E3DB0;
	sub_82472800(ctx, base);
	// 828E3DB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3DB4: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 828E3DB8: 419A003C  beq cr6, 0x828e3df4
	if ctx.cr[6].eq {
	pc = 0x828E3DF4; continue 'dispatch;
	}
	// 828E3DBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3DC0: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3DC8: 419A0024  beq cr6, 0x828e3dec
	if ctx.cr[6].eq {
	pc = 0x828E3DEC; continue 'dispatch;
	}
	// 828E3DCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3DD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3DD4: 4B8CE725  bl 0x821b24f8
	ctx.lr = 0x828E3DD8;
	sub_821B24F8(ctx, base);
	// 828E3DD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3DDC: 4BB8EA25  bl 0x82472800
	ctx.lr = 0x828E3DE0;
	sub_82472800(ctx, base);
	// 828E3DE0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3DE4: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 828E3DE8: 419A000C  beq cr6, 0x828e3df4
	if ctx.cr[6].eq {
	pc = 0x828E3DF4; continue 'dispatch;
	}
	// 828E3DEC: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3DF0: 48000008  b 0x828e3df8
	pc = 0x828E3DF8; continue 'dispatch;
	// 828E3DF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3DF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3E00: 419A0008  beq cr6, 0x828e3e08
	if ctx.cr[6].eq {
	pc = 0x828E3E08; continue 'dispatch;
	}
	// 828E3E04: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828E3E08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3E0C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3E10: 419A0024  beq cr6, 0x828e3e34
	if ctx.cr[6].eq {
	pc = 0x828E3E34; continue 'dispatch;
	}
	// 828E3E14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3E18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3E1C: 4B8CE6DD  bl 0x821b24f8
	ctx.lr = 0x828E3E20;
	sub_821B24F8(ctx, base);
	// 828E3E20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3E24: 4BB8E9DD  bl 0x82472800
	ctx.lr = 0x828E3E28;
	sub_82472800(ctx, base);
	// 828E3E28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3E2C: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 828E3E30: 419A003C  beq cr6, 0x828e3e6c
	if ctx.cr[6].eq {
	pc = 0x828E3E6C; continue 'dispatch;
	}
	// 828E3E34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3E38: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3E40: 419A0024  beq cr6, 0x828e3e64
	if ctx.cr[6].eq {
	pc = 0x828E3E64; continue 'dispatch;
	}
	// 828E3E44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3E48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3E4C: 4B8CE6AD  bl 0x821b24f8
	ctx.lr = 0x828E3E50;
	sub_821B24F8(ctx, base);
	// 828E3E50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3E54: 4BB8E9AD  bl 0x82472800
	ctx.lr = 0x828E3E58;
	sub_82472800(ctx, base);
	// 828E3E58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3E5C: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 828E3E60: 419A000C  beq cr6, 0x828e3e6c
	if ctx.cr[6].eq {
	pc = 0x828E3E6C; continue 'dispatch;
	}
	// 828E3E64: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3E68: 48000008  b 0x828e3e70
	pc = 0x828E3E70; continue 'dispatch;
	// 828E3E6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3E70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3E78: 419A0008  beq cr6, 0x828e3e80
	if ctx.cr[6].eq {
	pc = 0x828E3E80; continue 'dispatch;
	}
	// 828E3E7C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 828E3E80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3E84: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3E88: 419A0024  beq cr6, 0x828e3eac
	if ctx.cr[6].eq {
	pc = 0x828E3EAC; continue 'dispatch;
	}
	// 828E3E8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E3E90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3E94: 4B8CE665  bl 0x821b24f8
	ctx.lr = 0x828E3E98;
	sub_821B24F8(ctx, base);
	// 828E3E98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3E9C: 4BB8E965  bl 0x82472800
	ctx.lr = 0x828E3EA0;
	sub_82472800(ctx, base);
	// 828E3EA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3EA4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828E3EA8: 419A003C  beq cr6, 0x828e3ee4
	if ctx.cr[6].eq {
	pc = 0x828E3EE4; continue 'dispatch;
	}
	// 828E3EAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3EB0: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828E3EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3EB8: 419A0024  beq cr6, 0x828e3edc
	if ctx.cr[6].eq {
	pc = 0x828E3EDC; continue 'dispatch;
	}
	// 828E3EBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3EC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3EC4: 4B8CE635  bl 0x821b24f8
	ctx.lr = 0x828E3EC8;
	sub_821B24F8(ctx, base);
	// 828E3EC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E3ECC: 4BB8E935  bl 0x82472800
	ctx.lr = 0x828E3ED0;
	sub_82472800(ctx, base);
	// 828E3ED0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3ED4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828E3ED8: 419A000C  beq cr6, 0x828e3ee4
	if ctx.cr[6].eq {
	pc = 0x828E3EE4; continue 'dispatch;
	}
	// 828E3EDC: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E3EE0: 48000008  b 0x828e3ee8
	pc = 0x828E3EE8; continue 'dispatch;
	// 828E3EE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E3EE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E3EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3EF0: 419A0008  beq cr6, 0x828e3ef8
	if ctx.cr[6].eq {
	pc = 0x828E3EF8; continue 'dispatch;
	}
	// 828E3EF4: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 828E3EF8: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828E3EFC: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828E3F00: 4082FCBC  bne 0x828e3bbc
	if !ctx.cr[0].eq {
	pc = 0x828E3BBC; continue 'dispatch;
	}
	// 828E3F04: 570A063E  clrlwi r10, r24, 0x18
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 828E3F08: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E3F0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E3F10: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 828E3F14: 419A0058  beq cr6, 0x828e3f6c
	if ctx.cr[6].eq {
	pc = 0x828E3F6C; continue 'dispatch;
	}
	// 828E3F18: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E3F1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E3F20: 388B3E58  addi r4, r11, 0x3e58
	ctx.r[4].s64 = ctx.r[11].s64 + 15960;
	// 828E3F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F28: 4B948FA9  bl 0x8222ced0
	ctx.lr = 0x828E3F2C;
	sub_8222CED0(ctx, base);
	// 828E3F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F30: 4BCBC0E9  bl 0x825a0018
	ctx.lr = 0x828E3F34;
	sub_825A0018(ctx, base);
	// 828E3F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F38: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E3F3C: 4B8E282D  bl 0x821c6768
	ctx.lr = 0x828E3F40;
	sub_821C6768(ctx, base);
	// 828E3F40: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828E3F44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E3F48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3F4C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E3F50: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E3F54: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E3F58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3F5C: 4082FFE8  bne 0x828e3f44
	if !ctx.cr[0].eq {
	pc = 0x828E3F44; continue 'dispatch;
	}
	// 828E3F60: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E3F64: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E3F68: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E3F6C: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 828E3F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3F74: 419A0058  beq cr6, 0x828e3fcc
	if ctx.cr[6].eq {
	pc = 0x828E3FCC; continue 'dispatch;
	}
	// 828E3F78: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E3F7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E3F80: 388B3E74  addi r4, r11, 0x3e74
	ctx.r[4].s64 = ctx.r[11].s64 + 15988;
	// 828E3F84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F88: 4B948F49  bl 0x8222ced0
	ctx.lr = 0x828E3F8C;
	sub_8222CED0(ctx, base);
	// 828E3F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F90: 4BCBC089  bl 0x825a0018
	ctx.lr = 0x828E3F94;
	sub_825A0018(ctx, base);
	// 828E3F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F98: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E3F9C: 4B8E27CD  bl 0x821c6768
	ctx.lr = 0x828E3FA0;
	sub_821C6768(ctx, base);
	// 828E3FA0: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828E3FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E3FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3FAC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E3FB0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E3FB4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E3FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3FBC: 4082FFE8  bne 0x828e3fa4
	if !ctx.cr[0].eq {
	pc = 0x828E3FA4; continue 'dispatch;
	}
	// 828E3FC0: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E3FC4: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E3FC8: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E3FCC: 56CB063E  clrlwi r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 828E3FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3FD4: 419A0054  beq cr6, 0x828e4028
	if ctx.cr[6].eq {
	pc = 0x828E4028; continue 'dispatch;
	}
	// 828E3FD8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E3FDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E3FE0: 388B3E90  addi r4, r11, 0x3e90
	ctx.r[4].s64 = ctx.r[11].s64 + 16016;
	// 828E3FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3FE8: 4B948EE9  bl 0x8222ced0
	ctx.lr = 0x828E3FEC;
	sub_8222CED0(ctx, base);
	// 828E3FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3FF0: 4BCBC029  bl 0x825a0018
	ctx.lr = 0x828E3FF4;
	sub_825A0018(ctx, base);
	// 828E3FF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3FF8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E3FFC: 4B8E276D  bl 0x821c6768
	ctx.lr = 0x828E4000;
	sub_821C6768(ctx, base);
	// 828E4000: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4004: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4008: 7D40F828  lwarx r10, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E400C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E4010: 7D40F92D  stwcx. r10, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4014: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4018: 4082FFE8  bne 0x828e4000
	if !ctx.cr[0].eq {
	pc = 0x828E4000; continue 'dispatch;
	}
	// 828E401C: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E4020: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E4024: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E4028: 81720024  lwz r11, 0x24(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E402C: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828E4030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4034: 419A00F4  beq cr6, 0x828e4128
	if ctx.cr[6].eq {
	pc = 0x828E4128; continue 'dispatch;
	}
	// 828E4038: 8172008C  lwz r11, 0x8c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E403C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4040: 419A0024  beq cr6, 0x828e4064
	if ctx.cr[6].eq {
	pc = 0x828E4064; continue 'dispatch;
	}
	// 828E4044: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4048: 81720048  lwz r11, 0x48(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E404C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E4050: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E4054: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4058: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E405C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4060: 480000CC  b 0x828e412c
	pc = 0x828E412C; continue 'dispatch;
	// 828E4064: 81520048  lwz r10, 0x48(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4068: 80D2004C  lwz r6, 0x4c(r18)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E406C: 92810060  stw r20, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[20].u32 ) };
	// 828E4070: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E4074: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E4078: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E407C: 40810054  ble 0x828e40d0
	if !ctx.cr[0].gt {
	pc = 0x828E40D0; continue 'dispatch;
	}
	// 828E4080: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4084: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4088: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828E408C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4090: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828E4094: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4098: 41980008  blt cr6, 0x828e40a0
	if ctx.cr[6].lt {
	pc = 0x828E40A0; continue 'dispatch;
	}
	// 828E409C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 828E40A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E40A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E40A8: 419A0014  beq cr6, 0x828e40bc
	if ctx.cr[6].eq {
	pc = 0x828E40BC; continue 'dispatch;
	}
	// 828E40AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E40B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E40B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E40B8: 4800000C  b 0x828e40c4
	pc = 0x828E40C4; continue 'dispatch;
	// 828E40BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E40C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E40C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E40C8: 4199FFB8  bgt cr6, 0x828e4080
	if ctx.cr[6].gt {
	pc = 0x828E4080; continue 'dispatch;
	}
	// 828E40CC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E40D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E40D4: 419A0040  beq cr6, 0x828e4114
	if ctx.cr[6].eq {
	pc = 0x828E4114; continue 'dispatch;
	}
	// 828E40D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E40DC: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828E40E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E40E4: 41990008  bgt cr6, 0x828e40ec
	if ctx.cr[6].gt {
	pc = 0x828E40EC; continue 'dispatch;
	}
	// 828E40E8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E40EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E40F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E40F4: 409A0020  bne cr6, 0x828e4114
	if !ctx.cr[6].eq {
	pc = 0x828E4114; continue 'dispatch;
	}
	// 828E40F8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E40FC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E4100: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E4104: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4108: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E410C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4110: 4800001C  b 0x828e412c
	pc = 0x828E412C; continue 'dispatch;
	// 828E4114: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E4118: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E411C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828E4120: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4124: 48000008  b 0x828e412c
	pc = 0x828E412C; continue 'dispatch;
	// 828E4128: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828E412C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4134: 419A009C  beq cr6, 0x828e41d0
	if ctx.cr[6].eq {
	pc = 0x828E41D0; continue 'dispatch;
	}
	// 828E4138: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 828E413C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828E4140: 4B9594B9  bl 0x8223d5f8
	ctx.lr = 0x828E4144;
	sub_8223D5F8(ctx, base);
	// 828E4144: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E414C: 419A0038  beq cr6, 0x828e4184
	if ctx.cr[6].eq {
	pc = 0x828E4184; continue 'dispatch;
	}
	// 828E4150: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E4154: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E4158: 388B3EA8  addi r4, r11, 0x3ea8
	ctx.r[4].s64 = ctx.r[11].s64 + 16040;
	// 828E415C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4160: 4B948D71  bl 0x8222ced0
	ctx.lr = 0x828E4164;
	sub_8222CED0(ctx, base);
	// 828E4164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4168: 4BCBBEB1  bl 0x825a0018
	ctx.lr = 0x828E416C;
	sub_825A0018(ctx, base);
	// 828E416C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4170: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E4174: 4B930C65  bl 0x82214dd8
	ctx.lr = 0x828E4178;
	sub_82214DD8(ctx, base);
	// 828E4178: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E417C: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E4180: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E4184: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 828E4188: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828E418C: 4B95946D  bl 0x8223d5f8
	ctx.lr = 0x828E4190;
	sub_8223D5F8(ctx, base);
	// 828E4190: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4198: 419A0038  beq cr6, 0x828e41d0
	if ctx.cr[6].eq {
	pc = 0x828E41D0; continue 'dispatch;
	}
	// 828E419C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E41A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E41A4: 388B3EC4  addi r4, r11, 0x3ec4
	ctx.r[4].s64 = ctx.r[11].s64 + 16068;
	// 828E41A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E41AC: 4B948D25  bl 0x8222ced0
	ctx.lr = 0x828E41B0;
	sub_8222CED0(ctx, base);
	// 828E41B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E41B4: 4BCBBE65  bl 0x825a0018
	ctx.lr = 0x828E41B8;
	sub_825A0018(ctx, base);
	// 828E41B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E41BC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E41C0: 4B930C19  bl 0x82214dd8
	ctx.lr = 0x828E41C4;
	sub_82214DD8(ctx, base);
	// 828E41C4: C0110038  lfs f0, 0x38(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E41C8: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828E41CC: D1B10038  stfs f13, 0x38(r17)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828E41D0: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 828E41D4: 419A000C  beq cr6, 0x828e41e0
	if ctx.cr[6].eq {
	pc = 0x828E41E0; continue 'dispatch;
	}
	// 828E41D8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828E41DC: 4B937B5D  bl 0x8221bd38
	ctx.lr = 0x828E41E0;
	sub_8221BD38(ctx, base);
	// 828E41E0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 828E41E4: CBE1FF70  lfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 828E41E8: 483C5240  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E41F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E41F0 size=724
    let mut pc: u32 = 0x828E41F0;
    'dispatch: loop {
        match pc {
            0x828E41F0 => {
    //   block [0x828E41F0..0x828E44C4)
	// 828E41F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E41F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E41F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E41FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4200: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E4204: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4208: 80A30024  lwz r5, 0x24(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E420C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E4210: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E4214: 54AA67FE  rlwinm r10, r5, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000FFFFFu64;
	// 828E4218: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E421C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4220: 419A00E8  beq cr6, 0x828e4308
	if ctx.cr[6].eq {
	pc = 0x828E4308; continue 'dispatch;
	}
	// 828E4224: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E422C: 419A0020  beq cr6, 0x828e424c
	if ctx.cr[6].eq {
	pc = 0x828E424C; continue 'dispatch;
	}
	// 828E4230: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4234: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4238: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E423C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E4240: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4244: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4248: 480000C4  b 0x828e430c
	pc = 0x828E430C; continue 'dispatch;
	// 828E424C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4250: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4254: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E4258: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E425C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4260: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4264: 40810054  ble 0x828e42b8
	if !ctx.cr[0].gt {
	pc = 0x828E42B8; continue 'dispatch;
	}
	// 828E4268: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E426C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4270: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4274: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4278: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828E427C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4280: 41980008  blt cr6, 0x828e4288
	if ctx.cr[6].lt {
	pc = 0x828E4288; continue 'dispatch;
	}
	// 828E4284: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E4288: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E428C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4290: 419A0014  beq cr6, 0x828e42a4
	if ctx.cr[6].eq {
	pc = 0x828E42A4; continue 'dispatch;
	}
	// 828E4294: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4298: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E429C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E42A0: 4800000C  b 0x828e42ac
	pc = 0x828E42AC; continue 'dispatch;
	// 828E42A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E42A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E42AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E42B0: 4199FFB8  bgt cr6, 0x828e4268
	if ctx.cr[6].gt {
	pc = 0x828E4268; continue 'dispatch;
	}
	// 828E42B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E42B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E42BC: 419A003C  beq cr6, 0x828e42f8
	if ctx.cr[6].eq {
	pc = 0x828E42F8; continue 'dispatch;
	}
	// 828E42C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E42C4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828E42C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E42CC: 41990008  bgt cr6, 0x828e42d4
	if ctx.cr[6].gt {
	pc = 0x828E42D4; continue 'dispatch;
	}
	// 828E42D0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E42D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E42DC: 409A001C  bne cr6, 0x828e42f8
	if !ctx.cr[6].eq {
	pc = 0x828E42F8; continue 'dispatch;
	}
	// 828E42E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E42E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E42E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E42EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E42F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E42F4: 48000018  b 0x828e430c
	pc = 0x828E430C; continue 'dispatch;
	// 828E42F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E42FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4300: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4304: 48000008  b 0x828e430c
	pc = 0x828E430C; continue 'dispatch;
	// 828E4308: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828E430C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E4310: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4314: 419A0194  beq cr6, 0x828e44a8
	if ctx.cr[6].eq {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E4318: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E431C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E4320: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4324: 419A0184  beq cr6, 0x828e44a8
	if ctx.cr[6].eq {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E4328: 54AB5FFE  rlwinm r11, r5, 0xb, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x001FFFFFu64;
	// 828E432C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828E4330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4334: 419A00E4  beq cr6, 0x828e4418
	if ctx.cr[6].eq {
	pc = 0x828E4418; continue 'dispatch;
	}
	// 828E4338: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E433C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4344: 419A001C  beq cr6, 0x828e4360
	if ctx.cr[6].eq {
	pc = 0x828E4360; continue 'dispatch;
	}
	// 828E4348: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828E434C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E4350: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E4354: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4358: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E435C: 480000C0  b 0x828e441c
	pc = 0x828E441C; continue 'dispatch;
	// 828E4360: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4364: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E4368: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E436C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4370: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4374: 40810054  ble 0x828e43c8
	if !ctx.cr[0].gt {
	pc = 0x828E43C8; continue 'dispatch;
	}
	// 828E4378: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E437C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4380: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4384: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4388: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828E438C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4390: 41980008  blt cr6, 0x828e4398
	if ctx.cr[6].lt {
	pc = 0x828E4398; continue 'dispatch;
	}
	// 828E4394: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E4398: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E439C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E43A0: 419A0014  beq cr6, 0x828e43b4
	if ctx.cr[6].eq {
	pc = 0x828E43B4; continue 'dispatch;
	}
	// 828E43A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E43A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E43AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E43B0: 4800000C  b 0x828e43bc
	pc = 0x828E43BC; continue 'dispatch;
	// 828E43B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E43B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E43BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E43C0: 4199FFB8  bgt cr6, 0x828e4378
	if ctx.cr[6].gt {
	pc = 0x828E4378; continue 'dispatch;
	}
	// 828E43C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E43C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E43CC: 419A003C  beq cr6, 0x828e4408
	if ctx.cr[6].eq {
	pc = 0x828E4408; continue 'dispatch;
	}
	// 828E43D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E43D4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828E43D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E43DC: 41990008  bgt cr6, 0x828e43e4
	if ctx.cr[6].gt {
	pc = 0x828E43E4; continue 'dispatch;
	}
	// 828E43E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E43E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E43E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E43EC: 409A001C  bne cr6, 0x828e4408
	if !ctx.cr[6].eq {
	pc = 0x828E4408; continue 'dispatch;
	}
	// 828E43F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E43F4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E43F8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E43FC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4404: 48000018  b 0x828e441c
	pc = 0x828E441C; continue 'dispatch;
	// 828E4408: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E440C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4414: 48000008  b 0x828e441c
	pc = 0x828E441C; continue 'dispatch;
	// 828E4418: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E441C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4424: 419A0084  beq cr6, 0x828e44a8
	if ctx.cr[6].eq {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E4428: 38800027  li r4, 0x27
	ctx.r[4].s64 = 39;
	// 828E442C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4430: 4B91B199  bl 0x821ff5c8
	ctx.lr = 0x828E4434;
	sub_821FF5C8(ctx, base);
	// 828E4434: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E443C: 409A0014  bne cr6, 0x828e4450
	if !ctx.cr[6].eq {
	pc = 0x828E4450; continue 'dispatch;
	}
	// 828E4440: 38800027  li r4, 0x27
	ctx.r[4].s64 = 39;
	// 828E4444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4448: 4BB3B561  bl 0x8241f9a8
	ctx.lr = 0x828E444C;
	sub_8241F9A8(ctx, base);
	// 828E444C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828E4450: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E4454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4458: 4B910EC9  bl 0x821f5320
	ctx.lr = 0x828E445C;
	sub_821F5320(ctx, base);
	// 828E445C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E4460: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E4464: 419A0044  beq cr6, 0x828e44a8
	if ctx.cr[6].eq {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E4468: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E446C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4470: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E4474: 4E800421  bctrl
	ctx.lr = 0x828E4478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4478: 2F030027  cmpwi cr6, r3, 0x27
	ctx.cr[6].compare_i32(ctx.r[3].s32, 39, &mut ctx.xer);
	// 828E447C: 409A002C  bne cr6, 0x828e44a8
	if !ctx.cr[6].eq {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E4480: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828E4484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4488: 409A0014  bne cr6, 0x828e449c
	if !ctx.cr[6].eq {
	pc = 0x828E449C; continue 'dispatch;
	}
	// 828E448C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E4490: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E4494: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828E4498: 40980010  bge cr6, 0x828e44a8
	if !ctx.cr[6].lt {
	pc = 0x828E44A8; continue 'dispatch;
	}
	// 828E449C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E44A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E44A4: 4BF7E2B5  bl 0x82862758
	ctx.lr = 0x828E44A8;
	sub_82862758(ctx, base);
	// 828E44A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E44AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E44B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E44B4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E44B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E44BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E44C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E44C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E44C8 size=428
    let mut pc: u32 = 0x828E44C8;
    'dispatch: loop {
        match pc {
            0x828E44C8 => {
    //   block [0x828E44C8..0x828E4674)
	// 828E44C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E44CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E44D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E44D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E44D8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828E44DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E44E0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E44E4: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828E44E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E44EC: 419A0010  beq cr6, 0x828e44fc
	if ctx.cr[6].eq {
	pc = 0x828E44FC; continue 'dispatch;
	}
	// 828E44F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E44F4: 388BB9D4  addi r4, r11, -0x462c
	ctx.r[4].s64 = ctx.r[11].s64 + -17964;
	// 828E44F8: 48000144  b 0x828e463c
	pc = 0x828E463C; continue 'dispatch;
	// 828E44FC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E4500: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828E4504: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E4508: 419A0010  beq cr6, 0x828e4518
	if ctx.cr[6].eq {
	pc = 0x828E4518; continue 'dispatch;
	}
	// 828E450C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E4510: 388B1D50  addi r4, r11, 0x1d50
	ctx.r[4].s64 = ctx.r[11].s64 + 7504;
	// 828E4514: 48000128  b 0x828e463c
	pc = 0x828E463C; continue 'dispatch;
	// 828E4518: 554AB7FE  rlwinm r10, r10, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 828E451C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E4520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4524: 419A00F4  beq cr6, 0x828e4618
	if ctx.cr[6].eq {
	pc = 0x828E4618; continue 'dispatch;
	}
	// 828E4528: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E452C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4530: 419A0024  beq cr6, 0x828e4554
	if ctx.cr[6].eq {
	pc = 0x828E4554; continue 'dispatch;
	}
	// 828E4534: 894A004A  lbz r10, 0x4a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(74 as u32) ) } as u64;
	// 828E4538: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E453C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E4540: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E4544: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4548: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828E454C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4550: 480000CC  b 0x828e461c
	pc = 0x828E461C; continue 'dispatch;
	// 828E4554: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4558: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E455C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828E4560: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E4564: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4568: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E456C: 40810054  ble 0x828e45c0
	if !ctx.cr[0].gt {
	pc = 0x828E45C0; continue 'dispatch;
	}
	// 828E4570: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4574: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4578: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E457C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4580: 2F07004A  cmpwi cr6, r7, 0x4a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 74, &mut ctx.xer);
	// 828E4584: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4588: 41980008  blt cr6, 0x828e4590
	if ctx.cr[6].lt {
	pc = 0x828E4590; continue 'dispatch;
	}
	// 828E458C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828E4590: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E4594: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4598: 419A0014  beq cr6, 0x828e45ac
	if ctx.cr[6].eq {
	pc = 0x828E45AC; continue 'dispatch;
	}
	// 828E459C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E45A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E45A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E45A8: 4800000C  b 0x828e45b4
	pc = 0x828E45B4; continue 'dispatch;
	// 828E45AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E45B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E45B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E45B8: 4199FFB8  bgt cr6, 0x828e4570
	if ctx.cr[6].gt {
	pc = 0x828E4570; continue 'dispatch;
	}
	// 828E45BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E45C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E45C4: 419A0040  beq cr6, 0x828e4604
	if ctx.cr[6].eq {
	pc = 0x828E4604; continue 'dispatch;
	}
	// 828E45C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E45CC: 2F0B004A  cmpwi cr6, r11, 0x4a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 74, &mut ctx.xer);
	// 828E45D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E45D4: 41990008  bgt cr6, 0x828e45dc
	if ctx.cr[6].gt {
	pc = 0x828E45DC; continue 'dispatch;
	}
	// 828E45D8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828E45DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E45E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E45E4: 409A0020  bne cr6, 0x828e4604
	if !ctx.cr[6].eq {
	pc = 0x828E4604; continue 'dispatch;
	}
	// 828E45E8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E45EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E45F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E45F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E45F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828E45FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4600: 4800001C  b 0x828e461c
	pc = 0x828E461C; continue 'dispatch;
	// 828E4604: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E4608: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E460C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828E4610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4614: 48000008  b 0x828e461c
	pc = 0x828E461C; continue 'dispatch;
	// 828E4618: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828E461C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4624: 419A0010  beq cr6, 0x828e4634
	if ctx.cr[6].eq {
	pc = 0x828E4634; continue 'dispatch;
	}
	// 828E4628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E462C: 4BF4A3A5  bl 0x8282e9d0
	ctx.lr = 0x828E4630;
	sub_8282E9D0(ctx, base);
	// 828E4630: 4800002C  b 0x828e465c
	pc = 0x828E465C; continue 'dispatch;
	// 828E4634: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828E4638: 388B52AC  addi r4, r11, 0x52ac
	ctx.r[4].s64 = ctx.r[11].s64 + 21164;
	// 828E463C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E4640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4644: 4B94888D  bl 0x8222ced0
	ctx.lr = 0x828E4648;
	sub_8222CED0(ctx, base);
	// 828E4648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E464C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4650: 4B8B7F99  bl 0x8219c5e8
	ctx.lr = 0x828E4654;
	sub_8219C5E8(ctx, base);
	// 828E4654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4658: 4B930781  bl 0x82214dd8
	ctx.lr = 0x828E465C;
	sub_82214DD8(ctx, base);
	// 828E465C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E466C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E4678 size=632
    let mut pc: u32 = 0x828E4678;
    'dispatch: loop {
        match pc {
            0x828E4678 => {
    //   block [0x828E4678..0x828E48F0)
	// 828E4678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E467C: 483C4D91  bl 0x82ca940c
	ctx.lr = 0x828E4680;
	sub_82CA93D0(ctx, base);
	// 828E4680: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4684: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E4688: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E468C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E4690: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E4694: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828E4698: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E469C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E46A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E46A4: 4BCDF585  bl 0x825c3c28
	ctx.lr = 0x828E46A8;
	sub_825C3C28(ctx, base);
	// 828E46A8: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E46AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E46B0: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 828E46B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E46B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E46BC: 419A00E8  beq cr6, 0x828e47a4
	if ctx.cr[6].eq {
	pc = 0x828E47A4; continue 'dispatch;
	}
	// 828E46C0: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E46C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E46C8: 419A0020  beq cr6, 0x828e46e8
	if ctx.cr[6].eq {
	pc = 0x828E46E8; continue 'dispatch;
	}
	// 828E46CC: 894B0087  lbz r10, 0x87(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(135 as u32) ) } as u64;
	// 828E46D0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E46D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E46D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E46DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E46E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E46E4: 480000C4  b 0x828e47a8
	pc = 0x828E47A8; continue 'dispatch;
	// 828E46E8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E46EC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E46F0: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828E46F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E46F8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E46FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4700: 40810054  ble 0x828e4754
	if !ctx.cr[0].gt {
	pc = 0x828E4754; continue 'dispatch;
	}
	// 828E4704: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4708: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E470C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4710: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4714: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 828E4718: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E471C: 41980008  blt cr6, 0x828e4724
	if ctx.cr[6].lt {
	pc = 0x828E4724; continue 'dispatch;
	}
	// 828E4720: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E4724: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E4728: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E472C: 419A0014  beq cr6, 0x828e4740
	if ctx.cr[6].eq {
	pc = 0x828E4740; continue 'dispatch;
	}
	// 828E4730: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4734: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E4738: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E473C: 4800000C  b 0x828e4748
	pc = 0x828E4748; continue 'dispatch;
	// 828E4740: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E4744: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E4748: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E474C: 4199FFB8  bgt cr6, 0x828e4704
	if ctx.cr[6].gt {
	pc = 0x828E4704; continue 'dispatch;
	}
	// 828E4750: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E4754: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E4758: 419A003C  beq cr6, 0x828e4794
	if ctx.cr[6].eq {
	pc = 0x828E4794; continue 'dispatch;
	}
	// 828E475C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4760: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 828E4764: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4768: 41990008  bgt cr6, 0x828e4770
	if ctx.cr[6].gt {
	pc = 0x828E4770; continue 'dispatch;
	}
	// 828E476C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E4770: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4778: 409A001C  bne cr6, 0x828e4794
	if !ctx.cr[6].eq {
	pc = 0x828E4794; continue 'dispatch;
	}
	// 828E477C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E4780: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4784: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E4788: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E478C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4790: 48000018  b 0x828e47a8
	pc = 0x828E47A8; continue 'dispatch;
	// 828E4794: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E4798: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E479C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E47A0: 48000008  b 0x828e47a8
	pc = 0x828E47A8; continue 'dispatch;
	// 828E47A4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E47A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E47AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E47B0: 419A0020  beq cr6, 0x828e47d0
	if ctx.cr[6].eq {
	pc = 0x828E47D0; continue 'dispatch;
	}
	// 828E47B4: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 828E47B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E47BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E47C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E47C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E47C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E47CC: 4BB4DE0D  bl 0x824325d8
	ctx.lr = 0x828E47D0;
	sub_824325D8(ctx, base);
	// 828E47D0: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E47D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E47D8: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E47DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E47E0: 419A00E8  beq cr6, 0x828e48c8
	if ctx.cr[6].eq {
	pc = 0x828E48C8; continue 'dispatch;
	}
	// 828E47E4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E47E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E47EC: 419A0020  beq cr6, 0x828e480c
	if ctx.cr[6].eq {
	pc = 0x828E480C; continue 'dispatch;
	}
	// 828E47F0: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E47F4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E47F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E47FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E4800: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4804: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4808: 480000C4  b 0x828e48cc
	pc = 0x828E48CC; continue 'dispatch;
	// 828E480C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4810: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4814: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828E4818: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E481C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E4820: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4824: 40810054  ble 0x828e4878
	if !ctx.cr[0].gt {
	pc = 0x828E4878; continue 'dispatch;
	}
	// 828E4828: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E482C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4830: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4834: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4838: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E483C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4840: 41980008  blt cr6, 0x828e4848
	if ctx.cr[6].lt {
	pc = 0x828E4848; continue 'dispatch;
	}
	// 828E4844: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E4848: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E484C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4850: 419A0014  beq cr6, 0x828e4864
	if ctx.cr[6].eq {
	pc = 0x828E4864; continue 'dispatch;
	}
	// 828E4854: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4858: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E485C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E4860: 4800000C  b 0x828e486c
	pc = 0x828E486C; continue 'dispatch;
	// 828E4864: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E4868: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E486C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4870: 4199FFB8  bgt cr6, 0x828e4828
	if ctx.cr[6].gt {
	pc = 0x828E4828; continue 'dispatch;
	}
	// 828E4874: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E4878: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E487C: 419A003C  beq cr6, 0x828e48b8
	if ctx.cr[6].eq {
	pc = 0x828E48B8; continue 'dispatch;
	}
	// 828E4880: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4884: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E4888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E488C: 41990008  bgt cr6, 0x828e4894
	if ctx.cr[6].gt {
	pc = 0x828E4894; continue 'dispatch;
	}
	// 828E4890: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E4894: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E489C: 409A001C  bne cr6, 0x828e48b8
	if !ctx.cr[6].eq {
	pc = 0x828E48B8; continue 'dispatch;
	}
	// 828E48A0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E48A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E48A8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828E48AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E48B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E48B4: 48000018  b 0x828e48cc
	pc = 0x828E48CC; continue 'dispatch;
	// 828E48B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E48BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E48C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E48C4: 48000008  b 0x828e48cc
	pc = 0x828E48CC; continue 'dispatch;
	// 828E48C8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E48CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E48D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E48D4: 419A0014  beq cr6, 0x828e48e8
	if ctx.cr[6].eq {
	pc = 0x828E48E8; continue 'dispatch;
	}
	// 828E48D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E48DC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828E48E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E48E4: 4BB051CD  bl 0x823e9ab0
	ctx.lr = 0x828E48E8;
	sub_823E9AB0(ctx, base);
	// 828E48E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E48EC: 483C4B70  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E48F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E48F0 size=468
    let mut pc: u32 = 0x828E48F0;
    'dispatch: loop {
        match pc {
            0x828E48F0 => {
    //   block [0x828E48F0..0x828E4AC4)
	// 828E48F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E48F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E48F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E48FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4900: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E4904: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E4908: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E490C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4910: 419A00F4  beq cr6, 0x828e4a04
	if ctx.cr[6].eq {
	pc = 0x828E4A04; continue 'dispatch;
	}
	// 828E4914: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4918: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E491C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4920: 419A0020  beq cr6, 0x828e4940
	if ctx.cr[6].eq {
	pc = 0x828E4940; continue 'dispatch;
	}
	// 828E4924: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E4928: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E492C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E4930: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4934: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E4938: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E493C: 480000CC  b 0x828e4a08
	pc = 0x828E4A08; continue 'dispatch;
	// 828E4940: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4944: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4948: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E494C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E4950: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E4954: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4958: 40810054  ble 0x828e49ac
	if !ctx.cr[0].gt {
	pc = 0x828E49AC; continue 'dispatch;
	}
	// 828E495C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4960: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4964: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4968: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E496C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E4970: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4974: 41980008  blt cr6, 0x828e497c
	if ctx.cr[6].lt {
	pc = 0x828E497C; continue 'dispatch;
	}
	// 828E4978: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E497C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E4980: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4984: 419A0014  beq cr6, 0x828e4998
	if ctx.cr[6].eq {
	pc = 0x828E4998; continue 'dispatch;
	}
	// 828E4988: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E498C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E4990: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E4994: 4800000C  b 0x828e49a0
	pc = 0x828E49A0; continue 'dispatch;
	// 828E4998: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E499C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E49A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E49A4: 4199FFB8  bgt cr6, 0x828e495c
	if ctx.cr[6].gt {
	pc = 0x828E495C; continue 'dispatch;
	}
	// 828E49A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E49AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E49B0: 419A0040  beq cr6, 0x828e49f0
	if ctx.cr[6].eq {
	pc = 0x828E49F0; continue 'dispatch;
	}
	// 828E49B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E49B8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E49BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E49C0: 41990008  bgt cr6, 0x828e49c8
	if ctx.cr[6].gt {
	pc = 0x828E49C8; continue 'dispatch;
	}
	// 828E49C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E49C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E49CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E49D0: 409A0020  bne cr6, 0x828e49f0
	if !ctx.cr[6].eq {
	pc = 0x828E49F0; continue 'dispatch;
	}
	// 828E49D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E49D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E49DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E49E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E49E4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E49E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E49EC: 4800001C  b 0x828e4a08
	pc = 0x828E4A08; continue 'dispatch;
	// 828E49F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E49F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E49F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E49FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4A00: 48000008  b 0x828e4a08
	pc = 0x828E4A08; continue 'dispatch;
	// 828E4A04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4A08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A10: 419A009C  beq cr6, 0x828e4aac
	if ctx.cr[6].eq {
	pc = 0x828E4AAC; continue 'dispatch;
	}
	// 828E4A14: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4A1C: 419A0010  beq cr6, 0x828e4a2c
	if ctx.cr[6].eq {
	pc = 0x828E4A2C; continue 'dispatch;
	}
	// 828E4A20: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 828E4A24: 4B90416D  bl 0x821e8b90
	ctx.lr = 0x828E4A28;
	sub_821E8B90(ctx, base);
	// 828E4A28: 48000008  b 0x828e4a30
	pc = 0x828E4A30; continue 'dispatch;
	// 828E4A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4A30: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A38: 409A005C  bne cr6, 0x828e4a94
	if !ctx.cr[6].eq {
	pc = 0x828E4A94; continue 'dispatch;
	}
	// 828E4A3C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4A40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4A44: 419A0010  beq cr6, 0x828e4a54
	if ctx.cr[6].eq {
	pc = 0x828E4A54; continue 'dispatch;
	}
	// 828E4A48: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 828E4A4C: 4B904145  bl 0x821e8b90
	ctx.lr = 0x828E4A50;
	sub_821E8B90(ctx, base);
	// 828E4A50: 48000008  b 0x828e4a58
	pc = 0x828E4A58; continue 'dispatch;
	// 828E4A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4A58: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A60: 409A0034  bne cr6, 0x828e4a94
	if !ctx.cr[6].eq {
	pc = 0x828E4A94; continue 'dispatch;
	}
	// 828E4A64: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828E4A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4A6C: 4BB05295  bl 0x823e9d00
	ctx.lr = 0x828E4A70;
	sub_823E9D00(ctx, base);
	// 828E4A70: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A78: 409A001C  bne cr6, 0x828e4a94
	if !ctx.cr[6].eq {
	pc = 0x828E4A94; continue 'dispatch;
	}
	// 828E4A7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E4A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4A84: 4BB0527D  bl 0x823e9d00
	ctx.lr = 0x828E4A88;
	sub_823E9D00(ctx, base);
	// 828E4A88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A90: 419A001C  beq cr6, 0x828e4aac
	if ctx.cr[6].eq {
	pc = 0x828E4AAC; continue 'dispatch;
	}
	// 828E4A94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E4A98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4AA8: 4E800020  blr
	return;
	// 828E4AAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4AC8 size=384
    let mut pc: u32 = 0x828E4AC8;
    'dispatch: loop {
        match pc {
            0x828E4AC8 => {
    //   block [0x828E4AC8..0x828E4C48)
	// 828E4AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4AD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E4ADC: 4B9E3465  bl 0x822c7f40
	ctx.lr = 0x828E4AE0;
	sub_822C7F40(ctx, base);
	// 828E4AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4AE4: 419A0028  beq cr6, 0x828e4b0c
	if ctx.cr[6].eq {
	pc = 0x828E4B0C; continue 'dispatch;
	}
	// 828E4AE8: 8963002C  lbz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E4AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4AF0: 419A001C  beq cr6, 0x828e4b0c
	if ctx.cr[6].eq {
	pc = 0x828E4B0C; continue 'dispatch;
	}
	// 828E4AF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E4AF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4AFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4B00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4B08: 4E800020  blr
	return;
	// 828E4B0C: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E4B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4B14: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E4B18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E4B1C: 419A00E8  beq cr6, 0x828e4c04
	if ctx.cr[6].eq {
	pc = 0x828E4C04; continue 'dispatch;
	}
	// 828E4B20: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4B24: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4B2C: 419A001C  beq cr6, 0x828e4b48
	if ctx.cr[6].eq {
	pc = 0x828E4B48; continue 'dispatch;
	}
	// 828E4B30: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E4B34: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E4B38: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E4B3C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4B40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4B44: 480000C4  b 0x828e4c08
	pc = 0x828E4C08; continue 'dispatch;
	// 828E4B48: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4B50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4B54: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E4B58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E4B5C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4B60: 40810054  ble 0x828e4bb4
	if !ctx.cr[0].gt {
	pc = 0x828E4BB4; continue 'dispatch;
	}
	// 828E4B64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4B68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4B6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4B70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4B74: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E4B78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4B7C: 41980008  blt cr6, 0x828e4b84
	if ctx.cr[6].lt {
	pc = 0x828E4B84; continue 'dispatch;
	}
	// 828E4B80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E4B84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E4B88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4B8C: 419A0014  beq cr6, 0x828e4ba0
	if ctx.cr[6].eq {
	pc = 0x828E4BA0; continue 'dispatch;
	}
	// 828E4B90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4B94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E4B98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E4B9C: 4800000C  b 0x828e4ba8
	pc = 0x828E4BA8; continue 'dispatch;
	// 828E4BA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E4BA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E4BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4BAC: 4199FFB8  bgt cr6, 0x828e4b64
	if ctx.cr[6].gt {
	pc = 0x828E4B64; continue 'dispatch;
	}
	// 828E4BB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4BB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E4BB8: 419A003C  beq cr6, 0x828e4bf4
	if ctx.cr[6].eq {
	pc = 0x828E4BF4; continue 'dispatch;
	}
	// 828E4BBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4BC0: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E4BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4BC8: 41990008  bgt cr6, 0x828e4bd0
	if ctx.cr[6].gt {
	pc = 0x828E4BD0; continue 'dispatch;
	}
	// 828E4BCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4BD8: 409A001C  bne cr6, 0x828e4bf4
	if !ctx.cr[6].eq {
	pc = 0x828E4BF4; continue 'dispatch;
	}
	// 828E4BDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E4BE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4BE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E4BE8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E4BEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4BF0: 48000018  b 0x828e4c08
	pc = 0x828E4C08; continue 'dispatch;
	// 828E4BF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E4BF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E4BFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4C00: 48000008  b 0x828e4c08
	pc = 0x828E4C08; continue 'dispatch;
	// 828E4C04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4C08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E4C0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4C10: 419A0020  beq cr6, 0x828e4c30
	if ctx.cr[6].eq {
	pc = 0x828E4C30; continue 'dispatch;
	}
	// 828E4C14: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E4C18: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E4C1C: 4BB050E5  bl 0x823e9d00
	ctx.lr = 0x828E4C20;
	sub_823E9D00(ctx, base);
	// 828E4C20: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4C24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E4C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4C2C: 409A0008  bne cr6, 0x828e4c34
	if !ctx.cr[6].eq {
	pc = 0x828E4C34; continue 'dispatch;
	}
	// 828E4C30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4C40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4C48 size=420
    let mut pc: u32 = 0x828E4C48;
    'dispatch: loop {
        match pc {
            0x828E4C48 => {
    //   block [0x828E4C48..0x828E4DEC)
	// 828E4C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4C50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4C54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4C58: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E4C5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E4C60: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E4C64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4C68: 419A00F4  beq cr6, 0x828e4d5c
	if ctx.cr[6].eq {
	pc = 0x828E4D5C; continue 'dispatch;
	}
	// 828E4C6C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4C70: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E4C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4C78: 419A0020  beq cr6, 0x828e4c98
	if ctx.cr[6].eq {
	pc = 0x828E4C98; continue 'dispatch;
	}
	// 828E4C7C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E4C80: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E4C84: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E4C88: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4C8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E4C90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4C94: 480000CC  b 0x828e4d60
	pc = 0x828E4D60; continue 'dispatch;
	// 828E4C98: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E4C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4CA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4CA4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E4CA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E4CAC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4CB0: 40810054  ble 0x828e4d04
	if !ctx.cr[0].gt {
	pc = 0x828E4D04; continue 'dispatch;
	}
	// 828E4CB4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E4CB8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E4CBC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E4CC0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4CC4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E4CC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E4CCC: 41980008  blt cr6, 0x828e4cd4
	if ctx.cr[6].lt {
	pc = 0x828E4CD4; continue 'dispatch;
	}
	// 828E4CD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E4CD4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E4CD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E4CDC: 419A0014  beq cr6, 0x828e4cf0
	if ctx.cr[6].eq {
	pc = 0x828E4CF0; continue 'dispatch;
	}
	// 828E4CE0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4CE4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E4CE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E4CEC: 4800000C  b 0x828e4cf8
	pc = 0x828E4CF8; continue 'dispatch;
	// 828E4CF0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E4CF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E4CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E4CFC: 4199FFB8  bgt cr6, 0x828e4cb4
	if ctx.cr[6].gt {
	pc = 0x828E4CB4; continue 'dispatch;
	}
	// 828E4D00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E4D04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E4D08: 419A0040  beq cr6, 0x828e4d48
	if ctx.cr[6].eq {
	pc = 0x828E4D48; continue 'dispatch;
	}
	// 828E4D0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4D10: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E4D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4D18: 41990008  bgt cr6, 0x828e4d20
	if ctx.cr[6].gt {
	pc = 0x828E4D20; continue 'dispatch;
	}
	// 828E4D1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4D28: 409A0020  bne cr6, 0x828e4d48
	if !ctx.cr[6].eq {
	pc = 0x828E4D48; continue 'dispatch;
	}
	// 828E4D2C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E4D30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E4D34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E4D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4D3C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E4D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4D44: 4800001C  b 0x828e4d60
	pc = 0x828E4D60; continue 'dispatch;
	// 828E4D48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E4D4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4D50: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E4D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E4D58: 48000008  b 0x828e4d60
	pc = 0x828E4D60; continue 'dispatch;
	// 828E4D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E4D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4D68: 419A006C  beq cr6, 0x828e4dd4
	if ctx.cr[6].eq {
	pc = 0x828E4DD4; continue 'dispatch;
	}
	// 828E4D6C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4D74: 419A0010  beq cr6, 0x828e4d84
	if ctx.cr[6].eq {
	pc = 0x828E4D84; continue 'dispatch;
	}
	// 828E4D78: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 828E4D7C: 4B903E15  bl 0x821e8b90
	ctx.lr = 0x828E4D80;
	sub_821E8B90(ctx, base);
	// 828E4D80: 48000008  b 0x828e4d88
	pc = 0x828E4D88; continue 'dispatch;
	// 828E4D84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4D88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4D90: 409A002C  bne cr6, 0x828e4dbc
	if !ctx.cr[6].eq {
	pc = 0x828E4DBC; continue 'dispatch;
	}
	// 828E4D94: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E4D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4D9C: 419A0010  beq cr6, 0x828e4dac
	if ctx.cr[6].eq {
	pc = 0x828E4DAC; continue 'dispatch;
	}
	// 828E4DA0: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 828E4DA4: 4B903DED  bl 0x821e8b90
	ctx.lr = 0x828E4DA8;
	sub_821E8B90(ctx, base);
	// 828E4DA8: 48000008  b 0x828e4db0
	pc = 0x828E4DB0; continue 'dispatch;
	// 828E4DAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4DB0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4DB8: 419A001C  beq cr6, 0x828e4dd4
	if ctx.cr[6].eq {
	pc = 0x828E4DD4; continue 'dispatch;
	}
	// 828E4DBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E4DC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4DCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4DD0: 4E800020  blr
	return;
	// 828E4DD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E4DD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4DF0 size=560
    let mut pc: u32 = 0x828E4DF0;
    'dispatch: loop {
        match pc {
            0x828E4DF0 => {
    //   block [0x828E4DF0..0x828E5020)
	// 828E4DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4DF4: 483C4619  bl 0x82ca940c
	ctx.lr = 0x828E4DF8;
	sub_82CA93D0(ctx, base);
	// 828E4DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4DFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E4E00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E4E04: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828E4E08: 419A020C  beq cr6, 0x828e5014
	if ctx.cr[6].eq {
	pc = 0x828E5014; continue 'dispatch;
	}
	// 828E4E0C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4E10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4E14: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828E4E18: 7D472671  srawi. r7, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828E4E1C: 40820014  bne 0x828e4e30
	if !ctx.cr[0].eq {
	pc = 0x828E4E30; continue 'dispatch;
	}
	// 828E4E20: 4BCBB769  bl 0x825a0588
	ctx.lr = 0x828E4E24;
	sub_825A0588(ctx, base);
	// 828E4E24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E4E28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4E2C: 483C4630  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E4E30: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4E34: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4E38: 7CCA4050  subf r6, r10, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 828E4E3C: 7CC82670  srawi r8, r6, 4
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[6].s32 >> 4) as i64;
	// 828E4E40: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828E4E44: 41990068  bgt cr6, 0x828e4eac
	if ctx.cr[6].gt {
	pc = 0x828E4EAC; continue 'dispatch;
	}
	// 828E4E48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E4E4C: 419A0034  beq cr6, 0x828e4e80
	if ctx.cr[6].eq {
	pc = 0x828E4E80; continue 'dispatch;
	}
	// 828E4E50: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4E54: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E4E58: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4E5C: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828E4E60: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4E64: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828E4E68: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E4E6C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828E4E70: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 828E4E74: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 828E4E78: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E4E7C: 409AFFD4  bne cr6, 0x828e4e50
	if !ctx.cr[6].eq {
	pc = 0x828E4E50; continue 'dispatch;
	}
	// 828E4E80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E4E88: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4E8C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4E90: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E4E94: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 828E4E98: 54EB2036  slwi r11, r7, 4
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E4E9C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E4EA0: 90DD0008  stw r6, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828E4EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4EA8: 483C45B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E4EAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E4EB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4EB4: 409A000C  bne cr6, 0x828e4ec0
	if !ctx.cr[6].eq {
	pc = 0x828E4EC0; continue 'dispatch;
	}
	// 828E4EB8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E4EBC: 48000010  b 0x828e4ecc
	pc = 0x828E4ECC; continue 'dispatch;
	// 828E4EC0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E4EC4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828E4EC8: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 828E4ECC: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E4ED0: 419900A8  bgt cr6, 0x828e4f78
	if ctx.cr[6].gt {
	pc = 0x828E4F78; continue 'dispatch;
	}
	// 828E4ED4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4ED8: 55092036  slwi r9, r8, 4
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828E4EDC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828E4EE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E4EE4: 419A0034  beq cr6, 0x828e4f18
	if ctx.cr[6].eq {
	pc = 0x828E4F18; continue 'dispatch;
	}
	// 828E4EE8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4EEC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E4EF0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4EF4: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828E4EF8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4EFC: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828E4F00: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E4F04: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828E4F08: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 828E4F0C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 828E4F10: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E4F14: 409AFFD4  bne cr6, 0x828e4ee8
	if !ctx.cr[6].eq {
	pc = 0x828E4EE8; continue 'dispatch;
	}
	// 828E4F18: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4F1C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4F20: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828E4F24: 419A0044  beq cr6, 0x828e4f68
	if ctx.cr[6].eq {
	pc = 0x828E4F68; continue 'dispatch;
	}
	// 828E4F28: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 828E4F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4F30: 419A0024  beq cr6, 0x828e4f54
	if ctx.cr[6].eq {
	pc = 0x828E4F54; continue 'dispatch;
	}
	// 828E4F34: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 828E4F38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E4F3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4F40: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828E4F44: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4F48: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828E4F4C: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4F50: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 828E4F54: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 828E4F58: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828E4F5C: 392AFFFC  addi r9, r10, -4
	ctx.r[9].s64 = ctx.r[10].s64 + -4;
	// 828E4F60: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828E4F64: 409AFFC8  bne cr6, 0x828e4f2c
	if !ctx.cr[6].eq {
	pc = 0x828E4F2C; continue 'dispatch;
	}
	// 828E4F68: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828E4F6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E4F70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4F74: 483C44E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E4F78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4F7C: 419A000C  beq cr6, 0x828e4f88
	if ctx.cr[6].eq {
	pc = 0x828E4F88; continue 'dispatch;
	}
	// 828E4F80: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828E4F84: 4B936DB5  bl 0x8221bd38
	ctx.lr = 0x828E4F88;
	sub_8221BD38(ctx, base);
	// 828E4F88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4F8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4F90: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E4F94: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828E4F98: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828E4F9C: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828E4FA0: 7D242671  srawi. r4, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828E4FA4: 4082000C  bne 0x828e4fb0
	if !ctx.cr[0].eq {
	pc = 0x828E4FB0; continue 'dispatch;
	}
	// 828E4FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E4FAC: 4800000C  b 0x828e4fb8
	pc = 0x828E4FB8; continue 'dispatch;
	// 828E4FB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E4FB4: 4BAC7E1D  bl 0x823acdd0
	ctx.lr = 0x828E4FB8;
	sub_823ACDD0(ctx, base);
	// 828E4FB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E4FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4FC0: 419A0054  beq cr6, 0x828e5014
	if ctx.cr[6].eq {
	pc = 0x828E5014; continue 'dispatch;
	}
	// 828E4FC4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4FC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4FCC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4FD0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E4FD4: 419A003C  beq cr6, 0x828e5010
	if ctx.cr[6].eq {
	pc = 0x828E5010; continue 'dispatch;
	}
	// 828E4FD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E4FDC: 419A0024  beq cr6, 0x828e5000
	if ctx.cr[6].eq {
	pc = 0x828E5000; continue 'dispatch;
	}
	// 828E4FE0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4FE4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E4FE8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4FEC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828E4FF0: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E4FF4: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828E4FF8: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E4FFC: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 828E5000: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828E5004: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 828E5008: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E500C: 409AFFCC  bne cr6, 0x828e4fd8
	if !ctx.cr[6].eq {
	pc = 0x828E4FD8; continue 'dispatch;
	}
	// 828E5010: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E5014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E5018: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E501C: 483C4440  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5020 size=352
    let mut pc: u32 = 0x828E5020;
    'dispatch: loop {
        match pc {
            0x828E5020 => {
    //   block [0x828E5020..0x828E5180)
	// 828E5020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5024: 483C43DD  bl 0x82ca9400
	ctx.lr = 0x828E5028;
	sub_82CA93D0(ctx, base);
	// 828E5028: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828E502C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5180 size=348
    let mut pc: u32 = 0x828E5180;
    'dispatch: loop {
        match pc {
            0x828E5180 => {
    //   block [0x828E5180..0x828E52DC)
	// 828E5180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E518C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5190: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E52E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E52E0 size=268
    let mut pc: u32 = 0x828E52E0;
    'dispatch: loop {
        match pc {
            0x828E52E0 => {
    //   block [0x828E52E0..0x828E53EC)
	// 828E52E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E52E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E52E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E52EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E52F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E52F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E52F8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828E52FC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E5300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5304: 419A001C  beq cr6, 0x828e5320
	if ctx.cr[6].eq {
	pc = 0x828E5320; continue 'dispatch;
	}
	// 828E5308: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E530C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E5310: 419A000C  beq cr6, 0x828e531c
	if ctx.cr[6].eq {
	pc = 0x828E531C; continue 'dispatch;
	}
	// 828E5314: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828E5318: 4800000C  b 0x828e5324
	pc = 0x828E5324; continue 'dispatch;
	// 828E531C: 4B8AEB1D  bl 0x82193e38
	ctx.lr = 0x828E5320;
	sub_82193E38(ctx, base);
	// 828E5320: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E5324: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828E5328: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E532C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5330: 419A0020  beq cr6, 0x828e5350
	if ctx.cr[6].eq {
	pc = 0x828E5350; continue 'dispatch;
	}
	// 828E5334: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E533C: 419A000C  beq cr6, 0x828e5348
	if ctx.cr[6].eq {
	pc = 0x828E5348; continue 'dispatch;
	}
	// 828E5340: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828E5344: 48000010  b 0x828e5354
	pc = 0x828E5354; continue 'dispatch;
	// 828E5348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E534C: 4B8AEAED  bl 0x82193e38
	ctx.lr = 0x828E5350;
	sub_82193E38(ctx, base);
	// 828E5350: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E5354: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E5358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E535C: 4BD148DD  bl 0x825f9c38
	ctx.lr = 0x828E5360;
	sub_825F9C38(ctx, base);
	// 828E5360: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5368: 419A0064  beq cr6, 0x828e53cc
	if ctx.cr[6].eq {
	pc = 0x828E53CC; continue 'dispatch;
	}
	// 828E536C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5370: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E5374: 419A0070  beq cr6, 0x828e53e4
	if ctx.cr[6].eq {
	pc = 0x828E53E4; continue 'dispatch;
	}
	// 828E5378: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E537C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5380: 419A004C  beq cr6, 0x828e53cc
	if ctx.cr[6].eq {
	pc = 0x828E53CC; continue 'dispatch;
	}
	// 828E5384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5388: 4B88EAB1  bl 0x82173e38
	ctx.lr = 0x828E538C;
	sub_82173E38(ctx, base);
	// 828E538C: 4BAA849D  bl 0x8238d828
	ctx.lr = 0x828E5390;
	sub_8238D828(ctx, base);
	// 828E5390: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E5394: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E5398: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828E539C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E53A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E53A4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E53A8: 4B8AEA91  bl 0x82193e38
	ctx.lr = 0x828E53AC;
	sub_82193E38(ctx, base);
	// 828E53AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E53B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E53B4: 4BBECB15  bl 0x824d1ec8
	ctx.lr = 0x828E53B8;
	sub_824D1EC8(ctx, base);
	// 828E53B8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828E53BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E53C0: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828E53C4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828E53C8: 4B8AEA71  bl 0x82193e38
	ctx.lr = 0x828E53CC;
	sub_82193E38(ctx, base);
	// 828E53CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E53D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E53D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E53D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E53DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E53E0: 4E800020  blr
	return;
	// 828E53E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E53E8: 4BFFFFE0  b 0x828e53c8
	pc = 0x828E53C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E53F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828E53F0 size=72
    let mut pc: u32 = 0x828E53F0;
    'dispatch: loop {
        match pc {
            0x828E53F0 => {
    //   block [0x828E53F0..0x828E5438)
	// 828E53F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E53F4: C0030054  lfs f0, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E53F8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828E53FC: C1630050  lfs f11, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828E5400: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 828E5404: C1AB9484  lfs f13, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E5408: C98A9660  lfd f12, -0x69a0(r10)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828E540C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E5410: 81096C9C  lwz r8, 0x6c9c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27804 as u32) ) } as u64;
	// 828E5414: 80E96CA0  lwz r7, 0x6ca0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27808 as u32) ) } as u64;
	// 828E5418: 9101FFF0  stw r8, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u32 ) };
	// 828E541C: 90E1FFF4  stw r7, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 828E5420: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5424: FD4D6024  fdiv f10, f13, f12
	ctx.f[10].f64 = ctx.f[13].f64 / ctx.f[12].f64;
	// 828E5428: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 828E542C: EDA9582A  fadds f13, f9, f11
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64;
	// 828E5430: D1A30050  stfs f13, 0x50(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E5434: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5438 size=8
    let mut pc: u32 = 0x828E5438;
    'dispatch: loop {
        match pc {
            0x828E5438 => {
    //   block [0x828E5438..0x828E5440)
	// 828E5438: FF0D0000  fcmpu cr6, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828E543C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5440 size=12
    let mut pc: u32 = 0x828E5440;
    'dispatch: loop {
        match pc {
            0x828E5440 => {
    //   block [0x828E5440..0x828E544C)
	// 828E5440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5444: 99630048  stb r11, 0x48(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828E5448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5450 size=372
    let mut pc: u32 = 0x828E5450;
    'dispatch: loop {
        match pc {
            0x828E5450 => {
    //   block [0x828E5450..0x828E55C4)
	// 828E5450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E545C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5460: 38630018  addi r3, r3, 0x18
	ctx.r[3].s64 = ctx.r[3].s64 + 24;
	// 828E5464: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E5468: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E546C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5470: 419A0068  beq cr6, 0x828e54d8
	if ctx.cr[6].eq {
	pc = 0x828E54D8; continue 'dispatch;
	}
	// 828E5474: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5478: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E547C: 419A0058  beq cr6, 0x828e54d4
	if ctx.cr[6].eq {
	pc = 0x828E54D4; continue 'dispatch;
	}
	// 828E5480: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E5484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5488: 419A0050  beq cr6, 0x828e54d8
	if ctx.cr[6].eq {
	pc = 0x828E54D8; continue 'dispatch;
	}
	// 828E548C: 4B88E9AD  bl 0x82173e38
	ctx.lr = 0x828E5490;
	sub_82173E38(ctx, base);
	// 828E5490: 89630028  lbz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E5494: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E5498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E549C: 419A003C  beq cr6, 0x828e54d8
	if ctx.cr[6].eq {
	pc = 0x828E54D8; continue 'dispatch;
	}
	// 828E54A0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E54A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E54A8: 419A0048  beq cr6, 0x828e54f0
	if ctx.cr[6].eq {
	pc = 0x828E54F0; continue 'dispatch;
	}
	// 828E54AC: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E54B0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E54B4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E54B8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E54BC: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E54C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E54C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E54C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E54CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E54D0: 4E800020  blr
	return;
	// 828E54D4: 4B8AE965  bl 0x82193e38
	ctx.lr = 0x828E54D8;
	sub_82193E38(ctx, base);
	// 828E54D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E54DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E54E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E54E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E54E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E54EC: 4E800020  blr
	return;
	// 828E54F0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E54F4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E54F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E54FC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E5500: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E5504: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5508: 40810054  ble 0x828e555c
	if !ctx.cr[0].gt {
	pc = 0x828E555C; continue 'dispatch;
	}
	// 828E550C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E5510: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E5514: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E5518: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E551C: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 828E5520: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E5524: 41980008  blt cr6, 0x828e552c
	if ctx.cr[6].lt {
	pc = 0x828E552C; continue 'dispatch;
	}
	// 828E5528: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E552C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E5530: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E5534: 419A0014  beq cr6, 0x828e5548
	if ctx.cr[6].eq {
	pc = 0x828E5548; continue 'dispatch;
	}
	// 828E5538: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E553C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E5540: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E5544: 4800000C  b 0x828e5550
	pc = 0x828E5550; continue 'dispatch;
	// 828E5548: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E554C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E5550: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5554: 4199FFB8  bgt cr6, 0x828e550c
	if ctx.cr[6].gt {
	pc = 0x828E550C; continue 'dispatch;
	}
	// 828E5558: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E555C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E5560: 419A0048  beq cr6, 0x828e55a8
	if ctx.cr[6].eq {
	pc = 0x828E55A8; continue 'dispatch;
	}
	// 828E5564: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5568: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 828E556C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5570: 41990008  bgt cr6, 0x828e5578
	if ctx.cr[6].gt {
	pc = 0x828E5578; continue 'dispatch;
	}
	// 828E5574: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E5578: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E557C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5580: 409A0028  bne cr6, 0x828e55a8
	if !ctx.cr[6].eq {
	pc = 0x828E55A8; continue 'dispatch;
	}
	// 828E5584: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E5588: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E558C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5590: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5594: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5598: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E559C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E55A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E55A4: 4E800020  blr
	return;
	// 828E55A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E55AC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E55B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E55B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E55B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E55BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E55C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E55C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E55C8 size=176
    let mut pc: u32 = 0x828E55C8;
    'dispatch: loop {
        match pc {
            0x828E55C8 => {
    //   block [0x828E55C8..0x828E5678)
	// 828E55C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E55CC: 483C3E41  bl 0x82ca940c
	ctx.lr = 0x828E55D0;
	sub_82CA93D0(ctx, base);
	// 828E55D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E55D4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828E55D8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828E55DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E55E0: 3BEBEBE0  addi r31, r11, -0x1420
	ctx.r[31].s64 = ctx.r[11].s64 + -5152;
	// 828E55E4: 816A2380  lwz r11, 0x2380(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9088 as u32) ) } as u64;
	// 828E55E8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E55EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E55F0: 409A0078  bne cr6, 0x828e5668
	if !ctx.cr[6].eq {
	pc = 0x828E5668; continue 'dispatch;
	}
	// 828E55F4: 3D20811C  lis r9, -0x7ee4
	ctx.r[9].s64 = -2128871424;
	// 828E55F8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828E55FC: 613E9DC5  ori r30, r9, 0x9dc5
	ctx.r[30].u64 = ctx.r[9].u64 | 40389;
	// 828E5600: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E5604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5608: 38683FA4  addi r3, r8, 0x3fa4
	ctx.r[3].s64 = ctx.r[8].s64 + 16292;
	// 828E560C: 916A2380  stw r11, 0x2380(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9088 as u32), ctx.r[11].u32 ) };
	// 828E5610: 4B90E749  bl 0x821f3d58
	ctx.lr = 0x828E5614;
	sub_821F3D58(ctx, base);
	// 828E5614: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E5618: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828E561C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5620: 38673F98  addi r3, r7, 0x3f98
	ctx.r[3].s64 = ctx.r[7].s64 + 16280;
	// 828E5624: 4B90E735  bl 0x821f3d58
	ctx.lr = 0x828E5628;
	sub_821F3D58(ctx, base);
	// 828E5628: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828E562C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828E5630: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5634: 38663F8C  addi r3, r6, 0x3f8c
	ctx.r[3].s64 = ctx.r[6].s64 + 16268;
	// 828E5638: 4B90E721  bl 0x821f3d58
	ctx.lr = 0x828E563C;
	sub_821F3D58(ctx, base);
	// 828E563C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828E5640: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828E5644: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5648: 38653F80  addi r3, r5, 0x3f80
	ctx.r[3].s64 = ctx.r[5].s64 + 16256;
	// 828E564C: 4B90E70D  bl 0x821f3d58
	ctx.lr = 0x828E5650;
	sub_821F3D58(ctx, base);
	// 828E5650: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828E5654: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E5658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E565C: 386B3F74  addi r3, r11, 0x3f74
	ctx.r[3].s64 = ctx.r[11].s64 + 16244;
	// 828E5660: 4B90E6F9  bl 0x821f3d58
	ctx.lr = 0x828E5664;
	sub_821F3D58(ctx, base);
	// 828E5664: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 828E5668: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E566C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828E5670: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5674: 483C3DE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5678 size=168
    let mut pc: u32 = 0x828E5678;
    'dispatch: loop {
        match pc {
            0x828E5678 => {
    //   block [0x828E5678..0x828E5720)
	// 828E5678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E567C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E568C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828E5690: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828E5694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E5698: 3BEBEBF4  addi r31, r11, -0x140c
	ctx.r[31].s64 = ctx.r[11].s64 + -5132;
	// 828E569C: 816A2374  lwz r11, 0x2374(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9076 as u32) ) } as u64;
	// 828E56A0: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828E56A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E56A8: 409A003C  bne cr6, 0x828e56e4
	if !ctx.cr[6].eq {
	pc = 0x828E56E4; continue 'dispatch;
	}
	// 828E56AC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828E56B0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828E56B4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E56B8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828E56BC: 38693FD8  addi r3, r9, 0x3fd8
	ctx.r[3].s64 = ctx.r[9].s64 + 16344;
	// 828E56C0: 916A2374  stw r11, 0x2374(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9076 as u32), ctx.r[11].u32 ) };
	// 828E56C4: 4B90E695  bl 0x821f3d58
	ctx.lr = 0x828E56C8;
	sub_821F3D58(ctx, base);
	// 828E56C8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E56CC: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828E56D0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828E56D4: 38683FC4  addi r3, r8, 0x3fc4
	ctx.r[3].s64 = ctx.r[8].s64 + 16324;
	// 828E56D8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828E56DC: 4B90E67D  bl 0x821f3d58
	ctx.lr = 0x828E56E0;
	sub_821F3D58(ctx, base);
	// 828E56E0: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828E56E4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828E56E8: 4098000C  bge cr6, 0x828e56f4
	if !ctx.cr[6].lt {
	pc = 0x828E56F4; continue 'dispatch;
	}
	// 828E56EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E56F0: 48000010  b 0x828e5700
	pc = 0x828E5700; continue 'dispatch;
	// 828E56F4: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 828E56F8: 40990008  ble cr6, 0x828e5700
	if !ctx.cr[6].gt {
	pc = 0x828E5700; continue 'dispatch;
	}
	// 828E56FC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828E5700: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E5704: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828E5708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E570C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5714: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E5718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E571C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5720 size=360
    let mut pc: u32 = 0x828E5720;
    'dispatch: loop {
        match pc {
            0x828E5720 => {
    //   block [0x828E5720..0x828E5888)
	// 828E5720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5724: 483C3CE1  bl 0x82ca9404
	ctx.lr = 0x828E5728;
	sub_82CA93D0(ctx, base);
	// 828E5728: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5888 size=124
    let mut pc: u32 = 0x828E5888;
    'dispatch: loop {
        match pc {
            0x828E5888 => {
    //   block [0x828E5888..0x828E5904)
	// 828E5888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E588C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5894: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5908 size=128
    let mut pc: u32 = 0x828E5908;
    'dispatch: loop {
        match pc {
            0x828E5908 => {
    //   block [0x828E5908..0x828E5988)
	// 828E5908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E590C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5914: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E5918: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5988 size=132
    let mut pc: u32 = 0x828E5988;
    'dispatch: loop {
        match pc {
            0x828E5988 => {
    //   block [0x828E5988..0x828E5A0C)
	// 828E5988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E598C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5998: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5A10 size=104
    let mut pc: u32 = 0x828E5A10;
    'dispatch: loop {
        match pc {
            0x828E5A10 => {
    //   block [0x828E5A10..0x828E5A78)
	// 828E5A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5A18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5A1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5A20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E5A24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E5A28: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828E5A2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E5A30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5A34: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E5A38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E5A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5A40: 4B92EE59  bl 0x82214898
	ctx.lr = 0x828E5A44;
	sub_82214898(ctx, base);
	// 828E5A44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E5A48: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 828E5A4C: 4BBEC47D  bl 0x824d1ec8
	ctx.lr = 0x828E5A50;
	sub_824D1EC8(ctx, base);
	// 828E5A50: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828E5A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5A58: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828E5A5C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828E5A60: 4B8AE3D9  bl 0x82193e38
	ctx.lr = 0x828E5A64;
	sub_82193E38(ctx, base);
	// 828E5A64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5A68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5A6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5A78 size=84
    let mut pc: u32 = 0x828E5A78;
    'dispatch: loop {
        match pc {
            0x828E5A78 => {
    //   block [0x828E5A78..0x828E5ACC)
	// 828E5A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5A80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5A84: 38630070  addi r3, r3, 0x70
	ctx.r[3].s64 = ctx.r[3].s64 + 112;
	// 828E5A88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5A90: 419A0028  beq cr6, 0x828e5ab8
	if ctx.cr[6].eq {
	pc = 0x828E5AB8; continue 'dispatch;
	}
	// 828E5A94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5A98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E5A9C: 419A0018  beq cr6, 0x828e5ab4
	if ctx.cr[6].eq {
	pc = 0x828E5AB4; continue 'dispatch;
	}
	// 828E5AA0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828E5AA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E5AA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5AAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5AB0: 4E800020  blr
	return;
	// 828E5AB4: 4B8AE385  bl 0x82193e38
	ctx.lr = 0x828E5AB8;
	sub_82193E38(ctx, base);
	// 828E5AB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E5ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E5AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5AC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5AD0 size=196
    let mut pc: u32 = 0x828E5AD0;
    'dispatch: loop {
        match pc {
            0x828E5AD0 => {
    //   block [0x828E5AD0..0x828E5B94)
	// 828E5AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5AD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5ADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5AE0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5B98 size=4
    let mut pc: u32 = 0x828E5B98;
    'dispatch: loop {
        match pc {
            0x828E5B98 => {
    //   block [0x828E5B98..0x828E5B9C)
	// 828E5B98: 4BFFF858  b 0x828e53f0
	sub_828E53F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5BA0 size=268
    let mut pc: u32 = 0x828E5BA0;
    'dispatch: loop {
        match pc {
            0x828E5BA0 => {
    //   block [0x828E5BA0..0x828E5CAC)
	// 828E5BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5BB0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5CB0 size=336
    let mut pc: u32 = 0x828E5CB0;
    'dispatch: loop {
        match pc {
            0x828E5CB0 => {
    //   block [0x828E5CB0..0x828E5E00)
	// 828E5CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5CB4: 483C3759  bl 0x82ca940c
	ctx.lr = 0x828E5CB8;
	sub_82CA93D0(ctx, base);
	// 828E5CB8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828E5CBC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E5CC0: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5E00 size=408
    let mut pc: u32 = 0x828E5E00;
    'dispatch: loop {
        match pc {
            0x828E5E00 => {
    //   block [0x828E5E00..0x828E5F98)
	// 828E5E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E5E18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E5E1C: 419A0018  beq cr6, 0x828e5e34
	if ctx.cr[6].eq {
	pc = 0x828E5E34; continue 'dispatch;
	}
	// 828E5E20: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E5E24: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E5E28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5E2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E5E30: 409A0008  bne cr6, 0x828e5e38
	if !ctx.cr[6].eq {
	pc = 0x828E5E38; continue 'dispatch;
	}
	// 828E5E34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E5E38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E5E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5E40: 419A013C  beq cr6, 0x828e5f7c
	if ctx.cr[6].eq {
	pc = 0x828E5F7C; continue 'dispatch;
	}
	// 828E5E44: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E5E48: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828E5E4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E5E50: 419A00F8  beq cr6, 0x828e5f48
	if ctx.cr[6].eq {
	pc = 0x828E5F48; continue 'dispatch;
	}
	// 828E5E54: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E5E58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5E5C: 419A0024  beq cr6, 0x828e5e80
	if ctx.cr[6].eq {
	pc = 0x828E5E80; continue 'dispatch;
	}
	// 828E5E60: 894B0053  lbz r10, 0x53(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(83 as u32) ) } as u64;
	// 828E5E64: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E5E68: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E5E6C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E5E70: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5E74: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E5E78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5E7C: 480000D4  b 0x828e5f50
	pc = 0x828E5F50; continue 'dispatch;
	// 828E5E80: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E5E84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E5E88: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E5E8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E5E90: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E5E94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E5E98: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5E9C: 40810054  ble 0x828e5ef0
	if !ctx.cr[0].gt {
	pc = 0x828E5EF0; continue 'dispatch;
	}
	// 828E5EA0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E5EA4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E5EA8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E5EAC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5EB0: 2F070053  cmpwi cr6, r7, 0x53
	ctx.cr[6].compare_i32(ctx.r[7].s32, 83, &mut ctx.xer);
	// 828E5EB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E5EB8: 41980008  blt cr6, 0x828e5ec0
	if ctx.cr[6].lt {
	pc = 0x828E5EC0; continue 'dispatch;
	}
	// 828E5EBC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E5EC0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E5EC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E5EC8: 419A0014  beq cr6, 0x828e5edc
	if ctx.cr[6].eq {
	pc = 0x828E5EDC; continue 'dispatch;
	}
	// 828E5ECC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E5ED0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E5ED4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E5ED8: 4800000C  b 0x828e5ee4
	pc = 0x828E5EE4; continue 'dispatch;
	// 828E5EDC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E5EE0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E5EE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5EE8: 4199FFB8  bgt cr6, 0x828e5ea0
	if ctx.cr[6].gt {
	pc = 0x828E5EA0; continue 'dispatch;
	}
	// 828E5EEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E5EF0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E5EF4: 419A0040  beq cr6, 0x828e5f34
	if ctx.cr[6].eq {
	pc = 0x828E5F34; continue 'dispatch;
	}
	// 828E5EF8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5EFC: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 828E5F00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5F04: 41990008  bgt cr6, 0x828e5f0c
	if ctx.cr[6].gt {
	pc = 0x828E5F0C; continue 'dispatch;
	}
	// 828E5F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E5F0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E5F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5F14: 409A0020  bne cr6, 0x828e5f34
	if !ctx.cr[6].eq {
	pc = 0x828E5F34; continue 'dispatch;
	}
	// 828E5F18: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E5F1C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E5F20: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5F24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5F28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E5F2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5F30: 48000020  b 0x828e5f50
	pc = 0x828E5F50; continue 'dispatch;
	// 828E5F34: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E5F38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5F3C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E5F40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E5F44: 4800000C  b 0x828e5f50
	pc = 0x828E5F50; continue 'dispatch;
	// 828E5F48: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E5F4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E5F50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E5F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5F58: 419A0024  beq cr6, 0x828e5f7c
	if ctx.cr[6].eq {
	pc = 0x828E5F7C; continue 'dispatch;
	}
	// 828E5F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5F60: 4802F121  bl 0x82915080
	ctx.lr = 0x828E5F64;
	sub_82915080(ctx, base);
	// 828E5F64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E5F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5F6C: 419A0010  beq cr6, 0x828e5f7c
	if ctx.cr[6].eq {
	pc = 0x828E5F7C; continue 'dispatch;
	}
	// 828E5F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5F74: 4BFD1FCD  bl 0x828b7f40
	ctx.lr = 0x828E5F78;
	sub_828B7F40(ctx, base);
	// 828E5F78: 48000008  b 0x828e5f80
	pc = 0x828E5F80; continue 'dispatch;
	// 828E5F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5F80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5F84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5F88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5F8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E5F90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5F98 size=60
    let mut pc: u32 = 0x828E5F98;
    'dispatch: loop {
        match pc {
            0x828E5F98 => {
    //   block [0x828E5F98..0x828E5FD4)
	// 828E5F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5FA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5FA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5FA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E5FAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E5FB0: 388B9B60  addi r4, r11, -0x64a0
	ctx.r[4].s64 = ctx.r[11].s64 + -25760;
	// 828E5FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5FB8: 4B946F19  bl 0x8222ced0
	ctx.lr = 0x828E5FBC;
	sub_8222CED0(ctx, base);
	// 828E5FBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5FC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E5FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E5FD8 size=24
    let mut pc: u32 = 0x828E5FD8;
    'dispatch: loop {
        match pc {
            0x828E5FD8 => {
    //   block [0x828E5FD8..0x828E5FF0)
	// 828E5FD8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828E5FDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E5FE0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828E5FE4: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 828E5FE8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828E5FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5FF0 size=152
    let mut pc: u32 = 0x828E5FF0;
    'dispatch: loop {
        match pc {
            0x828E5FF0 => {
    //   block [0x828E5FF0..0x828E6088)
	// 828E5FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6004: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E6008: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828E600C: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 828E6010: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 828E6014: 48000075  bl 0x828e6088
	ctx.lr = 0x828E6018;
	sub_828E6088(ctx, base);
	// 828E6018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E601C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E6020: 419A0028  beq cr6, 0x828e6048
	if ctx.cr[6].eq {
	pc = 0x828E6048; continue 'dispatch;
	}
	// 828E6024: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828E6028: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E602C: 808BC88C  lwz r4, -0x3774(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14196 as u32) ) } as u64;
	// 828E6030: 4811A381  bl 0x82a003b0
	ctx.lr = 0x828E6034;
	sub_82A003B0(ctx, base);
	// 828E6034: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828E6038: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 828E603C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6040: 808AC890  lwz r4, -0x3770(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14192 as u32) ) } as u64;
	// 828E6044: 4811A36D  bl 0x82a003b0
	ctx.lr = 0x828E6048;
	sub_82A003B0(ctx, base);
	// 828E6048: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E604C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E6050: 419A001C  beq cr6, 0x828e606c
	if ctx.cr[6].eq {
	pc = 0x828E606C; continue 'dispatch;
	}
	// 828E6054: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828E6058: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828E605C: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828E6060: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 828E6064: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 828E6068: 48000008  b 0x828e6070
	pc = 0x828E6070; continue 'dispatch;
	// 828E606C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E607C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E6080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6088 size=156
    let mut pc: u32 = 0x828E6088;
    'dispatch: loop {
        match pc {
            0x828E6088 => {
    //   block [0x828E6088..0x828E6124)
	// 828E6088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E608C: 483C337D  bl 0x82ca9408
	ctx.lr = 0x828E6090;
	sub_82CA93D0(ctx, base);
	// 828E6090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6098: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E609C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828E60A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E60A4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E60A8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E60AC: 409A001C  bne cr6, 0x828e60c8
	if !ctx.cr[6].eq {
	pc = 0x828E60C8; continue 'dispatch;
	}
	// 828E60B0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E60B4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E60B8: 409A0010  bne cr6, 0x828e60c8
	if !ctx.cr[6].eq {
	pc = 0x828E60C8; continue 'dispatch;
	}
	// 828E60BC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E60C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E60C4: 483C3394  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828E60C8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E60CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E60D0: 419A0048  beq cr6, 0x828e6118
	if ctx.cr[6].eq {
	pc = 0x828E6118; continue 'dispatch;
	}
	// 828E60D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E60D8: 4BD26F89  bl 0x8260d060
	ctx.lr = 0x828E60DC;
	sub_8260D060(ctx, base);
	// 828E60DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E60E0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E60E4: 4811A43D  bl 0x82a00520
	ctx.lr = 0x828E60E8;
	sub_82A00520(ctx, base);
	// 828E60E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E60EC: 419A002C  beq cr6, 0x828e6118
	if ctx.cr[6].eq {
	pc = 0x828E6118; continue 'dispatch;
	}
	// 828E60F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828E60F4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828E60F8: 392BC8F4  addi r9, r11, -0x370c
	ctx.r[9].s64 = ctx.r[11].s64 + -14092;
	// 828E60FC: 7C8A482E  lwzx r4, r10, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828E6100: 4811A421  bl 0x82a00520
	ctx.lr = 0x828E6104;
	sub_82A00520(ctx, base);
	// 828E6104: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828E6108: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 828E610C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 828E6110: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6114: 483C3344  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828E6118: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E611C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6120: 483C3338  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6128 size=100
    let mut pc: u32 = 0x828E6128;
    'dispatch: loop {
        match pc {
            0x828E6128 => {
    //   block [0x828E6128..0x828E618C)
	// 828E6128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E612C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6134: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E6138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E613C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6140: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828E6144: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6148: 83EAC898  lwz r31, -0x3768(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14184 as u32) ) } as u64;
	// 828E614C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E6150: 4BFFFF39  bl 0x828e6088
	ctx.lr = 0x828E6154;
	sub_828E6088(ctx, base);
	// 828E6154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6158: 419A0018  beq cr6, 0x828e6170
	if ctx.cr[6].eq {
	pc = 0x828E6170; continue 'dispatch;
	}
	// 828E615C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E6160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6164: 4B8FF715  bl 0x821e5878
	ctx.lr = 0x828E6168;
	sub_821E5878(ctx, base);
	// 828E6168: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E616C: 48000008  b 0x828e6174
	pc = 0x828E6174; continue 'dispatch;
	// 828E6170: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6174: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6178: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E617C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6180: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E6184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6190 size=108
    let mut pc: u32 = 0x828E6190;
    'dispatch: loop {
        match pc {
            0x828E6190 => {
    //   block [0x828E6190..0x828E61FC)
	// 828E6190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6198: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E619C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E61A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E61A4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828E61A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E61AC: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828E61B0: 390BC8D4  addi r8, r11, -0x372c
	ctx.r[8].s64 = ctx.r[11].s64 + -14124;
	// 828E61B4: C3EA9490  lfs f31, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E61B8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E61BC: 7FE9402E  lwzx r31, r9, r8
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828E61C0: 4BFFFEC9  bl 0x828e6088
	ctx.lr = 0x828E61C4;
	sub_828E6088(ctx, base);
	// 828E61C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E61C8: 419A0018  beq cr6, 0x828e61e0
	if ctx.cr[6].eq {
	pc = 0x828E61E0; continue 'dispatch;
	}
	// 828E61CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E61D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E61D4: 4B8FF6A5  bl 0x821e5878
	ctx.lr = 0x828E61D8;
	sub_821E5878(ctx, base);
	// 828E61D8: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E61DC: 48000008  b 0x828e61e4
	pc = 0x828E61E4; continue 'dispatch;
	// 828E61E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E61E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E61E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E61EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E61F0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E61F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E61F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6200 size=100
    let mut pc: u32 = 0x828E6200;
    'dispatch: loop {
        match pc {
            0x828E6200 => {
    //   block [0x828E6200..0x828E6264)
	// 828E6200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E620C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E6210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6214: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6218: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828E621C: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6220: 83EAC894  lwz r31, -0x376c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14188 as u32) ) } as u64;
	// 828E6224: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E6228: 4BFFFE61  bl 0x828e6088
	ctx.lr = 0x828E622C;
	sub_828E6088(ctx, base);
	// 828E622C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6230: 419A0018  beq cr6, 0x828e6248
	if ctx.cr[6].eq {
	pc = 0x828E6248; continue 'dispatch;
	}
	// 828E6234: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E6238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E623C: 4B8FF63D  bl 0x821e5878
	ctx.lr = 0x828E6240;
	sub_821E5878(ctx, base);
	// 828E6240: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E6244: 48000008  b 0x828e624c
	pc = 0x828E624C; continue 'dispatch;
	// 828E6248: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E624C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6258: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E625C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6268 size=104
    let mut pc: u32 = 0x828E6268;
    'dispatch: loop {
        match pc {
            0x828E6268 => {
    //   block [0x828E6268..0x828E62D0)
	// 828E6268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E626C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E6274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E627C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828E6280: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828E6284: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E6288: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828E628C: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 828E6290: 83EBC8D0  lwz r31, -0x3730(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14128 as u32) ) } as u64;
	// 828E6294: 4BFFFDF5  bl 0x828e6088
	ctx.lr = 0x828E6298;
	sub_828E6088(ctx, base);
	// 828E6298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E629C: 419A0018  beq cr6, 0x828e62b4
	if ctx.cr[6].eq {
	pc = 0x828E62B4; continue 'dispatch;
	}
	// 828E62A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E62A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E62A8: 4811A109  bl 0x82a003b0
	ctx.lr = 0x828E62AC;
	sub_82A003B0(ctx, base);
	// 828E62AC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E62B0: 48000008  b 0x828e62b8
	pc = 0x828E62B8; continue 'dispatch;
	// 828E62B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E62B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E62BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E62C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E62C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E62C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E62CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E62D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E62D0 size=988
    let mut pc: u32 = 0x828E62D0;
    'dispatch: loop {
        match pc {
            0x828E62D0 => {
    //   block [0x828E62D0..0x828E66AC)
	// 828E62D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E62D4: 483C3139  bl 0x82ca940c
	ctx.lr = 0x828E62D8;
	sub_82CA93D0(ctx, base);
	// 828E62D8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E66B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E66B0 size=676
    let mut pc: u32 = 0x828E66B0;
    'dispatch: loop {
        match pc {
            0x828E66B0 => {
    //   block [0x828E66B0..0x828E6954)
	// 828E66B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E66B4: 483C2D59  bl 0x82ca940c
	ctx.lr = 0x828E66B8;
	sub_82CA93D0(ctx, base);
	// 828E66B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E66BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E66C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E66C4: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E66C8: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828E66CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E66D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E66D4: 419A00E8  beq cr6, 0x828e67bc
	if ctx.cr[6].eq {
	pc = 0x828E67BC; continue 'dispatch;
	}
	// 828E66D8: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E66DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E66E0: 419A0020  beq cr6, 0x828e6700
	if ctx.cr[6].eq {
	pc = 0x828E6700; continue 'dispatch;
	}
	// 828E66E4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828E66E8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E66EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E66F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E66F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E66F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E66FC: 480000C4  b 0x828e67c0
	pc = 0x828E67C0; continue 'dispatch;
	// 828E6700: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E6704: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E6708: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E670C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E6710: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E6714: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6718: 40810054  ble 0x828e676c
	if !ctx.cr[0].gt {
	pc = 0x828E676C; continue 'dispatch;
	}
	// 828E671C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E6720: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E6724: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E6728: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E672C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828E6730: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E6734: 41980008  blt cr6, 0x828e673c
	if ctx.cr[6].lt {
	pc = 0x828E673C; continue 'dispatch;
	}
	// 828E6738: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E673C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E6740: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E6744: 419A0014  beq cr6, 0x828e6758
	if ctx.cr[6].eq {
	pc = 0x828E6758; continue 'dispatch;
	}
	// 828E6748: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E674C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E6750: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E6754: 4800000C  b 0x828e6760
	pc = 0x828E6760; continue 'dispatch;
	// 828E6758: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E675C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E6760: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6764: 4199FFB8  bgt cr6, 0x828e671c
	if ctx.cr[6].gt {
	pc = 0x828E671C; continue 'dispatch;
	}
	// 828E6768: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E676C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E6770: 419A003C  beq cr6, 0x828e67ac
	if ctx.cr[6].eq {
	pc = 0x828E67AC; continue 'dispatch;
	}
	// 828E6774: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6778: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828E677C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E6780: 41990008  bgt cr6, 0x828e6788
	if ctx.cr[6].gt {
	pc = 0x828E6788; continue 'dispatch;
	}
	// 828E6784: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E6788: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E678C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6790: 409A001C  bne cr6, 0x828e67ac
	if !ctx.cr[6].eq {
	pc = 0x828E67AC; continue 'dispatch;
	}
	// 828E6794: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E6798: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E679C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E67A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E67A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E67A8: 48000018  b 0x828e67c0
	pc = 0x828E67C0; continue 'dispatch;
	// 828E67AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E67B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E67B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E67B8: 48000008  b 0x828e67c0
	pc = 0x828E67C0; continue 'dispatch;
	// 828E67BC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E67C0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E67C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E67C8: 419A0040  beq cr6, 0x828e6808
	if ctx.cr[6].eq {
	pc = 0x828E6808; continue 'dispatch;
	}
	// 828E67CC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828E67D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E67D4: 4B90EB4D  bl 0x821f5320
	ctx.lr = 0x828E67D8;
	sub_821F5320(ctx, base);
	// 828E67D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E67DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E67E0: 419A0028  beq cr6, 0x828e6808
	if ctx.cr[6].eq {
	pc = 0x828E6808; continue 'dispatch;
	}
	// 828E67E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E67E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E67EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E67F0: 4E800421  bctrl
	ctx.lr = 0x828E67F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E67F4: 2F030034  cmpwi cr6, r3, 0x34
	ctx.cr[6].compare_i32(ctx.r[3].s32, 52, &mut ctx.xer);
	// 828E67F8: 409A0010  bne cr6, 0x828e6808
	if !ctx.cr[6].eq {
	pc = 0x828E6808; continue 'dispatch;
	}
	// 828E67FC: C03F002C  lfs f1, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E6800: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6804: 483C2C58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E6808: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E680C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E6810: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E6814: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E6818: 419A00E4  beq cr6, 0x828e68fc
	if ctx.cr[6].eq {
	pc = 0x828E68FC; continue 'dispatch;
	}
	// 828E681C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E6820: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E6824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6828: 419A001C  beq cr6, 0x828e6844
	if ctx.cr[6].eq {
	pc = 0x828E6844; continue 'dispatch;
	}
	// 828E682C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6830: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E6834: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E6838: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E683C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E6840: 480000C0  b 0x828e6900
	pc = 0x828E6900; continue 'dispatch;
	// 828E6844: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E6848: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E684C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E6850: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E6854: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6858: 40810054  ble 0x828e68ac
	if !ctx.cr[0].gt {
	pc = 0x828E68AC; continue 'dispatch;
	}
	// 828E685C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E6860: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E6864: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E6868: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E686C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E6870: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E6874: 41980008  blt cr6, 0x828e687c
	if ctx.cr[6].lt {
	pc = 0x828E687C; continue 'dispatch;
	}
	// 828E6878: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E687C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E6880: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E6884: 419A0014  beq cr6, 0x828e6898
	if ctx.cr[6].eq {
	pc = 0x828E6898; continue 'dispatch;
	}
	// 828E6888: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E688C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E6890: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E6894: 4800000C  b 0x828e68a0
	pc = 0x828E68A0; continue 'dispatch;
	// 828E6898: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E689C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E68A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E68A4: 4199FFB8  bgt cr6, 0x828e685c
	if ctx.cr[6].gt {
	pc = 0x828E685C; continue 'dispatch;
	}
	// 828E68A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E68AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E68B0: 419A003C  beq cr6, 0x828e68ec
	if ctx.cr[6].eq {
	pc = 0x828E68EC; continue 'dispatch;
	}
	// 828E68B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E68B8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E68BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E68C0: 41990008  bgt cr6, 0x828e68c8
	if ctx.cr[6].gt {
	pc = 0x828E68C8; continue 'dispatch;
	}
	// 828E68C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E68C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E68CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E68D0: 409A001C  bne cr6, 0x828e68ec
	if !ctx.cr[6].eq {
	pc = 0x828E68EC; continue 'dispatch;
	}
	// 828E68D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E68D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E68DC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E68E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E68E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E68E8: 48000018  b 0x828e6900
	pc = 0x828E6900; continue 'dispatch;
	// 828E68EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E68F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E68F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E68F8: 48000008  b 0x828e6900
	pc = 0x828E6900; continue 'dispatch;
	// 828E68FC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828E6900: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E6904: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E6908: 419A003C  beq cr6, 0x828e6944
	if ctx.cr[6].eq {
	pc = 0x828E6944; continue 'dispatch;
	}
	// 828E690C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6910: 4B8D1F89  bl 0x821b8898
	ctx.lr = 0x828E6914;
	sub_821B8898(ctx, base);
	// 828E6914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6918: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E691C: 419A0028  beq cr6, 0x828e6944
	if ctx.cr[6].eq {
	pc = 0x828E6944; continue 'dispatch;
	}
	// 828E6920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6924: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E6928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E692C: 4E800421  bctrl
	ctx.lr = 0x828E6930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E6930: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 828E6934: 409A0010  bne cr6, 0x828e6944
	if !ctx.cr[6].eq {
	pc = 0x828E6944; continue 'dispatch;
	}
	// 828E6938: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E693C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6940: 483C2B1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E6944: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6948: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E694C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6950: 483C2B0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6958 size=436
    let mut pc: u32 = 0x828E6958;
    'dispatch: loop {
        match pc {
            0x828E6958 => {
    //   block [0x828E6958..0x828E6B0C)
	// 828E6958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E695C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6964: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6968: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E696C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E6970: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E6974: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828E6978: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E697C: 419A00F4  beq cr6, 0x828e6a70
	if ctx.cr[6].eq {
	pc = 0x828E6A70; continue 'dispatch;
	}
	// 828E6980: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E6984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E6988: 419A0024  beq cr6, 0x828e69ac
	if ctx.cr[6].eq {
	pc = 0x828E69AC; continue 'dispatch;
	}
	// 828E698C: 892A0021  lbz r9, 0x21(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6990: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E6994: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E6998: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E699C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E69A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E69A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E69A8: 480000CC  b 0x828e6a74
	pc = 0x828E6A74; continue 'dispatch;
	// 828E69AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E69B0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E69B4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828E69B8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E69BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E69C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E69C4: 40810054  ble 0x828e6a18
	if !ctx.cr[0].gt {
	pc = 0x828E6A18; continue 'dispatch;
	}
	// 828E69C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E69CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E69D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E69D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E69D8: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828E69DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E69E0: 41980008  blt cr6, 0x828e69e8
	if ctx.cr[6].lt {
	pc = 0x828E69E8; continue 'dispatch;
	}
	// 828E69E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828E69E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E69EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E69F0: 419A0014  beq cr6, 0x828e6a04
	if ctx.cr[6].eq {
	pc = 0x828E6A04; continue 'dispatch;
	}
	// 828E69F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E69F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E69FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E6A00: 4800000C  b 0x828e6a0c
	pc = 0x828E6A0C; continue 'dispatch;
	// 828E6A04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E6A08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E6A0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6A10: 4199FFB8  bgt cr6, 0x828e69c8
	if ctx.cr[6].gt {
	pc = 0x828E69C8; continue 'dispatch;
	}
	// 828E6A14: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E6A18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E6A1C: 419A0040  beq cr6, 0x828e6a5c
	if ctx.cr[6].eq {
	pc = 0x828E6A5C; continue 'dispatch;
	}
	// 828E6A20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6A24: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828E6A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E6A2C: 41990008  bgt cr6, 0x828e6a34
	if ctx.cr[6].gt {
	pc = 0x828E6A34; continue 'dispatch;
	}
	// 828E6A30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E6A34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E6A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6A3C: 409A0020  bne cr6, 0x828e6a5c
	if !ctx.cr[6].eq {
	pc = 0x828E6A5C; continue 'dispatch;
	}
	// 828E6A40: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E6A44: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E6A48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E6A4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6A50: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6A54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E6A58: 4800001C  b 0x828e6a74
	pc = 0x828E6A74; continue 'dispatch;
	// 828E6A5C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E6A60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6A64: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6A68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E6A6C: 48000008  b 0x828e6a74
	pc = 0x828E6A74; continue 'dispatch;
	// 828E6A70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E6A74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E6A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6A7C: 419A0078  beq cr6, 0x828e6af4
	if ctx.cr[6].eq {
	pc = 0x828E6AF4; continue 'dispatch;
	}
	// 828E6A80: 4B8D1E19  bl 0x821b8898
	ctx.lr = 0x828E6A84;
	sub_821B8898(ctx, base);
	// 828E6A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6A88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E6A8C: 419A0068  beq cr6, 0x828e6af4
	if ctx.cr[6].eq {
	pc = 0x828E6AF4; continue 'dispatch;
	}
	// 828E6A90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6A94: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E6A98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E6A9C: 4E800421  bctrl
	ctx.lr = 0x828E6AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E6AA0: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 828E6AA4: 409A001C  bne cr6, 0x828e6ac0
	if !ctx.cr[6].eq {
	pc = 0x828E6AC0; continue 'dispatch;
	}
	// 828E6AA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E6AAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6AB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6ABC: 4E800020  blr
	return;
	// 828E6AC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6AC8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E6ACC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E6AD0: 4E800421  bctrl
	ctx.lr = 0x828E6AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E6AD4: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 828E6AD8: 409A001C  bne cr6, 0x828e6af4
	if !ctx.cr[6].eq {
	pc = 0x828E6AF4; continue 'dispatch;
	}
	// 828E6ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6AE0: 4BDD7191  bl 0x826bdc70
	ctx.lr = 0x828E6AE4;
	sub_826BDC70(ctx, base);
	// 828E6AE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E6AE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E6AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6AF0: 419A0008  beq cr6, 0x828e6af8
	if ctx.cr[6].eq {
	pc = 0x828E6AF8; continue 'dispatch;
	}
	// 828E6AF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E6AF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6AFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6B00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6B10 size=428
    let mut pc: u32 = 0x828E6B10;
    'dispatch: loop {
        match pc {
            0x828E6B10 => {
    //   block [0x828E6B10..0x828E6CBC)
	// 828E6B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6B14: 483C28D5  bl 0x82ca93e8
	ctx.lr = 0x828E6B18;
	sub_82CA93D0(ctx, base);
	// 828E6B18: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 828E6B1C: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 828E6B20: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6B24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E6B28: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E6B2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E6B30: 4B938729  bl 0x8221f258
	ctx.lr = 0x828E6B34;
	sub_8221F258(ctx, base);
	// 828E6B34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6B38: 419A0008  beq cr6, 0x828e6b40
	if ctx.cr[6].eq {
	pc = 0x828E6B40; continue 'dispatch;
	}
	// 828E6B3C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E6B40: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6B44: 41820008  beq 0x828e6b4c
	if ctx.cr[0].eq {
	pc = 0x828E6B4C; continue 'dispatch;
	}
	// 828E6B48: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E6B4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6B50: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828E6B54: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 828E6B58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6B5C: 92BD0008  stw r21, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[21].u32 ) };
	// 828E6B60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E6B64: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828E6B68: D3DD000C  stfs f30, 0xc(r29)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E6B6C: 4B8F37DD  bl 0x821da348
	ctx.lr = 0x828E6B70;
	sub_821DA348(ctx, base);
	// 828E6B70: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E6B74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E6B78: 419A0130  beq cr6, 0x828e6ca8
	if ctx.cr[6].eq {
	pc = 0x828E6CA8; continue 'dispatch;
	}
	// 828E6B7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E6B80: 4B8CB979  bl 0x821b24f8
	ctx.lr = 0x828E6B84;
	sub_821B24F8(ctx, base);
	// 828E6B84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E6B88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E6B8C: 48119E05  bl 0x82a00990
	ctx.lr = 0x828E6B90;
	sub_82A00990(ctx, base);
	// 828E6B90: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828E6B94: 82810064  lwz r20, 0x64(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E6B98: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828E6B9C: 7F1FA040  cmplw cr6, r31, r20
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[20].u32, &mut ctx.xer);
	// 828E6BA0: 419A0100  beq cr6, 0x828e6ca0
	if ctx.cr[6].eq {
	pc = 0x828E6CA0; continue 'dispatch;
	}
	// 828E6BA4: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828E6BA8: C3E1005C  lfs f31, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6BAC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828E6BB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828E6BB4: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 828E6BB8: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 828E6BBC: 83DC6DA0  lwz r30, 0x6da0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828E6BC0: 3F20834A  lis r25, -0x7cb6
	ctx.r[25].s64 = -2092302336;
	// 828E6BC4: 3B0A4194  addi r24, r10, 0x4194
	ctx.r[24].s64 = ctx.r[10].s64 + 16788;
	// 828E6BC8: 3B4BE460  addi r26, r11, -0x1ba0
	ctx.r[26].s64 = ctx.r[11].s64 + -7072;
	// 828E6BCC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E6BD0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828E6BD4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E6BD8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828E6BDC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E6BE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6BE4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828E6BE8: 419A0020  beq cr6, 0x828e6c08
	if ctx.cr[6].eq {
	pc = 0x828E6C08; continue 'dispatch;
	}
	// 828E6BEC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828E6BF0: 409A0018  bne cr6, 0x828e6c08
	if !ctx.cr[6].eq {
	pc = 0x828E6C08; continue 'dispatch;
	}
	// 828E6BF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6BF8: 8139E454  lwz r9, -0x1bac(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828E6BFC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E6C00: 409A0008  bne cr6, 0x828e6c08
	if !ctx.cr[6].eq {
	pc = 0x828E6C08; continue 'dispatch;
	}
	// 828E6C04: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828E6C08: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6C0C: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 828E6C10: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E6C14: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 828E6C18: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828E6C1C: 419A0040  beq cr6, 0x828e6c5c
	if ctx.cr[6].eq {
	pc = 0x828E6C5C; continue 'dispatch;
	}
	// 828E6C20: 81766AB8  lwz r11, 0x6ab8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E6C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6C28: 409A0010  bne cr6, 0x828e6c38
	if !ctx.cr[6].eq {
	pc = 0x828E6C38; continue 'dispatch;
	}
	// 828E6C2C: 81776AC0  lwz r11, 0x6ac0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27328 as u32) ) } as u64;
	// 828E6C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6C34: 419A0010  beq cr6, 0x828e6c44
	if ctx.cr[6].eq {
	pc = 0x828E6C44; continue 'dispatch;
	}
	// 828E6C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6C3C: 4B8FD615  bl 0x821e4250
	ctx.lr = 0x828E6C40;
	sub_821E4250(ctx, base);
	// 828E6C40: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828E6C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E6C48: 4B8CB8B1  bl 0x821b24f8
	ctx.lr = 0x828E6C4C;
	sub_821B24F8(ctx, base);
	// 828E6C4C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828E6C50: 4B8AFF31  bl 0x82196b80
	ctx.lr = 0x828E6C54;
	sub_82196B80(ctx, base);
	// 828E6C54: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E6C58: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828E6C5C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828E6C60: 40990034  ble cr6, 0x828e6c94
	if !ctx.cr[6].gt {
	pc = 0x828E6C94; continue 'dispatch;
	}
	// 828E6C64: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6C68: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E6C6C: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 828E6C70: D1BD000C  stfs f13, 0xc(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E6C74: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E6C78: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 828E6C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6C80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6C84: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828E6C88: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E6C8C: 4BD9CF15  bl 0x82683ba0
	ctx.lr = 0x828E6C90;
	sub_82683BA0(ctx, base);
	// 828E6C90: 83DC6DA0  lwz r30, 0x6da0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828E6C94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E6C98: 7F1FA040  cmplw cr6, r31, r20
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[20].u32, &mut ctx.xer);
	// 828E6C9C: 409AFF30  bne cr6, 0x828e6bcc
	if !ctx.cr[6].eq {
	pc = 0x828E6BCC; continue 'dispatch;
	}
	// 828E6CA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E6CA4: 4B935095  bl 0x8221bd38
	ctx.lr = 0x828E6CA8;
	sub_8221BD38(ctx, base);
	// 828E6CA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6CAC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828E6CB0: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 828E6CB4: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 828E6CB8: 483C2780  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6CC0 size=204
    let mut pc: u32 = 0x828E6CC0;
    'dispatch: loop {
        match pc {
            0x828E6CC0 => {
    //   block [0x828E6CC0..0x828E6D8C)
	// 828E6CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6CD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E6CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6CDC: 419A0098  beq cr6, 0x828e6d74
	if ctx.cr[6].eq {
	pc = 0x828E6D74; continue 'dispatch;
	}
	// 828E6CE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6CE4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E6CE8: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E6CEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E6CF0: 40990084  ble cr6, 0x828e6d74
	if !ctx.cr[6].gt {
	pc = 0x828E6D74; continue 'dispatch;
	}
	// 828E6CF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E6CF8: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E6CFC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E6D00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6D04: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E6D08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6D0C: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 828E6D10: 4B909CB9  bl 0x821f09c8
	ctx.lr = 0x828E6D14;
	sub_821F09C8(ctx, base);
	// 828E6D14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6D18: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828E6D1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6D20: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E6D24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E6D28: 419A004C  beq cr6, 0x828e6d74
	if ctx.cr[6].eq {
	pc = 0x828E6D74; continue 'dispatch;
	}
	// 828E6D2C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E6D30: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828E6D34: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828E6D38: 41980018  blt cr6, 0x828e6d50
	if ctx.cr[6].lt {
	pc = 0x828E6D50; continue 'dispatch;
	}
	// 828E6D3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E6D40: 409A0008  bne cr6, 0x828e6d48
	if !ctx.cr[6].eq {
	pc = 0x828E6D48; continue 'dispatch;
	}
	// 828E6D44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E6D48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6D4C: 4BFFFFD8  b 0x828e6d24
	pc = 0x828E6D24; continue 'dispatch;
	// 828E6D50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E6D54: 409A0008  bne cr6, 0x828e6d5c
	if !ctx.cr[6].eq {
	pc = 0x828E6D5C; continue 'dispatch;
	}
	// 828E6D58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E6D5C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E6D60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E6D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6D6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6D70: 4E800020  blr
	return;
	// 828E6D74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E6D78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E6D7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6D80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6D84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6D88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6D90 size=332
    let mut pc: u32 = 0x828E6D90;
    'dispatch: loop {
        match pc {
            0x828E6D90 => {
    //   block [0x828E6D90..0x828E6EDC)
	// 828E6D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6D94: 483C2679  bl 0x82ca940c
	ctx.lr = 0x828E6D98;
	sub_82CA93D0(ctx, base);
	// 828E6D98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6D9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E6DA0: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 828E6DA4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6DA8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6DAC: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6DB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E6DB4: 409A002C  bne cr6, 0x828e6de0
	if !ctx.cr[6].eq {
	pc = 0x828E6DE0; continue 'dispatch;
	}
	// 828E6DB8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6DBC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828E6DC0: 4098000C  bge cr6, 0x828e6dcc
	if !ctx.cr[6].lt {
	pc = 0x828E6DCC; continue 'dispatch;
	}
	// 828E6DC4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E6DC8: 4800000C  b 0x828e6dd4
	pc = 0x828E6DD4; continue 'dispatch;
	// 828E6DCC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E6DD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6DD4: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6DD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E6DDC: 419AFFDC  beq cr6, 0x828e6db8
	if ctx.cr[6].eq {
	pc = 0x828E6DB8; continue 'dispatch;
	}
	// 828E6DE0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6DE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E6DE8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E6DEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E6DF0: 419A0018  beq cr6, 0x828e6e08
	if ctx.cr[6].eq {
	pc = 0x828E6E08; continue 'dispatch;
	}
	// 828E6DF4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6DF8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E6DFC: 4198000C  blt cr6, 0x828e6e08
	if ctx.cr[6].lt {
	pc = 0x828E6E08; continue 'dispatch;
	}
	// 828E6E00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E6E04: 48000010  b 0x828e6e14
	pc = 0x828E6E14; continue 'dispatch;
	// 828E6E08: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828E6E0C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828E6E10: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828E6E14: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828E6E18: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828E6E1C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E6E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6E24: 419A000C  beq cr6, 0x828e6e30
	if ctx.cr[6].eq {
	pc = 0x828E6E30; continue 'dispatch;
	}
	// 828E6E28: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828E6E2C: 419A0008  beq cr6, 0x828e6e34
	if ctx.cr[6].eq {
	pc = 0x828E6E34; continue 'dispatch;
	}
	// 828E6E30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E6E34: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E6E38: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E6E3C: 409A0088  bne cr6, 0x828e6ec4
	if !ctx.cr[6].eq {
	pc = 0x828E6EC4; continue 'dispatch;
	}
	// 828E6E40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E6E44: 4BFFFCCD  bl 0x828e6b10
	ctx.lr = 0x828E6E48;
	sub_828E6B10(ctx, base);
	// 828E6E48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E6E4C: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 828E6E50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6E54: 4800008D  bl 0x828e6ee0
	ctx.lr = 0x828E6E58;
	sub_828E6EE0(ctx, base);
	// 828E6E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6E5C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828E6E60: 419A0044  beq cr6, 0x828e6ea4
	if ctx.cr[6].eq {
	pc = 0x828E6EA4; continue 'dispatch;
	}
	// 828E6E64: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6E68: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828E6E6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E6E70: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6E74: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E6E78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E6E7C: 4812DF15  bl 0x82a14d90
	ctx.lr = 0x828E6E80;
	sub_82A14D90(ctx, base);
	// 828E6E80: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6E88: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828E6E8C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E6E90: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E6E94: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6E98: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 828E6E9C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E6EA0: 48000821  bl 0x828e76c0
	ctx.lr = 0x828E6EA4;
	sub_828E76C0(ctx, base);
	// 828E6EA4: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E6EA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E6EAC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E6EB0: 4812DEE1  bl 0x82a14d90
	ctx.lr = 0x828E6EB4;
	sub_82A14D90(ctx, base);
	// 828E6EB4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E6EB8: 4B934E81  bl 0x8221bd38
	ctx.lr = 0x828E6EBC;
	sub_8221BD38(ctx, base);
	// 828E6EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E6EC0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828E6EC4: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 828E6EC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6ECC: 48000015  bl 0x828e6ee0
	ctx.lr = 0x828E6ED0;
	sub_828E6EE0(ctx, base);
	// 828E6ED0: 4BFFFDF1  bl 0x828e6cc0
	ctx.lr = 0x828E6ED4;
	sub_828E6CC0(ctx, base);
	// 828E6ED4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E6ED8: 483C2584  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6EE0 size=348
    let mut pc: u32 = 0x828E6EE0;
    'dispatch: loop {
        match pc {
            0x828E6EE0 => {
    //   block [0x828E6EE0..0x828E703C)
	// 828E6EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E6EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6EF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E6EF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E6EFC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6F00: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6F04: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6F08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E6F0C: 409A0030  bne cr6, 0x828e6f3c
	if !ctx.cr[6].eq {
	pc = 0x828E6F3C; continue 'dispatch;
	}
	// 828E6F10: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6F14: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6F18: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E6F1C: 4098000C  bge cr6, 0x828e6f28
	if !ctx.cr[6].lt {
	pc = 0x828E6F28; continue 'dispatch;
	}
	// 828E6F20: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E6F24: 4800000C  b 0x828e6f30
	pc = 0x828E6F30; continue 'dispatch;
	// 828E6F28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E6F2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6F30: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E6F34: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E6F38: 419AFFDC  beq cr6, 0x828e6f14
	if ctx.cr[6].eq {
	pc = 0x828E6F14; continue 'dispatch;
	}
	// 828E6F3C: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6F40: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E6F44: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828E6F48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E6F4C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828E6F50: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E6F54: 419A0014  beq cr6, 0x828e6f68
	if ctx.cr[6].eq {
	pc = 0x828E6F68; continue 'dispatch;
	}
	// 828E6F58: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6F5C: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6F60: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828E6F64: 409800A0  bge cr6, 0x828e7004
	if !ctx.cr[6].lt {
	pc = 0x828E7004; continue 'dispatch;
	}
	// 828E6F68: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E6F6C: 4B9382ED  bl 0x8221f258
	ctx.lr = 0x828E6F70;
	sub_8221F258(ctx, base);
	// 828E6F70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6F74: 419A0008  beq cr6, 0x828e6f7c
	if ctx.cr[6].eq {
	pc = 0x828E6F7C; continue 'dispatch;
	}
	// 828E6F78: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E6F7C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6F80: 41820008  beq 0x828e6f88
	if ctx.cr[0].eq {
	pc = 0x828E6F88; continue 'dispatch;
	}
	// 828E6F84: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828E6F88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E6F8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6F90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E6F94: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 828E6F98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E6F9C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828E6FA0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E6FA4: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E6FA8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828E6FAC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828E6FB0: 480002B1  bl 0x828e7260
	ctx.lr = 0x828E6FB4;
	sub_828E7260(ctx, base);
	// 828E6FB4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828E6FB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6FBC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E6FC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E6FC4: 4800007D  bl 0x828e7040
	ctx.lr = 0x828E6FC8;
	sub_828E7040(ctx, base);
	// 828E6FC8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828E6FCC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E6FD0: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 828E6FD4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828E6FD8: 4812DDB9  bl 0x82a14d90
	ctx.lr = 0x828E6FDC;
	sub_82A14D90(ctx, base);
	// 828E6FDC: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828E6FE0: 4B934D59  bl 0x8221bd38
	ctx.lr = 0x828E6FE4;
	sub_8221BD38(ctx, base);
	// 828E6FE4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 828E6FE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E6FEC: 4812DDA5  bl 0x82a14d90
	ctx.lr = 0x828E6FF0;
	sub_82A14D90(ctx, base);
	// 828E6FF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E6FF4: 4B934D45  bl 0x8221bd38
	ctx.lr = 0x828E6FF8;
	sub_8221BD38(ctx, base);
	// 828E6FF8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E6FFC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7000: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828E7004: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7008: 409A0008  bne cr6, 0x828e7010
	if !ctx.cr[6].eq {
	pc = 0x828E7010; continue 'dispatch;
	}
	// 828E700C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7010: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7014: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E7018: 409A0008  bne cr6, 0x828e7020
	if !ctx.cr[6].eq {
	pc = 0x828E7020; continue 'dispatch;
	}
	// 828E701C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7020: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828E7024: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E7028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E702C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7040 size=540
    let mut pc: u32 = 0x828E7040;
    'dispatch: loop {
        match pc {
            0x828E7040 => {
    //   block [0x828E7040..0x828E725C)
	// 828E7040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7044: 483C23C1  bl 0x82ca9404
	ctx.lr = 0x828E7048;
	sub_82CA93D0(ctx, base);
	// 828E7048: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E704C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E7050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E7054: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828E7058: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E705C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7060: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 828E7064: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E7068: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E706C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E7070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7074: 409A0020  bne cr6, 0x828e7094
	if !ctx.cr[6].eq {
	pc = 0x828E7094; continue 'dispatch;
	}
	// 828E7078: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E707C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7080: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E7084: 480003C5  bl 0x828e7448
	ctx.lr = 0x828E7088;
	sub_828E7448(ctx, base);
	// 828E7088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E708C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E7090: 483C23C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E7094: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7098: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828E709C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E70A0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E70A4: 419A000C  beq cr6, 0x828e70b0
	if ctx.cr[6].eq {
	pc = 0x828E70B0; continue 'dispatch;
	}
	// 828E70A8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828E70AC: 419A0008  beq cr6, 0x828e70b4
	if ctx.cr[6].eq {
	pc = 0x828E70B4; continue 'dispatch;
	}
	// 828E70B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E70B4: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828E70B8: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E70BC: 409A0038  bne cr6, 0x828e70f4
	if !ctx.cr[6].eq {
	pc = 0x828E70F4; continue 'dispatch;
	}
	// 828E70C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E70C4: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E70C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E70CC: 40980160  bge cr6, 0x828e722c
	if !ctx.cr[6].lt {
	pc = 0x828E722C; continue 'dispatch;
	}
	// 828E70D0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E70D4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828E70D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E70DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E70E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E70E4: 48000365  bl 0x828e7448
	ctx.lr = 0x828E70E8;
	sub_828E7448(ctx, base);
	// 828E70E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E70EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E70F0: 483C2364  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E70F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E70F8: 419A000C  beq cr6, 0x828e7104
	if ctx.cr[6].eq {
	pc = 0x828E7104; continue 'dispatch;
	}
	// 828E70FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828E7100: 419A0008  beq cr6, 0x828e7108
	if ctx.cr[6].eq {
	pc = 0x828E7108; continue 'dispatch;
	}
	// 828E7104: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7108: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E710C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E7110: 409A0034  bne cr6, 0x828e7144
	if !ctx.cr[6].eq {
	pc = 0x828E7144; continue 'dispatch;
	}
	// 828E7114: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E7118: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E711C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E7120: 4098010C  bge cr6, 0x828e722c
	if !ctx.cr[6].lt {
	pc = 0x828E722C; continue 'dispatch;
	}
	// 828E7124: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E7128: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E712C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7134: 48000315  bl 0x828e7448
	ctx.lr = 0x828E7138;
	sub_828E7448(ctx, base);
	// 828E7138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E713C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E7140: 483C2314  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E7144: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7148: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E714C: 40980058  bge cr6, 0x828e71a4
	if !ctx.cr[6].lt {
	pc = 0x828E71A4; continue 'dispatch;
	}
	// 828E7150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7154: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828E7158: 4BA97289  bl 0x8237e3e0
	ctx.lr = 0x828E715C;
	sub_8237E3E0(ctx, base);
	// 828E715C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E7160: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7164: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7168: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E716C: 40980038  bge cr6, 0x828e71a4
	if !ctx.cr[6].lt {
	pc = 0x828E71A4; continue 'dispatch;
	}
	// 828E7170: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E7174: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E7178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E717C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7180: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E7184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7188: 409A0090  bne cr6, 0x828e7218
	if !ctx.cr[6].eq {
	pc = 0x828E7218; continue 'dispatch;
	}
	// 828E718C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828E7190: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E7194: 480002B5  bl 0x828e7448
	ctx.lr = 0x828E7198;
	sub_828E7448(ctx, base);
	// 828E7198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E719C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E71A0: 483C22B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E71A4: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E71A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E71AC: 40980080  bge cr6, 0x828e722c
	if !ctx.cr[6].lt {
	pc = 0x828E722C; continue 'dispatch;
	}
	// 828E71B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E71B4: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828E71B8: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E71BC: 4BA2D96D  bl 0x82314b28
	ctx.lr = 0x828E71C0;
	sub_82314B28(ctx, base);
	// 828E71C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E71C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E71C8: 419A000C  beq cr6, 0x828e71d4
	if ctx.cr[6].eq {
	pc = 0x828E71D4; continue 'dispatch;
	}
	// 828E71CC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828E71D0: 419A0008  beq cr6, 0x828e71d8
	if ctx.cr[6].eq {
	pc = 0x828E71D8; continue 'dispatch;
	}
	// 828E71D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E71D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E71DC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E71E0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828E71E4: 419A0014  beq cr6, 0x828e71f8
	if ctx.cr[6].eq {
	pc = 0x828E71F8; continue 'dispatch;
	}
	// 828E71E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E71EC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E71F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E71F4: 40980038  bge cr6, 0x828e722c
	if !ctx.cr[6].lt {
	pc = 0x828E722C; continue 'dispatch;
	}
	// 828E71F8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E71FC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E7200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7208: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E720C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7210: 419AFF80  beq cr6, 0x828e7190
	if ctx.cr[6].eq {
	pc = 0x828E7190; continue 'dispatch;
	}
	// 828E7214: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828E7218: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E721C: 4800022D  bl 0x828e7448
	ctx.lr = 0x828E7220;
	sub_828E7448(ctx, base);
	// 828E7220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7224: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E7228: 483C222C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E722C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828E7230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7234: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7238: 480000D1  bl 0x828e7308
	ctx.lr = 0x828E723C;
	sub_828E7308(ctx, base);
	// 828E723C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E7240: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7244: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7248: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E724C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7250: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E7254: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E7258: 483C21FC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7260 size=168
    let mut pc: u32 = 0x828E7260;
    'dispatch: loop {
        match pc {
            0x828E7260 => {
    //   block [0x828E7260..0x828E7308)
	// 828E7260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E726C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7270: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E7278: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E727C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E7280: 4B937FD9  bl 0x8221f258
	ctx.lr = 0x828E7284;
	sub_8221F258(ctx, base);
	// 828E7284: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E7288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E728C: 419A0008  beq cr6, 0x828e7294
	if ctx.cr[6].eq {
	pc = 0x828E7294; continue 'dispatch;
	}
	// 828E7290: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E7294: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E7298: 41820008  beq 0x828e72a0
	if ctx.cr[0].eq {
	pc = 0x828E72A0; continue 'dispatch;
	}
	// 828E729C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E72A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E72A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828E72A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E72AC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828E72B0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E72B4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E72B8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E72BC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 828E72C0: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E72C4: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828E72C8: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 828E72CC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828E72D0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E72D4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E72D8: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E72DC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E72E0: 480003E1  bl 0x828e76c0
	ctx.lr = 0x828E72E4;
	sub_828E76C0(ctx, base);
	// 828E72E4: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E72E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E72EC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828E72F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E72F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E72F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E72FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7300: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7308 size=316
    let mut pc: u32 = 0x828E7308;
    'dispatch: loop {
        match pc {
            0x828E7308 => {
    //   block [0x828E7308..0x828E7444)
	// 828E7308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E730C: 483C20F5  bl 0x82ca9400
	ctx.lr = 0x828E7310;
	sub_82CA93D0(ctx, base);
	// 828E7310: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7314: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828E7318: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828E731C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E7320: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828E7324: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828E7328: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E732C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7330: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E7334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7338: 409A003C  bne cr6, 0x828e7374
	if !ctx.cr[6].eq {
	pc = 0x828E7374; continue 'dispatch;
	}
	// 828E733C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7340: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7344: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E7348: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828E734C: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 828E7350: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 828E7354: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E7358: 419A000C  beq cr6, 0x828e7364
	if ctx.cr[6].eq {
	pc = 0x828E7364; continue 'dispatch;
	}
	// 828E735C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7360: 48000008  b 0x828e7368
	pc = 0x828E7368; continue 'dispatch;
	// 828E7364: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E7368: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828E736C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7370: 419AFFD0  beq cr6, 0x828e7340
	if ctx.cr[6].eq {
	pc = 0x828E7340; continue 'dispatch;
	}
	// 828E7374: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828E7378: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E737C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828E7380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7384: 419A0054  beq cr6, 0x828e73d8
	if ctx.cr[6].eq {
	pc = 0x828E73D8; continue 'dispatch;
	}
	// 828E7388: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E738C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7390: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7394: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E7398: 409A003C  bne cr6, 0x828e73d4
	if !ctx.cr[6].eq {
	pc = 0x828E73D4; continue 'dispatch;
	}
	// 828E739C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828E73A0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828E73A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E73A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E73AC: 4800009D  bl 0x828e7448
	ctx.lr = 0x828E73B0;
	sub_828E7448(ctx, base);
	// 828E73B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E73B4: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828E73B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E73BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E73C0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E73C4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E73C8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E73CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E73D0: 483C2080  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828E73D4: 4BA9700D  bl 0x8237e3e0
	ctx.lr = 0x828E73D8;
	sub_8237E3E0(ctx, base);
	// 828E73D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E73DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E73E0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E73E4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E73E8: 40980040  bge cr6, 0x828e7428
	if !ctx.cr[6].lt {
	pc = 0x828E7428; continue 'dispatch;
	}
	// 828E73EC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828E73F0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828E73F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828E73F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E73FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7400: 48000049  bl 0x828e7448
	ctx.lr = 0x828E7404;
	sub_828E7448(ctx, base);
	// 828E7404: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E7408: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828E740C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7414: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7418: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E741C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E7420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E7424: 483C202C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828E7428: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E742C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E7430: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7434: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828E7438: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E743C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E7440: 483C2010  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7448 size=632
    let mut pc: u32 = 0x828E7448;
    'dispatch: loop {
        match pc {
            0x828E7448 => {
    //   block [0x828E7448..0x828E76C0)
	// 828E7448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E744C: 483C1FAD  bl 0x82ca93f8
	ctx.lr = 0x828E7450;
	sub_82CA93D0(ctx, base);
	// 828E7450: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7454: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E7458: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 828E745C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828E7460: 6169CCCB  ori r9, r11, 0xcccb
	ctx.r[9].u64 = ctx.r[11].u64 | 52427;
	// 828E7464: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E7468: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E746C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828E7470: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828E7474: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E7478: 41980048  blt cr6, 0x828e74c0
	if ctx.cr[6].lt {
	pc = 0x828E74C0; continue 'dispatch;
	}
	// 828E747C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828E7480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7484: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 828E7488: 4BA0AAB9  bl 0x822f1f40
	ctx.lr = 0x828E748C;
	sub_822F1F40(ctx, base);
	// 828E748C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E7490: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E7494: 4BA0A91D  bl 0x822f1db0
	ctx.lr = 0x828E7498;
	sub_822F1DB0(ctx, base);
	// 828E7498: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828E749C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E74A0: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828E74A4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828E74A8: 4BA0A979  bl 0x822f1e20
	ctx.lr = 0x828E74AC;
	sub_822F1E20(ctx, base);
	// 828E74AC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828E74B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E74B4: 4BD9432D  bl 0x8267b7e0
	ctx.lr = 0x828E74B8;
	sub_8267B7E0(ctx, base);
	// 828E74B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E74BC: 4B88A355  bl 0x82171810
	ctx.lr = 0x828E74C0;
	sub_82171810(ctx, base);
	// 828E74C0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 828E74C4: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E74C8: 4B937D91  bl 0x8221f258
	ctx.lr = 0x828E74CC;
	sub_8221F258(ctx, base);
	// 828E74CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E74D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828E74D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828E74D8: 419A0030  beq cr6, 0x828e7508
	if ctx.cr[6].eq {
	pc = 0x828E7508; continue 'dispatch;
	}
	// 828E74DC: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 828E74E0: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E74E4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828E74E8: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 828E74EC: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828E74F0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 828E74F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E74F8: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828E74FC: 4BFFFD65  bl 0x828e7260
	ctx.lr = 0x828E7500;
	sub_828E7260(ctx, base);
	// 828E7500: 9B3B0020  stb r25, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828E7504: 9B3B0021  stb r25, 0x21(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	// 828E7508: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E750C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7510: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E7514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E7518: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E751C: 409A001C  bne cr6, 0x828e7538
	if !ctx.cr[6].eq {
	pc = 0x828E7538; continue 'dispatch;
	}
	// 828E7520: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828E7524: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7528: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828E752C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7530: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828E7534: 48000044  b 0x828e7578
	pc = 0x828E7578; continue 'dispatch;
	// 828E7538: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828E753C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7540: 419A0020  beq cr6, 0x828e7560
	if ctx.cr[6].eq {
	pc = 0x828E7560; continue 'dispatch;
	}
	// 828E7544: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828E7548: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E754C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7550: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E7554: 409A0024  bne cr6, 0x828e7578
	if !ctx.cr[6].eq {
	pc = 0x828E7578; continue 'dispatch;
	}
	// 828E7558: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828E755C: 4800001C  b 0x828e7578
	pc = 0x828E7578; continue 'dispatch;
	// 828E7560: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828E7564: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7568: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E756C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E7570: 409A0008  bne cr6, 0x828e7578
	if !ctx.cr[6].eq {
	pc = 0x828E7578; continue 'dispatch;
	}
	// 828E7574: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828E7578: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E757C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828E7580: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828E7584: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E7588: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E758C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7590: 409A0110  bne cr6, 0x828e76a0
	if !ctx.cr[6].eq {
	pc = 0x828E76A0; continue 'dispatch;
	}
	// 828E7594: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7598: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E759C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E75A0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828E75A4: 409A0078  bne cr6, 0x828e761c
	if !ctx.cr[6].eq {
	pc = 0x828E761C; continue 'dispatch;
	}
	// 828E75A8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E75AC: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E75B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E75B4: 409A0028  bne cr6, 0x828e75dc
	if !ctx.cr[6].eq {
	pc = 0x828E75DC; continue 'dispatch;
	}
	// 828E75B8: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828E75BC: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E75C0: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E75C4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E75C8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E75CC: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828E75D0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E75D4: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E75D8: 480000B4  b 0x828e768c
	pc = 0x828E768C; continue 'dispatch;
	// 828E75DC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E75E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E75E4: 409A0010  bne cr6, 0x828e75f4
	if !ctx.cr[6].eq {
	pc = 0x828E75F4; continue 'dispatch;
	}
	// 828E75E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E75EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E75F0: 4BFCA291  bl 0x828b1880
	ctx.lr = 0x828E75F4;
	sub_828B1880(ctx, base);
	// 828E75F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E75F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E75FC: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E7600: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7604: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7608: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828E760C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7610: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7614: 4BA2C4E5  bl 0x82313af8
	ctx.lr = 0x828E7618;
	sub_82313AF8(ctx, base);
	// 828E7618: 48000074  b 0x828e768c
	pc = 0x828E768C; continue 'dispatch;
	// 828E761C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7620: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E7624: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7628: 409A0028  bne cr6, 0x828e7650
	if !ctx.cr[6].eq {
	pc = 0x828E7650; continue 'dispatch;
	}
	// 828E762C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7630: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E7634: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E7638: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E763C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7640: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828E7644: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7648: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E764C: 48000040  b 0x828e768c
	pc = 0x828E768C; continue 'dispatch;
	// 828E7650: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7654: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E7658: 409A0010  bne cr6, 0x828e7668
	if !ctx.cr[6].eq {
	pc = 0x828E7668; continue 'dispatch;
	}
	// 828E765C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E7660: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E7664: 4BA2C495  bl 0x82313af8
	ctx.lr = 0x828E7668;
	sub_82313AF8(ctx, base);
	// 828E7668: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E766C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E7670: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E7674: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7678: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E767C: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 828E7680: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7684: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7688: 4BFCA1F9  bl 0x828b1880
	ctx.lr = 0x828E768C;
	sub_828B1880(ctx, base);
	// 828E768C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7690: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828E7694: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E7698: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E769C: 419AFEF8  beq cr6, 0x828e7594
	if ctx.cr[6].eq {
	pc = 0x828E7594; continue 'dispatch;
	}
	// 828E76A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E76A4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828E76A8: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828E76AC: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E76B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E76B4: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828E76B8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828E76BC: 483C1D8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E76C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E76C0 size=148
    let mut pc: u32 = 0x828E76C0;
    'dispatch: loop {
        match pc {
            0x828E76C0 => {
    //   block [0x828E76C0..0x828E7754)
	// 828E76C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E76C4: 483C1D3D  bl 0x82ca9400
	ctx.lr = 0x828E76C8;
	sub_82CA93D0(ctx, base);
	// 828E76C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E76CC: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828E76D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E76D4: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 828E76D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828E76DC: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828E76E0: 834100B8  lwz r26, 0xb8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828E76E4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E76E8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E76EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E76F0: 419A000C  beq cr6, 0x828e76fc
	if ctx.cr[6].eq {
	pc = 0x828E76FC; continue 'dispatch;
	}
	// 828E76F4: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828E76F8: 419A0008  beq cr6, 0x828e7700
	if ctx.cr[6].eq {
	pc = 0x828E7700; continue 'dispatch;
	}
	// 828E76FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7700: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828E7704: 419A0048  beq cr6, 0x828e774c
	if ctx.cr[6].eq {
	pc = 0x828E774C; continue 'dispatch;
	}
	// 828E7708: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E770C: 409A0008  bne cr6, 0x828e7714
	if !ctx.cr[6].eq {
	pc = 0x828E7714; continue 'dispatch;
	}
	// 828E7710: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7714: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7718: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E771C: 409A0008  bne cr6, 0x828e7724
	if !ctx.cr[6].eq {
	pc = 0x828E7724; continue 'dispatch;
	}
	// 828E7720: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7724: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828E7728: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E772C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E7730: 4BD9C471  bl 0x82683ba0
	ctx.lr = 0x828E7734;
	sub_82683BA0(ctx, base);
	// 828E7734: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7738: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E773C: 409A0008  bne cr6, 0x828e7744
	if !ctx.cr[6].eq {
	pc = 0x828E7744; continue 'dispatch;
	}
	// 828E7740: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E7744: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7748: 4BFFFFA4  b 0x828e76ec
	pc = 0x828E76EC; continue 'dispatch;
	// 828E774C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E7750: 483C1D00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7758 size=60
    let mut pc: u32 = 0x828E7758;
    'dispatch: loop {
        match pc {
            0x828E7758 => {
    //   block [0x828E7758..0x828E7794)
	// 828E7758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E775C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7768: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E776C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E7770: 388B93A8  addi r4, r11, -0x6c58
	ctx.r[4].s64 = ctx.r[11].s64 + -27736;
	// 828E7774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E7778: 4B945759  bl 0x8222ced0
	ctx.lr = 0x828E777C;
	sub_8222CED0(ctx, base);
	// 828E777C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7780: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E7784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E778C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7798 size=612
    let mut pc: u32 = 0x828E7798;
    'dispatch: loop {
        match pc {
            0x828E7798 => {
    //   block [0x828E7798..0x828E79FC)
	// 828E7798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E779C: 483C1C71  bl 0x82ca940c
	ctx.lr = 0x828E77A0;
	sub_82CA93D0(ctx, base);
	// 828E77A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E77A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E77A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E77AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E77B0: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 828E77B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E77B8: 9BA10052  stb r29, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[29].u8 ) };
	// 828E77BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E77C0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828E77C4: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 828E77C8: 419A00B0  beq cr6, 0x828e7878
	if ctx.cr[6].eq {
	pc = 0x828E7878; continue 'dispatch;
	}
	// 828E77CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828E77D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E77D4: 388B37E8  addi r4, r11, 0x37e8
	ctx.r[4].s64 = ctx.r[11].s64 + 14312;
	// 828E77D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E77DC: 4BAC5B65  bl 0x823ad340
	ctx.lr = 0x828E77E0;
	sub_823AD340(ctx, base);
	// 828E77E0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828E77E4: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 828E77E8: 388A37F8  addi r4, r10, 0x37f8
	ctx.r[4].s64 = ctx.r[10].s64 + 14328;
	// 828E77EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E77F0: 4BAC5B51  bl 0x823ad340
	ctx.lr = 0x828E77F4;
	sub_823AD340(ctx, base);
	// 828E77F4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 828E77F8: 38A10052  addi r5, r1, 0x52
	ctx.r[5].s64 = ctx.r[1].s64 + 82;
	// 828E77FC: 38893810  addi r4, r9, 0x3810
	ctx.r[4].s64 = ctx.r[9].s64 + 14352;
	// 828E7800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7804: 4BAC5B3D  bl 0x823ad340
	ctx.lr = 0x828E7808;
	sub_823AD340(ctx, base);
	// 828E7808: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828E780C: 38A10053  addi r5, r1, 0x53
	ctx.r[5].s64 = ctx.r[1].s64 + 83;
	// 828E7810: 38883824  addi r4, r8, 0x3824
	ctx.r[4].s64 = ctx.r[8].s64 + 14372;
	// 828E7814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7818: 4BAC5B29  bl 0x823ad340
	ctx.lr = 0x828E781C;
	sub_823AD340(ctx, base);
	// 828E781C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 828E7820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7824: 38A7C4AC  addi r5, r7, -0x3b54
	ctx.r[5].s64 = ctx.r[7].s64 + -15188;
	// 828E7828: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E782C: 4BE9BBED  bl 0x82783418
	ctx.lr = 0x828E7830;
	sub_82783418(ctx, base);
	// 828E7830: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E7834: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828E7838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E783C: 38A541AC  addi r5, r5, 0x41ac
	ctx.r[5].s64 = ctx.r[5].s64 + 16812;
	// 828E7840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7844: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7848: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828E784C: 4BE9BBCD  bl 0x82783418
	ctx.lr = 0x828E7850;
	sub_82783418(ctx, base);
	// 828E7850: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828E7854: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828E7858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E785C: 38A941B8  addi r5, r9, 0x41b8
	ctx.r[5].s64 = ctx.r[9].s64 + 16824;
	// 828E7860: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E7864: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7868: 911E001C  stw r8, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 828E786C: 4BE9BBAD  bl 0x82783418
	ctx.lr = 0x828E7870;
	sub_82783418(ctx, base);
	// 828E7870: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7874: 90FE0020  stw r7, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 828E7878: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E787C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828E7880: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E7884: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828E7888: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E788C: 419A00D4  beq cr6, 0x828e7960
	if ctx.cr[6].eq {
	pc = 0x828E7960; continue 'dispatch;
	}
	// 828E7890: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E7894: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7898: 419A001C  beq cr6, 0x828e78b4
	if ctx.cr[6].eq {
	pc = 0x828E78B4; continue 'dispatch;
	}
	// 828E789C: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828E78A0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E78A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E78A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E78AC: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E78B0: 480000B0  b 0x828e7960
	pc = 0x828E7960; continue 'dispatch;
	// 828E78B4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E78B8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E78BC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828E78C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E78C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E78C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E78CC: 40810054  ble 0x828e7920
	if !ctx.cr[0].gt {
	pc = 0x828E7920; continue 'dispatch;
	}
	// 828E78D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E78D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E78D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E78DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E78E0: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828E78E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E78E8: 41980008  blt cr6, 0x828e78f0
	if ctx.cr[6].lt {
	pc = 0x828E78F0; continue 'dispatch;
	}
	// 828E78EC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E78F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E78F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E78F8: 419A0014  beq cr6, 0x828e790c
	if ctx.cr[6].eq {
	pc = 0x828E790C; continue 'dispatch;
	}
	// 828E78FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E7900: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E7904: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E7908: 4800000C  b 0x828e7914
	pc = 0x828E7914; continue 'dispatch;
	// 828E790C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E7910: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E7914: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7918: 4199FFB8  bgt cr6, 0x828e78d0
	if ctx.cr[6].gt {
	pc = 0x828E78D0; continue 'dispatch;
	}
	// 828E791C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E7920: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E7924: 419A0034  beq cr6, 0x828e7958
	if ctx.cr[6].eq {
	pc = 0x828E7958; continue 'dispatch;
	}
	// 828E7928: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E792C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828E7930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E7934: 41990008  bgt cr6, 0x828e793c
	if ctx.cr[6].gt {
	pc = 0x828E793C; continue 'dispatch;
	}
	// 828E7938: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828E793C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E7940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7944: 409A0014  bne cr6, 0x828e7958
	if !ctx.cr[6].eq {
	pc = 0x828E7958; continue 'dispatch;
	}
	// 828E7948: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E794C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828E7950: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E7954: 48000008  b 0x828e795c
	pc = 0x828E795C; continue 'dispatch;
	// 828E7958: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E795C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7960: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 828E7964: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E7968: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E796C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E7970: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828E7974: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828E7978: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828E797C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828E7980: 481AF9E9  bl 0x82a97368
	ctx.lr = 0x828E7984;
	sub_82A97368(ctx, base);
	// 828E7984: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7988: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E798C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E7990: 616A0040  ori r10, r11, 0x40
	ctx.r[10].u64 = ctx.r[11].u64 | 64;
	// 828E7994: 419A0008  beq cr6, 0x828e799c
	if ctx.cr[6].eq {
	pc = 0x828E799C; continue 'dispatch;
	}
	// 828E7998: 556A06B0  rlwinm r10, r11, 0, 0x1a, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E799C: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828E79A0: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828E79A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E79A8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E79AC: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828E79B0: 409A0008  bne cr6, 0x828e79b8
	if !ctx.cr[6].eq {
	pc = 0x828E79B8; continue 'dispatch;
	}
	// 828E79B4: 556A066E  rlwinm r10, r11, 0, 0x19, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E79B8: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828E79BC: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828E79C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E79C4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E79C8: 616A0200  ori r10, r11, 0x200
	ctx.r[10].u64 = ctx.r[11].u64 | 512;
	// 828E79CC: 409A0008  bne cr6, 0x828e79d4
	if !ctx.cr[6].eq {
	pc = 0x828E79D4; continue 'dispatch;
	}
	// 828E79D0: 556A05EA  rlwinm r10, r11, 0, 0x17, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E79D4: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828E79D8: 89410053  lbz r10, 0x53(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 828E79DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E79E0: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E79E4: 616A0400  ori r10, r11, 0x400
	ctx.r[10].u64 = ctx.r[11].u64 | 1024;
	// 828E79E8: 409A0008  bne cr6, 0x828e79f0
	if !ctx.cr[6].eq {
	pc = 0x828E79F0; continue 'dispatch;
	}
	// 828E79EC: 556A05A8  rlwinm r10, r11, 0, 0x16, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E79F0: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828E79F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E79F8: 483C1A64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7A00 size=368
    let mut pc: u32 = 0x828E7A00;
    'dispatch: loop {
        match pc {
            0x828E7A00 => {
    //   block [0x828E7A00..0x828E7B70)
	// 828E7A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E7A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7A14: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E7A18: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E7A1C: 419A013C  beq cr6, 0x828e7b58
	if ctx.cr[6].eq {
	pc = 0x828E7B58; continue 'dispatch;
	}
	// 828E7A20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7A24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E7A28: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 828E7A2C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E7A30: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828E7A34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7A38: 419A00D4  beq cr6, 0x828e7b0c
	if ctx.cr[6].eq {
	pc = 0x828E7B0C; continue 'dispatch;
	}
	// 828E7A3C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E7A40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7A44: 419A001C  beq cr6, 0x828e7a60
	if ctx.cr[6].eq {
	pc = 0x828E7A60; continue 'dispatch;
	}
	// 828E7A48: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828E7A4C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E7A50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E7A54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E7A58: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7A5C: 480000B0  b 0x828e7b0c
	pc = 0x828E7B0C; continue 'dispatch;
	// 828E7A60: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E7A64: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E7A68: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E7A6C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E7A70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E7A74: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7A78: 40810054  ble 0x828e7acc
	if !ctx.cr[0].gt {
	pc = 0x828E7ACC; continue 'dispatch;
	}
	// 828E7A7C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E7A80: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E7A84: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E7A88: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7A8C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828E7A90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E7A94: 41980008  blt cr6, 0x828e7a9c
	if ctx.cr[6].lt {
	pc = 0x828E7A9C; continue 'dispatch;
	}
	// 828E7A98: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E7A9C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E7AA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E7AA4: 419A0014  beq cr6, 0x828e7ab8
	if ctx.cr[6].eq {
	pc = 0x828E7AB8; continue 'dispatch;
	}
	// 828E7AA8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E7AAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E7AB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E7AB4: 4800000C  b 0x828e7ac0
	pc = 0x828E7AC0; continue 'dispatch;
	// 828E7AB8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E7ABC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E7AC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7AC4: 4199FFB8  bgt cr6, 0x828e7a7c
	if ctx.cr[6].gt {
	pc = 0x828E7A7C; continue 'dispatch;
	}
	// 828E7AC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E7ACC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E7AD0: 419A0034  beq cr6, 0x828e7b04
	if ctx.cr[6].eq {
	pc = 0x828E7B04; continue 'dispatch;
	}
	// 828E7AD4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7AD8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828E7ADC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E7AE0: 41990008  bgt cr6, 0x828e7ae8
	if ctx.cr[6].gt {
	pc = 0x828E7AE8; continue 'dispatch;
	}
	// 828E7AE4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E7AE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E7AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7AF0: 409A0014  bne cr6, 0x828e7b04
	if !ctx.cr[6].eq {
	pc = 0x828E7B04; continue 'dispatch;
	}
	// 828E7AF4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E7AF8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E7AFC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E7B00: 48000008  b 0x828e7b08
	pc = 0x828E7B08; continue 'dispatch;
	// 828E7B04: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E7B08: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7B0C: 83DF0090  lwz r30, 0x90(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E7B10: 57CB0630  rlwinm r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 828E7B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7B18: 409A000C  bne cr6, 0x828e7b24
	if !ctx.cr[6].eq {
	pc = 0x828E7B24; continue 'dispatch;
	}
	// 828E7B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7B20: 4BC8ADC9  bl 0x825728e8
	ctx.lr = 0x828E7B24;
	sub_825728E8(ctx, base);
	// 828E7B24: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E7B28: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828E7B2C: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828E7B30: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828E7B34: 409A0024  bne cr6, 0x828e7b58
	if !ctx.cr[6].eq {
	pc = 0x828E7B58; continue 'dispatch;
	}
	// 828E7B38: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E7B3C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7B40: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E7B44: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7B48: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E7B4C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7B50: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7B54: 4B9294C5  bl 0x82211018
	ctx.lr = 0x828E7B58;
	sub_82211018(ctx, base);
	// 828E7B58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E7B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7B64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E7B70 size=16
    let mut pc: u32 = 0x828E7B70;
    'dispatch: loop {
        match pc {
            0x828E7B70 => {
    //   block [0x828E7B70..0x828E7B80)
	// 828E7B70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E7B74: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828E7B78: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 828E7B7C: 4BC978AC  b 0x8257f428
	sub_8257F428(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7B80 size=196
    let mut pc: u32 = 0x828E7B80;
    'dispatch: loop {
        match pc {
            0x828E7B80 => {
    //   block [0x828E7B80..0x828E7C44)
	// 828E7B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7B84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7B88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E7B8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7B90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7B94: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7B98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E7B9C: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 828E7BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7BA4: 40990088  ble cr6, 0x828e7c2c
	if !ctx.cr[6].gt {
	pc = 0x828E7C2C; continue 'dispatch;
	}
	// 828E7BA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E7BAC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828E7BB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7BB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E7BB8: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E7BBC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7BC0: 80690070  lwz r3, 0x70(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 828E7BC4: 4B957635  bl 0x8223f1f8
	ctx.lr = 0x828E7BC8;
	sub_8223F1F8(ctx, base);
	// 828E7BC8: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E7BCC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7BD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E7BD4: 419A0010  beq cr6, 0x828e7be4
	if ctx.cr[6].eq {
	pc = 0x828E7BE4; continue 'dispatch;
	}
	// 828E7BD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E7BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7BE0: 4BFD4639  bl 0x828bc218
	ctx.lr = 0x828E7BE4;
	sub_828BC218(ctx, base);
	// 828E7BE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E7BE8: 419A0044  beq cr6, 0x828e7c2c
	if ctx.cr[6].eq {
	pc = 0x828E7C2C; continue 'dispatch;
	}
	// 828E7BEC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828E7BF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7BF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7BF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7BFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E7C00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7C04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7C08: 4082FFE8  bne 0x828e7bf0
	if !ctx.cr[0].eq {
	pc = 0x828E7BF0; continue 'dispatch;
	}
	// 828E7C0C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E7C10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7C14: 409A0018  bne cr6, 0x828e7c2c
	if !ctx.cr[6].eq {
	pc = 0x828E7C2C; continue 'dispatch;
	}
	// 828E7C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7C20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7C24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E7C28: 4E800421  bctrl
	ctx.lr = 0x828E7C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E7C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7C38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7C48 size=384
    let mut pc: u32 = 0x828E7C48;
    'dispatch: loop {
        match pc {
            0x828E7C48 => {
    //   block [0x828E7C48..0x828E7DC8)
	// 828E7C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7C4C: 483C17BD  bl 0x82ca9408
	ctx.lr = 0x828E7C50;
	sub_82CA93D0(ctx, base);
	// 828E7C50: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7C54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E7C58: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828E7C5C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E7C60: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 828E7C64: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7C6C: 40990150  ble cr6, 0x828e7dbc
	if !ctx.cr[6].gt {
	pc = 0x828E7DBC; continue 'dispatch;
	}
	// 828E7C70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E7C74: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828E7C78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7C7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E7C80: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E7C84: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7C88: 80690070  lwz r3, 0x70(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 828E7C8C: 4B95756D  bl 0x8223f1f8
	ctx.lr = 0x828E7C90;
	sub_8223F1F8(ctx, base);
	// 828E7C90: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E7C94: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E7C98: 419A00DC  beq cr6, 0x828e7d74
	if ctx.cr[6].eq {
	pc = 0x828E7D74; continue 'dispatch;
	}
	// 828E7C9C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7CA0: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E7CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E7CA8: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828E7CAC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E7CB0: 4BF65111  bl 0x8284cdc0
	ctx.lr = 0x828E7CB4;
	sub_8284CDC0(ctx, base);
	// 828E7CB4: 817DFFF8  lwz r11, -8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7CB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E7CBC: 83AB007C  lwz r29, 0x7c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E7CC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E7CC4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7CC8: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 828E7CCC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828E7CD0: 4E800421  bctrl
	ctx.lr = 0x828E7CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7CD4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828E7CD8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828E7CDC: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7CE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E7CE4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E7CE8: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 828E7CEC: E9680008  ld r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 828E7CF0: 81460040  lwz r10, 0x40(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 828E7CF4: F8A70000  std r5, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828E7CF8: F9670008  std r11, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E7CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E7D00: 4E800421  bctrl
	ctx.lr = 0x828E7D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7D04: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828E7D08: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E7D0C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828E7D10: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7DC8 size=280
    let mut pc: u32 = 0x828E7DC8;
    'dispatch: loop {
        match pc {
            0x828E7DC8 => {
    //   block [0x828E7DC8..0x828E7EE0)
	// 828E7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7DD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7DD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7DD8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7DDC: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 828E7DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7DE4: 409900E4  ble cr6, 0x828e7ec8
	if !ctx.cr[6].gt {
	pc = 0x828E7EC8; continue 'dispatch;
	}
	// 828E7DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E7DEC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828E7DF0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7DF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E7DF8: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E7DFC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E7E00: 80690070  lwz r3, 0x70(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 828E7E04: 4B9573F5  bl 0x8223f1f8
	ctx.lr = 0x828E7E08;
	sub_8223F1F8(ctx, base);
	// 828E7E08: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E7E0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7E10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E7E14: 419A0070  beq cr6, 0x828e7e84
	if ctx.cr[6].eq {
	pc = 0x828E7E84; continue 'dispatch;
	}
	// 828E7E18: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 828E7E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7E20: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828E7E24: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828E7E28: 7D3F2670  srawi r31, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 828E7E2C: 419A0040  beq cr6, 0x828e7e6c
	if ctx.cr[6].eq {
	pc = 0x828E7E6C; continue 'dispatch;
	}
	// 828E7E30: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 828E7E34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7E38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7E3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7E40: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E7E44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7E48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7E4C: 4082FFE8  bne 0x828e7e34
	if !ctx.cr[0].eq {
	pc = 0x828E7E34; continue 'dispatch;
	}
	// 828E7E50: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E7E54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7E58: 409A0014  bne cr6, 0x828e7e6c
	if !ctx.cr[6].eq {
	pc = 0x828E7E6C; continue 'dispatch;
	}
	// 828E7E5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7E60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7E64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E7E68: 4E800421  bctrl
	ctx.lr = 0x828E7E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7E70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E7E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7E80: 4E800020  blr
	return;
	// 828E7E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7E88: 419A0040  beq cr6, 0x828e7ec8
	if ctx.cr[6].eq {
	pc = 0x828E7EC8; continue 'dispatch;
	}
	// 828E7E8C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 828E7E90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7E94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7E98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7E9C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E7EA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7EA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7EA8: 4082FFE8  bne 0x828e7e90
	if !ctx.cr[0].eq {
	pc = 0x828E7E90; continue 'dispatch;
	}
	// 828E7EAC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828E7EB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7EB4: 409A0014  bne cr6, 0x828e7ec8
	if !ctx.cr[6].eq {
	pc = 0x828E7EC8; continue 'dispatch;
	}
	// 828E7EB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7EBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E7EC4: 4E800421  bctrl
	ctx.lr = 0x828E7EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7EC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E7ECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E7ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7ED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7EDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7EE0 size=360
    let mut pc: u32 = 0x828E7EE0;
    'dispatch: loop {
        match pc {
            0x828E7EE0 => {
    //   block [0x828E7EE0..0x828E8048)
	// 828E7EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E7EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7EF4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7EF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E7EFC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828E7F00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7F04: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E7F08: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828E7F0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E7F10: 419A00D4  beq cr6, 0x828e7fe4
	if ctx.cr[6].eq {
	pc = 0x828E7FE4; continue 'dispatch;
	}
	// 828E7F14: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E7F18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E7F1C: 419A001C  beq cr6, 0x828e7f38
	if ctx.cr[6].eq {
	pc = 0x828E7F38; continue 'dispatch;
	}
	// 828E7F20: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828E7F24: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E7F28: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E7F2C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E7F30: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7F34: 480000B0  b 0x828e7fe4
	pc = 0x828E7FE4; continue 'dispatch;
	// 828E7F38: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E7F3C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E7F40: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E7F44: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E7F48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E7F4C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7F50: 40810054  ble 0x828e7fa4
	if !ctx.cr[0].gt {
	pc = 0x828E7FA4; continue 'dispatch;
	}
	// 828E7F54: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E7F58: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E7F5C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E7F60: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7F64: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828E7F68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E7F6C: 41980008  blt cr6, 0x828e7f74
	if ctx.cr[6].lt {
	pc = 0x828E7F74; continue 'dispatch;
	}
	// 828E7F70: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E7F74: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E7F78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E7F7C: 419A0014  beq cr6, 0x828e7f90
	if ctx.cr[6].eq {
	pc = 0x828E7F90; continue 'dispatch;
	}
	// 828E7F80: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E7F84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E7F88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E7F8C: 4800000C  b 0x828e7f98
	pc = 0x828E7F98; continue 'dispatch;
	// 828E7F90: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E7F94: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E7F98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7F9C: 4199FFB8  bgt cr6, 0x828e7f54
	if ctx.cr[6].gt {
	pc = 0x828E7F54; continue 'dispatch;
	}
	// 828E7FA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E7FA4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E7FA8: 419A0034  beq cr6, 0x828e7fdc
	if ctx.cr[6].eq {
	pc = 0x828E7FDC; continue 'dispatch;
	}
	// 828E7FAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7FB0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828E7FB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E7FB8: 41990008  bgt cr6, 0x828e7fc0
	if ctx.cr[6].gt {
	pc = 0x828E7FC0; continue 'dispatch;
	}
	// 828E7FBC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E7FC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E7FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7FC8: 409A0014  bne cr6, 0x828e7fdc
	if !ctx.cr[6].eq {
	pc = 0x828E7FDC; continue 'dispatch;
	}
	// 828E7FCC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E7FD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E7FD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E7FD8: 48000008  b 0x828e7fe0
	pc = 0x828E7FE0; continue 'dispatch;
	// 828E7FDC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E7FE0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7FE4: 83DF0090  lwz r30, 0x90(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E7FE8: 57CB0630  rlwinm r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 828E7FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7FF0: 409A000C  bne cr6, 0x828e7ffc
	if !ctx.cr[6].eq {
	pc = 0x828E7FFC; continue 'dispatch;
	}
	// 828E7FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7FF8: 4BC8A8F1  bl 0x825728e8
	ctx.lr = 0x828E7FFC;
	sub_825728E8(ctx, base);
	// 828E7FFC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E8000: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828E8004: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828E8008: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828E800C: 409A0024  bne cr6, 0x828e8030
	if !ctx.cr[6].eq {
	pc = 0x828E8030; continue 'dispatch;
	}
	// 828E8010: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E8014: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8018: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828E801C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8020: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E8024: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8028: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E802C: 4B928FED  bl 0x82211018
	ctx.lr = 0x828E8030;
	sub_82211018(ctx, base);
	// 828E8030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E8034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E803C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E8040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8048 size=60
    let mut pc: u32 = 0x828E8048;
    'dispatch: loop {
        match pc {
            0x828E8048 => {
    //   block [0x828E8048..0x828E8084)
	// 828E8048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E804C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8054: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8058: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E805C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8060: 388B9510  addi r4, r11, -0x6af0
	ctx.r[4].s64 = ctx.r[11].s64 + -27376;
	// 828E8064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8068: 4B944E69  bl 0x8222ced0
	ctx.lr = 0x828E806C;
	sub_8222CED0(ctx, base);
	// 828E806C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8070: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E8074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E807C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8088 size=112
    let mut pc: u32 = 0x828E8088;
    'dispatch: loop {
        match pc {
            0x828E8088 => {
    //   block [0x828E8088..0x828E80F8)
	// 828E8088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E808C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E8094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E809C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E80A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E80A4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E80A8: 4BE45291  bl 0x8272d338
	ctx.lr = 0x828E80AC;
	sub_8272D338(ctx, base);
	// 828E80AC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E80B0: 4B933C89  bl 0x8221bd38
	ctx.lr = 0x828E80B4;
	sub_8221BD38(ctx, base);
	// 828E80B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828E80B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E80BC: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828E80C0: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828E80C4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828E80C8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E80CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E80D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E80D4: 419A000C  beq cr6, 0x828e80e0
	if ctx.cr[6].eq {
	pc = 0x828E80E0; continue 'dispatch;
	}
	// 828E80D8: 4B933C61  bl 0x8221bd38
	ctx.lr = 0x828E80DC;
	sub_8221BD38(ctx, base);
	// 828E80DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E80E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E80E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E80E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E80EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E80F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E80F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E80F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E80F8 size=100
    let mut pc: u32 = 0x828E80F8;
    'dispatch: loop {
        match pc {
            0x828E80F8 => {
    //   block [0x828E80F8..0x828E815C)
	// 828E80F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E80FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8104: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8108: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E810C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E8110: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828E8114: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E811C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E8120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8124: 4B92C775  bl 0x82214898
	ctx.lr = 0x828E8128;
	sub_82214898(ctx, base);
	// 828E8128: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E812C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E8130: 4B9C0CD9  bl 0x822a8e08
	ctx.lr = 0x828E8134;
	sub_822A8E08(ctx, base);
	// 828E8134: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828E8138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E813C: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828E8140: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828E8144: 4B8ABCF5  bl 0x82193e38
	ctx.lr = 0x828E8148;
	sub_82193E38(ctx, base);
	// 828E8148: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E814C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E8154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8160 size=172
    let mut pc: u32 = 0x828E8160;
    'dispatch: loop {
        match pc {
            0x828E8160 => {
    //   block [0x828E8160..0x828E820C)
	// 828E8160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E816C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E8178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E817C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8180: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8184: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8188: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E818C: 4E800421  bctrl
	ctx.lr = 0x828E8190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8190: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 828E8194: 409A0038  bne cr6, 0x828e81cc
	if !ctx.cr[6].eq {
	pc = 0x828E81CC; continue 'dispatch;
	}
	// 828E8198: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E819C: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 828E81A0: 893E0004  lbz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E81A4: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 828E81A8: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E81AC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 828E81B0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828E81B4: 419A0040  beq cr6, 0x828e81f4
	if ctx.cr[6].eq {
	pc = 0x828E81F4; continue 'dispatch;
	}
	// 828E81B8: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828E81BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E81C0: 4BD05961  bl 0x825edb20
	ctx.lr = 0x828E81C4;
	sub_825EDB20(ctx, base);
	// 828E81C4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E81C8: 4BFFFFE8  b 0x828e81b0
	pc = 0x828E81B0; continue 'dispatch;
	// 828E81CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E81D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E81D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E81D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E81DC: 4E800421  bctrl
	ctx.lr = 0x828E81E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E81E0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 828E81E4: 409A0010  bne cr6, 0x828e81f4
	if !ctx.cr[6].eq {
	pc = 0x828E81F4; continue 'dispatch;
	}
	// 828E81E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E81EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E81F0: 48000021  bl 0x828e8210
	ctx.lr = 0x828E81F4;
	sub_828E8210(ctx, base);
	// 828E81F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E81F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E81FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E8200: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E8204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E8210 size=520
    let mut pc: u32 = 0x828E8210;
    'dispatch: loop {
        match pc {
            0x828E8210 => {
    //   block [0x828E8210..0x828E8418)
	// 828E8210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8214: 483C11F1  bl 0x82ca9404
	ctx.lr = 0x828E8218;
	sub_82CA93D0(ctx, base);
	// 828E8218: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E821C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E8220: 3B83000C  addi r28, r3, 0xc
	ctx.r[28].s64 = ctx.r[3].s64 + 12;
	// 828E8224: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828E8228: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E822C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E8230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8234: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8238: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E823C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828E8240: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E8244: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E8248: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E824C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E8250: 419A000C  beq cr6, 0x828e825c
	if ctx.cr[6].eq {
	pc = 0x828E825C; continue 'dispatch;
	}
	// 828E8254: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828E8258: 419A0008  beq cr6, 0x828e8260
	if ctx.cr[6].eq {
	pc = 0x828E8260; continue 'dispatch;
	}
	// 828E825C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8260: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8264: 419A01AC  beq cr6, 0x828e8410
	if ctx.cr[6].eq {
	pc = 0x828E8410; continue 'dispatch;
	}
	// 828E8268: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E826C: 409A0008  bne cr6, 0x828e8274
	if !ctx.cr[6].eq {
	pc = 0x828E8274; continue 'dispatch;
	}
	// 828E8270: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8274: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8278: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E827C: 409A0008  bne cr6, 0x828e8284
	if !ctx.cr[6].eq {
	pc = 0x828E8284; continue 'dispatch;
	}
	// 828E8280: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8284: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8288: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828E828C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8290: 419A0084  beq cr6, 0x828e8314
	if ctx.cr[6].eq {
	pc = 0x828E8314; continue 'dispatch;
	}
	// 828E8294: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8298: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E829C: 419A0074  beq cr6, 0x828e8310
	if ctx.cr[6].eq {
	pc = 0x828E8310; continue 'dispatch;
	}
	// 828E82A0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E82A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E82A8: 419A0018  beq cr6, 0x828e82c0
	if ctx.cr[6].eq {
	pc = 0x828E82C0; continue 'dispatch;
	}
	// 828E82AC: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E82B0: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828E82B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E82B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E82BC: 409A0008  bne cr6, 0x828e82c4
	if !ctx.cr[6].eq {
	pc = 0x828E82C4; continue 'dispatch;
	}
	// 828E82C0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828E82C4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E82C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E82CC: 419A012C  beq cr6, 0x828e83f8
	if ctx.cr[6].eq {
	pc = 0x828E83F8; continue 'dispatch;
	}
	// 828E82D0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E82D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E82D8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828E82DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E82E0: 419A0100  beq cr6, 0x828e83e0
	if ctx.cr[6].eq {
	pc = 0x828E83E0; continue 'dispatch;
	}
	// 828E82E4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E82E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E82EC: 419A0030  beq cr6, 0x828e831c
	if ctx.cr[6].eq {
	pc = 0x828E831C; continue 'dispatch;
	}
	// 828E82F0: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828E82F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E82F8: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E82FC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E8300: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8304: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E8308: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E830C: 480000D8  b 0x828e83e4
	pc = 0x828E83E4; continue 'dispatch;
	// 828E8310: 4B8ABB29  bl 0x82193e38
	ctx.lr = 0x828E8314;
	sub_82193E38(ctx, base);
	// 828E8314: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E8318: 4BFFFFA8  b 0x828e82c0
	pc = 0x828E82C0; continue 'dispatch;
	// 828E831C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E8320: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E8324: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E8328: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E832C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8330: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8334: 40810054  ble 0x828e8388
	if !ctx.cr[0].gt {
	pc = 0x828E8388; continue 'dispatch;
	}
	// 828E8338: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E833C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E8340: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E8344: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8348: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828E834C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E8350: 41980008  blt cr6, 0x828e8358
	if ctx.cr[6].lt {
	pc = 0x828E8358; continue 'dispatch;
	}
	// 828E8354: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E8358: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E835C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E8360: 419A0014  beq cr6, 0x828e8374
	if ctx.cr[6].eq {
	pc = 0x828E8374; continue 'dispatch;
	}
	// 828E8364: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E8368: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E836C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E8370: 4800000C  b 0x828e837c
	pc = 0x828E837C; continue 'dispatch;
	// 828E8374: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E8378: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E837C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8380: 4199FFB8  bgt cr6, 0x828e8338
	if ctx.cr[6].gt {
	pc = 0x828E8338; continue 'dispatch;
	}
	// 828E8384: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8388: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E838C: 419A0040  beq cr6, 0x828e83cc
	if ctx.cr[6].eq {
	pc = 0x828E83CC; continue 'dispatch;
	}
	// 828E8390: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8394: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828E8398: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E839C: 41990008  bgt cr6, 0x828e83a4
	if ctx.cr[6].gt {
	pc = 0x828E83A4; continue 'dispatch;
	}
	// 828E83A0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E83A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E83A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E83AC: 409A0020  bne cr6, 0x828e83cc
	if !ctx.cr[6].eq {
	pc = 0x828E83CC; continue 'dispatch;
	}
	// 828E83B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E83B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828E83B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E83BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E83C0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E83C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E83C8: 4800001C  b 0x828e83e4
	pc = 0x828E83E4; continue 'dispatch;
	// 828E83CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E83D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E83D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E83D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E83DC: 48000008  b 0x828e83e4
	pc = 0x828E83E4; continue 'dispatch;
	// 828E83E0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E83E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E83E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E83EC: 419A000C  beq cr6, 0x828e83f8
	if ctx.cr[6].eq {
	pc = 0x828E83F8; continue 'dispatch;
	}
	// 828E83F0: C03B0004  lfs f1, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E83F4: 4BC8AE2D  bl 0x82573220
	ctx.lr = 0x828E83F8;
	sub_82573220(ctx, base);
	// 828E83F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E83FC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8400: 409A0008  bne cr6, 0x828e8408
	if !ctx.cr[6].eq {
	pc = 0x828E8408; continue 'dispatch;
	}
	// 828E8404: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8408: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E840C: 4BFFFE3C  b 0x828e8248
	pc = 0x828E8248; continue 'dispatch;
	// 828E8410: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E8414: 483C1040  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8418 size=172
    let mut pc: u32 = 0x828E8418;
    'dispatch: loop {
        match pc {
            0x828E8418 => {
    //   block [0x828E8418..0x828E84C4)
	// 828E8418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E841C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8424: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E8428: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 828E842C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E8430: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 828E8434: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8438: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E843C: 419A0008  beq cr6, 0x828e8444
	if ctx.cr[6].eq {
	pc = 0x828E8444; continue 'dispatch;
	}
	// 828E8440: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8444: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828E8448: 419A0068  beq cr6, 0x828e84b0
	if ctx.cr[6].eq {
	pc = 0x828E84B0; continue 'dispatch;
	}
	// 828E844C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828E8450: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828E8454: 419A0018  beq cr6, 0x828e846c
	if ctx.cr[6].eq {
	pc = 0x828E846C; continue 'dispatch;
	}
	// 828E8458: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E845C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828E8460: 409AFFD4  bne cr6, 0x828e8434
	if !ctx.cr[6].eq {
	pc = 0x828E8434; continue 'dispatch;
	}
	// 828E8464: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8468: 4BFFFFCC  b 0x828e8434
	pc = 0x828E8434; continue 'dispatch;
	// 828E846C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8470: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E8474: 409A0008  bne cr6, 0x828e847c
	if !ctx.cr[6].eq {
	pc = 0x828E847C; continue 'dispatch;
	}
	// 828E8478: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E847C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 828E8480: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8488: 419A0028  beq cr6, 0x828e84b0
	if ctx.cr[6].eq {
	pc = 0x828E84B0; continue 'dispatch;
	}
	// 828E848C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8490: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E8494: 419A0018  beq cr6, 0x828e84ac
	if ctx.cr[6].eq {
	pc = 0x828E84AC; continue 'dispatch;
	}
	// 828E8498: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828E849C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E84A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E84A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E84A8: 4E800020  blr
	return;
	// 828E84AC: 4B8AB98D  bl 0x82193e38
	ctx.lr = 0x828E84B0;
	sub_82193E38(ctx, base);
	// 828E84B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E84B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E84B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E84BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E84C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E84C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E84C8 size=380
    let mut pc: u32 = 0x828E84C8;
    'dispatch: loop {
        match pc {
            0x828E84C8 => {
    //   block [0x828E84C8..0x828E8644)
	// 828E84C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E84CC: 483C0F3D  bl 0x82ca9408
	ctx.lr = 0x828E84D0;
	sub_82CA93D0(ctx, base);
	// 828E84D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E84D4: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E84D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E84DC: 3BC3000C  addi r30, r3, 0xc
	ctx.r[30].s64 = ctx.r[3].s64 + 12;
	// 828E84E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E84E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E84E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E84EC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828E84F0: 419A0008  beq cr6, 0x828e84f8
	if ctx.cr[6].eq {
	pc = 0x828E84F8; continue 'dispatch;
	}
	// 828E84F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E84F8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E84FC: 419A010C  beq cr6, 0x828e8608
	if ctx.cr[6].eq {
	pc = 0x828E8608; continue 'dispatch;
	}
	// 828E8500: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8504: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8508: 409A0008  bne cr6, 0x828e8510
	if !ctx.cr[6].eq {
	pc = 0x828E8510; continue 'dispatch;
	}
	// 828E850C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8510: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8514: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828E8518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E851C: 419A001C  beq cr6, 0x828e8538
	if ctx.cr[6].eq {
	pc = 0x828E8538; continue 'dispatch;
	}
	// 828E8520: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E8528: 419A000C  beq cr6, 0x828e8534
	if ctx.cr[6].eq {
	pc = 0x828E8534; continue 'dispatch;
	}
	// 828E852C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E8530: 4800000C  b 0x828e853c
	pc = 0x828E853C; continue 'dispatch;
	// 828E8534: 4B8AB905  bl 0x82193e38
	ctx.lr = 0x828E8538;
	sub_82193E38(ctx, base);
	// 828E8538: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828E853C: 806B0080  lwz r3, 0x80(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E8540: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8544: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828E8548: 409A000C  bne cr6, 0x828e8554
	if !ctx.cr[6].eq {
	pc = 0x828E8554; continue 'dispatch;
	}
	// 828E854C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E8550: 48000020  b 0x828e8570
	pc = 0x828E8570; continue 'dispatch;
	// 828E8554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8558: 419A0014  beq cr6, 0x828e856c
	if ctx.cr[6].eq {
	pc = 0x828E856C; continue 'dispatch;
	}
	// 828E855C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E8560: 419A000C  beq cr6, 0x828e856c
	if ctx.cr[6].eq {
	pc = 0x828E856C; continue 'dispatch;
	}
	// 828E8564: 4B98522D  bl 0x8226d790
	ctx.lr = 0x828E8568;
	sub_8226D790(ctx, base);
	// 828E8568: 48000008  b 0x828e8570
	pc = 0x828E8570; continue 'dispatch;
	// 828E856C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E8570: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E8574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8578: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E857C: 409A0018  bne cr6, 0x828e8594
	if !ctx.cr[6].eq {
	pc = 0x828E8594; continue 'dispatch;
	}
	// 828E8580: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8584: 409A0008  bne cr6, 0x828e858c
	if !ctx.cr[6].eq {
	pc = 0x828E858C; continue 'dispatch;
	}
	// 828E8588: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E858C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8590: 4BFFFF58  b 0x828e84e8
	pc = 0x828E84E8; continue 'dispatch;
	// 828E8594: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8598: 409A0008  bne cr6, 0x828e85a0
	if !ctx.cr[6].eq {
	pc = 0x828E85A0; continue 'dispatch;
	}
	// 828E859C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E85A0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E85A4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828E85A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E85AC: 419A001C  beq cr6, 0x828e85c8
	if ctx.cr[6].eq {
	pc = 0x828E85C8; continue 'dispatch;
	}
	// 828E85B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E85B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E85B8: 419A000C  beq cr6, 0x828e85c4
	if ctx.cr[6].eq {
	pc = 0x828E85C4; continue 'dispatch;
	}
	// 828E85BC: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828E85C0: 4800000C  b 0x828e85cc
	pc = 0x828E85CC; continue 'dispatch;
	// 828E85C4: 4B8AB875  bl 0x82193e38
	ctx.lr = 0x828E85C8;
	sub_82193E38(ctx, base);
	// 828E85C8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828E85CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E85D0: 4B8DE199  bl 0x821c6768
	ctx.lr = 0x828E85D4;
	sub_821C6768(ctx, base);
	// 828E85D4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E85D8: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828E85DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E85E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E85E4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E85E8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E85EC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E85F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E85F4: 4082FFE8  bne 0x828e85dc
	if !ctx.cr[0].eq {
	pc = 0x828E85DC; continue 'dispatch;
	}
	// 828E85F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E85FC: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E8600: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E8604: 483C0E54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828E8608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E860C: 4B8DE15D  bl 0x821c6768
	ctx.lr = 0x828E8610;
	sub_821C6768(ctx, base);
	// 828E8610: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828E8614: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828E8618: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E861C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8620: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E8624: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828E8628: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E862C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8630: 4082FFE8  bne 0x828e8618
	if !ctx.cr[0].eq {
	pc = 0x828E8618; continue 'dispatch;
	}
	// 828E8634: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E8638: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E863C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E8640: 483C0E18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8648 size=472
    let mut pc: u32 = 0x828E8648;
    'dispatch: loop {
        match pc {
            0x828E8648 => {
    //   block [0x828E8648..0x828E8820)
	// 828E8648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E864C: 483C0DB9  bl 0x82ca9404
	ctx.lr = 0x828E8650;
	sub_82CA93D0(ctx, base);
	// 828E8650: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8654: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E8658: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828E865C: 3B83000C  addi r28, r3, 0xc
	ctx.r[28].s64 = ctx.r[3].s64 + 12;
	// 828E8660: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E8664: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8668: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E866C: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828E8670: 419A0008  beq cr6, 0x828e8678
	if ctx.cr[6].eq {
	pc = 0x828E8678; continue 'dispatch;
	}
	// 828E8674: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8678: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E867C: 419A0198  beq cr6, 0x828e8814
	if ctx.cr[6].eq {
	pc = 0x828E8814; continue 'dispatch;
	}
	// 828E8680: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8684: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828E8688: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E868C: 409A0008  bne cr6, 0x828e8694
	if !ctx.cr[6].eq {
	pc = 0x828E8694; continue 'dispatch;
	}
	// 828E8690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8694: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8698: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 828E869C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E86A0: 419A001C  beq cr6, 0x828e86bc
	if ctx.cr[6].eq {
	pc = 0x828E86BC; continue 'dispatch;
	}
	// 828E86A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E86A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E86AC: 419A000C  beq cr6, 0x828e86b8
	if ctx.cr[6].eq {
	pc = 0x828E86B8; continue 'dispatch;
	}
	// 828E86B0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E86B4: 4800000C  b 0x828e86c0
	pc = 0x828E86C0; continue 'dispatch;
	// 828E86B8: 4B8AB781  bl 0x82193e38
	ctx.lr = 0x828E86BC;
	sub_82193E38(ctx, base);
	// 828E86BC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E86C0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E86C4: 5549BFFE  rlwinm r9, r10, 0x17, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 828E86C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E86CC: 419A00F4  beq cr6, 0x828e87c0
	if ctx.cr[6].eq {
	pc = 0x828E87C0; continue 'dispatch;
	}
	// 828E86D0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E86D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E86D8: 419A0024  beq cr6, 0x828e86fc
	if ctx.cr[6].eq {
	pc = 0x828E86FC; continue 'dispatch;
	}
	// 828E86DC: 892A0049  lbz r9, 0x49(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(73 as u32) ) } as u64;
	// 828E86E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E86E4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E86E8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E86EC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E86F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E86F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E86F8: 480000CC  b 0x828e87c4
	pc = 0x828E87C4; continue 'dispatch;
	// 828E86FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E8700: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E8704: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E8708: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E870C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8710: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8714: 40810054  ble 0x828e8768
	if !ctx.cr[0].gt {
	pc = 0x828E8768; continue 'dispatch;
	}
	// 828E8718: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E871C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E8720: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E8724: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8728: 2F070049  cmpwi cr6, r7, 0x49
	ctx.cr[6].compare_i32(ctx.r[7].s32, 73, &mut ctx.xer);
	// 828E872C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E8730: 41980008  blt cr6, 0x828e8738
	if ctx.cr[6].lt {
	pc = 0x828E8738; continue 'dispatch;
	}
	// 828E8734: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E8738: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E873C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E8740: 419A0014  beq cr6, 0x828e8754
	if ctx.cr[6].eq {
	pc = 0x828E8754; continue 'dispatch;
	}
	// 828E8744: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E8748: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E874C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E8750: 4800000C  b 0x828e875c
	pc = 0x828E875C; continue 'dispatch;
	// 828E8754: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E8758: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E875C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8760: 4199FFB8  bgt cr6, 0x828e8718
	if ctx.cr[6].gt {
	pc = 0x828E8718; continue 'dispatch;
	}
	// 828E8764: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E8768: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E876C: 419A0040  beq cr6, 0x828e87ac
	if ctx.cr[6].eq {
	pc = 0x828E87AC; continue 'dispatch;
	}
	// 828E8770: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8774: 2F0B0049  cmpwi cr6, r11, 0x49
	ctx.cr[6].compare_i32(ctx.r[11].s32, 73, &mut ctx.xer);
	// 828E8778: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E877C: 41990008  bgt cr6, 0x828e8784
	if ctx.cr[6].gt {
	pc = 0x828E8784; continue 'dispatch;
	}
	// 828E8780: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E8784: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E8788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E878C: 409A0020  bne cr6, 0x828e87ac
	if !ctx.cr[6].eq {
	pc = 0x828E87AC; continue 'dispatch;
	}
	// 828E8790: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E8794: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828E8798: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E879C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E87A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E87A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E87A8: 4800001C  b 0x828e87c4
	pc = 0x828E87C4; continue 'dispatch;
	// 828E87AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E87B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E87B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E87B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E87BC: 48000008  b 0x828e87c4
	pc = 0x828E87C4; continue 'dispatch;
	// 828E87C0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E87C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E87C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E87CC: 419A0010  beq cr6, 0x828e87dc
	if ctx.cr[6].eq {
	pc = 0x828E87DC; continue 'dispatch;
	}
	// 828E87D0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E87D4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828E87D8: 419A001C  beq cr6, 0x828e87f4
	if ctx.cr[6].eq {
	pc = 0x828E87F4; continue 'dispatch;
	}
	// 828E87DC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E87E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E87E4: 409A0008  bne cr6, 0x828e87ec
	if !ctx.cr[6].eq {
	pc = 0x828E87EC; continue 'dispatch;
	}
	// 828E87E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E87EC: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E87F0: 4BFFFE78  b 0x828e8668
	pc = 0x828E8668; continue 'dispatch;
	// 828E87F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E87F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E87FC: 409A0008  bne cr6, 0x828e8804
	if !ctx.cr[6].eq {
	pc = 0x828E8804; continue 'dispatch;
	}
	// 828E8800: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828E8804: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 828E8808: 4B88B631  bl 0x82173e38
	ctx.lr = 0x828E880C;
	sub_82173E38(ctx, base);
	// 828E880C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E8810: 483C0C44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828E8814: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E8818: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E881C: 483C0C38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8820 size=548
    let mut pc: u32 = 0x828E8820;
    'dispatch: loop {
        match pc {
            0x828E8820 => {
    //   block [0x828E8820..0x828E8A44)
	// 828E8820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E882C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8834: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828E8838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E883C: 3BCBD144  addi r30, r11, -0x2ebc
	ctx.r[30].s64 = ctx.r[11].s64 + -11964;
	// 828E8840: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E884C: 4B944685  bl 0x8222ced0
	ctx.lr = 0x828E8850;
	sub_8222CED0(ctx, base);
	// 828E8850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E8858: 480001F1  bl 0x828e8a48
	ctx.lr = 0x828E885C;
	sub_828E8A48(ctx, base);
	// 828E885C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8860: 4B92C579  bl 0x82214dd8
	ctx.lr = 0x828E8864;
	sub_82214DD8(ctx, base);
	// 828E8864: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828E8868: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E886C: 388A41D4  addi r4, r10, 0x41d4
	ctx.r[4].s64 = ctx.r[10].s64 + 16852;
	// 828E8870: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E8874: 4B94465D  bl 0x8222ced0
	ctx.lr = 0x828E8878;
	sub_8222CED0(ctx, base);
	// 828E8878: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E887C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8884: 4B94464D  bl 0x8222ced0
	ctx.lr = 0x828E8888;
	sub_8222CED0(ctx, base);
	// 828E8888: 3D208291  lis r9, -0x7d6f
	ctx.r[9].s64 = -2104426496;
	// 828E888C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8890: 38C9DD08  addi r6, r9, -0x22f8
	ctx.r[6].s64 = ctx.r[9].s64 + -8952;
	// 828E8894: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828E8898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E889C: 480003F5  bl 0x828e8c90
	ctx.lr = 0x828E88A0;
	sub_828E8C90(ctx, base);
	// 828E88A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E88A4: 4B92C535  bl 0x82214dd8
	ctx.lr = 0x828E88A8;
	sub_82214DD8(ctx, base);
	// 828E88A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E88AC: 4B92C52D  bl 0x82214dd8
	ctx.lr = 0x828E88B0;
	sub_82214DD8(ctx, base);
	// 828E88B0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828E88B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E88B8: 388841F0  addi r4, r8, 0x41f0
	ctx.r[4].s64 = ctx.r[8].s64 + 16880;
	// 828E88BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E88C0: 4B944611  bl 0x8222ced0
	ctx.lr = 0x828E88C4;
	sub_8222CED0(ctx, base);
	// 828E88C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E88C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E88CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E88D0: 4B944601  bl 0x8222ced0
	ctx.lr = 0x828E88D4;
	sub_8222CED0(ctx, base);
	// 828E88D4: 3CE0828F  lis r7, -0x7d71
	ctx.r[7].s64 = -2104557568;
	// 828E88D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E88DC: 38C78418  addi r6, r7, -0x7be8
	ctx.r[6].s64 = ctx.r[7].s64 + -31720;
	// 828E88E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E88E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828E88E8: 480005B1  bl 0x828e8e98
	ctx.lr = 0x828E88EC;
	sub_828E8E98(ctx, base);
	// 828E88EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E88F0: 4B92C4E9  bl 0x82214dd8
	ctx.lr = 0x828E88F4;
	sub_82214DD8(ctx, base);
	// 828E88F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E88F8: 4B92C4E1  bl 0x82214dd8
	ctx.lr = 0x828E88FC;
	sub_82214DD8(ctx, base);
	// 828E88FC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828E8900: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8904: 38864208  addi r4, r6, 0x4208
	ctx.r[4].s64 = ctx.r[6].s64 + 16904;
	// 828E8908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E890C: 4B9445C5  bl 0x8222ced0
	ctx.lr = 0x828E8910;
	sub_8222CED0(ctx, base);
	// 828E8910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8914: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8918: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E891C: 4B9445B5  bl 0x8222ced0
	ctx.lr = 0x828E8920;
	sub_8222CED0(ctx, base);
	// 828E8920: 3C808224  lis r4, -0x7ddc
	ctx.r[4].s64 = -2111569920;
	// 828E8924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8928: 38C41070  addi r6, r4, 0x1070
	ctx.r[6].s64 = ctx.r[4].s64 + 4208;
	// 828E892C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E8930: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828E8934: 4800076D  bl 0x828e90a0
	ctx.lr = 0x828E8938;
	sub_828E90A0(ctx, base);
	// 828E8938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E893C: 4B92C49D  bl 0x82214dd8
	ctx.lr = 0x828E8940;
	sub_82214DD8(ctx, base);
	// 828E8940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8944: 4B92C495  bl 0x82214dd8
	ctx.lr = 0x828E8948;
	sub_82214DD8(ctx, base);
	// 828E8948: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828E894C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8950: 38834228  addi r4, r3, 0x4228
	ctx.r[4].s64 = ctx.r[3].s64 + 16936;
	// 828E8954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8958: 4B944579  bl 0x8222ced0
	ctx.lr = 0x828E895C;
	sub_8222CED0(ctx, base);
	// 828E895C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8960: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E8964: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E8968: 4B944569  bl 0x8222ced0
	ctx.lr = 0x828E896C;
	sub_8222CED0(ctx, base);
	// 828E896C: 3D608224  lis r11, -0x7ddc
	ctx.r[11].s64 = -2111569920;
	// 828E8970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8974: 38CB1250  addi r6, r11, 0x1250
	ctx.r[6].s64 = ctx.r[11].s64 + 4688;
	// 828E8978: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E897C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828E8980: 48000929  bl 0x828e92a8
	ctx.lr = 0x828E8984;
	sub_828E92A8(ctx, base);
	// 828E8984: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E8988: 4B92C451  bl 0x82214dd8
	ctx.lr = 0x828E898C;
	sub_82214DD8(ctx, base);
	// 828E898C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8990: 4B92C449  bl 0x82214dd8
	ctx.lr = 0x828E8994;
	sub_82214DD8(ctx, base);
	// 828E8994: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828E8998: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E899C: 388A4244  addi r4, r10, 0x4244
	ctx.r[4].s64 = ctx.r[10].s64 + 16964;
	// 828E89A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E89A4: 4B94452D  bl 0x8222ced0
	ctx.lr = 0x828E89A8;
	sub_8222CED0(ctx, base);
	// 828E89A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E89AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E89B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E89B4: 4B94451D  bl 0x8222ced0
	ctx.lr = 0x828E89B8;
	sub_8222CED0(ctx, base);
	// 828E89B8: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828E89BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E89C0: 38C984C8  addi r6, r9, -0x7b38
	ctx.r[6].s64 = ctx.r[9].s64 + -31544;
	// 828E89C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E89C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828E89CC: 48000AE5  bl 0x828e94b0
	ctx.lr = 0x828E89D0;
	sub_828E94B0(ctx, base);
	// 828E89D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E89D4: 4B92C405  bl 0x82214dd8
	ctx.lr = 0x828E89D8;
	sub_82214DD8(ctx, base);
	// 828E89D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E89DC: 4B92C3FD  bl 0x82214dd8
	ctx.lr = 0x828E89E0;
	sub_82214DD8(ctx, base);
	// 828E89E0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828E89E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E89E8: 3888425C  addi r4, r8, 0x425c
	ctx.r[4].s64 = ctx.r[8].s64 + 16988;
	// 828E89EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E89F0: 4B9444E1  bl 0x8222ced0
	ctx.lr = 0x828E89F4;
	sub_8222CED0(ctx, base);
	// 828E89F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E89F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828E89FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E8A00: 4B9444D1  bl 0x8222ced0
	ctx.lr = 0x828E8A04;
	sub_8222CED0(ctx, base);
	// 828E8A04: 3CE0828F  lis r7, -0x7d71
	ctx.r[7].s64 = -2104557568;
	// 828E8A08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E8A0C: 38C78648  addi r6, r7, -0x79b8
	ctx.r[6].s64 = ctx.r[7].s64 + -31160;
	// 828E8A10: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828E8A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8A18: 48000CA1  bl 0x828e96b8
	ctx.lr = 0x828E8A1C;
	sub_828E96B8(ctx, base);
	// 828E8A1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E8A20: 4B92C3B9  bl 0x82214dd8
	ctx.lr = 0x828E8A24;
	sub_82214DD8(ctx, base);
	// 828E8A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8A28: 4B92C3B1  bl 0x82214dd8
	ctx.lr = 0x828E8A2C;
	sub_82214DD8(ctx, base);
	// 828E8A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E8A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E8A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E8A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8A48 size=584
    let mut pc: u32 = 0x828E8A48;
    'dispatch: loop {
        match pc {
            0x828E8A48 => {
    //   block [0x828E8A48..0x828E8C90)
	// 828E8A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8A4C: 483C09B5  bl 0x82ca9400
	ctx.lr = 0x828E8A50;
	sub_82CA93D0(ctx, base);
	// 828E8A50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8A54: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8A58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E8A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8A60: 409A0010  bne cr6, 0x828e8a70
	if !ctx.cr[6].eq {
	pc = 0x828E8A70; continue 'dispatch;
	}
	// 828E8A64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E8A68: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828E8A6C: 48000008  b 0x828e8a74
	pc = 0x828E8A74; continue 'dispatch;
	// 828E8A70: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8A74: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8A78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8A7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8A80: 4BAE5B41  bl 0x823ce5c0
	ctx.lr = 0x828E8A84;
	sub_823CE5C0(ctx, base);
	// 828E8A84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E8A88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8A8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8A90: 4BAE5771  bl 0x823ce200
	ctx.lr = 0x828E8A94;
	sub_823CE200(ctx, base);
	// 828E8A94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8A98: 4B8CF081  bl 0x821b7b18
	ctx.lr = 0x828E8A9C;
	sub_821B7B18(ctx, base);
	// 828E8A9C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828E8AA0: 4B9367B9  bl 0x8221f258
	ctx.lr = 0x828E8AA4;
	sub_8221F258(ctx, base);
	// 828E8AA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E8AA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E8AAC: 419A0040  beq cr6, 0x828e8aec
	if ctx.cr[6].eq {
	pc = 0x828E8AEC; continue 'dispatch;
	}
	// 828E8AB0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828E8AB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E8AB8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828E8ABC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E8AC0: 4B936799  bl 0x8221f258
	ctx.lr = 0x828E8AC4;
	sub_8221F258(ctx, base);
	// 828E8AC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8AC8: 419A0028  beq cr6, 0x828e8af0
	if ctx.cr[6].eq {
	pc = 0x828E8AF0; continue 'dispatch;
	}
	// 828E8ACC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E8AD0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E8AD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E8AD8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E8ADC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E8AE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E8AE4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E8AE8: 4800000C  b 0x828e8af4
	pc = 0x828E8AF4; continue 'dispatch;
	// 828E8AEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E8AF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E8AF4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E8AF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E8AFC: 419A00FC  beq cr6, 0x828e8bf8
	if ctx.cr[6].eq {
	pc = 0x828E8BF8; continue 'dispatch;
	}
	// 828E8B00: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8B04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E8B08: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8B0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E8B10: 4B9405F9  bl 0x82229108
	ctx.lr = 0x828E8B14;
	sub_82229108(ctx, base);
	// 828E8B14: 3D60822D  lis r11, -0x7dd3
	ctx.r[11].s64 = -2110980096;
	// 828E8B18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E8B1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E8B20: 3BCB3580  addi r30, r11, 0x3580
	ctx.r[30].s64 = ctx.r[11].s64 + 13696;
	// 828E8B24: 4B93ED5D  bl 0x82227880
	ctx.lr = 0x828E8B28;
	sub_82227880(ctx, base);
	// 828E8B28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E8B2C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828E8B30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E8B34: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828E8B38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E8B3C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E8B40: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E8B44: 4B8B1F3D  bl 0x8219aa80
	ctx.lr = 0x828E8B48;
	sub_8219AA80(ctx, base);
	// 828E8B48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828E8B4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E8B50: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828E8B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8B58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E8B5C: 4BAE58C5  bl 0x823ce420
	ctx.lr = 0x828E8B60;
	sub_823CE420(ctx, base);
	// 828E8B60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E8B64: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E8B68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E8B6C: 4813BB5D  bl 0x82a246c8
	ctx.lr = 0x828E8B70;
	sub_82A246C8(ctx, base);
	// 828E8B70: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8B74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E8B78: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828E8B7C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828E8B80: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8B84: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8B8C: 4B94057D  bl 0x82229108
	ctx.lr = 0x828E8B90;
	sub_82229108(ctx, base);
	// 828E8B90: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828E8B94: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E8B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8B9C: 3BEB6D58  addi r31, r11, 0x6d58
	ctx.r[31].s64 = ctx.r[11].s64 + 27992;
	// 828E8BA0: 4B93ECE1  bl 0x82227880
	ctx.lr = 0x828E8BA4;
	sub_82227880(ctx, base);
	// 828E8BA4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828E8BA8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828E8BAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E8BB0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828E8BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8BB8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E8BBC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828E8BC0: 4B8B1EC1  bl 0x8219aa80
	ctx.lr = 0x828E8BC4;
	sub_8219AA80(ctx, base);
	// 828E8BC4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828E8BC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8BCC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828E8BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8BD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8BD8: 4BAE5849  bl 0x823ce420
	ctx.lr = 0x828E8BDC;
	sub_823CE420(ctx, base);
	// 828E8BDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8BE0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E8BE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8BE8: 4813BAE1  bl 0x82a246c8
	ctx.lr = 0x828E8BEC;
	sub_82A246C8(ctx, base);
	// 828E8BEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8BF0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828E8BF4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828E8BF8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828E8BFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828E8C00: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828E8C04: 419A0020  beq cr6, 0x828e8c24
	if ctx.cr[6].eq {
	pc = 0x828E8C24; continue 'dispatch;
	}
	// 828E8C08: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E8C0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8C10: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E8C14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E8C18: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8C1C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8C20: 4082FFE8  bne 0x828e8c08
	if !ctx.cr[0].eq {
	pc = 0x828E8C08; continue 'dispatch;
	}
	// 828E8C24: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8C28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E8C2C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E8C30: 4BA0CD19  bl 0x822f5948
	ctx.lr = 0x828E8C34;
	sub_822F5948(ctx, base);
	// 828E8C34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8C38: 4B8CEEE1  bl 0x821b7b18
	ctx.lr = 0x828E8C3C;
	sub_821B7B18(ctx, base);
	// 828E8C3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828E8C40: 419A0040  beq cr6, 0x828e8c80
	if ctx.cr[6].eq {
	pc = 0x828E8C80; continue 'dispatch;
	}
	// 828E8C44: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E8C48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8C4C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E8C50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E8C54: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8C58: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8C5C: 4082FFE8  bne 0x828e8c44
	if !ctx.cr[0].eq {
	pc = 0x828E8C44; continue 'dispatch;
	}
	// 828E8C60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8C64: 409A001C  bne cr6, 0x828e8c80
	if !ctx.cr[6].eq {
	pc = 0x828E8C80; continue 'dispatch;
	}
	// 828E8C68: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8C6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8C70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8C74: 4E800421  bctrl
	ctx.lr = 0x828E8C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8C78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E8C7C: 4B9330BD  bl 0x8221bd38
	ctx.lr = 0x828E8C80;
	sub_8221BD38(ctx, base);
	// 828E8C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8C84: 4B8CEE95  bl 0x821b7b18
	ctx.lr = 0x828E8C88;
	sub_821B7B18(ctx, base);
	// 828E8C88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E8C8C: 483C07C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8C90 size=516
    let mut pc: u32 = 0x828E8C90;
    'dispatch: loop {
        match pc {
            0x828E8C90 => {
    //   block [0x828E8C90..0x828E8E94)
	// 828E8C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8C94: 483C0769  bl 0x82ca93fc
	ctx.lr = 0x828E8C98;
	sub_82CA93D0(ctx, base);
	// 828E8C98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8C9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E8CA0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E8CA4: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828E8CA8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E8CAC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E8CB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8CB4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E8CB8: 3BAADD08  addi r29, r10, -0x22f8
	ctx.r[29].s64 = ctx.r[10].s64 + -8952;
	// 828E8CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8CC0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E8CC4: 419A0008  beq cr6, 0x828e8ccc
	if ctx.cr[6].eq {
	pc = 0x828E8CCC; continue 'dispatch;
	}
	// 828E8CC8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8CCC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8CD4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8CD8: 4BAE58E9  bl 0x823ce5c0
	ctx.lr = 0x828E8CDC;
	sub_823CE5C0(ctx, base);
	// 828E8CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E8CE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8CE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8CE8: 4BAE5429  bl 0x823ce110
	ctx.lr = 0x828E8CEC;
	sub_823CE110(ctx, base);
	// 828E8CEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8CF0: 4B8CEE29  bl 0x821b7b18
	ctx.lr = 0x828E8CF4;
	sub_821B7B18(ctx, base);
	// 828E8CF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E8CF8: 4B936561  bl 0x8221f258
	ctx.lr = 0x828E8CFC;
	sub_8221F258(ctx, base);
	// 828E8CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8D00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E8D04: 419A005C  beq cr6, 0x828e8d60
	if ctx.cr[6].eq {
	pc = 0x828E8D60; continue 'dispatch;
	}
	// 828E8D08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E8D0C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E8D10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E8D14: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E8D18: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E8D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8D20: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E8D24: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E8D28: 4B907519  bl 0x821f0240
	ctx.lr = 0x828E8D2C;
	sub_821F0240(ctx, base);
	// 828E8D2C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E8D30: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E8D34: 4B936525  bl 0x8221f258
	ctx.lr = 0x828E8D38;
	sub_8221F258(ctx, base);
	// 828E8D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8D3C: 419A0028  beq cr6, 0x828e8d64
	if ctx.cr[6].eq {
	pc = 0x828E8D64; continue 'dispatch;
	}
	// 828E8D40: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E8D44: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E8D48: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E8D4C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E8D50: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E8D54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E8D58: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E8D5C: 4800000C  b 0x828e8d68
	pc = 0x828E8D68; continue 'dispatch;
	// 828E8D60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E8D64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E8D68: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8D6C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8D74: 419A0008  beq cr6, 0x828e8d7c
	if ctx.cr[6].eq {
	pc = 0x828E8D7C; continue 'dispatch;
	}
	// 828E8D78: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8D7C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E8D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8D84: 419A0078  beq cr6, 0x828e8dfc
	if ctx.cr[6].eq {
	pc = 0x828E8DFC; continue 'dispatch;
	}
	// 828E8D88: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8D8C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E8D90: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8D94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8D98: 4B940371  bl 0x82229108
	ctx.lr = 0x828E8D9C;
	sub_82229108(ctx, base);
	// 828E8D9C: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828E8DA0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E8DA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8DA8: 3BCB98C0  addi r30, r11, -0x6740
	ctx.r[30].s64 = ctx.r[11].s64 + -26432;
	// 828E8DAC: 4B93EAD5  bl 0x82227880
	ctx.lr = 0x828E8DB0;
	sub_82227880(ctx, base);
	// 828E8DB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E8DB4: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828E8DB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E8DBC: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 828E8DC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8DC4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E8DC8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E8DCC: 4B8B1CB5  bl 0x8219aa80
	ctx.lr = 0x828E8DD0;
	sub_8219AA80(ctx, base);
	// 828E8DD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8DD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E8DD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8DDC: 4BAE5645  bl 0x823ce420
	ctx.lr = 0x828E8DE0;
	sub_823CE420(ctx, base);
	// 828E8DE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8DE4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E8DE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8DEC: 4813B8DD  bl 0x82a246c8
	ctx.lr = 0x828E8DF0;
	sub_82A246C8(ctx, base);
	// 828E8DF0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8DF4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E8DF8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E8DFC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E8E00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E8E04: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E8E08: 419A0020  beq cr6, 0x828e8e28
	if ctx.cr[6].eq {
	pc = 0x828E8E28; continue 'dispatch;
	}
	// 828E8E0C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E8E10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8E14: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E8E18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E8E1C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8E20: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8E24: 4082FFE8  bne 0x828e8e0c
	if !ctx.cr[0].eq {
	pc = 0x828E8E0C; continue 'dispatch;
	}
	// 828E8E28: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8E2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E8E30: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E8E34: 4BA0CB15  bl 0x822f5948
	ctx.lr = 0x828E8E38;
	sub_822F5948(ctx, base);
	// 828E8E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8E3C: 4B8CECDD  bl 0x821b7b18
	ctx.lr = 0x828E8E40;
	sub_821B7B18(ctx, base);
	// 828E8E40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E8E44: 419A0040  beq cr6, 0x828e8e84
	if ctx.cr[6].eq {
	pc = 0x828E8E84; continue 'dispatch;
	}
	// 828E8E48: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E8E4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8E50: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E8E54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E8E58: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8E5C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8E60: 4082FFE8  bne 0x828e8e48
	if !ctx.cr[0].eq {
	pc = 0x828E8E48; continue 'dispatch;
	}
	// 828E8E64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8E68: 409A001C  bne cr6, 0x828e8e84
	if !ctx.cr[6].eq {
	pc = 0x828E8E84; continue 'dispatch;
	}
	// 828E8E6C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8E70: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8E74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8E78: 4E800421  bctrl
	ctx.lr = 0x828E8E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8E7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E8E80: 4B932EB9  bl 0x8221bd38
	ctx.lr = 0x828E8E84;
	sub_8221BD38(ctx, base);
	// 828E8E84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8E88: 4B8CEC91  bl 0x821b7b18
	ctx.lr = 0x828E8E8C;
	sub_821B7B18(ctx, base);
	// 828E8E8C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E8E90: 483C05BC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8E98 size=516
    let mut pc: u32 = 0x828E8E98;
    'dispatch: loop {
        match pc {
            0x828E8E98 => {
    //   block [0x828E8E98..0x828E909C)
	// 828E8E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8E9C: 483C0561  bl 0x82ca93fc
	ctx.lr = 0x828E8EA0;
	sub_82CA93D0(ctx, base);
	// 828E8EA0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8EA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E8EA8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E8EAC: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E8EB0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E8EB4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E8EB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8EBC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E8EC0: 3BAA8418  addi r29, r10, -0x7be8
	ctx.r[29].s64 = ctx.r[10].s64 + -31720;
	// 828E8EC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8EC8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E8ECC: 419A0008  beq cr6, 0x828e8ed4
	if ctx.cr[6].eq {
	pc = 0x828E8ED4; continue 'dispatch;
	}
	// 828E8ED0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8ED4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8ED8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8EDC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8EE0: 4BAE56E1  bl 0x823ce5c0
	ctx.lr = 0x828E8EE4;
	sub_823CE5C0(ctx, base);
	// 828E8EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E8EE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8EEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8EF0: 4BAE5221  bl 0x823ce110
	ctx.lr = 0x828E8EF4;
	sub_823CE110(ctx, base);
	// 828E8EF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8EF8: 4B8CEC21  bl 0x821b7b18
	ctx.lr = 0x828E8EFC;
	sub_821B7B18(ctx, base);
	// 828E8EFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E8F00: 4B936359  bl 0x8221f258
	ctx.lr = 0x828E8F04;
	sub_8221F258(ctx, base);
	// 828E8F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8F08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E8F0C: 419A005C  beq cr6, 0x828e8f68
	if ctx.cr[6].eq {
	pc = 0x828E8F68; continue 'dispatch;
	}
	// 828E8F10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E8F14: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E8F18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E8F1C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E8F20: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E8F24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8F28: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E8F2C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E8F30: 4B907311  bl 0x821f0240
	ctx.lr = 0x828E8F34;
	sub_821F0240(ctx, base);
	// 828E8F34: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E8F38: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E8F3C: 4B93631D  bl 0x8221f258
	ctx.lr = 0x828E8F40;
	sub_8221F258(ctx, base);
	// 828E8F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8F44: 419A0028  beq cr6, 0x828e8f6c
	if ctx.cr[6].eq {
	pc = 0x828E8F6C; continue 'dispatch;
	}
	// 828E8F48: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E8F4C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E8F50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E8F54: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E8F58: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E8F5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E8F60: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E8F64: 4800000C  b 0x828e8f70
	pc = 0x828E8F70; continue 'dispatch;
	// 828E8F68: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E8F6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E8F70: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8F74: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E8F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8F7C: 419A0008  beq cr6, 0x828e8f84
	if ctx.cr[6].eq {
	pc = 0x828E8F84; continue 'dispatch;
	}
	// 828E8F80: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8F84: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E8F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8F8C: 419A0078  beq cr6, 0x828e9004
	if ctx.cr[6].eq {
	pc = 0x828E9004; continue 'dispatch;
	}
	// 828E8F90: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8F94: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E8F98: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8F9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8FA0: 4B940169  bl 0x82229108
	ctx.lr = 0x828E8FA4;
	sub_82229108(ctx, base);
	// 828E8FA4: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828E8FA8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E8FAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8FB0: 3BCB9A38  addi r30, r11, -0x65c8
	ctx.r[30].s64 = ctx.r[11].s64 + -26056;
	// 828E8FB4: 4B93E8CD  bl 0x82227880
	ctx.lr = 0x828E8FB8;
	sub_82227880(ctx, base);
	// 828E8FB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E8FBC: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E8FC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E8FC4: 388A9D68  addi r4, r10, -0x6298
	ctx.r[4].s64 = ctx.r[10].s64 + -25240;
	// 828E8FC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8FCC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E8FD0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E8FD4: 4B8B1AAD  bl 0x8219aa80
	ctx.lr = 0x828E8FD8;
	sub_8219AA80(ctx, base);
	// 828E8FD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8FDC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E8FE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E8FE4: 4BAE543D  bl 0x823ce420
	ctx.lr = 0x828E8FE8;
	sub_823CE420(ctx, base);
	// 828E8FE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E8FEC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E8FF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E8FF4: 4813B6D5  bl 0x82a246c8
	ctx.lr = 0x828E8FF8;
	sub_82A246C8(ctx, base);
	// 828E8FF8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8FFC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E9000: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E9004: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E9008: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E900C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E9010: 419A0020  beq cr6, 0x828e9030
	if ctx.cr[6].eq {
	pc = 0x828E9030; continue 'dispatch;
	}
	// 828E9014: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9018: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E901C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9020: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E9024: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9028: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E902C: 4082FFE8  bne 0x828e9014
	if !ctx.cr[0].eq {
	pc = 0x828E9014; continue 'dispatch;
	}
	// 828E9030: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9038: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E903C: 4BA0C90D  bl 0x822f5948
	ctx.lr = 0x828E9040;
	sub_822F5948(ctx, base);
	// 828E9040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9044: 4B8CEAD5  bl 0x821b7b18
	ctx.lr = 0x828E9048;
	sub_821B7B18(ctx, base);
	// 828E9048: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E904C: 419A0040  beq cr6, 0x828e908c
	if ctx.cr[6].eq {
	pc = 0x828E908C; continue 'dispatch;
	}
	// 828E9050: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9058: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E905C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9060: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9064: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9068: 4082FFE8  bne 0x828e9050
	if !ctx.cr[0].eq {
	pc = 0x828E9050; continue 'dispatch;
	}
	// 828E906C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9070: 409A001C  bne cr6, 0x828e908c
	if !ctx.cr[6].eq {
	pc = 0x828E908C; continue 'dispatch;
	}
	// 828E9074: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9078: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E907C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9080: 4E800421  bctrl
	ctx.lr = 0x828E9084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9084: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9088: 4B932CB1  bl 0x8221bd38
	ctx.lr = 0x828E908C;
	sub_8221BD38(ctx, base);
	// 828E908C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E9090: 4B8CEA89  bl 0x821b7b18
	ctx.lr = 0x828E9094;
	sub_821B7B18(ctx, base);
	// 828E9094: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E9098: 483C03B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E90A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E90A0 size=516
    let mut pc: u32 = 0x828E90A0;
    'dispatch: loop {
        match pc {
            0x828E90A0 => {
    //   block [0x828E90A0..0x828E92A4)
	// 828E90A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E90A4: 483C0359  bl 0x82ca93fc
	ctx.lr = 0x828E90A8;
	sub_82CA93D0(ctx, base);
	// 828E90A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E90AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E90B0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E90B4: 3D408224  lis r10, -0x7ddc
	ctx.r[10].s64 = -2111569920;
	// 828E90B8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E90BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E90C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E90C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E90C8: 3BAA1070  addi r29, r10, 0x1070
	ctx.r[29].s64 = ctx.r[10].s64 + 4208;
	// 828E90CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E90D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E90D4: 419A0008  beq cr6, 0x828e90dc
	if ctx.cr[6].eq {
	pc = 0x828E90DC; continue 'dispatch;
	}
	// 828E90D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E90DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E90E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E90E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E90E8: 4BAE54D9  bl 0x823ce5c0
	ctx.lr = 0x828E90EC;
	sub_823CE5C0(ctx, base);
	// 828E90EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E90F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E90F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E90F8: 4BAE5019  bl 0x823ce110
	ctx.lr = 0x828E90FC;
	sub_823CE110(ctx, base);
	// 828E90FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9100: 4B8CEA19  bl 0x821b7b18
	ctx.lr = 0x828E9104;
	sub_821B7B18(ctx, base);
	// 828E9104: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E9108: 4B936151  bl 0x8221f258
	ctx.lr = 0x828E910C;
	sub_8221F258(ctx, base);
	// 828E910C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9110: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E9114: 419A005C  beq cr6, 0x828e9170
	if ctx.cr[6].eq {
	pc = 0x828E9170; continue 'dispatch;
	}
	// 828E9118: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E911C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E9120: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E9124: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E9128: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E912C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9130: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E9134: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E9138: 4B907109  bl 0x821f0240
	ctx.lr = 0x828E913C;
	sub_821F0240(ctx, base);
	// 828E913C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E9140: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E9144: 4B936115  bl 0x8221f258
	ctx.lr = 0x828E9148;
	sub_8221F258(ctx, base);
	// 828E9148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E914C: 419A0028  beq cr6, 0x828e9174
	if ctx.cr[6].eq {
	pc = 0x828E9174; continue 'dispatch;
	}
	// 828E9150: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E9154: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E9158: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E915C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E9160: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E9164: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9168: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E916C: 4800000C  b 0x828e9178
	pc = 0x828E9178; continue 'dispatch;
	// 828E9170: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E9174: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9178: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E917C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E9180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9184: 419A0008  beq cr6, 0x828e918c
	if ctx.cr[6].eq {
	pc = 0x828E918C; continue 'dispatch;
	}
	// 828E9188: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E918C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9194: 419A0078  beq cr6, 0x828e920c
	if ctx.cr[6].eq {
	pc = 0x828E920C; continue 'dispatch;
	}
	// 828E9198: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E919C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E91A0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E91A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E91A8: 4B93FF61  bl 0x82229108
	ctx.lr = 0x828E91AC;
	sub_82229108(ctx, base);
	// 828E91AC: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828E91B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E91B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E91B8: 3BCB9A38  addi r30, r11, -0x65c8
	ctx.r[30].s64 = ctx.r[11].s64 + -26056;
	// 828E91BC: 4B93E6C5  bl 0x82227880
	ctx.lr = 0x828E91C0;
	sub_82227880(ctx, base);
	// 828E91C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E91C4: 3D408250  lis r10, -0x7db0
	ctx.r[10].s64 = -2108686336;
	// 828E91C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E91CC: 388A8990  addi r4, r10, -0x7670
	ctx.r[4].s64 = ctx.r[10].s64 + -30320;
	// 828E91D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E91D4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E91D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E91DC: 4B8B18A5  bl 0x8219aa80
	ctx.lr = 0x828E91E0;
	sub_8219AA80(ctx, base);
	// 828E91E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E91E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E91E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E91EC: 4BAE5235  bl 0x823ce420
	ctx.lr = 0x828E91F0;
	sub_823CE420(ctx, base);
	// 828E91F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E91F4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E91F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E91FC: 4813B4CD  bl 0x82a246c8
	ctx.lr = 0x828E9200;
	sub_82A246C8(ctx, base);
	// 828E9200: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9204: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E9208: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E920C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E9210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E9214: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E9218: 419A0020  beq cr6, 0x828e9238
	if ctx.cr[6].eq {
	pc = 0x828E9238; continue 'dispatch;
	}
	// 828E921C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9220: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9224: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9228: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E922C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9230: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9234: 4082FFE8  bne 0x828e921c
	if !ctx.cr[0].eq {
	pc = 0x828E921C; continue 'dispatch;
	}
	// 828E9238: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E923C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9240: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E9244: 4BA0C705  bl 0x822f5948
	ctx.lr = 0x828E9248;
	sub_822F5948(ctx, base);
	// 828E9248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E924C: 4B8CE8CD  bl 0x821b7b18
	ctx.lr = 0x828E9250;
	sub_821B7B18(ctx, base);
	// 828E9250: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E9254: 419A0040  beq cr6, 0x828e9294
	if ctx.cr[6].eq {
	pc = 0x828E9294; continue 'dispatch;
	}
	// 828E9258: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E925C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9260: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9264: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9268: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E926C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9270: 4082FFE8  bne 0x828e9258
	if !ctx.cr[0].eq {
	pc = 0x828E9258; continue 'dispatch;
	}
	// 828E9274: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9278: 409A001C  bne cr6, 0x828e9294
	if !ctx.cr[6].eq {
	pc = 0x828E9294; continue 'dispatch;
	}
	// 828E927C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9280: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9288: 4E800421  bctrl
	ctx.lr = 0x828E928C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E928C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9290: 4B932AA9  bl 0x8221bd38
	ctx.lr = 0x828E9294;
	sub_8221BD38(ctx, base);
	// 828E9294: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E9298: 4B8CE881  bl 0x821b7b18
	ctx.lr = 0x828E929C;
	sub_821B7B18(ctx, base);
	// 828E929C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E92A0: 483C01AC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E92A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E92A8 size=516
    let mut pc: u32 = 0x828E92A8;
    'dispatch: loop {
        match pc {
            0x828E92A8 => {
    //   block [0x828E92A8..0x828E94AC)
	// 828E92A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E92AC: 483C0151  bl 0x82ca93fc
	ctx.lr = 0x828E92B0;
	sub_82CA93D0(ctx, base);
	// 828E92B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E92B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E92B8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E92BC: 3D408224  lis r10, -0x7ddc
	ctx.r[10].s64 = -2111569920;
	// 828E92C0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E92C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E92C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E92CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E92D0: 3BAA1250  addi r29, r10, 0x1250
	ctx.r[29].s64 = ctx.r[10].s64 + 4688;
	// 828E92D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E92D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E92DC: 419A0008  beq cr6, 0x828e92e4
	if ctx.cr[6].eq {
	pc = 0x828E92E4; continue 'dispatch;
	}
	// 828E92E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E92E4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E92E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E92EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E92F0: 4BAE52D1  bl 0x823ce5c0
	ctx.lr = 0x828E92F4;
	sub_823CE5C0(ctx, base);
	// 828E92F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E92F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E92FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E9300: 4BAE4E11  bl 0x823ce110
	ctx.lr = 0x828E9304;
	sub_823CE110(ctx, base);
	// 828E9304: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9308: 4B8CE811  bl 0x821b7b18
	ctx.lr = 0x828E930C;
	sub_821B7B18(ctx, base);
	// 828E930C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E9310: 4B935F49  bl 0x8221f258
	ctx.lr = 0x828E9314;
	sub_8221F258(ctx, base);
	// 828E9314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9318: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E931C: 419A005C  beq cr6, 0x828e9378
	if ctx.cr[6].eq {
	pc = 0x828E9378; continue 'dispatch;
	}
	// 828E9320: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E9324: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E9328: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E932C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E9330: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E9334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9338: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E933C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E9340: 4B906F01  bl 0x821f0240
	ctx.lr = 0x828E9344;
	sub_821F0240(ctx, base);
	// 828E9344: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E9348: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E934C: 4B935F0D  bl 0x8221f258
	ctx.lr = 0x828E9350;
	sub_8221F258(ctx, base);
	// 828E9350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9354: 419A0028  beq cr6, 0x828e937c
	if ctx.cr[6].eq {
	pc = 0x828E937C; continue 'dispatch;
	}
	// 828E9358: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E935C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E9360: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E9364: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E9368: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E936C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9370: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9374: 4800000C  b 0x828e9380
	pc = 0x828E9380; continue 'dispatch;
	// 828E9378: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E937C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9380: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9384: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E9388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E938C: 419A0008  beq cr6, 0x828e9394
	if ctx.cr[6].eq {
	pc = 0x828E9394; continue 'dispatch;
	}
	// 828E9390: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9394: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E939C: 419A0078  beq cr6, 0x828e9414
	if ctx.cr[6].eq {
	pc = 0x828E9414; continue 'dispatch;
	}
	// 828E93A0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E93A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E93A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E93AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E93B0: 4B93FD59  bl 0x82229108
	ctx.lr = 0x828E93B4;
	sub_82229108(ctx, base);
	// 828E93B4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 828E93B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E93BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E93C0: 3BCBA260  addi r30, r11, -0x5da0
	ctx.r[30].s64 = ctx.r[11].s64 + -23968;
	// 828E93C4: 4B93E4BD  bl 0x82227880
	ctx.lr = 0x828E93C8;
	sub_82227880(ctx, base);
	// 828E93C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E93CC: 3D40822C  lis r10, -0x7dd4
	ctx.r[10].s64 = -2111045632;
	// 828E93D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E93D4: 388AF488  addi r4, r10, -0xb78
	ctx.r[4].s64 = ctx.r[10].s64 + -2936;
	// 828E93D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E93DC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E93E0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E93E4: 4B8B169D  bl 0x8219aa80
	ctx.lr = 0x828E93E8;
	sub_8219AA80(ctx, base);
	// 828E93E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E93EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E93F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E93F4: 4BAE502D  bl 0x823ce420
	ctx.lr = 0x828E93F8;
	sub_823CE420(ctx, base);
	// 828E93F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E93FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E9400: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E9404: 4813B2C5  bl 0x82a246c8
	ctx.lr = 0x828E9408;
	sub_82A246C8(ctx, base);
	// 828E9408: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E940C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E9410: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E9414: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E9418: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E941C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E9420: 419A0020  beq cr6, 0x828e9440
	if ctx.cr[6].eq {
	pc = 0x828E9440; continue 'dispatch;
	}
	// 828E9424: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9428: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E942C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9430: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E9434: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9438: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E943C: 4082FFE8  bne 0x828e9424
	if !ctx.cr[0].eq {
	pc = 0x828E9424; continue 'dispatch;
	}
	// 828E9440: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9444: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9448: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E944C: 4BA0C4FD  bl 0x822f5948
	ctx.lr = 0x828E9450;
	sub_822F5948(ctx, base);
	// 828E9450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9454: 4B8CE6C5  bl 0x821b7b18
	ctx.lr = 0x828E9458;
	sub_821B7B18(ctx, base);
	// 828E9458: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E945C: 419A0040  beq cr6, 0x828e949c
	if ctx.cr[6].eq {
	pc = 0x828E949C; continue 'dispatch;
	}
	// 828E9460: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9464: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9468: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E946C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9470: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9474: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9478: 4082FFE8  bne 0x828e9460
	if !ctx.cr[0].eq {
	pc = 0x828E9460; continue 'dispatch;
	}
	// 828E947C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9480: 409A001C  bne cr6, 0x828e949c
	if !ctx.cr[6].eq {
	pc = 0x828E949C; continue 'dispatch;
	}
	// 828E9484: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9488: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E948C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9490: 4E800421  bctrl
	ctx.lr = 0x828E9494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9498: 4B9328A1  bl 0x8221bd38
	ctx.lr = 0x828E949C;
	sub_8221BD38(ctx, base);
	// 828E949C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E94A0: 4B8CE679  bl 0x821b7b18
	ctx.lr = 0x828E94A4;
	sub_821B7B18(ctx, base);
	// 828E94A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E94A8: 483BFFA4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E94B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E94B0 size=516
    let mut pc: u32 = 0x828E94B0;
    'dispatch: loop {
        match pc {
            0x828E94B0 => {
    //   block [0x828E94B0..0x828E96B4)
	// 828E94B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E94B4: 483BFF49  bl 0x82ca93fc
	ctx.lr = 0x828E94B8;
	sub_82CA93D0(ctx, base);
	// 828E94B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E94BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E94C0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E94C4: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E94C8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E94CC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E94D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E94D4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E94D8: 3BAA84C8  addi r29, r10, -0x7b38
	ctx.r[29].s64 = ctx.r[10].s64 + -31544;
	// 828E94DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E94E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E94E4: 419A0008  beq cr6, 0x828e94ec
	if ctx.cr[6].eq {
	pc = 0x828E94EC; continue 'dispatch;
	}
	// 828E94E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E94EC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E94F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E94F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E94F8: 4BAE50C9  bl 0x823ce5c0
	ctx.lr = 0x828E94FC;
	sub_823CE5C0(ctx, base);
	// 828E94FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9500: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E9504: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E9508: 4BAE4C09  bl 0x823ce110
	ctx.lr = 0x828E950C;
	sub_823CE110(ctx, base);
	// 828E950C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9510: 4B8CE609  bl 0x821b7b18
	ctx.lr = 0x828E9514;
	sub_821B7B18(ctx, base);
	// 828E9514: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E9518: 4B935D41  bl 0x8221f258
	ctx.lr = 0x828E951C;
	sub_8221F258(ctx, base);
	// 828E951C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9520: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E9524: 419A005C  beq cr6, 0x828e9580
	if ctx.cr[6].eq {
	pc = 0x828E9580; continue 'dispatch;
	}
	// 828E9528: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E952C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E9530: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E9534: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E9538: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E953C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9540: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E9544: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E9548: 4B906CF9  bl 0x821f0240
	ctx.lr = 0x828E954C;
	sub_821F0240(ctx, base);
	// 828E954C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E9550: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E9554: 4B935D05  bl 0x8221f258
	ctx.lr = 0x828E9558;
	sub_8221F258(ctx, base);
	// 828E9558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E955C: 419A0028  beq cr6, 0x828e9584
	if ctx.cr[6].eq {
	pc = 0x828E9584; continue 'dispatch;
	}
	// 828E9560: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E9564: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E9568: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E956C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E9570: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E9574: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9578: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E957C: 4800000C  b 0x828e9588
	pc = 0x828E9588; continue 'dispatch;
	// 828E9580: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E9584: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9588: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E958C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E9590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9594: 419A0008  beq cr6, 0x828e959c
	if ctx.cr[6].eq {
	pc = 0x828E959C; continue 'dispatch;
	}
	// 828E9598: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E959C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E95A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E95A4: 419A0078  beq cr6, 0x828e961c
	if ctx.cr[6].eq {
	pc = 0x828E961C; continue 'dispatch;
	}
	// 828E95A8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E95AC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E95B0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E95B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E95B8: 4B93FB51  bl 0x82229108
	ctx.lr = 0x828E95BC;
	sub_82229108(ctx, base);
	// 828E95BC: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828E95C0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E95C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E95C8: 3BCB9BC8  addi r30, r11, -0x6438
	ctx.r[30].s64 = ctx.r[11].s64 + -25656;
	// 828E95CC: 4B93E2B5  bl 0x82227880
	ctx.lr = 0x828E95D0;
	sub_82227880(ctx, base);
	// 828E95D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E95D4: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E95D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E95DC: 388A9DF0  addi r4, r10, -0x6210
	ctx.r[4].s64 = ctx.r[10].s64 + -25104;
	// 828E95E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E95E4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E95E8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E95EC: 4B8B1495  bl 0x8219aa80
	ctx.lr = 0x828E95F0;
	sub_8219AA80(ctx, base);
	// 828E95F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E95F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E95F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E95FC: 4BAE4E25  bl 0x823ce420
	ctx.lr = 0x828E9600;
	sub_823CE420(ctx, base);
	// 828E9600: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E9604: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E9608: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E960C: 4813B0BD  bl 0x82a246c8
	ctx.lr = 0x828E9610;
	sub_82A246C8(ctx, base);
	// 828E9610: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9614: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E9618: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E961C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E9620: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E9624: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E9628: 419A0020  beq cr6, 0x828e9648
	if ctx.cr[6].eq {
	pc = 0x828E9648; continue 'dispatch;
	}
	// 828E962C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9630: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9634: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9638: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E963C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9640: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9644: 4082FFE8  bne 0x828e962c
	if !ctx.cr[0].eq {
	pc = 0x828E962C; continue 'dispatch;
	}
	// 828E9648: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E964C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9650: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E9654: 4BA0C2F5  bl 0x822f5948
	ctx.lr = 0x828E9658;
	sub_822F5948(ctx, base);
	// 828E9658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E965C: 4B8CE4BD  bl 0x821b7b18
	ctx.lr = 0x828E9660;
	sub_821B7B18(ctx, base);
	// 828E9660: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E9664: 419A0040  beq cr6, 0x828e96a4
	if ctx.cr[6].eq {
	pc = 0x828E96A4; continue 'dispatch;
	}
	// 828E9668: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E966C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9670: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9674: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9678: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E967C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9680: 4082FFE8  bne 0x828e9668
	if !ctx.cr[0].eq {
	pc = 0x828E9668; continue 'dispatch;
	}
	// 828E9684: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9688: 409A001C  bne cr6, 0x828e96a4
	if !ctx.cr[6].eq {
	pc = 0x828E96A4; continue 'dispatch;
	}
	// 828E968C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9690: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9698: 4E800421  bctrl
	ctx.lr = 0x828E969C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E969C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E96A0: 4B932699  bl 0x8221bd38
	ctx.lr = 0x828E96A4;
	sub_8221BD38(ctx, base);
	// 828E96A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E96A8: 4B8CE471  bl 0x821b7b18
	ctx.lr = 0x828E96AC;
	sub_821B7B18(ctx, base);
	// 828E96AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E96B0: 483BFD9C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E96B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E96B8 size=516
    let mut pc: u32 = 0x828E96B8;
    'dispatch: loop {
        match pc {
            0x828E96B8 => {
    //   block [0x828E96B8..0x828E98BC)
	// 828E96B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E96BC: 483BFD41  bl 0x82ca93fc
	ctx.lr = 0x828E96C0;
	sub_82CA93D0(ctx, base);
	// 828E96C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E96C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E96C8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E96CC: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E96D0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828E96D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E96D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E96DC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828E96E0: 3BAA8648  addi r29, r10, -0x79b8
	ctx.r[29].s64 = ctx.r[10].s64 + -31160;
	// 828E96E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E96E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E96EC: 419A0008  beq cr6, 0x828e96f4
	if ctx.cr[6].eq {
	pc = 0x828E96F4; continue 'dispatch;
	}
	// 828E96F0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E96F4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E96F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E96FC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9700: 4BAE4EC1  bl 0x823ce5c0
	ctx.lr = 0x828E9704;
	sub_823CE5C0(ctx, base);
	// 828E9704: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E970C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E9710: 4BAE4A01  bl 0x823ce110
	ctx.lr = 0x828E9714;
	sub_823CE110(ctx, base);
	// 828E9714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9718: 4B8CE401  bl 0x821b7b18
	ctx.lr = 0x828E971C;
	sub_821B7B18(ctx, base);
	// 828E971C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E9720: 4B935B39  bl 0x8221f258
	ctx.lr = 0x828E9724;
	sub_8221F258(ctx, base);
	// 828E9724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9728: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E972C: 419A005C  beq cr6, 0x828e9788
	if ctx.cr[6].eq {
	pc = 0x828E9788; continue 'dispatch;
	}
	// 828E9730: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828E9734: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828E9738: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E973C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828E9740: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E9744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9748: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E974C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828E9750: 4B906AF1  bl 0x821f0240
	ctx.lr = 0x828E9754;
	sub_821F0240(ctx, base);
	// 828E9754: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828E9758: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828E975C: 4B935AFD  bl 0x8221f258
	ctx.lr = 0x828E9760;
	sub_8221F258(ctx, base);
	// 828E9760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9764: 419A0028  beq cr6, 0x828e978c
	if ctx.cr[6].eq {
	pc = 0x828E978C; continue 'dispatch;
	}
	// 828E9768: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828E976C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828E9770: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E9774: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828E9778: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E977C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9780: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9784: 4800000C  b 0x828e9790
	pc = 0x828E9790; continue 'dispatch;
	// 828E9788: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828E978C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9790: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9794: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828E9798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E979C: 419A0008  beq cr6, 0x828e97a4
	if ctx.cr[6].eq {
	pc = 0x828E97A4; continue 'dispatch;
	}
	// 828E97A0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E97A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E97A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E97AC: 419A0078  beq cr6, 0x828e9824
	if ctx.cr[6].eq {
	pc = 0x828E9824; continue 'dispatch;
	}
	// 828E97B0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E97B4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828E97B8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E97BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E97C0: 4B93F949  bl 0x82229108
	ctx.lr = 0x828E97C4;
	sub_82229108(ctx, base);
	// 828E97C4: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828E97C8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828E97CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E97D0: 3BCB9A38  addi r30, r11, -0x65c8
	ctx.r[30].s64 = ctx.r[11].s64 + -26056;
	// 828E97D4: 4B93E0AD  bl 0x82227880
	ctx.lr = 0x828E97D8;
	sub_82227880(ctx, base);
	// 828E97D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E97DC: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828E97E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E97E4: 388A9E78  addi r4, r10, -0x6188
	ctx.r[4].s64 = ctx.r[10].s64 + -24968;
	// 828E97E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E97EC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828E97F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828E97F4: 4B8B128D  bl 0x8219aa80
	ctx.lr = 0x828E97F8;
	sub_8219AA80(ctx, base);
	// 828E97F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E97FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E9800: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E9804: 4BAE4C1D  bl 0x823ce420
	ctx.lr = 0x828E9808;
	sub_823CE420(ctx, base);
	// 828E9808: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E980C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828E9810: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E9814: 4813AEB5  bl 0x82a246c8
	ctx.lr = 0x828E9818;
	sub_82A246C8(ctx, base);
	// 828E9818: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E981C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828E9820: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828E9824: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E9828: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E982C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828E9830: 419A0020  beq cr6, 0x828e9850
	if ctx.cr[6].eq {
	pc = 0x828E9850; continue 'dispatch;
	}
	// 828E9834: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9838: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E983C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E9840: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E9844: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9848: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E984C: 4082FFE8  bne 0x828e9834
	if !ctx.cr[0].eq {
	pc = 0x828E9834; continue 'dispatch;
	}
	// 828E9850: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9858: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828E985C: 4BA0C0ED  bl 0x822f5948
	ctx.lr = 0x828E9860;
	sub_822F5948(ctx, base);
	// 828E9860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9864: 4B8CE2B5  bl 0x821b7b18
	ctx.lr = 0x828E9868;
	sub_821B7B18(ctx, base);
	// 828E9868: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E986C: 419A0040  beq cr6, 0x828e98ac
	if ctx.cr[6].eq {
	pc = 0x828E98AC; continue 'dispatch;
	}
	// 828E9870: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828E9874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9878: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828E987C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9880: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9884: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9888: 4082FFE8  bne 0x828e9870
	if !ctx.cr[0].eq {
	pc = 0x828E9870; continue 'dispatch;
	}
	// 828E988C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9890: 409A001C  bne cr6, 0x828e98ac
	if !ctx.cr[6].eq {
	pc = 0x828E98AC; continue 'dispatch;
	}
	// 828E9894: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9898: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E989C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E98A0: 4E800421  bctrl
	ctx.lr = 0x828E98A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E98A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E98A8: 4B932491  bl 0x8221bd38
	ctx.lr = 0x828E98AC;
	sub_8221BD38(ctx, base);
	// 828E98AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E98B0: 4B8CE269  bl 0x821b7b18
	ctx.lr = 0x828E98B4;
	sub_821B7B18(ctx, base);
	// 828E98B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828E98B8: 483BFB94  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E98C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E98C0 size=372
    let mut pc: u32 = 0x828E98C0;
    'dispatch: loop {
        match pc {
            0x828E98C0 => {
    //   block [0x828E98C0..0x828E9A34)
	// 828E98C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E98C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E98C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E98CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E98D0: 419A0018  beq cr6, 0x828e98e8
	if ctx.cr[6].eq {
	pc = 0x828E98E8; continue 'dispatch;
	}
	// 828E98D4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E98D8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E98DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E98E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E98E4: 409A0008  bne cr6, 0x828e98ec
	if !ctx.cr[6].eq {
	pc = 0x828E98EC; continue 'dispatch;
	}
	// 828E98E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E98EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E98F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E98F4: 419A012C  beq cr6, 0x828e9a20
	if ctx.cr[6].eq {
	pc = 0x828E9A20; continue 'dispatch;
	}
	// 828E98F8: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E98FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E9900: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828E9904: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E9908: 419A00E8  beq cr6, 0x828e99f0
	if ctx.cr[6].eq {
	pc = 0x828E99F0; continue 'dispatch;
	}
	// 828E990C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E9910: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E9914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9918: 419A001C  beq cr6, 0x828e9934
	if ctx.cr[6].eq {
	pc = 0x828E9934; continue 'dispatch;
	}
	// 828E991C: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828E9920: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828E9924: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E9928: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E992C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E9930: 480000C4  b 0x828e99f4
	pc = 0x828E99F4; continue 'dispatch;
	// 828E9934: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E9938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E993C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E9940: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E9944: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E9948: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E994C: 40810054  ble 0x828e99a0
	if !ctx.cr[0].gt {
	pc = 0x828E99A0; continue 'dispatch;
	}
	// 828E9950: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E9954: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E9958: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E995C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9960: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828E9964: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E9968: 41980008  blt cr6, 0x828e9970
	if ctx.cr[6].lt {
	pc = 0x828E9970; continue 'dispatch;
	}
	// 828E996C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E9970: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E9974: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E9978: 419A0014  beq cr6, 0x828e998c
	if ctx.cr[6].eq {
	pc = 0x828E998C; continue 'dispatch;
	}
	// 828E997C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E9980: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E9984: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9988: 4800000C  b 0x828e9994
	pc = 0x828E9994; continue 'dispatch;
	// 828E998C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E9990: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E9994: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9998: 4199FFB8  bgt cr6, 0x828e9950
	if ctx.cr[6].gt {
	pc = 0x828E9950; continue 'dispatch;
	}
	// 828E999C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E99A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E99A4: 419A003C  beq cr6, 0x828e99e0
	if ctx.cr[6].eq {
	pc = 0x828E99E0; continue 'dispatch;
	}
	// 828E99A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E99AC: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828E99B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E99B4: 41990008  bgt cr6, 0x828e99bc
	if ctx.cr[6].gt {
	pc = 0x828E99BC; continue 'dispatch;
	}
	// 828E99B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E99BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E99C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E99C4: 409A001C  bne cr6, 0x828e99e0
	if !ctx.cr[6].eq {
	pc = 0x828E99E0; continue 'dispatch;
	}
	// 828E99C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E99CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E99D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E99D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E99D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E99DC: 48000018  b 0x828e99f4
	pc = 0x828E99F4; continue 'dispatch;
	// 828E99E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E99E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E99E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E99EC: 48000008  b 0x828e99f4
	pc = 0x828E99F4; continue 'dispatch;
	// 828E99F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E99F4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E99F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E99FC: 419A0024  beq cr6, 0x828e9a20
	if ctx.cr[6].eq {
	pc = 0x828E9A20; continue 'dispatch;
	}
	// 828E9A00: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9A04: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E9A08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E9A0C: 4E800421  bctrl
	ctx.lr = 0x828E9A10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E9A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9A1C: 4E800020  blr
	return;
	// 828E9A20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E9A24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E9A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9A38 size=396
    let mut pc: u32 = 0x828E9A38;
    'dispatch: loop {
        match pc {
            0x828E9A38 => {
    //   block [0x828E9A38..0x828E9BC4)
	// 828E9A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9A40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9A44: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828E9A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9A4C: 419A0018  beq cr6, 0x828e9a64
	if ctx.cr[6].eq {
	pc = 0x828E9A64; continue 'dispatch;
	}
	// 828E9A50: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E9A54: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828E9A58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E9A5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828E9A60: 409A0008  bne cr6, 0x828e9a68
	if !ctx.cr[6].eq {
	pc = 0x828E9A68; continue 'dispatch;
	}
	// 828E9A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E9A68: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828E9A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E9A70: 419A0140  beq cr6, 0x828e9bb0
	if ctx.cr[6].eq {
	pc = 0x828E9BB0; continue 'dispatch;
	}
	// 828E9A74: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E9A78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E9A7C: 55280FFE  srwi r8, r9, 0x1f
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E9A80: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828E9A84: 419A00F8  beq cr6, 0x828e9b7c
	if ctx.cr[6].eq {
	pc = 0x828E9B7C; continue 'dispatch;
	}
	// 828E9A88: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E9A8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E9A90: 419A0024  beq cr6, 0x828e9ab4
	if ctx.cr[6].eq {
	pc = 0x828E9AB4; continue 'dispatch;
	}
	// 828E9A94: 892A003F  lbz r9, 0x3f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(63 as u32) ) } as u64;
	// 828E9A98: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E9A9C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828E9AA0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E9AA4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9AA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E9AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9AB0: 480000D0  b 0x828e9b80
	pc = 0x828E9B80; continue 'dispatch;
	// 828E9AB4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E9AB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E9ABC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E9AC0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828E9AC4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E9AC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E9ACC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9AD0: 40810054  ble 0x828e9b24
	if !ctx.cr[0].gt {
	pc = 0x828E9B24; continue 'dispatch;
	}
	// 828E9AD4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E9AD8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E9ADC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E9AE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9AE4: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828E9AE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E9AEC: 41980008  blt cr6, 0x828e9af4
	if ctx.cr[6].lt {
	pc = 0x828E9AF4; continue 'dispatch;
	}
	// 828E9AF0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828E9AF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E9AF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E9AFC: 419A0014  beq cr6, 0x828e9b10
	if ctx.cr[6].eq {
	pc = 0x828E9B10; continue 'dispatch;
	}
	// 828E9B00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E9B04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E9B08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9B0C: 4800000C  b 0x828e9b18
	pc = 0x828E9B18; continue 'dispatch;
	// 828E9B10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E9B14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E9B18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9B1C: 4199FFB8  bgt cr6, 0x828e9ad4
	if ctx.cr[6].gt {
	pc = 0x828E9AD4; continue 'dispatch;
	}
	// 828E9B20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E9B24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E9B28: 419A0040  beq cr6, 0x828e9b68
	if ctx.cr[6].eq {
	pc = 0x828E9B68; continue 'dispatch;
	}
	// 828E9B2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9B30: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828E9B34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9B38: 41990008  bgt cr6, 0x828e9b40
	if ctx.cr[6].gt {
	pc = 0x828E9B40; continue 'dispatch;
	}
	// 828E9B3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E9B40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E9B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9B48: 409A0020  bne cr6, 0x828e9b68
	if !ctx.cr[6].eq {
	pc = 0x828E9B68; continue 'dispatch;
	}
	// 828E9B4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E9B50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E9B54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E9B58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9B5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E9B60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9B64: 4800001C  b 0x828e9b80
	pc = 0x828E9B80; continue 'dispatch;
	// 828E9B68: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E9B6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9B70: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828E9B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9B78: 48000008  b 0x828e9b80
	pc = 0x828E9B80; continue 'dispatch;
	// 828E9B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E9B80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E9B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9B88: 419A0028  beq cr6, 0x828e9bb0
	if ctx.cr[6].eq {
	pc = 0x828E9BB0; continue 'dispatch;
	}
	// 828E9B8C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9B90: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828E9B94: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828E9B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9B9C: 4E800421  bctrl
	ctx.lr = 0x828E9BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9BA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E9BA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9BA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9BAC: 4E800020  blr
	return;
	// 828E9BB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E9BB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E9BB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9BBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9BC8 size=416
    let mut pc: u32 = 0x828E9BC8;
    'dispatch: loop {
        match pc {
            0x828E9BC8 => {
    //   block [0x828E9BC8..0x828E9D68)
	// 828E9BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9BCC: 483BF841  bl 0x82ca940c
	ctx.lr = 0x828E9BD0;
	sub_82CA93D0(ctx, base);
	// 828E9BD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9BD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9BD8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E9BDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E9BE0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E9BE4: 419A0018  beq cr6, 0x828e9bfc
	if ctx.cr[6].eq {
	pc = 0x828E9BFC; continue 'dispatch;
	}
	// 828E9BE8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E9BEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E9BF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E9BF8: 409A0008  bne cr6, 0x828e9c00
	if !ctx.cr[6].eq {
	pc = 0x828E9C00; continue 'dispatch;
	}
	// 828E9BFC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E9C00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E9C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9C08: 419A014C  beq cr6, 0x828e9d54
	if ctx.cr[6].eq {
	pc = 0x828E9D54; continue 'dispatch;
	}
	// 828E9C0C: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828E9C10: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828E9C14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828E9C18: 419A00F4  beq cr6, 0x828e9d0c
	if ctx.cr[6].eq {
	pc = 0x828E9D0C; continue 'dispatch;
	}
	// 828E9C1C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E9C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9C24: 419A0024  beq cr6, 0x828e9c48
	if ctx.cr[6].eq {
	pc = 0x828E9C48; continue 'dispatch;
	}
	// 828E9C28: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828E9C2C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E9C30: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828E9C34: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E9C38: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9C3C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E9C40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9C44: 480000CC  b 0x828e9d10
	pc = 0x828E9D10; continue 'dispatch;
	// 828E9C48: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E9C4C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828E9C50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E9C54: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828E9C58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E9C5C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9C60: 40810054  ble 0x828e9cb4
	if !ctx.cr[0].gt {
	pc = 0x828E9CB4; continue 'dispatch;
	}
	// 828E9C64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828E9C68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828E9C6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828E9C70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9C74: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828E9C78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828E9C7C: 41980008  blt cr6, 0x828e9c84
	if ctx.cr[6].lt {
	pc = 0x828E9C84; continue 'dispatch;
	}
	// 828E9C80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828E9C84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828E9C88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828E9C8C: 419A0014  beq cr6, 0x828e9ca0
	if ctx.cr[6].eq {
	pc = 0x828E9CA0; continue 'dispatch;
	}
	// 828E9C90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828E9C94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828E9C98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828E9C9C: 4800000C  b 0x828e9ca8
	pc = 0x828E9CA8; continue 'dispatch;
	// 828E9CA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828E9CA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828E9CA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9CAC: 4199FFB8  bgt cr6, 0x828e9c64
	if ctx.cr[6].gt {
	pc = 0x828E9C64; continue 'dispatch;
	}
	// 828E9CB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828E9CB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828E9CB8: 419A0040  beq cr6, 0x828e9cf8
	if ctx.cr[6].eq {
	pc = 0x828E9CF8; continue 'dispatch;
	}
	// 828E9CBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9CC0: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828E9CC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9CC8: 41990008  bgt cr6, 0x828e9cd0
	if ctx.cr[6].gt {
	pc = 0x828E9CD0; continue 'dispatch;
	}
	// 828E9CCC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E9CD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E9CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9CD8: 409A0020  bne cr6, 0x828e9cf8
	if !ctx.cr[6].eq {
	pc = 0x828E9CF8; continue 'dispatch;
	}
	// 828E9CDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828E9CE0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828E9CE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E9CE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9CEC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E9CF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9CF4: 4800001C  b 0x828e9d10
	pc = 0x828E9D10; continue 'dispatch;
	// 828E9CF8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828E9CFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9D00: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E9D04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E9D08: 48000008  b 0x828e9d10
	pc = 0x828E9D10; continue 'dispatch;
	// 828E9D0C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828E9D10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828E9D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9D18: 419A003C  beq cr6, 0x828e9d54
	if ctx.cr[6].eq {
	pc = 0x828E9D54; continue 'dispatch;
	}
	// 828E9D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9D24: 4B90651D  bl 0x821f0240
	ctx.lr = 0x828E9D28;
	sub_821F0240(ctx, base);
	// 828E9D28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9D2C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E9D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E9D38: 4E800421  bctrl
	ctx.lr = 0x828E9D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9D44: 4B92B095  bl 0x82214dd8
	ctx.lr = 0x828E9D48;
	sub_82214DD8(ctx, base);
	// 828E9D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9D4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9D50: 483BF70C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828E9D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9D58: 4B92B081  bl 0x82214dd8
	ctx.lr = 0x828E9D5C;
	sub_82214DD8(ctx, base);
	// 828E9D5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E9D60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9D64: 483BF6F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9D68 size=132
    let mut pc: u32 = 0x828E9D68;
    'dispatch: loop {
        match pc {
            0x828E9D68 => {
    //   block [0x828E9D68..0x828E9DEC)
	// 828E9D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9D6C: 483BF69D  bl 0x82ca9408
	ctx.lr = 0x828E9D70;
	sub_82CA93D0(ctx, base);
	// 828E9D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9D74: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828E9D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9D7C: 4B93E37D  bl 0x822280f8
	ctx.lr = 0x828E9D80;
	sub_822280F8(ctx, base);
	// 828E9D80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9D84: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828E9D88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E9D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9D90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E9D94: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828E9D98: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9D9C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9DA0: 4B93E359  bl 0x822280f8
	ctx.lr = 0x828E9DA4;
	sub_822280F8(ctx, base);
	// 828E9DA4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9DA8: 4B93D7B9  bl 0x82227560
	ctx.lr = 0x828E9DAC;
	sub_82227560(ctx, base);
	// 828E9DAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E9DB0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828E9DB4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9DB8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9DBC: 4BF088B5  bl 0x827f2670
	ctx.lr = 0x828E9DC0;
	sub_827F2670(ctx, base);
	// 828E9DC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E9DC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E9DC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9DCC: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828E9DD0: 4E800421  bctrl
	ctx.lr = 0x828E9DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9DD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9DDC: 4BAB91E5  bl 0x823a2fc0
	ctx.lr = 0x828E9DE0;
	sub_823A2FC0(ctx, base);
	// 828E9DE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E9DE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9DE8: 483BF670  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9DF0 size=136
    let mut pc: u32 = 0x828E9DF0;
    'dispatch: loop {
        match pc {
            0x828E9DF0 => {
    //   block [0x828E9DF0..0x828E9E78)
	// 828E9DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9DF4: 483BF615  bl 0x82ca9408
	ctx.lr = 0x828E9DF8;
	sub_82CA93D0(ctx, base);
	// 828E9DF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9DFC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828E9E00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9E04: 4B93E2F5  bl 0x822280f8
	ctx.lr = 0x828E9E08;
	sub_822280F8(ctx, base);
	// 828E9E08: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9E0C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828E9E10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E9E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9E18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E9E1C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828E9E20: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9E24: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9E28: 4B93E2D1  bl 0x822280f8
	ctx.lr = 0x828E9E2C;
	sub_822280F8(ctx, base);
	// 828E9E2C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9E30: 4B93D731  bl 0x82227560
	ctx.lr = 0x828E9E34;
	sub_82227560(ctx, base);
	// 828E9E34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9E38: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9E3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E9E40: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828E9E44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E9E48: 4BA181A1  bl 0x82301fe8
	ctx.lr = 0x828E9E4C;
	sub_82301FE8(ctx, base);
	// 828E9E4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E9E50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E9E54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9E58: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828E9E5C: 4E800421  bctrl
	ctx.lr = 0x828E9E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9E60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9E68: 4BAB9159  bl 0x823a2fc0
	ctx.lr = 0x828E9E6C;
	sub_823A2FC0(ctx, base);
	// 828E9E6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E9E70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9E74: 483BF5E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9E78 size=132
    let mut pc: u32 = 0x828E9E78;
    'dispatch: loop {
        match pc {
            0x828E9E78 => {
    //   block [0x828E9E78..0x828E9EFC)
	// 828E9E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9E7C: 483BF58D  bl 0x82ca9408
	ctx.lr = 0x828E9E80;
	sub_82CA93D0(ctx, base);
	// 828E9E80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9E84: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 828E9E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9E8C: 4B93E26D  bl 0x822280f8
	ctx.lr = 0x828E9E90;
	sub_822280F8(ctx, base);
	// 828E9E90: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9E94: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828E9E98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828E9E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9EA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E9EA4: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828E9EA8: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9EAC: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9EB0: 4B93E249  bl 0x822280f8
	ctx.lr = 0x828E9EB4;
	sub_822280F8(ctx, base);
	// 828E9EB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9EB8: 4B93D6A9  bl 0x82227560
	ctx.lr = 0x828E9EBC;
	sub_82227560(ctx, base);
	// 828E9EBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E9EC0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828E9EC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9EC8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9ECC: 4BA3C7BD  bl 0x82326688
	ctx.lr = 0x828E9ED0;
	sub_82326688(ctx, base);
	// 828E9ED0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E9ED4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E9ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E9EDC: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828E9EE0: 4E800421  bctrl
	ctx.lr = 0x828E9EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E9EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9EEC: 4BAB90D5  bl 0x823a2fc0
	ctx.lr = 0x828E9EF0;
	sub_823A2FC0(ctx, base);
	// 828E9EF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E9EF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9EF8: 483BF560  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9F00 size=116
    let mut pc: u32 = 0x828E9F00;
    'dispatch: loop {
        match pc {
            0x828E9F00 => {
    //   block [0x828E9F00..0x828E9F74)
	// 828E9F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9F18: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 828E9F1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9F20: 4B935339  bl 0x8221f258
	ctx.lr = 0x828E9F24;
	sub_8221F258(ctx, base);
	// 828E9F24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9F28: 419A0014  beq cr6, 0x828e9f3c
	if ctx.cr[6].eq {
	pc = 0x828E9F3C; continue 'dispatch;
	}
	// 828E9F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E9F30: 48000049  bl 0x828e9f78
	ctx.lr = 0x828E9F34;
	sub_828E9F78(ctx, base);
	// 828E9F34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9F38: 48000008  b 0x828e9f40
	pc = 0x828E9F40; continue 'dispatch;
	// 828E9F3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E9F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9F44: 4B9D5FD5  bl 0x822bff18
	ctx.lr = 0x828E9F48;
	sub_822BFF18(ctx, base);
	// 828E9F48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9F50: 419A0008  beq cr6, 0x828e9f58
	if ctx.cr[6].eq {
	pc = 0x828E9F58; continue 'dispatch;
	}
	// 828E9F54: 4B8972CD  bl 0x82181220
	ctx.lr = 0x828E9F58;
	sub_82181220(ctx, base);
	// 828E9F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9F5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9F68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E9F78 size=96
    let mut pc: u32 = 0x828E9F78;
    'dispatch: loop {
        match pc {
            0x828E9F78 => {
    //   block [0x828E9F78..0x828E9FD8)
	// 828E9F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9F80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9F84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9F90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9F94: 4BB1FD5D  bl 0x82409cf0
	ctx.lr = 0x828E9F98;
	sub_82409CF0(ctx, base);
	// 828E9F98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E9F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9FA0: 394B55A8  addi r10, r11, 0x55a8
	ctx.r[10].s64 = ctx.r[11].s64 + 21928;
	// 828E9FA4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E9FA8: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E9FAC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828E9FB0: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E9FB4: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828E9FB8: C19E0080  lfs f12, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E9FBC: D19F0080  stfs f12, 0x80(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828E9FC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9FCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9FD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9FD8 size=8
    let mut pc: u32 = 0x828E9FD8;
    'dispatch: loop {
        match pc {
            0x828E9FD8 => {
    //   block [0x828E9FD8..0x828E9FE0)
	// 828E9FD8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828E9FDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E9FE0 size=176
    let mut pc: u32 = 0x828E9FE0;
    'dispatch: loop {
        match pc {
            0x828E9FE0 => {
    //   block [0x828E9FE0..0x828EA090)
	// 828E9FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9FE4: 483BF429  bl 0x82ca940c
	ctx.lr = 0x828E9FE8;
	sub_82CA93D0(ctx, base);
	// 828E9FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9FEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E9FF0: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 828E9FF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9FF8: 4B935261  bl 0x8221f258
	ctx.lr = 0x828E9FFC;
	sub_8221F258(ctx, base);
	// 828E9FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA000: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA004: 419A0064  beq cr6, 0x828ea068
	if ctx.cr[6].eq {
	pc = 0x828EA068; continue 'dispatch;
	}
	// 828EA008: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA00C: 4BB1FCE5  bl 0x82409cf0
	ctx.lr = 0x828EA010;
	sub_82409CF0(ctx, base);
	// 828EA010: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA014: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 828EA018: 394B43E0  addi r10, r11, 0x43e0
	ctx.r[10].s64 = ctx.r[11].s64 + 17376;
	// 828EA01C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA020: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA024: 4B90621D  bl 0x821f0240
	ctx.lr = 0x828EA028;
	sub_821F0240(ctx, base);
	// 828EA028: 389E007C  addi r4, r30, 0x7c
	ctx.r[4].s64 = ctx.r[30].s64 + 124;
	// 828EA02C: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EA030: 4B906211  bl 0x821f0240
	ctx.lr = 0x828EA034;
	sub_821F0240(ctx, base);
	// 828EA034: 813E0080  lwz r9, 0x80(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EA038: 39600090  li r11, 0x90
	ctx.r[11].s64 = 144;
	// 828EA03C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA040: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 828EA044: C01E0084  lfs f0, 0x84(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EA048: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828EA04C: C1BE0088  lfs f13, 0x88(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828EA050: D1BF0088  stfs f13, 0x88(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA090 size=108
    let mut pc: u32 = 0x828EA090;
    'dispatch: loop {
        match pc {
            0x828EA090 => {
    //   block [0x828EA090..0x828EA0FC)
	// 828EA090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA09C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA0A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA0A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA0AC: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EA0B0: 4B92AD29  bl 0x82214dd8
	ctx.lr = 0x828EA0B4;
	sub_82214DD8(ctx, base);
	// 828EA0B4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA0B8: 4B92AD21  bl 0x82214dd8
	ctx.lr = 0x828EA0BC;
	sub_82214DD8(ctx, base);
	// 828EA0BC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA0C0: 4B92AD19  bl 0x82214dd8
	ctx.lr = 0x828EA0C4;
	sub_82214DD8(ctx, base);
	// 828EA0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA0C8: 4B8C2A69  bl 0x821acb30
	ctx.lr = 0x828EA0CC;
	sub_821ACB30(ctx, base);
	// 828EA0CC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA0D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA0D8: 419A000C  beq cr6, 0x828ea0e4
	if ctx.cr[6].eq {
	pc = 0x828EA0E4; continue 'dispatch;
	}
	// 828EA0DC: 4B931C5D  bl 0x8221bd38
	ctx.lr = 0x828EA0E0;
	sub_8221BD38(ctx, base);
	// 828EA0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA0E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA0E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA0EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA0F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA0F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA100 size=152
    let mut pc: u32 = 0x828EA100;
    'dispatch: loop {
        match pc {
            0x828EA100 => {
    //   block [0x828EA100..0x828EA198)
	// 828EA100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA104: 483BF309  bl 0x82ca940c
	ctx.lr = 0x828EA108;
	sub_82CA93D0(ctx, base);
	// 828EA108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA10C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA110: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828EA114: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA118: 4B935141  bl 0x8221f258
	ctx.lr = 0x828EA11C;
	sub_8221F258(ctx, base);
	// 828EA11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA120: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA124: 419A004C  beq cr6, 0x828ea170
	if ctx.cr[6].eq {
	pc = 0x828EA170; continue 'dispatch;
	}
	// 828EA128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA12C: 4BB1FBC5  bl 0x82409cf0
	ctx.lr = 0x828EA130;
	sub_82409CF0(ctx, base);
	// 828EA130: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EA134: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 828EA138: 392A4430  addi r9, r10, 0x4430
	ctx.r[9].s64 = ctx.r[10].s64 + 17456;
	// 828EA13C: 389E0090  addi r4, r30, 0x90
	ctx.r[4].s64 = ctx.r[30].s64 + 144;
	// 828EA140: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828EA144: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA198 size=108
    let mut pc: u32 = 0x828EA198;
    'dispatch: loop {
        match pc {
            0x828EA198 => {
    //   block [0x828EA198..0x828EA204)
	// 828EA198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA1A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA1B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA1B4: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 828EA1B8: 4B92AC21  bl 0x82214dd8
	ctx.lr = 0x828EA1BC;
	sub_82214DD8(ctx, base);
	// 828EA1BC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 828EA1C0: 4B92AC19  bl 0x82214dd8
	ctx.lr = 0x828EA1C4;
	sub_82214DD8(ctx, base);
	// 828EA1C4: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA1C8: 4B92AC11  bl 0x82214dd8
	ctx.lr = 0x828EA1CC;
	sub_82214DD8(ctx, base);
	// 828EA1CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA1D0: 4B8C2961  bl 0x821acb30
	ctx.lr = 0x828EA1D4;
	sub_821ACB30(ctx, base);
	// 828EA1D4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA1E0: 419A000C  beq cr6, 0x828ea1ec
	if ctx.cr[6].eq {
	pc = 0x828EA1EC; continue 'dispatch;
	}
	// 828EA1E4: 4B931B55  bl 0x8221bd38
	ctx.lr = 0x828EA1E8;
	sub_8221BD38(ctx, base);
	// 828EA1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA1EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA1F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA1F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA1F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA1FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA208 size=140
    let mut pc: u32 = 0x828EA208;
    'dispatch: loop {
        match pc {
            0x828EA208 => {
    //   block [0x828EA208..0x828EA294)
	// 828EA208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA20C: 483BF201  bl 0x82ca940c
	ctx.lr = 0x828EA210;
	sub_82CA93D0(ctx, base);
	// 828EA210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA214: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA218: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 828EA21C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA220: 4B935039  bl 0x8221f258
	ctx.lr = 0x828EA224;
	sub_8221F258(ctx, base);
	// 828EA224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA22C: 419A0040  beq cr6, 0x828ea26c
	if ctx.cr[6].eq {
	pc = 0x828EA26C; continue 'dispatch;
	}
	// 828EA230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA234: 4BB1FABD  bl 0x82409cf0
	ctx.lr = 0x828EA238;
	sub_82409CF0(ctx, base);
	// 828EA238: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA23C: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 828EA240: 394B4480  addi r10, r11, 0x4480
	ctx.r[10].s64 = ctx.r[11].s64 + 17536;
	// 828EA244: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA248: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA24C: 4B905FF5  bl 0x821f0240
	ctx.lr = 0x828EA250;
	sub_821F0240(ctx, base);
	// 828EA250: 389E007C  addi r4, r30, 0x7c
	ctx.r[4].s64 = ctx.r[30].s64 + 124;
	// 828EA254: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EA258: 4B905FE9  bl 0x821f0240
	ctx.lr = 0x828EA25C;
	sub_821F0240(ctx, base);
	// 828EA25C: 893E0080  lbz r9, 0x80(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EA260: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA264: 993F0080  stb r9, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u8 ) };
	// 828EA268: 48000008  b 0x828ea270
	pc = 0x828EA270; continue 'dispatch;
	// 828EA26C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA270: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA274: 4B9D5CA5  bl 0x822bff18
	ctx.lr = 0x828EA278;
	sub_822BFF18(ctx, base);
	// 828EA278: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA27C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA280: 419A0008  beq cr6, 0x828ea288
	if ctx.cr[6].eq {
	pc = 0x828EA288; continue 'dispatch;
	}
	// 828EA284: 4B896F9D  bl 0x82181220
	ctx.lr = 0x828EA288;
	sub_82181220(ctx, base);
	// 828EA288: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA28C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA290: 483BF1CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA298 size=160
    let mut pc: u32 = 0x828EA298;
    'dispatch: loop {
        match pc {
            0x828EA298 => {
    //   block [0x828EA298..0x828EA338)
	// 828EA298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA29C: 483BF171  bl 0x82ca940c
	ctx.lr = 0x828EA2A0;
	sub_82CA93D0(ctx, base);
	// 828EA2A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA2A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA2A8: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 828EA2AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA2B0: 4B934FA9  bl 0x8221f258
	ctx.lr = 0x828EA2B4;
	sub_8221F258(ctx, base);
	// 828EA2B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA2B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA2BC: 419A0054  beq cr6, 0x828ea310
	if ctx.cr[6].eq {
	pc = 0x828EA310; continue 'dispatch;
	}
	// 828EA2C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA2C4: 4BB1FA2D  bl 0x82409cf0
	ctx.lr = 0x828EA2C8;
	sub_82409CF0(ctx, base);
	// 828EA2C8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA2CC: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 828EA2D0: 394B44D0  addi r10, r11, 0x44d0
	ctx.r[10].s64 = ctx.r[11].s64 + 17616;
	// 828EA2D4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA2D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA2DC: 4B905F65  bl 0x821f0240
	ctx.lr = 0x828EA2E0;
	sub_821F0240(ctx, base);
	// 828EA2E0: 389E007C  addi r4, r30, 0x7c
	ctx.r[4].s64 = ctx.r[30].s64 + 124;
	// 828EA2E4: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EA2E8: 4B905F59  bl 0x821f0240
	ctx.lr = 0x828EA2EC;
	sub_821F0240(ctx, base);
	// 828EA2EC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828EA2F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828EA2F4: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 828EA2F8: 911F0084  stw r8, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 828EA2FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA300: 90FF0080  stw r7, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828EA304: 80DE0088  lwz r6, 0x88(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 828EA308: 90DF0088  stw r6, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[6].u32 ) };
	// 828EA30C: 48000008  b 0x828ea314
	pc = 0x828EA314; continue 'dispatch;
	// 828EA310: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA318: 4B9D5C01  bl 0x822bff18
	ctx.lr = 0x828EA31C;
	sub_822BFF18(ctx, base);
	// 828EA31C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA324: 419A0008  beq cr6, 0x828ea32c
	if ctx.cr[6].eq {
	pc = 0x828EA32C; continue 'dispatch;
	}
	// 828EA328: 4B896EF9  bl 0x82181220
	ctx.lr = 0x828EA32C;
	sub_82181220(ctx, base);
	// 828EA32C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA334: 483BF128  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA338 size=116
    let mut pc: u32 = 0x828EA338;
    'dispatch: loop {
        match pc {
            0x828EA338 => {
    //   block [0x828EA338..0x828EA3AC)
	// 828EA338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA34C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA350: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA354: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 828EA358: 4B9B04F9  bl 0x8229a850
	ctx.lr = 0x828EA35C;
	sub_8229A850(ctx, base);
	// 828EA35C: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EA360: 4B92AA79  bl 0x82214dd8
	ctx.lr = 0x828EA364;
	sub_82214DD8(ctx, base);
	// 828EA364: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA368: 4B92AA71  bl 0x82214dd8
	ctx.lr = 0x828EA36C;
	sub_82214DD8(ctx, base);
	// 828EA36C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA370: 4B92AA69  bl 0x82214dd8
	ctx.lr = 0x828EA374;
	sub_82214DD8(ctx, base);
	// 828EA374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA378: 4B8C27B9  bl 0x821acb30
	ctx.lr = 0x828EA37C;
	sub_821ACB30(ctx, base);
	// 828EA37C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA388: 419A000C  beq cr6, 0x828ea394
	if ctx.cr[6].eq {
	pc = 0x828EA394; continue 'dispatch;
	}
	// 828EA38C: 4B9319AD  bl 0x8221bd38
	ctx.lr = 0x828EA390;
	sub_8221BD38(ctx, base);
	// 828EA390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA39C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA3A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA3A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA3B0 size=120
    let mut pc: u32 = 0x828EA3B0;
    'dispatch: loop {
        match pc {
            0x828EA3B0 => {
    //   block [0x828EA3B0..0x828EA428)
	// 828EA3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA3B4: 483BF059  bl 0x82ca940c
	ctx.lr = 0x828EA3B8;
	sub_82CA93D0(ctx, base);
	// 828EA3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA3BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA3C0: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 828EA3C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA3C8: 4B934E91  bl 0x8221f258
	ctx.lr = 0x828EA3CC;
	sub_8221F258(ctx, base);
	// 828EA3CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA3D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA3D4: 419A002C  beq cr6, 0x828ea400
	if ctx.cr[6].eq {
	pc = 0x828EA400; continue 'dispatch;
	}
	// 828EA3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA3DC: 4BB1F915  bl 0x82409cf0
	ctx.lr = 0x828EA3E0;
	sub_82409CF0(ctx, base);
	// 828EA3E0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA3E4: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 828EA3E8: 394B4528  addi r10, r11, 0x4528
	ctx.r[10].s64 = ctx.r[11].s64 + 17704;
	// 828EA3EC: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA3F0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA3F4: 4B905E4D  bl 0x821f0240
	ctx.lr = 0x828EA3F8;
	sub_821F0240(ctx, base);
	// 828EA3F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA3FC: 48000008  b 0x828ea404
	pc = 0x828EA404; continue 'dispatch;
	// 828EA400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA404: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA408: 4B9D5B11  bl 0x822bff18
	ctx.lr = 0x828EA40C;
	sub_822BFF18(ctx, base);
	// 828EA40C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA414: 419A0008  beq cr6, 0x828ea41c
	if ctx.cr[6].eq {
	pc = 0x828EA41C; continue 'dispatch;
	}
	// 828EA418: 4B896E09  bl 0x82181220
	ctx.lr = 0x828EA41C;
	sub_82181220(ctx, base);
	// 828EA41C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA424: 483BF038  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA428 size=100
    let mut pc: u32 = 0x828EA428;
    'dispatch: loop {
        match pc {
            0x828EA428 => {
    //   block [0x828EA428..0x828EA48C)
	// 828EA428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA43C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA440: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA444: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA448: 4B92A991  bl 0x82214dd8
	ctx.lr = 0x828EA44C;
	sub_82214DD8(ctx, base);
	// 828EA44C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA450: 4B92A989  bl 0x82214dd8
	ctx.lr = 0x828EA454;
	sub_82214DD8(ctx, base);
	// 828EA454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA458: 4B8C26D9  bl 0x821acb30
	ctx.lr = 0x828EA45C;
	sub_821ACB30(ctx, base);
	// 828EA45C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA468: 419A000C  beq cr6, 0x828ea474
	if ctx.cr[6].eq {
	pc = 0x828EA474; continue 'dispatch;
	}
	// 828EA46C: 4B9318CD  bl 0x8221bd38
	ctx.lr = 0x828EA470;
	sub_8221BD38(ctx, base);
	// 828EA470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA490 size=120
    let mut pc: u32 = 0x828EA490;
    'dispatch: loop {
        match pc {
            0x828EA490 => {
    //   block [0x828EA490..0x828EA508)
	// 828EA490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA494: 483BEF79  bl 0x82ca940c
	ctx.lr = 0x828EA498;
	sub_82CA93D0(ctx, base);
	// 828EA498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA49C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA4A0: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 828EA4A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA4A8: 4B934DB1  bl 0x8221f258
	ctx.lr = 0x828EA4AC;
	sub_8221F258(ctx, base);
	// 828EA4AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA4B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA4B4: 419A002C  beq cr6, 0x828ea4e0
	if ctx.cr[6].eq {
	pc = 0x828EA4E0; continue 'dispatch;
	}
	// 828EA4B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA4BC: 4BFFFABD  bl 0x828e9f78
	ctx.lr = 0x828EA4C0;
	sub_828E9F78(ctx, base);
	// 828EA4C0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA4C4: 389E0084  addi r4, r30, 0x84
	ctx.r[4].s64 = ctx.r[30].s64 + 132;
	// 828EA4C8: 394B4578  addi r10, r11, 0x4578
	ctx.r[10].s64 = ctx.r[11].s64 + 17784;
	// 828EA4CC: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 828EA4D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA4D4: 4B905D6D  bl 0x821f0240
	ctx.lr = 0x828EA4D8;
	sub_821F0240(ctx, base);
	// 828EA4D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA4DC: 48000008  b 0x828ea4e4
	pc = 0x828EA4E4; continue 'dispatch;
	// 828EA4E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA4E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA4E8: 4B9D5A31  bl 0x822bff18
	ctx.lr = 0x828EA4EC;
	sub_822BFF18(ctx, base);
	// 828EA4EC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA4F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA4F4: 419A0008  beq cr6, 0x828ea4fc
	if ctx.cr[6].eq {
	pc = 0x828EA4FC; continue 'dispatch;
	}
	// 828EA4F8: 4B896D29  bl 0x82181220
	ctx.lr = 0x828EA4FC;
	sub_82181220(ctx, base);
	// 828EA4FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA500: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA504: 483BEF58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA508 size=100
    let mut pc: u32 = 0x828EA508;
    'dispatch: loop {
        match pc {
            0x828EA508 => {
    //   block [0x828EA508..0x828EA56C)
	// 828EA508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA51C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA524: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 828EA528: 4B92A8B1  bl 0x82214dd8
	ctx.lr = 0x828EA52C;
	sub_82214DD8(ctx, base);
	// 828EA52C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA530: 4B92A8A9  bl 0x82214dd8
	ctx.lr = 0x828EA534;
	sub_82214DD8(ctx, base);
	// 828EA534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA538: 4B8C25F9  bl 0x821acb30
	ctx.lr = 0x828EA53C;
	sub_821ACB30(ctx, base);
	// 828EA53C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA548: 419A000C  beq cr6, 0x828ea554
	if ctx.cr[6].eq {
	pc = 0x828EA554; continue 'dispatch;
	}
	// 828EA54C: 4B9317ED  bl 0x8221bd38
	ctx.lr = 0x828EA550;
	sub_8221BD38(ctx, base);
	// 828EA550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA570 size=120
    let mut pc: u32 = 0x828EA570;
    'dispatch: loop {
        match pc {
            0x828EA570 => {
    //   block [0x828EA570..0x828EA5E8)
	// 828EA570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA574: 483BEE99  bl 0x82ca940c
	ctx.lr = 0x828EA578;
	sub_82CA93D0(ctx, base);
	// 828EA578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA57C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA580: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 828EA584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA588: 4B934CD1  bl 0x8221f258
	ctx.lr = 0x828EA58C;
	sub_8221F258(ctx, base);
	// 828EA58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA590: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA594: 419A002C  beq cr6, 0x828ea5c0
	if ctx.cr[6].eq {
	pc = 0x828EA5C0; continue 'dispatch;
	}
	// 828EA598: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA59C: 4BE1518D  bl 0x826ff728
	ctx.lr = 0x828EA5A0;
	sub_826FF728(ctx, base);
	// 828EA5A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA5A4: 389E008C  addi r4, r30, 0x8c
	ctx.r[4].s64 = ctx.r[30].s64 + 140;
	// 828EA5A8: 394B45C8  addi r10, r11, 0x45c8
	ctx.r[10].s64 = ctx.r[11].s64 + 17864;
	// 828EA5AC: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828EA5B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA5B4: 4B905C8D  bl 0x821f0240
	ctx.lr = 0x828EA5B8;
	sub_821F0240(ctx, base);
	// 828EA5B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA5BC: 48000008  b 0x828ea5c4
	pc = 0x828EA5C4; continue 'dispatch;
	// 828EA5C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA5C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA5C8: 4B9D5951  bl 0x822bff18
	ctx.lr = 0x828EA5CC;
	sub_822BFF18(ctx, base);
	// 828EA5CC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA5D4: 419A0008  beq cr6, 0x828ea5dc
	if ctx.cr[6].eq {
	pc = 0x828EA5DC; continue 'dispatch;
	}
	// 828EA5D8: 4B896C49  bl 0x82181220
	ctx.lr = 0x828EA5DC;
	sub_82181220(ctx, base);
	// 828EA5DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA5E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA5E4: 483BEE78  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA5E8 size=100
    let mut pc: u32 = 0x828EA5E8;
    'dispatch: loop {
        match pc {
            0x828EA5E8 => {
    //   block [0x828EA5E8..0x828EA64C)
	// 828EA5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA5F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA5F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA5FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA600: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA604: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828EA608: 4B92A7D1  bl 0x82214dd8
	ctx.lr = 0x828EA60C;
	sub_82214DD8(ctx, base);
	// 828EA60C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA610: 4B92A7C9  bl 0x82214dd8
	ctx.lr = 0x828EA614;
	sub_82214DD8(ctx, base);
	// 828EA614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA618: 4B8C2519  bl 0x821acb30
	ctx.lr = 0x828EA61C;
	sub_821ACB30(ctx, base);
	// 828EA61C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA628: 419A000C  beq cr6, 0x828ea634
	if ctx.cr[6].eq {
	pc = 0x828EA634; continue 'dispatch;
	}
	// 828EA62C: 4B93170D  bl 0x8221bd38
	ctx.lr = 0x828EA630;
	sub_8221BD38(ctx, base);
	// 828EA630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA63C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA650 size=120
    let mut pc: u32 = 0x828EA650;
    'dispatch: loop {
        match pc {
            0x828EA650 => {
    //   block [0x828EA650..0x828EA6C8)
	// 828EA650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA654: 483BEDB9  bl 0x82ca940c
	ctx.lr = 0x828EA658;
	sub_82CA93D0(ctx, base);
	// 828EA658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA65C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA660: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828EA664: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA668: 4B934BF1  bl 0x8221f258
	ctx.lr = 0x828EA66C;
	sub_8221F258(ctx, base);
	// 828EA66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EA674: 419A002C  beq cr6, 0x828ea6a0
	if ctx.cr[6].eq {
	pc = 0x828EA6A0; continue 'dispatch;
	}
	// 828EA678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA67C: 4BB1F675  bl 0x82409cf0
	ctx.lr = 0x828EA680;
	sub_82409CF0(ctx, base);
	// 828EA680: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA684: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 828EA688: 394B4618  addi r10, r11, 0x4618
	ctx.r[10].s64 = ctx.r[11].s64 + 17944;
	// 828EA68C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA690: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EA694: 4B8AC6DD  bl 0x82196d70
	ctx.lr = 0x828EA698;
	sub_82196D70(ctx, base);
	// 828EA698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA69C: 48000008  b 0x828ea6a4
	pc = 0x828EA6A4; continue 'dispatch;
	// 828EA6A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA6A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA6A8: 4B9D5871  bl 0x822bff18
	ctx.lr = 0x828EA6AC;
	sub_822BFF18(ctx, base);
	// 828EA6AC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA6B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA6B4: 419A0008  beq cr6, 0x828ea6bc
	if ctx.cr[6].eq {
	pc = 0x828EA6BC; continue 'dispatch;
	}
	// 828EA6B8: 4B896B69  bl 0x82181220
	ctx.lr = 0x828EA6BC;
	sub_82181220(ctx, base);
	// 828EA6BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA6C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA6C4: 483BED98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA6C8 size=120
    let mut pc: u32 = 0x828EA6C8;
    'dispatch: loop {
        match pc {
            0x828EA6C8 => {
    //   block [0x828EA6C8..0x828EA740)
	// 828EA6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA6D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA6D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA6D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA6DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EA6E4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EA6E8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828EA6EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EA6F0: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828EA6F4: 4B8A9745  bl 0x82193e38
	ctx.lr = 0x828EA6F8;
	sub_82193E38(ctx, base);
	// 828EA6F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828EA6FC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828EA700: 913F007C  stw r9, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 828EA704: 4B92A6D5  bl 0x82214dd8
	ctx.lr = 0x828EA708;
	sub_82214DD8(ctx, base);
	// 828EA708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA70C: 4B8C2425  bl 0x821acb30
	ctx.lr = 0x828EA710;
	sub_821ACB30(ctx, base);
	// 828EA710: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EA714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA718: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828EA71C: 419A000C  beq cr6, 0x828ea728
	if ctx.cr[6].eq {
	pc = 0x828EA728; continue 'dispatch;
	}
	// 828EA720: 4B931619  bl 0x8221bd38
	ctx.lr = 0x828EA724;
	sub_8221BD38(ctx, base);
	// 828EA724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA728: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA734: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA738: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA740 size=116
    let mut pc: u32 = 0x828EA740;
    'dispatch: loop {
        match pc {
            0x828EA740 => {
    //   block [0x828EA740..0x828EA7B4)
	// 828EA740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA74C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA754: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828EA758: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EA75C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828EA760: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 828EA764: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828EA768: 38EB1848  addi r7, r11, 0x1848
	ctx.r[7].s64 = ctx.r[11].s64 + 6216;
	// 828EA76C: 388943D0  addi r4, r9, 0x43d0
	ctx.r[4].s64 = ctx.r[9].s64 + 17360;
	// 828EA770: 38CA43B4  addi r6, r10, 0x43b4
	ctx.r[6].s64 = ctx.r[10].s64 + 17332;
	// 828EA774: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828EA778: 38680E0C  addi r3, r8, 0xe0c
	ctx.r[3].s64 = ctx.r[8].s64 + 3596;
	// 828EA77C: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828EA780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EA784: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828EA788: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828EA78C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828EA790: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828EA794: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828EA798: 4B905AA9  bl 0x821f0240
	ctx.lr = 0x828EA79C;
	sub_821F0240(ctx, base);
	// 828EA79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA7A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EA7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA7B8 size=348
    let mut pc: u32 = 0x828EA7B8;
    'dispatch: loop {
        match pc {
            0x828EA7B8 => {
    //   block [0x828EA7B8..0x828EA914)
	// 828EA7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EA7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA7C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA7CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EA7D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EA7D4: 4B981F2D  bl 0x8226c700
	ctx.lr = 0x828EA7D8;
	sub_8226C700(ctx, base);
	// 828EA7D8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EA7DC: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828EA7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EA7E4: 419A00DC  beq cr6, 0x828ea8c0
	if ctx.cr[6].eq {
	pc = 0x828EA8C0; continue 'dispatch;
	}
	// 828EA7E8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EA7EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA7F0: 419A001C  beq cr6, 0x828ea80c
	if ctx.cr[6].eq {
	pc = 0x828EA80C; continue 'dispatch;
	}
	// 828EA7F4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 828EA7F8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EA7FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828EA800: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828EA804: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA808: 480000B4  b 0x828ea8bc
	pc = 0x828EA8BC; continue 'dispatch;
	// 828EA80C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EA810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EA814: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EA818: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EA81C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EA820: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EA824: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA828: 40810054  ble 0x828ea87c
	if !ctx.cr[0].gt {
	pc = 0x828EA87C; continue 'dispatch;
	}
	// 828EA82C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EA830: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EA834: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EA838: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA83C: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828EA840: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EA844: 41980008  blt cr6, 0x828ea84c
	if ctx.cr[6].lt {
	pc = 0x828EA84C; continue 'dispatch;
	}
	// 828EA848: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EA84C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EA850: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EA854: 419A0014  beq cr6, 0x828ea868
	if ctx.cr[6].eq {
	pc = 0x828EA868; continue 'dispatch;
	}
	// 828EA858: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EA85C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EA860: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EA864: 4800000C  b 0x828ea870
	pc = 0x828EA870; continue 'dispatch;
	// 828EA868: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EA86C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EA870: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA874: 4199FFB8  bgt cr6, 0x828ea82c
	if ctx.cr[6].gt {
	pc = 0x828EA82C; continue 'dispatch;
	}
	// 828EA878: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EA87C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EA880: 419A0034  beq cr6, 0x828ea8b4
	if ctx.cr[6].eq {
	pc = 0x828EA8B4; continue 'dispatch;
	}
	// 828EA884: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA888: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828EA88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EA890: 41990008  bgt cr6, 0x828ea898
	if ctx.cr[6].gt {
	pc = 0x828EA898; continue 'dispatch;
	}
	// 828EA894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EA898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EA89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA8A0: 409A0014  bne cr6, 0x828ea8b4
	if !ctx.cr[6].eq {
	pc = 0x828EA8B4; continue 'dispatch;
	}
	// 828EA8A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EA8A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828EA8AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EA8B0: 48000008  b 0x828ea8b8
	pc = 0x828EA8B8; continue 'dispatch;
	// 828EA8B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EA8B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA8BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EA8C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828EA8C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EA8C8: 388B2F88  addi r4, r11, 0x2f88
	ctx.r[4].s64 = ctx.r[11].s64 + 12168;
	// 828EA8CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA8D0: 4B942601  bl 0x8222ced0
	ctx.lr = 0x828EA8D4;
	sub_8222CED0(ctx, base);
	// 828EA8D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828EA8D8: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 828EA8DC: 409A0008  bne cr6, 0x828ea8e4
	if !ctx.cr[6].eq {
	pc = 0x828EA8E4; continue 'dispatch;
	}
	// 828EA8E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EA8E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EA8E8: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 828EA8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA8F0: 4B953B39  bl 0x8223e428
	ctx.lr = 0x828EA8F4;
	sub_8223E428(ctx, base);
	// 828EA8F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA8F8: 4B92A4E1  bl 0x82214dd8
	ctx.lr = 0x828EA8FC;
	sub_82214DD8(ctx, base);
	// 828EA8FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EA900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EA90C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA918 size=660
    let mut pc: u32 = 0x828EA918;
    'dispatch: loop {
        match pc {
            0x828EA918 => {
    //   block [0x828EA918..0x828EABAC)
	// 828EA918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA91C: 483BEAE9  bl 0x82ca9404
	ctx.lr = 0x828EA920;
	sub_82CA93D0(ctx, base);
	// 828EA920: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA924: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA92C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828EA930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA934: 409A0044  bne cr6, 0x828ea978
	if !ctx.cr[6].eq {
	pc = 0x828EA978; continue 'dispatch;
	}
	// 828EA938: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EA93C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 828EA940: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 828EA944: 39692F88  addi r11, r9, 0x2f88
	ctx.r[11].s64 = ctx.r[9].s64 + 12168;
	// 828EA948: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA94C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA950: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828EA954: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828EA958: 419A0014  beq cr6, 0x828ea96c
	if ctx.cr[6].eq {
	pc = 0x828EA96C; continue 'dispatch;
	}
	// 828EA95C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828EA960: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EA964: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828EA968: 419AFFE0  beq cr6, 0x828ea948
	if ctx.cr[6].eq {
	pc = 0x828EA948; continue 'dispatch;
	}
	// 828EA96C: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828EA970: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828EA974: 4800001C  b 0x828ea990
	pc = 0x828EA990; continue 'dispatch;
	// 828EA978: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828EA97C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA980: 388A2F88  addi r4, r10, 0x2f88
	ctx.r[4].s64 = ctx.r[10].s64 + 12168;
	// 828EA984: 4B982E75  bl 0x8226d7f8
	ctx.lr = 0x828EA988;
	sub_8226D7F8(ctx, base);
	// 828EA988: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828EA98C: 552BDFFE  rlwinm r11, r9, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828EA990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EA994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA998: 419A020C  beq cr6, 0x828eaba4
	if ctx.cr[6].eq {
	pc = 0x828EABA4; continue 'dispatch;
	}
	// 828EA99C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EA9A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EA9A4: 388B42D8  addi r4, r11, 0x42d8
	ctx.r[4].s64 = ctx.r[11].s64 + 17112;
	// 828EA9A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EA9AC: 4B942525  bl 0x8222ced0
	ctx.lr = 0x828EA9B0;
	sub_8222CED0(ctx, base);
	// 828EA9B0: 3B9FFFF8  addi r28, r31, -8
	ctx.r[28].s64 = ctx.r[31].s64 + -8;
	// 828EA9B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EA9B8: 4B981D49  bl 0x8226c700
	ctx.lr = 0x828EA9BC;
	sub_8226C700(ctx, base);
	// 828EA9BC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828EA9C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EA9C4: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EA9C8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA9CC: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828EA9D0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828EA9D4: 4E800421  bctrl
	ctx.lr = 0x828EA9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA9D8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828EA9DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EA9E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828EA9E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EA9E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EA9EC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EABB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EABB0 size=304
    let mut pc: u32 = 0x828EABB0;
    'dispatch: loop {
        match pc {
            0x828EABB0 => {
    //   block [0x828EABB0..0x828EACE0)
	// 828EABB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EABB4: 483BE859  bl 0x82ca940c
	ctx.lr = 0x828EABB8;
	sub_82CA93D0(ctx, base);
	// 828EABB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EABBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EABC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EABC4: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 828EABC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EABCC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EABD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EABD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EABD8: 4B9422F9  bl 0x8222ced0
	ctx.lr = 0x828EABDC;
	sub_8222CED0(ctx, base);
	// 828EABDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EABE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EABE4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828EABE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EABEC: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828EABF0: 4B8A89E1  bl 0x821935d0
	ctx.lr = 0x828EABF4;
	sub_821935D0(ctx, base);
	// 828EABF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EABF8: 4B92A1E1  bl 0x82214dd8
	ctx.lr = 0x828EABFC;
	sub_82214DD8(ctx, base);
	// 828EABFC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EAC00: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828EAC04: 390A43E0  addi r8, r10, 0x43e0
	ctx.r[8].s64 = ctx.r[10].s64 + 17376;
	// 828EAC08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EAC0C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828EAC10: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EAC14: 38894500  addi r4, r9, 0x4500
	ctx.r[4].s64 = ctx.r[9].s64 + 17664;
	// 828EAC18: 4BA1E3A9  bl 0x82308fc0
	ctx.lr = 0x828EAC1C;
	sub_82308FC0(ctx, base);
	// 828EAC1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EAC20: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828EAC24: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EAC28: 4B9422A9  bl 0x8222ced0
	ctx.lr = 0x828EAC2C;
	sub_8222CED0(ctx, base);
	// 828EAC2C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828EAC30: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828EAC34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EAC38: 38A742EC  addi r5, r7, 0x42ec
	ctx.r[5].s64 = ctx.r[7].s64 + 17132;
	// 828EAC3C: 38864300  addi r4, r6, 0x4300
	ctx.r[4].s64 = ctx.r[6].s64 + 17152;
	// 828EAC40: 4BA1E381  bl 0x82308fc0
	ctx.lr = 0x828EAC44;
	sub_82308FC0(ctx, base);
	// 828EAC44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EAC48: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828EAC4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EAC50: 4B942281  bl 0x8222ced0
	ctx.lr = 0x828EAC54;
	sub_8222CED0(ctx, base);
	// 828EAC54: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828EAC58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EAC5C: 38854314  addi r4, r5, 0x4314
	ctx.r[4].s64 = ctx.r[5].s64 + 17172;
	// 828EAC60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EAC64: 4B9B318D  bl 0x8229ddf0
	ctx.lr = 0x828EAC68;
	sub_8229DDF0(ctx, base);
	// 828EAC68: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828EAC6C: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 828EAC70: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828EAC74: 397D9484  addi r11, r29, -0x6b7c
	ctx.r[11].s64 = ctx.r[29].s64 + -27516;
	// 828EAC78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EAC7C: 38844324  addi r4, r4, 0x4324
	ctx.r[4].s64 = ctx.r[4].s64 + 17188;
	// 828EAC80: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAC84: 4B8F47D5  bl 0x821df458
	ctx.lr = 0x828EAC88;
	sub_821DF458(ctx, base);
	// 828EAC88: D03F0084  stfs f1, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828EAC8C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EAC90: C03D9484  lfs f1, -0x6b7c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EAC98: 388A4330  addi r4, r10, 0x4330
	ctx.r[4].s64 = ctx.r[10].s64 + 17200;
	// 828EAC9C: 4B8F47BD  bl 0x821df458
	ctx.lr = 0x828EACA0;
	sub_821DF458(ctx, base);
	// 828EACA0: D03F0088  stfs f1, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828EACA4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828EACA8: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 828EACAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EACB0: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 828EACB4: 38A94340  addi r5, r9, 0x4340
	ctx.r[5].s64 = ctx.r[9].s64 + 17216;
	// 828EACB8: 4B8B8881  bl 0x821a3538
	ctx.lr = 0x828EACBC;
	sub_821A3538(ctx, base);
	// 828EACBC: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828EACC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EACC4: 38884348  addi r4, r8, 0x4348
	ctx.r[4].s64 = ctx.r[8].s64 + 17224;
	// 828EACC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EACCC: 4B8F95ED  bl 0x821e42b8
	ctx.lr = 0x828EACD0;
	sub_821E42B8(ctx, base);
	// 828EACD0: 987F00A0  stb r3, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[3].u8 ) };
	// 828EACD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EACD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EACDC: 483BE780  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EACE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EACE0 size=648
    let mut pc: u32 = 0x828EACE0;
    'dispatch: loop {
        match pc {
            0x828EACE0 => {
    //   block [0x828EACE0..0x828EAF68)
	// 828EACE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EACE4: 483BE71D  bl 0x82ca9400
	ctx.lr = 0x828EACE8;
	sub_82CA93D0(ctx, base);
	// 828EACE8: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828EACEC: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828EACF0: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EAF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EAF68 size=168
    let mut pc: u32 = 0x828EAF68;
    'dispatch: loop {
        match pc {
            0x828EAF68 => {
    //   block [0x828EAF68..0x828EB010)
	// 828EAF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EAF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EAF70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EAF74: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 828EAF78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EAF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EAF80: 419A001C  beq cr6, 0x828eaf9c
	if ctx.cr[6].eq {
	pc = 0x828EAF9C; continue 'dispatch;
	}
	// 828EAF84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAF88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EAF8C: 419A000C  beq cr6, 0x828eaf98
	if ctx.cr[6].eq {
	pc = 0x828EAF98; continue 'dispatch;
	}
	// 828EAF90: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EAF94: 4800000C  b 0x828eafa0
	pc = 0x828EAFA0; continue 'dispatch;
	// 828EAF98: 4B8A8EA1  bl 0x82193e38
	ctx.lr = 0x828EAF9C;
	sub_82193E38(ctx, base);
	// 828EAF9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EAFA0: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EAFA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAFA8: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EAFAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828EAFB0: 4E800421  bctrl
	ctx.lr = 0x828EAFB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EAFB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828EAFB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EAFBC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828EAFC0: 419A0040  beq cr6, 0x828eb000
	if ctx.cr[6].eq {
	pc = 0x828EB000; continue 'dispatch;
	}
	// 828EAFC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAFC8: 4BE31A29  bl 0x8271c9f0
	ctx.lr = 0x828EAFCC;
	sub_8271C9F0(ctx, base);
	// 828EAFCC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EAFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EAFD4: 419A002C  beq cr6, 0x828eb000
	if ctx.cr[6].eq {
	pc = 0x828EB000; continue 'dispatch;
	}
	// 828EAFD8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EAFDC: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828EAFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EAFE4: 419A001C  beq cr6, 0x828eb000
	if ctx.cr[6].eq {
	pc = 0x828EB000; continue 'dispatch;
	}
	// 828EAFE8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828EAFEC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828EAFF0: 816A6D1C  lwz r11, 0x6d1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27932 as u32) ) } as u64;
	// 828EAFF4: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 828EAFF8: 90AA6D1C  stw r5, 0x6d1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27932 as u32), ctx.r[5].u32 ) };
	// 828EAFFC: 4BC90375  bl 0x8257b370
	ctx.lr = 0x828EB000;
	sub_8257B370(ctx, base);
	// 828EB000: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EB004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EB008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EB00C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EB010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EB010 size=240
    let mut pc: u32 = 0x828EB010;
    'dispatch: loop {
        match pc {
            0x828EB010 => {
    //   block [0x828EB010..0x828EB100)
	// 828EB010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EB014: 483BE3F9  bl 0x82ca940c
	ctx.lr = 0x828EB018;
	sub_82CA93D0(ctx, base);
	// 828EB018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EB01C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EB020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EB024: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 828EB028: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EB02C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EB030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB034: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EB038: 4B941E99  bl 0x8222ced0
	ctx.lr = 0x828EB03C;
	sub_8222CED0(ctx, base);
	// 828EB03C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EB040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EB044: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828EB048: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EB04C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 828EB050: 4B8A8581  bl 0x821935d0
	ctx.lr = 0x828EB054;
	sub_821935D0(ctx, base);
	// 828EB054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB058: 4B929D81  bl 0x82214dd8
	ctx.lr = 0x828EB05C;
	sub_82214DD8(ctx, base);
	// 828EB05C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EB060: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828EB064: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 828EB068: 390A4430  addi r8, r10, 0x4430
	ctx.r[8].s64 = ctx.r[10].s64 + 17456;
	// 828EB06C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EB070: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828EB074: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 828EB078: 38A9D238  addi r5, r9, -0x2dc8
	ctx.r[5].s64 = ctx.r[9].s64 + -11720;
	// 828EB07C: 4B8B84BD  bl 0x821a3538
	ctx.lr = 0x828EB080;
	sub_821A3538(ctx, base);
	// 828EB080: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 828EB084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EB088: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EB08C: 38874500  addi r4, r7, 0x4500
	ctx.r[4].s64 = ctx.r[7].s64 + 17664;
	// 828EB090: 4BA1DF31  bl 0x82308fc0
	ctx.lr = 0x828EB094;
	sub_82308FC0(ctx, base);
	// 828EB094: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EB098: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 828EB09C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EB0A0: 4B941E31  bl 0x8222ced0
	ctx.lr = 0x828EB0A4;
	sub_8222CED0(ctx, base);
	// 828EB0A4: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 828EB0A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828EB0AC: 39667088  addi r11, r6, 0x7088
	ctx.r[11].s64 = ctx.r[6].s64 + 28808;
	// 828EB0B0: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 828EB0B4: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828EB0B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EB0BC: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828EB0C0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828EB0C4: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EB0C8: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EB0CC: 4082FFE8  bne 0x828eb0b4
	if !ctx.cr[0].eq {
	pc = 0x828EB0B4; continue 'dispatch;
	}
	// 828EB0D0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EB0D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EB0D8: 388A4358  addi r4, r10, 0x4358
	ctx.r[4].s64 = ctx.r[10].s64 + 17240;
	// 828EB0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EB0E0: 4B8F91D9  bl 0x821e42b8
	ctx.lr = 0x828EB0E4;
	sub_821E42B8(ctx, base);
	// 828EB0E4: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828EB0E8: 987F0098  stb r3, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[3].u8 ) };
	// 828EB0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EB0F0: 61280004  ori r8, r9, 4
	ctx.r[8].u64 = ctx.r[9].u64 | 4;
	// 828EB0F4: 911F0038  stw r8, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u32 ) };
	// 828EB0F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EB0FC: 483BE360  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EB100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EB100 size=2012
    let mut pc: u32 = 0x828EB100;
    'dispatch: loop {
        match pc {
            0x828EB100 => {
    //   block [0x828EB100..0x828EB8DC)
	// 828EB100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EB104: 483BE2FD  bl 0x82ca9400
	ctx.lr = 0x828EB108;
	sub_82CA93D0(ctx, base);
	// 828EB108: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828EB10C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EB8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EB8E0 size=380
    let mut pc: u32 = 0x828EB8E0;
    'dispatch: loop {
        match pc {
            0x828EB8E0 => {
    //   block [0x828EB8E0..0x828EBA5C)
	// 828EB8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EB8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EB8E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EB8EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EB8F0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 828EB8F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EB8F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EB8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EB900: 419A001C  beq cr6, 0x828eb91c
	if ctx.cr[6].eq {
	pc = 0x828EB91C; continue 'dispatch;
	}
	// 828EB904: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EB90C: 419A000C  beq cr6, 0x828eb918
	if ctx.cr[6].eq {
	pc = 0x828EB918; continue 'dispatch;
	}
	// 828EB910: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EB914: 4800000C  b 0x828eb920
	pc = 0x828EB920; continue 'dispatch;
	// 828EB918: 4B8A8521  bl 0x82193e38
	ctx.lr = 0x828EB91C;
	sub_82193E38(ctx, base);
	// 828EB91C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EB920: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EB924: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828EB928: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828EB92C: 419A00D8  beq cr6, 0x828eba04
	if ctx.cr[6].eq {
	pc = 0x828EBA04; continue 'dispatch;
	}
	// 828EB930: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EB934: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EB938: 419A001C  beq cr6, 0x828eb954
	if ctx.cr[6].eq {
	pc = 0x828EB954; continue 'dispatch;
	}
	// 828EB93C: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828EB940: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EB944: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828EB948: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828EB94C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EB950: 480000B0  b 0x828eba00
	pc = 0x828EBA00; continue 'dispatch;
	// 828EB954: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EB958: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EB95C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EB960: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EB964: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EB968: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EB96C: 40810054  ble 0x828eb9c0
	if !ctx.cr[0].gt {
	pc = 0x828EB9C0; continue 'dispatch;
	}
	// 828EB970: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EB974: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EB978: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EB97C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB980: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828EB984: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EB988: 41980008  blt cr6, 0x828eb990
	if ctx.cr[6].lt {
	pc = 0x828EB990; continue 'dispatch;
	}
	// 828EB98C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828EB990: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EB994: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EB998: 419A0014  beq cr6, 0x828eb9ac
	if ctx.cr[6].eq {
	pc = 0x828EB9AC; continue 'dispatch;
	}
	// 828EB99C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EB9A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EB9A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EB9A8: 4800000C  b 0x828eb9b4
	pc = 0x828EB9B4; continue 'dispatch;
	// 828EB9AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EB9B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EB9B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EB9B8: 4199FFB8  bgt cr6, 0x828eb970
	if ctx.cr[6].gt {
	pc = 0x828EB970; continue 'dispatch;
	}
	// 828EB9BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EB9C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EB9C4: 419A0034  beq cr6, 0x828eb9f8
	if ctx.cr[6].eq {
	pc = 0x828EB9F8; continue 'dispatch;
	}
	// 828EB9C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB9CC: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828EB9D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EB9D4: 41990008  bgt cr6, 0x828eb9dc
	if ctx.cr[6].gt {
	pc = 0x828EB9DC; continue 'dispatch;
	}
	// 828EB9D8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EB9DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EB9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EB9E4: 409A0014  bne cr6, 0x828eb9f8
	if !ctx.cr[6].eq {
	pc = 0x828EB9F8; continue 'dispatch;
	}
	// 828EB9E8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EB9EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828EB9F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EB9F4: 48000008  b 0x828eb9fc
	pc = 0x828EB9FC; continue 'dispatch;
	// 828EB9F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EB9FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EBA00: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EBA04: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828EBA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EBA0C: 4B913BBD  bl 0x821ff5c8
	ctx.lr = 0x828EBA10;
	sub_821FF5C8(ctx, base);
	// 828EBA10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EBA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EBA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EBA1C: 419A000C  beq cr6, 0x828eba28
	if ctx.cr[6].eq {
	pc = 0x828EBA28; continue 'dispatch;
	}
	// 828EBA20: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828EBA24: 48000020  b 0x828eba44
	pc = 0x828EBA44; continue 'dispatch;
	// 828EBA28: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 828EBA2C: 4B913B9D  bl 0x821ff5c8
	ctx.lr = 0x828EBA30;
	sub_821FF5C8(ctx, base);
	// 828EBA30: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EBA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EBA38: 419A0010  beq cr6, 0x828eba48
	if ctx.cr[6].eq {
	pc = 0x828EBA48; continue 'dispatch;
	}
	// 828EBA3C: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 828EBA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EBA44: 4BB3485D  bl 0x824202a0
	ctx.lr = 0x828EBA48;
	sub_824202A0(ctx, base);
	// 828EBA48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EBA4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EBA50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EBA54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EBA58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EBA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EBA60 size=1452
    let mut pc: u32 = 0x828EBA60;
    'dispatch: loop {
        match pc {
            0x828EBA60 => {
    //   block [0x828EBA60..0x828EC00C)
	// 828EBA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EBA64: 483BD9A1  bl 0x82ca9404
	ctx.lr = 0x828EBA68;
	sub_82CA93D0(ctx, base);
	// 828EBA68: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828EBA6C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EBA70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828EBA74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828EBA78: 897C0080  lbz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EBA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EBA80: 419A0044  beq cr6, 0x828ebac4
	if ctx.cr[6].eq {
	pc = 0x828EBAC4; continue 'dispatch;
	}
	// 828EBA84: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 828EBA88: 4B9337D1  bl 0x8221f258
	ctx.lr = 0x828EBA8C;
	sub_8221F258(ctx, base);
	// 828EBA8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EBA90: 419A0014  beq cr6, 0x828ebaa4
	if ctx.cr[6].eq {
	pc = 0x828EBAA4; continue 'dispatch;
	}
	// 828EBA94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828EBA98: 4B8A2379  bl 0x8218de10
	ctx.lr = 0x828EBA9C;
	sub_8218DE10(ctx, base);
	// 828EBA9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EBAA0: 48000008  b 0x828ebaa8
	pc = 0x828EBAA8; continue 'dispatch;
	// 828EBAA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EBAA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EBAAC: 4B8D0005  bl 0x821bbab0
	ctx.lr = 0x828EBAB0;
	sub_821BBAB0(ctx, base);
	// 828EBAB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EBAB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EBAB8: 4B9803B1  bl 0x8226be68
	ctx.lr = 0x828EBABC;
	sub_8226BE68(ctx, base);
	// 828EBABC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EBAC0: 4B8CC059  bl 0x821b7b18
	ctx.lr = 0x828EBAC4;
	sub_821B7B18(ctx, base);
	// 828EBAC4: 817C0078  lwz r11, 0x78(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EBAC8: 3BFC0078  addi r31, r28, 0x78
	ctx.r[31].s64 = ctx.r[28].s64 + 120;
	// 828EBACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EBAD0: 419A0304  beq cr6, 0x828ebdd4
	if ctx.cr[6].eq {
	pc = 0x828EBDD4; continue 'dispatch;
	}
	// 828EBAD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EBAD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EBADC: 419A02F8  beq cr6, 0x828ebdd4
	if ctx.cr[6].eq {
	pc = 0x828EBDD4; continue 'dispatch;
	}
	// 828EBAE0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EBAE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EBAE8: 388B4378  addi r4, r11, 0x4378
	ctx.r[4].s64 = ctx.r[11].s64 + 17272;
	// 828EBAEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EBAF0: 4B9413E1  bl 0x8222ced0
	ctx.lr = 0x828EBAF4;
	sub_8222CED0(ctx, base);
	// 828EBAF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EBAF8: 4B888971  bl 0x82174468
	ctx.lr = 0x828EBAFC;
	sub_82174468(ctx, base);
	// 828EBAFC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828EBB00: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828EBB04: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EBB08: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EBB0C: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828EBB10: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828EBB14: 4E800421  bctrl
	ctx.lr = 0x828EBB18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EBB18: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 828EBB1C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EBB20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828EBB24: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EBB28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EBB2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC010 size=324
    let mut pc: u32 = 0x828EC010;
    'dispatch: loop {
        match pc {
            0x828EC010 => {
    //   block [0x828EC010..0x828EC154)
	// 828EC010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC01C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC020: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 828EC024: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EC028: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC030: 419A001C  beq cr6, 0x828ec04c
	if ctx.cr[6].eq {
	pc = 0x828EC04C; continue 'dispatch;
	}
	// 828EC034: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC038: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC03C: 419A000C  beq cr6, 0x828ec048
	if ctx.cr[6].eq {
	pc = 0x828EC048; continue 'dispatch;
	}
	// 828EC040: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EC044: 4800000C  b 0x828ec050
	pc = 0x828EC050; continue 'dispatch;
	// 828EC048: 4B8A7DF1  bl 0x82193e38
	ctx.lr = 0x828EC04C;
	sub_82193E38(ctx, base);
	// 828EC04C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EC050: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EC054: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828EC058: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828EC05C: 419A00D8  beq cr6, 0x828ec134
	if ctx.cr[6].eq {
	pc = 0x828EC134; continue 'dispatch;
	}
	// 828EC060: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EC064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC068: 419A001C  beq cr6, 0x828ec084
	if ctx.cr[6].eq {
	pc = 0x828EC084; continue 'dispatch;
	}
	// 828EC06C: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828EC070: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC074: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828EC078: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828EC07C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC080: 480000B0  b 0x828ec130
	pc = 0x828EC130; continue 'dispatch;
	// 828EC084: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC088: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EC08C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EC090: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EC094: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EC098: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC09C: 40810054  ble 0x828ec0f0
	if !ctx.cr[0].gt {
	pc = 0x828EC0F0; continue 'dispatch;
	}
	// 828EC0A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EC0A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EC0A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EC0AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC0B0: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828EC0B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EC0B8: 41980008  blt cr6, 0x828ec0c0
	if ctx.cr[6].lt {
	pc = 0x828EC0C0; continue 'dispatch;
	}
	// 828EC0BC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828EC0C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EC0C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EC0C8: 419A0014  beq cr6, 0x828ec0dc
	if ctx.cr[6].eq {
	pc = 0x828EC0DC; continue 'dispatch;
	}
	// 828EC0CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EC0D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EC0D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EC0D8: 4800000C  b 0x828ec0e4
	pc = 0x828EC0E4; continue 'dispatch;
	// 828EC0DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EC0E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EC0E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC0E8: 4199FFB8  bgt cr6, 0x828ec0a0
	if ctx.cr[6].gt {
	pc = 0x828EC0A0; continue 'dispatch;
	}
	// 828EC0EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EC0F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EC0F4: 419A0034  beq cr6, 0x828ec128
	if ctx.cr[6].eq {
	pc = 0x828EC128; continue 'dispatch;
	}
	// 828EC0F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC0FC: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828EC100: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC104: 41990008  bgt cr6, 0x828ec10c
	if ctx.cr[6].gt {
	pc = 0x828EC10C; continue 'dispatch;
	}
	// 828EC108: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EC10C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EC110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC114: 409A0014  bne cr6, 0x828ec128
	if !ctx.cr[6].eq {
	pc = 0x828EC128; continue 'dispatch;
	}
	// 828EC118: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EC11C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828EC120: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EC124: 48000008  b 0x828ec12c
	pc = 0x828EC12C; continue 'dispatch;
	// 828EC128: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EC12C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC130: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC134: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828EC138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC13C: 4BB3386D  bl 0x8241f9a8
	ctx.lr = 0x828EC140;
	sub_8241F9A8(ctx, base);
	// 828EC140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC158 size=184
    let mut pc: u32 = 0x828EC158;
    'dispatch: loop {
        match pc {
            0x828EC158 => {
    //   block [0x828EC158..0x828EC210)
	// 828EC158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC160: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC164: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC16C: 4B8F75CD  bl 0x821e3738
	ctx.lr = 0x828EC170;
	sub_821E3738(ctx, base);
	// 828EC170: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828EC174: 4B9330E5  bl 0x8221f258
	ctx.lr = 0x828EC178;
	sub_8221F258(ctx, base);
	// 828EC178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EC17C: 419A001C  beq cr6, 0x828ec198
	if ctx.cr[6].eq {
	pc = 0x828EC198; continue 'dispatch;
	}
	// 828EC180: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EC184: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 828EC188: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EC18C: 4BD941E5  bl 0x82680370
	ctx.lr = 0x828EC190;
	sub_82680370(ctx, base);
	// 828EC190: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC194: 48000008  b 0x828ec19c
	pc = 0x828EC19C; continue 'dispatch;
	// 828EC198: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EC19C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC1A0: 4B8CF911  bl 0x821bbab0
	ctx.lr = 0x828EC1A4;
	sub_821BBAB0(ctx, base);
	// 828EC1A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC1AC: 4B97FCBD  bl 0x8226be68
	ctx.lr = 0x828EC1B0;
	sub_8226BE68(ctx, base);
	// 828EC1B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC1B4: 4B8CB965  bl 0x821b7b18
	ctx.lr = 0x828EC1B8;
	sub_821B7B18(ctx, base);
	// 828EC1B8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828EC1BC: 4B93309D  bl 0x8221f258
	ctx.lr = 0x828EC1C0;
	sub_8221F258(ctx, base);
	// 828EC1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EC1C4: 419A0018  beq cr6, 0x828ec1dc
	if ctx.cr[6].eq {
	pc = 0x828EC1DC; continue 'dispatch;
	}
	// 828EC1C8: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 828EC1CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EC1D0: 4BFFE571  bl 0x828ea740
	ctx.lr = 0x828EC1D4;
	sub_828EA740(ctx, base);
	// 828EC1D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC1D8: 48000008  b 0x828ec1e0
	pc = 0x828EC1E0; continue 'dispatch;
	// 828EC1DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EC1E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EC1E4: 4B8CF8CD  bl 0x821bbab0
	ctx.lr = 0x828EC1E8;
	sub_821BBAB0(ctx, base);
	// 828EC1E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC1F0: 4B97FC79  bl 0x8226be68
	ctx.lr = 0x828EC1F4;
	sub_8226BE68(ctx, base);
	// 828EC1F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EC1F8: 4B8CB921  bl 0x821b7b18
	ctx.lr = 0x828EC1FC;
	sub_821B7B18(ctx, base);
	// 828EC1FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC20C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC210 size=112
    let mut pc: u32 = 0x828EC210;
    'dispatch: loop {
        match pc {
            0x828EC210 => {
    //   block [0x828EC210..0x828EC280)
	// 828EC210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC21C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC224: 4B8F7515  bl 0x821e3738
	ctx.lr = 0x828EC228;
	sub_821E3738(ctx, base);
	// 828EC228: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828EC22C: 4B93302D  bl 0x8221f258
	ctx.lr = 0x828EC230;
	sub_8221F258(ctx, base);
	// 828EC230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EC234: 419A0018  beq cr6, 0x828ec24c
	if ctx.cr[6].eq {
	pc = 0x828EC24C; continue 'dispatch;
	}
	// 828EC238: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 828EC23C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EC240: 4BFFE501  bl 0x828ea740
	ctx.lr = 0x828EC244;
	sub_828EA740(ctx, base);
	// 828EC244: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC248: 48000008  b 0x828ec250
	pc = 0x828EC250; continue 'dispatch;
	// 828EC24C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EC250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC254: 4B8CF85D  bl 0x821bbab0
	ctx.lr = 0x828EC258;
	sub_821BBAB0(ctx, base);
	// 828EC258: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC260: 4B97FC09  bl 0x8226be68
	ctx.lr = 0x828EC264;
	sub_8226BE68(ctx, base);
	// 828EC264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC268: 4B8CB8B1  bl 0x821b7b18
	ctx.lr = 0x828EC26C;
	sub_821B7B18(ctx, base);
	// 828EC26C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC280 size=112
    let mut pc: u32 = 0x828EC280;
    'dispatch: loop {
        match pc {
            0x828EC280 => {
    //   block [0x828EC280..0x828EC2F0)
	// 828EC280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC28C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC294: 4B9BD315  bl 0x822a95a8
	ctx.lr = 0x828EC298;
	sub_822A95A8(ctx, base);
	// 828EC298: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828EC29C: 4B932FBD  bl 0x8221f258
	ctx.lr = 0x828EC2A0;
	sub_8221F258(ctx, base);
	// 828EC2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EC2A4: 419A0018  beq cr6, 0x828ec2bc
	if ctx.cr[6].eq {
	pc = 0x828EC2BC; continue 'dispatch;
	}
	// 828EC2A8: 38BF0084  addi r5, r31, 0x84
	ctx.r[5].s64 = ctx.r[31].s64 + 132;
	// 828EC2AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EC2B0: 4BFFE491  bl 0x828ea740
	ctx.lr = 0x828EC2B4;
	sub_828EA740(ctx, base);
	// 828EC2B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC2B8: 48000008  b 0x828ec2c0
	pc = 0x828EC2C0; continue 'dispatch;
	// 828EC2BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EC2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC2C4: 4B8CF7ED  bl 0x821bbab0
	ctx.lr = 0x828EC2C8;
	sub_821BBAB0(ctx, base);
	// 828EC2C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC2D0: 4B97FB99  bl 0x8226be68
	ctx.lr = 0x828EC2D4;
	sub_8226BE68(ctx, base);
	// 828EC2D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC2D8: 4B8CB841  bl 0x821b7b18
	ctx.lr = 0x828EC2DC;
	sub_821B7B18(ctx, base);
	// 828EC2DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC2E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC2E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC2E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC2F0 size=112
    let mut pc: u32 = 0x828EC2F0;
    'dispatch: loop {
        match pc {
            0x828EC2F0 => {
    //   block [0x828EC2F0..0x828EC360)
	// 828EC2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC2F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC2FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC304: 4BE1757D  bl 0x82703880
	ctx.lr = 0x828EC308;
	sub_82703880(ctx, base);
	// 828EC308: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828EC30C: 4B932F4D  bl 0x8221f258
	ctx.lr = 0x828EC310;
	sub_8221F258(ctx, base);
	// 828EC310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EC314: 419A0018  beq cr6, 0x828ec32c
	if ctx.cr[6].eq {
	pc = 0x828EC32C; continue 'dispatch;
	}
	// 828EC318: 38BF008C  addi r5, r31, 0x8c
	ctx.r[5].s64 = ctx.r[31].s64 + 140;
	// 828EC31C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EC320: 4BFFE421  bl 0x828ea740
	ctx.lr = 0x828EC324;
	sub_828EA740(ctx, base);
	// 828EC324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC328: 48000008  b 0x828ec330
	pc = 0x828EC330; continue 'dispatch;
	// 828EC32C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EC330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC334: 4B8CF77D  bl 0x821bbab0
	ctx.lr = 0x828EC338;
	sub_821BBAB0(ctx, base);
	// 828EC338: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC340: 4B97FB29  bl 0x8226be68
	ctx.lr = 0x828EC344;
	sub_8226BE68(ctx, base);
	// 828EC344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EC348: 4B8CB7D1  bl 0x821b7b18
	ctx.lr = 0x828EC34C;
	sub_821B7B18(ctx, base);
	// 828EC34C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC358: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC35C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC360 size=1228
    let mut pc: u32 = 0x828EC360;
    'dispatch: loop {
        match pc {
            0x828EC360 => {
    //   block [0x828EC360..0x828EC82C)
	// 828EC360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC364: 483BD09D  bl 0x82ca9400
	ctx.lr = 0x828EC368;
	sub_82CA93D0(ctx, base);
	// 828EC368: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828EC36C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC374: 4B8F73C5  bl 0x821e3738
	ctx.lr = 0x828EC378;
	sub_821E3738(ctx, base);
	// 828EC378: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EC37C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 828EC380: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828EC384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC388: 419A0020  beq cr6, 0x828ec3a8
	if ctx.cr[6].eq {
	pc = 0x828EC3A8; continue 'dispatch;
	}
	// 828EC38C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC394: 419A000C  beq cr6, 0x828ec3a0
	if ctx.cr[6].eq {
	pc = 0x828EC3A0; continue 'dispatch;
	}
	// 828EC398: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828EC39C: 48000010  b 0x828ec3ac
	pc = 0x828EC3AC; continue 'dispatch;
	// 828EC3A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EC3A4: 4B8A7A95  bl 0x82193e38
	ctx.lr = 0x828EC3A8;
	sub_82193E38(ctx, base);
	// 828EC3A8: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828EC3AC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EC3B0: 3B7F0078  addi r27, r31, 0x78
	ctx.r[27].s64 = ctx.r[31].s64 + 120;
	// 828EC3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC3B8: 419A0020  beq cr6, 0x828ec3d8
	if ctx.cr[6].eq {
	pc = 0x828EC3D8; continue 'dispatch;
	}
	// 828EC3BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC3C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC3C4: 419A000C  beq cr6, 0x828ec3d0
	if ctx.cr[6].eq {
	pc = 0x828EC3D0; continue 'dispatch;
	}
	// 828EC3C8: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828EC3CC: 48000010  b 0x828ec3dc
	pc = 0x828EC3DC; continue 'dispatch;
	// 828EC3D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EC3D4: 4B8A7A65  bl 0x82193e38
	ctx.lr = 0x828EC3D8;
	sub_82193E38(ctx, base);
	// 828EC3D8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828EC3DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC3E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC3E4: 419A0020  beq cr6, 0x828ec404
	if ctx.cr[6].eq {
	pc = 0x828EC404; continue 'dispatch;
	}
	// 828EC3E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC3EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC3F0: 419A000C  beq cr6, 0x828ec3fc
	if ctx.cr[6].eq {
	pc = 0x828EC3FC; continue 'dispatch;
	}
	// 828EC3F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EC3F8: 48000010  b 0x828ec408
	pc = 0x828EC408; continue 'dispatch;
	// 828EC3FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EC400: 4B8A7A39  bl 0x82193e38
	ctx.lr = 0x828EC404;
	sub_82193E38(ctx, base);
	// 828EC404: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828EC408: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EC40C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EC410: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC414: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828EC418: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828EC41C: 4E800421  bctrl
	ctx.lr = 0x828EC420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EC420: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828EC424: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828EC428: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 828EC42C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828EC430: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828EC434: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828EC438: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828EC43C: 38800057  li r4, 0x57
	ctx.r[4].s64 = 87;
	// 828EC440: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EC444: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EC448: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC44C: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EC450: 4B98D731  bl 0x82279b80
	ctx.lr = 0x828EC454;
	sub_82279B80(ctx, base);
	// 828EC454: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC458: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828EC45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC460: 419A0020  beq cr6, 0x828ec480
	if ctx.cr[6].eq {
	pc = 0x828EC480; continue 'dispatch;
	}
	// 828EC464: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC46C: 419A000C  beq cr6, 0x828ec478
	if ctx.cr[6].eq {
	pc = 0x828EC478; continue 'dispatch;
	}
	// 828EC470: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EC474: 48000010  b 0x828ec484
	pc = 0x828EC484; continue 'dispatch;
	// 828EC478: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EC47C: 4B8A79BD  bl 0x82193e38
	ctx.lr = 0x828EC480;
	sub_82193E38(ctx, base);
	// 828EC480: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828EC484: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828EC488: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828EC48C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828EC490: 419A00F4  beq cr6, 0x828ec584
	if ctx.cr[6].eq {
	pc = 0x828EC584; continue 'dispatch;
	}
	// 828EC494: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EC498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC49C: 419A0024  beq cr6, 0x828ec4c0
	if ctx.cr[6].eq {
	pc = 0x828EC4C0; continue 'dispatch;
	}
	// 828EC4A0: 894A0023  lbz r10, 0x23(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(35 as u32) ) } as u64;
	// 828EC4A4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC4A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828EC4AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828EC4B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC4B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC4BC: 480000CC  b 0x828ec588
	pc = 0x828EC588; continue 'dispatch;
	// 828EC4C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC4C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EC4C8: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 828EC4CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EC4D0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828EC4D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC4D8: 40810054  ble 0x828ec52c
	if !ctx.cr[0].gt {
	pc = 0x828EC52C; continue 'dispatch;
	}
	// 828EC4DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EC4E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EC4E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EC4E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC4EC: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 828EC4F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EC4F4: 41980008  blt cr6, 0x828ec4fc
	if ctx.cr[6].lt {
	pc = 0x828EC4FC; continue 'dispatch;
	}
	// 828EC4F8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828EC4FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EC500: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EC504: 419A0014  beq cr6, 0x828ec518
	if ctx.cr[6].eq {
	pc = 0x828EC518; continue 'dispatch;
	}
	// 828EC508: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EC50C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EC510: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EC514: 4800000C  b 0x828ec520
	pc = 0x828EC520; continue 'dispatch;
	// 828EC518: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EC51C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EC520: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC524: 4199FFB8  bgt cr6, 0x828ec4dc
	if ctx.cr[6].gt {
	pc = 0x828EC4DC; continue 'dispatch;
	}
	// 828EC528: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828EC52C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EC530: 419A0040  beq cr6, 0x828ec570
	if ctx.cr[6].eq {
	pc = 0x828EC570; continue 'dispatch;
	}
	// 828EC534: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC538: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 828EC53C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC540: 41990008  bgt cr6, 0x828ec548
	if ctx.cr[6].gt {
	pc = 0x828EC548; continue 'dispatch;
	}
	// 828EC544: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828EC548: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EC54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC550: 409A0020  bne cr6, 0x828ec570
	if !ctx.cr[6].eq {
	pc = 0x828EC570; continue 'dispatch;
	}
	// 828EC554: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828EC558: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828EC55C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EC560: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC564: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC568: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC56C: 4800001C  b 0x828ec588
	pc = 0x828EC588; continue 'dispatch;
	// 828EC570: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EC574: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC578: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC57C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC580: 48000008  b 0x828ec588
	pc = 0x828EC588; continue 'dispatch;
	// 828EC584: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828EC588: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EC58C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC590: 419A0018  beq cr6, 0x828ec5a8
	if ctx.cr[6].eq {
	pc = 0x828EC5A8; continue 'dispatch;
	}
	// 828EC594: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EC598: 4B8878A1  bl 0x82173e38
	ctx.lr = 0x828EC59C;
	sub_82173E38(ctx, base);
	// 828EC59C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC5A4: 4BE867AD  bl 0x82772d50
	ctx.lr = 0x828EC5A8;
	sub_82772D50(ctx, base);
	// 828EC5A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EC5AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EC5B0: 388B4368  addi r4, r11, 0x4368
	ctx.r[4].s64 = ctx.r[11].s64 + 17256;
	// 828EC5B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EC5B8: 4B940919  bl 0x8222ced0
	ctx.lr = 0x828EC5BC;
	sub_8222CED0(ctx, base);
	// 828EC5BC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828EC5C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EC5C4: 388A439C  addi r4, r10, 0x439c
	ctx.r[4].s64 = ctx.r[10].s64 + 17308;
	// 828EC5C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EC5CC: 4B940905  bl 0x8222ced0
	ctx.lr = 0x828EC5D0;
	sub_8222CED0(ctx, base);
	// 828EC5D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC5D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC5D8: 419A0020  beq cr6, 0x828ec5f8
	if ctx.cr[6].eq {
	pc = 0x828EC5F8; continue 'dispatch;
	}
	// 828EC5DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC5E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC5E4: 419A000C  beq cr6, 0x828ec5f0
	if ctx.cr[6].eq {
	pc = 0x828EC5F0; continue 'dispatch;
	}
	// 828EC5E8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EC5EC: 48000010  b 0x828ec5fc
	pc = 0x828EC5FC; continue 'dispatch;
	// 828EC5F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EC5F4: 4B8A7845  bl 0x82193e38
	ctx.lr = 0x828EC5F8;
	sub_82193E38(ctx, base);
	// 828EC5F8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828EC5FC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828EC600: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828EC604: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC608: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828EC60C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828EC610: 4E800421  bctrl
	ctx.lr = 0x828EC614;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EC614: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 828EC618: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EC61C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828EC620: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EC624: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828EC628: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC830 size=388
    let mut pc: u32 = 0x828EC830;
    'dispatch: loop {
        match pc {
            0x828EC830 => {
    //   block [0x828EC830..0x828EC9B4)
	// 828EC830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EC83C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EC848: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EC84C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 828EC850: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EC854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC858: 419A001C  beq cr6, 0x828ec874
	if ctx.cr[6].eq {
	pc = 0x828EC874; continue 'dispatch;
	}
	// 828EC85C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC864: 419A000C  beq cr6, 0x828ec870
	if ctx.cr[6].eq {
	pc = 0x828EC870; continue 'dispatch;
	}
	// 828EC868: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EC86C: 4800000C  b 0x828ec878
	pc = 0x828EC878; continue 'dispatch;
	// 828EC870: 4B8A75C9  bl 0x82193e38
	ctx.lr = 0x828EC874;
	sub_82193E38(ctx, base);
	// 828EC874: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EC878: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EC87C: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828EC880: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828EC884: 419A00F4  beq cr6, 0x828ec978
	if ctx.cr[6].eq {
	pc = 0x828EC978; continue 'dispatch;
	}
	// 828EC888: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EC88C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EC890: 419A0024  beq cr6, 0x828ec8b4
	if ctx.cr[6].eq {
	pc = 0x828EC8B4; continue 'dispatch;
	}
	// 828EC894: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EC898: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC89C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828EC8A0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828EC8A4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC8A8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC8AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC8B0: 480000CC  b 0x828ec97c
	pc = 0x828EC97C; continue 'dispatch;
	// 828EC8B4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EC8B8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EC8BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EC8C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EC8C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EC8C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC8CC: 40810054  ble 0x828ec920
	if !ctx.cr[0].gt {
	pc = 0x828EC920; continue 'dispatch;
	}
	// 828EC8D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EC8D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EC8D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EC8DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC8E0: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828EC8E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EC8E8: 41980008  blt cr6, 0x828ec8f0
	if ctx.cr[6].lt {
	pc = 0x828EC8F0; continue 'dispatch;
	}
	// 828EC8EC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828EC8F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EC8F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EC8F8: 419A0014  beq cr6, 0x828ec90c
	if ctx.cr[6].eq {
	pc = 0x828EC90C; continue 'dispatch;
	}
	// 828EC8FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EC900: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EC904: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EC908: 4800000C  b 0x828ec914
	pc = 0x828EC914; continue 'dispatch;
	// 828EC90C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EC910: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EC914: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EC918: 4199FFB8  bgt cr6, 0x828ec8d0
	if ctx.cr[6].gt {
	pc = 0x828EC8D0; continue 'dispatch;
	}
	// 828EC91C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EC920: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EC924: 419A0040  beq cr6, 0x828ec964
	if ctx.cr[6].eq {
	pc = 0x828EC964; continue 'dispatch;
	}
	// 828EC928: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EC92C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828EC930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC934: 41990008  bgt cr6, 0x828ec93c
	if ctx.cr[6].gt {
	pc = 0x828EC93C; continue 'dispatch;
	}
	// 828EC938: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EC93C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EC940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC944: 409A0020  bne cr6, 0x828ec964
	if !ctx.cr[6].eq {
	pc = 0x828EC964; continue 'dispatch;
	}
	// 828EC948: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EC94C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828EC950: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EC954: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC958: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC95C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC960: 4800001C  b 0x828ec97c
	pc = 0x828EC97C; continue 'dispatch;
	// 828EC964: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EC968: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EC96C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EC970: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EC974: 48000008  b 0x828ec97c
	pc = 0x828EC97C; continue 'dispatch;
	// 828EC978: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EC97C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EC980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EC984: 419A0018  beq cr6, 0x828ec99c
	if ctx.cr[6].eq {
	pc = 0x828EC99C; continue 'dispatch;
	}
	// 828EC988: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 828EC98C: 4B8874AD  bl 0x82173e38
	ctx.lr = 0x828EC990;
	sub_82173E38(ctx, base);
	// 828EC990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EC994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC998: 4BAB8501  bl 0x823a4e98
	ctx.lr = 0x828EC99C;
	sub_823A4E98(ctx, base);
	// 828EC99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EC9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC9A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EC9AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC9B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC9B8 size=60
    let mut pc: u32 = 0x828EC9B8;
    'dispatch: loop {
        match pc {
            0x828EC9B8 => {
    //   block [0x828EC9B8..0x828EC9F4)
	// 828EC9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EC9C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EC9C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EC9C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828EC9CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EC9D0: 388B9960  addi r4, r11, -0x66a0
	ctx.r[4].s64 = ctx.r[11].s64 + -26272;
	// 828EC9D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EC9D8: 4B9404F9  bl 0x8222ced0
	ctx.lr = 0x828EC9DC;
	sub_8222CED0(ctx, base);
	// 828EC9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EC9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EC9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EC9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EC9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EC9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EC9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EC9F8 size=140
    let mut pc: u32 = 0x828EC9F8;
    'dispatch: loop {
        match pc {
            0x828EC9F8 => {
    //   block [0x828EC9F8..0x828ECA84)
	// 828EC9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EC9FC: 483BCA0D  bl 0x82ca9408
	ctx.lr = 0x828ECA00;
	sub_82CA93D0(ctx, base);
	// 828ECA00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ECA04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ECA08: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828ECA0C: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 828ECA10: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828ECA14: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828ECA18: 419A0018  beq cr6, 0x828eca30
	if ctx.cr[6].eq {
	pc = 0x828ECA30; continue 'dispatch;
	}
	// 828ECA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ECA20: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ECA24: 481A54DD  bl 0x82a91f00
	ctx.lr = 0x828ECA28;
	sub_82A91F00(ctx, base);
	// 828ECA28: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ECA2C: 4B92F30D  bl 0x8221bd38
	ctx.lr = 0x828ECA30;
	sub_8221BD38(ctx, base);
	// 828ECA30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ECA34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828ECA38: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828ECA3C: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828ECA40: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828ECA44: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828ECA48: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828ECA4C: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 828ECA50: 4B8A73E9  bl 0x82193e38
	ctx.lr = 0x828ECA54;
	sub_82193E38(ctx, base);
	// 828ECA54: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828ECA58: 578807FE  clrlwi r8, r28, 0x1f
	ctx.r[8].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 828ECA5C: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 828ECA60: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828ECA64: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828ECA68: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828ECA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ECA70: 419A000C  beq cr6, 0x828eca7c
	if ctx.cr[6].eq {
	pc = 0x828ECA7C; continue 'dispatch;
	}
	// 828ECA74: 4B92F2C5  bl 0x8221bd38
	ctx.lr = 0x828ECA78;
	sub_8221BD38(ctx, base);
	// 828ECA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ECA7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828ECA80: 483BC9D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECA88 size=836
    let mut pc: u32 = 0x828ECA88;
    'dispatch: loop {
        match pc {
            0x828ECA88 => {
    //   block [0x828ECA88..0x828ECDCC)
	// 828ECA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ECA8C: 483BC981  bl 0x82ca940c
	ctx.lr = 0x828ECA90;
	sub_82CA93D0(ctx, base);
	// 828ECA90: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828ECA94: 483C1241  bl 0x82cadcd4
	ctx.lr = 0x828ECA98;
	sub_82CADCA0(ctx, base);
	// 828ECA98: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ECDD0 size=100
    let mut pc: u32 = 0x828ECDD0;
    'dispatch: loop {
        match pc {
            0x828ECDD0 => {
    //   block [0x828ECDD0..0x828ECE34)
	// 828ECDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ECDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ECDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ECDDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ECDE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ECDE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ECDE8: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828ECDEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828ECDF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ECDF4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828ECDF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ECDFC: 4B927A9D  bl 0x82214898
	ctx.lr = 0x828ECE00;
	sub_82214898(ctx, base);
	// 828ECE00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ECE04: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828ECE08: 4BBE50C1  bl 0x824d1ec8
	ctx.lr = 0x828ECE0C;
	sub_824D1EC8(ctx, base);
	// 828ECE0C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828ECE10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ECE14: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828ECE18: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828ECE1C: 4B8A701D  bl 0x82193e38
	ctx.lr = 0x828ECE20;
	sub_82193E38(ctx, base);
	// 828ECE20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ECE24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ECE28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ECE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ECE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ECE38 size=200
    let mut pc: u32 = 0x828ECE38;
    'dispatch: loop {
        match pc {
            0x828ECE38 => {
    //   block [0x828ECE38..0x828ECF00)
	// 828ECE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ECE3C: 483BC5C9  bl 0x82ca9404
	ctx.lr = 0x828ECE40;
	sub_82CA93D0(ctx, base);
	// 828ECE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ECE44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ECE48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828ECE4C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828ECE50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828ECE54: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828ECE58: 83DD0030  lwz r30, 0x30(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828ECE5C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ECE60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828ECE64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828ECE68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828ECE6C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ECE70: 419A0044  beq cr6, 0x828eceb4
	if ctx.cr[6].eq {
	pc = 0x828ECEB4; continue 'dispatch;
	}
	// 828ECE74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ECE78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ECE7C: 419A0020  beq cr6, 0x828ece9c
	if ctx.cr[6].eq {
	pc = 0x828ECE9C; continue 'dispatch;
	}
	// 828ECE80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ECE84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ECE88: 419A000C  beq cr6, 0x828ece94
	if ctx.cr[6].eq {
	pc = 0x828ECE94; continue 'dispatch;
	}
	// 828ECE8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828ECE90: 48000010  b 0x828ecea0
	pc = 0x828ECEA0; continue 'dispatch;
	// 828ECE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ECE98: 4B8A6FA1  bl 0x82193e38
	ctx.lr = 0x828ECE9C;
	sub_82193E38(ctx, base);
	// 828ECE9C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828ECEA0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828ECEA4: 419A0010  beq cr6, 0x828eceb4
	if ctx.cr[6].eq {
	pc = 0x828ECEB4; continue 'dispatch;
	}
	// 828ECEA8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828ECEAC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ECEB0: 409AFFC4  bne cr6, 0x828ece74
	if !ctx.cr[6].eq {
	pc = 0x828ECE74; continue 'dispatch;
	}
	// 828ECEB4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ECEB8: 409A0040  bne cr6, 0x828ecef8
	if !ctx.cr[6].eq {
	pc = 0x828ECEF8; continue 'dispatch;
	}
	// 828ECEBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ECEC0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828ECEC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ECEC8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828ECECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ECED0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828ECED4: 4B9279C5  bl 0x82214898
	ctx.lr = 0x828ECED8;
	sub_82214898(ctx, base);
	// 828ECED8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ECEDC: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 828ECEE0: 480007B9  bl 0x828ed698
	ctx.lr = 0x828ECEE4;
	sub_828ED698(ctx, base);
	// 828ECEE4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828ECEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ECEEC: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828ECEF0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828ECEF4: 4B8A6F45  bl 0x82193e38
	ctx.lr = 0x828ECEF8;
	sub_82193E38(ctx, base);
	// 828ECEF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828ECEFC: 483BC558  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECF00 size=52
    let mut pc: u32 = 0x828ECF00;
    'dispatch: loop {
        match pc {
            0x828ECF00 => {
    //   block [0x828ECF00..0x828ECF34)
	// 828ECF00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828ECF04: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828ECF08: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 828ECF0C: 419A0018  beq cr6, 0x828ecf24
	if ctx.cr[6].eq {
	pc = 0x828ECF24; continue 'dispatch;
	}
	// 828ECF10: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ECF14: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828ECF18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ECF1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ECF20: 409A0008  bne cr6, 0x828ecf28
	if !ctx.cr[6].eq {
	pc = 0x828ECF28; continue 'dispatch;
	}
	// 828ECF24: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828ECF28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ECF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ECF30: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECF34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECF34 size=16
    let mut pc: u32 = 0x828ECF34;
    'dispatch: loop {
        match pc {
            0x828ECF34 => {
    //   block [0x828ECF34..0x828ECF44)
	// 828ECF34: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828ECF38: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828ECF3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ECF40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECF44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECF44 size=40
    let mut pc: u32 = 0x828ECF44;
    'dispatch: loop {
        match pc {
            0x828ECF44 => {
    //   block [0x828ECF44..0x828ECF6C)
	// 828ECF44: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828ECF48: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828ECF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ECF50: 419A001C  beq cr6, 0x828ecf6c
	if ctx.cr[6].eq {
		sub_828ECF6C(ctx, base);
		return;
	}
	// 828ECF54: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828ECF58: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828ECF5C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828ECF60: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ECF64: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ECF68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECF6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECF6C size=84
    let mut pc: u32 = 0x828ECF6C;
    'dispatch: loop {
        match pc {
            0x828ECF6C => {
    //   block [0x828ECF6C..0x828ECFC0)
	// 828ECF6C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828ECF70: 90A1FFF0  stw r5, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u32 ) };
	// 828ECF74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828ECF78: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828ECF7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ECF80: 40810054  ble 0x828ecfd4
	if !ctx.cr[0].gt {
		sub_828ECFC0(ctx, base);
		return;
	}
	// 828ECF84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828ECF88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828ECF8C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828ECF90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ECF94: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828ECF98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ECF9C: 41980008  blt cr6, 0x828ecfa4
	if ctx.cr[6].lt {
	pc = 0x828ECFA4; continue 'dispatch;
	}
	// 828ECFA0: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828ECFA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828ECFA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828ECFAC: 419A0014  beq cr6, 0x828ecfc0
	if ctx.cr[6].eq {
		sub_828ECFC0(ctx, base);
		return;
	}
	// 828ECFB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828ECFB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828ECFB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828ECFBC: 4800000C  b 0x828ecfc8
	sub_828ECFC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ECFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ECFC0 size=84
    let mut pc: u32 = 0x828ECFC0;
    'dispatch: loop {
        match pc {
            0x828ECFC0 => {
    //   block [0x828ECFC0..0x828ED014)
	// 828ECFC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828ECFC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828ECFC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ECFCC: 4199FFB8  bgt cr6, 0x828ecf84
	if ctx.cr[6].gt {
		sub_828ECF6C(ctx, base);
		return;
	}
	// 828ECFD0: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828ECFD4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828ECFD8: 419A003C  beq cr6, 0x828ed014
	if ctx.cr[6].eq {
		sub_828ED014(ctx, base);
		return;
	}
	// 828ECFDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ECFE0: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 828ECFE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ECFE8: 41990008  bgt cr6, 0x828ecff0
	if ctx.cr[6].gt {
	pc = 0x828ECFF0; continue 'dispatch;
	}
	// 828ECFEC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828ECFF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ECFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ECFF8: 409A001C  bne cr6, 0x828ed014
	if !ctx.cr[6].eq {
		sub_828ED014(ctx, base);
		return;
	}
	// 828ECFFC: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED000: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828ED004: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828ED008: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED00C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED014(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ED014 size=16
    let mut pc: u32 = 0x828ED014;
    'dispatch: loop {
        match pc {
            0x828ED014 => {
    //   block [0x828ED014..0x828ED024)
	// 828ED014: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828ED018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED01C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828ED028 size=1648
    let mut pc: u32 = 0x828ED028;
    'dispatch: loop {
        match pc {
            0x828ED028 => {
    //   block [0x828ED028..0x828ED698)
	// 828ED028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED02C: 483BC3C5  bl 0x82ca93f0
	ctx.lr = 0x828ED030;
	sub_82CA93D0(ctx, base);
	// 828ED030: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED034: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ED038: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 828ED03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED040: 409A0504  bne cr6, 0x828ed544
	if !ctx.cr[6].eq {
	pc = 0x828ED544; continue 'dispatch;
	}
	// 828ED044: 3B3D0020  addi r25, r29, 0x20
	ctx.r[25].s64 = ctx.r[29].s64 + 32;
	// 828ED048: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828ED04C: 4B886DED  bl 0x82173e38
	ctx.lr = 0x828ED050;
	sub_82173E38(ctx, base);
	// 828ED050: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828ED054: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED058: 419A0018  beq cr6, 0x828ed070
	if ctx.cr[6].eq {
	pc = 0x828ED070; continue 'dispatch;
	}
	// 828ED05C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828ED060: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828ED064: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ED068: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828ED06C: 409A0008  bne cr6, 0x828ed074
	if !ctx.cr[6].eq {
	pc = 0x828ED074; continue 'dispatch;
	}
	// 828ED070: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828ED074: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828ED078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED07C: 409A0010  bne cr6, 0x828ed08c
	if !ctx.cr[6].eq {
	pc = 0x828ED08C; continue 'dispatch;
	}
	// 828ED080: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828ED084: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED088: 4B927811  bl 0x82214898
	ctx.lr = 0x828ED08C;
	sub_82214898(ctx, base);
	// 828ED08C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED090: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828ED094: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828ED098: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828ED09C: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 828ED0A0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828ED0A4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED0A8: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828ED0AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828ED0B0: 4E800421  bctrl
	ctx.lr = 0x828ED0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ED0B4: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 828ED0B8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 828ED0BC: C19D000C  lfs f12, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828ED0C0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828ED0C4: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED0C8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 828ED0CC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED698 size=160
    let mut pc: u32 = 0x828ED698;
    'dispatch: loop {
        match pc {
            0x828ED698 => {
    //   block [0x828ED698..0x828ED738)
	// 828ED698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828ED6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED6A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED6AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828ED6B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED6B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED6B8: 409A000C  bne cr6, 0x828ed6c4
	if !ctx.cr[6].eq {
	pc = 0x828ED6C4; continue 'dispatch;
	}
	// 828ED6BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ED6C0: 48000010  b 0x828ed6d0
	pc = 0x828ED6D0; continue 'dispatch;
	// 828ED6C4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828ED6C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828ED6CC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828ED6D0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED6D4: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828ED6D8: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828ED6DC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828ED6E0: 40980020  bge cr6, 0x828ed700
	if !ctx.cr[6].lt {
	pc = 0x828ED700; continue 'dispatch;
	}
	// 828ED6E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED6E8: 419A000C  beq cr6, 0x828ed6f4
	if ctx.cr[6].eq {
	pc = 0x828ED6F4; continue 'dispatch;
	}
	// 828ED6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED6F0: 4B8A9681  bl 0x82196d70
	ctx.lr = 0x828ED6F4;
	sub_82196D70(ctx, base);
	// 828ED6F4: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 828ED6F8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828ED6FC: 48000024  b 0x828ed720
	pc = 0x828ED720; continue 'dispatch;
	// 828ED700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ED704: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828ED708: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828ED70C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828ED710: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828ED714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED718: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828ED71C: 4800001D  bl 0x828ed738
	ctx.lr = 0x828ED720;
	sub_828ED738(ctx, base);
	// 828ED720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ED724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED72C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828ED730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED738 size=652
    let mut pc: u32 = 0x828ED738;
    'dispatch: loop {
        match pc {
            0x828ED738 => {
    //   block [0x828ED738..0x828ED9C4)
	// 828ED738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED73C: 483BBCC1  bl 0x82ca93fc
	ctx.lr = 0x828ED740;
	sub_82CA93D0(ctx, base);
	// 828ED740: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED744: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828ED748: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 828ED74C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828ED750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ED754: 4B8A961D  bl 0x82196d70
	ctx.lr = 0x828ED758;
	sub_82196D70(ctx, base);
	// 828ED758: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED760: 409A000C  bne cr6, 0x828ed76c
	if !ctx.cr[6].eq {
	pc = 0x828ED76C; continue 'dispatch;
	}
	// 828ED764: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828ED768: 48000010  b 0x828ed778
	pc = 0x828ED778; continue 'dispatch;
	// 828ED76C: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 828ED770: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828ED774: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828ED778: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED77C: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 828ED780: 7D0BF050  subf r8, r11, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 828ED784: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828ED788: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828ED78C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828ED790: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828ED794: 4098000C  bge cr6, 0x828ed7a0
	if !ctx.cr[6].lt {
	pc = 0x828ED7A0; continue 'dispatch;
	}
	// 828ED798: 48159D31  bl 0x82a474c8
	ctx.lr = 0x828ED79C;
	sub_82A474C8(ctx, base);
	// 828ED79C: 4800020C  b 0x828ed9a8
	pc = 0x828ED9A8; continue 'dispatch;
	// 828ED7A0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 828ED7A4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828ED7A8: 40980110  bge cr6, 0x828ed8b8
	if !ctx.cr[6].lt {
	pc = 0x828ED8B8; continue 'dispatch;
	}
	// 828ED7AC: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828ED7B0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828ED7B4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828ED7B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828ED7BC: 41980008  blt cr6, 0x828ed7c4
	if ctx.cr[6].lt {
	pc = 0x828ED7C4; continue 'dispatch;
	}
	// 828ED7C0: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828ED7C4: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828ED7C8: 40980008  bge cr6, 0x828ed7d0
	if !ctx.cr[6].lt {
	pc = 0x828ED7D0; continue 'dispatch;
	}
	// 828ED7CC: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 828ED7D0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828ED7D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828ED7D8: 481C3181  bl 0x82ab0958
	ctx.lr = 0x828ED7DC;
	sub_82AB0958(ctx, base);
	// 828ED7DC: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED7E0: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828ED7E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828ED7E8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828ED7EC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828ED7F0: 419A0028  beq cr6, 0x828ed818
	if ctx.cr[6].eq {
	pc = 0x828ED818; continue 'dispatch;
	}
	// 828ED7F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED7F8: 419A0010  beq cr6, 0x828ed808
	if ctx.cr[6].eq {
	pc = 0x828ED808; continue 'dispatch;
	}
	// 828ED7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ED800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED804: 4B8A956D  bl 0x82196d70
	ctx.lr = 0x828ED808;
	sub_82196D70(ctx, base);
	// 828ED808: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828ED80C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828ED810: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828ED814: 409AFFE0  bne cr6, 0x828ed7f4
	if !ctx.cr[6].eq {
	pc = 0x828ED7F4; continue 'dispatch;
	}
	// 828ED818: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED81C: 419A0010  beq cr6, 0x828ed82c
	if ctx.cr[6].eq {
	pc = 0x828ED82C; continue 'dispatch;
	}
	// 828ED820: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ED824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED828: 4B8A9549  bl 0x82196d70
	ctx.lr = 0x828ED82C;
	sub_82196D70(ctx, base);
	// 828ED82C: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED830: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 828ED834: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828ED838: 419A0034  beq cr6, 0x828ed86c
	if ctx.cr[6].eq {
	pc = 0x828ED86C; continue 'dispatch;
	}
	// 828ED83C: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 828ED840: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828ED844: 3BEBFFF8  addi r31, r11, -8
	ctx.r[31].s64 = ctx.r[11].s64 + -8;
	// 828ED848: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828ED84C: 419A0010  beq cr6, 0x828ed85c
	if ctx.cr[6].eq {
	pc = 0x828ED85C; continue 'dispatch;
	}
	// 828ED850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED858: 4B8A9519  bl 0x82196d70
	ctx.lr = 0x828ED85C;
	sub_82196D70(ctx, base);
	// 828ED85C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828ED860: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828ED864: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828ED868: 409AFFE0  bne cr6, 0x828ed848
	if !ctx.cr[6].eq {
	pc = 0x828ED848; continue 'dispatch;
	}
	// 828ED86C: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED870: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED874: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828ED878: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828ED87C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828ED880: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 828ED884: 419A0014  beq cr6, 0x828ed898
	if ctx.cr[6].eq {
	pc = 0x828ED898; continue 'dispatch;
	}
	// 828ED888: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828ED88C: 481A4675  bl 0x82a91f00
	ctx.lr = 0x828ED890;
	sub_82A91F00(ctx, base);
	// 828ED890: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED894: 4B92E4A5  bl 0x8221bd38
	ctx.lr = 0x828ED898;
	sub_8221BD38(ctx, base);
	// 828ED898: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828ED89C: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828ED8A0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828ED8A4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828ED8A8: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828ED8AC: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828ED8B0: 915A0008  stw r10, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828ED8B4: 480000F4  b 0x828ed9a8
	pc = 0x828ED9A8; continue 'dispatch;
	// 828ED8B8: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828ED8BC: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828ED8C0: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828ED8C4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828ED8C8: 40980084  bge cr6, 0x828ed94c
	if !ctx.cr[6].lt {
	pc = 0x828ED94C; continue 'dispatch;
	}
	// 828ED8CC: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	// 828ED8D0: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ED8D4: 419A002C  beq cr6, 0x828ed900
	if ctx.cr[6].eq {
	pc = 0x828ED900; continue 'dispatch;
	}
	// 828ED8D8: 3BBFFFF8  addi r29, r31, -8
	ctx.r[29].s64 = ctx.r[31].s64 + -8;
	// 828ED8DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED8E0: 419A0010  beq cr6, 0x828ed8f0
	if ctx.cr[6].eq {
	pc = 0x828ED8F0; continue 'dispatch;
	}
	// 828ED8E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828ED8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED8EC: 4B8A9485  bl 0x82196d70
	ctx.lr = 0x828ED8F0;
	sub_82196D70(ctx, base);
	// 828ED8F0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828ED8F4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828ED8F8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ED8FC: 409AFFE0  bne cr6, 0x828ed8dc
	if !ctx.cr[6].eq {
	pc = 0x828ED8DC; continue 'dispatch;
	}
	// 828ED900: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED904: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828ED908: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828ED90C: 23EA0001  subfic r31, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[31].s64 = (1 as i64) - ctx.r[10].s64;
	// 828ED910: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED914: 419A0024  beq cr6, 0x828ed938
	if ctx.cr[6].eq {
	pc = 0x828ED938; continue 'dispatch;
	}
	// 828ED918: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828ED91C: 419A0010  beq cr6, 0x828ed92c
	if ctx.cr[6].eq {
	pc = 0x828ED92C; continue 'dispatch;
	}
	// 828ED920: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ED924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED928: 4B8A9449  bl 0x82196d70
	ctx.lr = 0x828ED92C;
	sub_82196D70(ctx, base);
	// 828ED92C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828ED930: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828ED934: 4082FFE4  bne 0x828ed918
	if !ctx.cr[0].eq {
	pc = 0x828ED918; continue 'dispatch;
	}
	// 828ED938: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828ED93C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828ED940: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828ED944: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828ED948: 48000054  b 0x828ed99c
	pc = 0x828ED99C; continue 'dispatch;
	// 828ED94C: 3B9EFFF8  addi r28, r30, -8
	ctx.r[28].s64 = ctx.r[30].s64 + -8;
	// 828ED950: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828ED954: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828ED958: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ED95C: 419A0028  beq cr6, 0x828ed984
	if ctx.cr[6].eq {
	pc = 0x828ED984; continue 'dispatch;
	}
	// 828ED960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED964: 419A0010  beq cr6, 0x828ed974
	if ctx.cr[6].eq {
	pc = 0x828ED974; continue 'dispatch;
	}
	// 828ED968: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828ED96C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED970: 4B8A9401  bl 0x82196d70
	ctx.lr = 0x828ED974;
	sub_82196D70(ctx, base);
	// 828ED974: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828ED978: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828ED97C: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828ED980: 409AFFE0  bne cr6, 0x828ed960
	if !ctx.cr[6].eq {
	pc = 0x828ED960; continue 'dispatch;
	}
	// 828ED984: 93FA0008  stw r31, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828ED988: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828ED98C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828ED990: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ED994: 4BD72CE5  bl 0x82660678
	ctx.lr = 0x828ED998;
	sub_82660678(ctx, base);
	// 828ED998: 389B0008  addi r4, r27, 8
	ctx.r[4].s64 = ctx.r[27].s64 + 8;
	// 828ED99C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828ED9A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ED9A4: 4BA7F0BD  bl 0x8236ca60
	ctx.lr = 0x828ED9A8;
	sub_8236CA60(ctx, base);
	// 828ED9A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ED9AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ED9B0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828ED9B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828ED9B8: 4B8A6481  bl 0x82193e38
	ctx.lr = 0x828ED9BC;
	sub_82193E38(ctx, base);
	// 828ED9BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828ED9C0: 483BBA8C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828ED9C8 size=400
    let mut pc: u32 = 0x828ED9C8;
    'dispatch: loop {
        match pc {
            0x828ED9C8 => {
    //   block [0x828ED9C8..0x828EDB58)
	// 828ED9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED9CC: 483BBA05  bl 0x82ca93d0
	ctx.lr = 0x828ED9D0;
	sub_82CA93D0(ctx, base);
	// 828ED9D0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED9D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED9D8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 828ED9DC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828ED9E0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828ED9E4: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 828ED9E8: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828ED9EC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED9F0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828ED9F4: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828ED9F8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828ED9FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EDA00: 81366C10  lwz r9, 0x6c10(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828EDA04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDA08: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EDA0C: 3BC90001  addi r30, r9, 1
	ctx.r[30].s64 = ctx.r[9].s64 + 1;
	// 828EDA10: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828EDA14: 93D66C10  stw r30, 0x6c10(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(27664 as u32), ctx.r[30].u32 ) };
	// 828EDA18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828EDA1C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDA20: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828EDA24: 82E90064  lwz r23, 0x64(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EDA28: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828EDA2C: 4B977FFD  bl 0x82265a28
	ctx.lr = 0x828EDA30;
	sub_82265A28(ctx, base);
	// 828EDA30: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828EDA34: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828EDA38: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828EDA3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828EDA40: 40990110  ble cr6, 0x828edb50
	if !ctx.cr[6].gt {
	pc = 0x828EDB50; continue 'dispatch;
	}
	// 828EDA44: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828EDA48: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 828EDA4C: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EDA50: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828EDA54: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EDA58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828EDA5C: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828EDA60: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	// 828EDA64: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828EDA68: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EDA6C: 7D18582E  lwzx r8, r24, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828EDA70: 7D5D4630  sraw r29, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828EDA74: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828EDA78: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828EDA7C: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	// 828EDA80: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828EDA84: 7E7DD851  subf. r19, r29, r27
	ctx.r[19].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828EDA88: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828EDA8C: 418200A8  beq 0x828edb34
	if ctx.cr[0].eq {
	pc = 0x828EDB34; continue 'dispatch;
	}
	// 828EDA90: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EDA94: 418200A0  beq 0x828edb34
	if ctx.cr[0].eq {
	pc = 0x828EDB34; continue 'dispatch;
	}
	// 828EDA98: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 828EDA9C: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828EDAA0: 40980094  bge cr6, 0x828edb34
	if !ctx.cr[6].lt {
	pc = 0x828EDB34; continue 'dispatch;
	}
	// 828EDAA4: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EDAA8: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 828EDAAC: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EDAB0: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828EDAB4: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 828EDAB8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDABC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDAC0: 7D69C9D6  mullw r11, r9, r25
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[25].s32 as i64);
	// 828EDAC4: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828EDAC8: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EDACC: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828EDAD0: 40980050  bge cr6, 0x828edb20
	if !ctx.cr[6].lt {
	pc = 0x828EDB20; continue 'dispatch;
	}
	// 828EDAD4: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	// 828EDAD8: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDADC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EDAE0: 419A0034  beq cr6, 0x828edb14
	if ctx.cr[6].eq {
	pc = 0x828EDB14; continue 'dispatch;
	}
	// 828EDAE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDAE8: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EDAEC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EDAF0: 40980018  bge cr6, 0x828edb08
	if !ctx.cr[6].lt {
	pc = 0x828EDB08; continue 'dispatch;
	}
	// 828EDAF4: 93CB004C  stw r30, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 828EDAF8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828EDAFC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDB00: 48000059  bl 0x828edb58
	ctx.lr = 0x828EDB04;
	sub_828EDB58(ctx, base);
	// 828EDB04: 83D66C10  lwz r30, 0x6c10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828EDB08: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDB0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EDB10: 409AFFD4  bne cr6, 0x828edae4
	if !ctx.cr[6].eq {
	pc = 0x828EDAE4; continue 'dispatch;
	}
	// 828EDB14: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828EDB18: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 828EDB1C: 4082FFBC  bne 0x828edad8
	if !ctx.cr[0].eq {
	pc = 0x828EDAD8; continue 'dispatch;
	}
	// 828EDB20: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828EDB24: 7F199000  cmpw cr6, r25, r18
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828EDB28: 4198FF7C  blt cr6, 0x828edaa4
	if ctx.cr[6].lt {
	pc = 0x828EDAA4; continue 'dispatch;
	}
	// 828EDB2C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828EDB30: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828EDB34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EDB38: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828EDB3C: 3B180010  addi r24, r24, 0x10
	ctx.r[24].s64 = ctx.r[24].s64 + 16;
	// 828EDB40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828EDB44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EDB48: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828EDB4C: 4198FF18  blt cr6, 0x828eda64
	if ctx.cr[6].lt {
	pc = 0x828EDA64; continue 'dispatch;
	}
	// 828EDB50: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828EDB54: 483BB8CC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDB58 size=304
    let mut pc: u32 = 0x828EDB58;
    'dispatch: loop {
        match pc {
            0x828EDB58 => {
    //   block [0x828EDB58..0x828EDC88)
	// 828EDB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDB5C: 483BB8A9  bl 0x82ca9404
	ctx.lr = 0x828EDB60;
	sub_82CA93D0(ctx, base);
	// 828EDB60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDB64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDB68: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828EDB6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EDB70: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDB74: 4B915A6D  bl 0x822035e0
	ctx.lr = 0x828EDB78;
	sub_822035E0(ctx, base);
	// 828EDB78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EDB7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDB80: 419A0100  beq cr6, 0x828edc80
	if ctx.cr[6].eq {
	pc = 0x828EDC80; continue 'dispatch;
	}
	// 828EDB84: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDB88: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828EDB8C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDB90: 4BC22191  bl 0x8250fd20
	ctx.lr = 0x828EDB94;
	sub_8250FD20(ctx, base);
	// 828EDB94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EDB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDB9C: 419A00C4  beq cr6, 0x828edc60
	if ctx.cr[6].eq {
	pc = 0x828EDC60; continue 'dispatch;
	}
	// 828EDBA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDBA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828EDBA8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828EDBAC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDBB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDBB4: 83C90008  lwz r30, 8(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EDBB8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EDBBC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828EDBC0: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EDBC4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828EDBC8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EDBCC: 419A0044  beq cr6, 0x828edc10
	if ctx.cr[6].eq {
	pc = 0x828EDC10; continue 'dispatch;
	}
	// 828EDBD0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDBD8: 419A0020  beq cr6, 0x828edbf8
	if ctx.cr[6].eq {
	pc = 0x828EDBF8; continue 'dispatch;
	}
	// 828EDBDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDBE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EDBE4: 419A000C  beq cr6, 0x828edbf0
	if ctx.cr[6].eq {
	pc = 0x828EDBF0; continue 'dispatch;
	}
	// 828EDBE8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828EDBEC: 48000010  b 0x828edbfc
	pc = 0x828EDBFC; continue 'dispatch;
	// 828EDBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDBF4: 4B8A6245  bl 0x82193e38
	ctx.lr = 0x828EDBF8;
	sub_82193E38(ctx, base);
	// 828EDBF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EDBFC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828EDC00: 419A0010  beq cr6, 0x828edc10
	if ctx.cr[6].eq {
	pc = 0x828EDC10; continue 'dispatch;
	}
	// 828EDC04: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828EDC08: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EDC0C: 409AFFC4  bne cr6, 0x828edbd0
	if !ctx.cr[6].eq {
	pc = 0x828EDBD0; continue 'dispatch;
	}
	// 828EDC10: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EDC14: 409A004C  bne cr6, 0x828edc60
	if !ctx.cr[6].eq {
	pc = 0x828EDC60; continue 'dispatch;
	}
	// 828EDC18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828EDC1C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EDC20: 4B9124C9  bl 0x822000e8
	ctx.lr = 0x828EDC24;
	sub_822000E8(ctx, base);
	// 828EDC24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EDC28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDC2C: 419A0034  beq cr6, 0x828edc60
	if ctx.cr[6].eq {
	pc = 0x828EDC60; continue 'dispatch;
	}
	// 828EDC30: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EDC34: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDC38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDC3C: 419A0010  beq cr6, 0x828edc4c
	if ctx.cr[6].eq {
	pc = 0x828EDC4C; continue 'dispatch;
	}
	// 828EDC40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828EDC44: 4B8B5A3D  bl 0x821a3680
	ctx.lr = 0x828EDC48;
	sub_821A3680(ctx, base);
	// 828EDC48: 48000008  b 0x828edc50
	pc = 0x828EDC50; continue 'dispatch;
	// 828EDC4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828EDC50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EDC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDC58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EDC5C: 409A0008  bne cr6, 0x828edc64
	if !ctx.cr[6].eq {
	pc = 0x828EDC64; continue 'dispatch;
	}
	// 828EDC60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EDC64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EDC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDC6C: 419A0014  beq cr6, 0x828edc80
	if ctx.cr[6].eq {
	pc = 0x828EDC80; continue 'dispatch;
	}
	// 828EDC70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828EDC74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EDC78: 807B0008  lwz r3, 8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EDC7C: 4B8EE085  bl 0x821dbd00
	ctx.lr = 0x828EDC80;
	sub_821DBD00(ctx, base);
	// 828EDC80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828EDC84: 483BB7D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EDC88 size=8
    let mut pc: u32 = 0x828EDC88;
    'dispatch: loop {
        match pc {
            0x828EDC88 => {
    //   block [0x828EDC88..0x828EDC90)
	// 828EDC88: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 828EDC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDC90 size=80
    let mut pc: u32 = 0x828EDC90;
    'dispatch: loop {
        match pc {
            0x828EDC90 => {
    //   block [0x828EDC90..0x828EDCE0)
	// 828EDC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EDC98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EDC9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EDCA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDCA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDCA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EDCAC: 48000035  bl 0x828edce0
	ctx.lr = 0x828EDCB0;
	sub_828EDCE0(ctx, base);
	// 828EDCB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDCB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDCB8: 4BAC4659  bl 0x823b2310
	ctx.lr = 0x828EDCBC;
	sub_823B2310(ctx, base);
	// 828EDCBC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EDCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDCC4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828EDCC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EDCCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EDCD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EDCD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EDCD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EDCDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDCE0 size=464
    let mut pc: u32 = 0x828EDCE0;
    'dispatch: loop {
        match pc {
            0x828EDCE0 => {
    //   block [0x828EDCE0..0x828EDEB0)
	// 828EDCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDCE4: 483BB729  bl 0x82ca940c
	ctx.lr = 0x828EDCE8;
	sub_82CA93D0(ctx, base);
	// 828EDCE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDCEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EDCF0: 4B953C49  bl 0x82241938
	ctx.lr = 0x828EDCF4;
	sub_82241938(ctx, base);
	// 828EDCF4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828EDCF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828EDCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDD00: 419A013C  beq cr6, 0x828ede3c
	if ctx.cr[6].eq {
	pc = 0x828EDE3C; continue 'dispatch;
	}
	// 828EDD04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EDD08: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828EDD0C: 4B939855  bl 0x82227560
	ctx.lr = 0x828EDD10;
	sub_82227560(ctx, base);
	// 828EDD10: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828EDD14: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 828EDD18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EDD1C: 419A00D8  beq cr6, 0x828eddf4
	if ctx.cr[6].eq {
	pc = 0x828EDDF4; continue 'dispatch;
	}
	// 828EDD20: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EDD24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDD28: 419A001C  beq cr6, 0x828edd44
	if ctx.cr[6].eq {
	pc = 0x828EDD44; continue 'dispatch;
	}
	// 828EDD2C: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828EDD30: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EDD34: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828EDD38: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828EDD3C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDD40: 480000B0  b 0x828eddf0
	pc = 0x828EDDF0; continue 'dispatch;
	// 828EDD44: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828EDD48: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828EDD4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828EDD50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828EDD54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EDD58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EDD5C: 40810054  ble 0x828eddb0
	if !ctx.cr[0].gt {
	pc = 0x828EDDB0; continue 'dispatch;
	}
	// 828EDD60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828EDD64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828EDD68: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828EDD6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDD70: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 828EDD74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EDD78: 41980008  blt cr6, 0x828edd80
	if ctx.cr[6].lt {
	pc = 0x828EDD80; continue 'dispatch;
	}
	// 828EDD7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828EDD80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828EDD84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EDD88: 419A0014  beq cr6, 0x828edd9c
	if ctx.cr[6].eq {
	pc = 0x828EDD9C; continue 'dispatch;
	}
	// 828EDD8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828EDD90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828EDD94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828EDD98: 4800000C  b 0x828edda4
	pc = 0x828EDDA4; continue 'dispatch;
	// 828EDD9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828EDDA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828EDDA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EDDA8: 4199FFB8  bgt cr6, 0x828edd60
	if ctx.cr[6].gt {
	pc = 0x828EDD60; continue 'dispatch;
	}
	// 828EDDAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EDDB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828EDDB4: 419A0034  beq cr6, 0x828edde8
	if ctx.cr[6].eq {
	pc = 0x828EDDE8; continue 'dispatch;
	}
	// 828EDDB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDDBC: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 828EDDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EDDC4: 41990008  bgt cr6, 0x828eddcc
	if ctx.cr[6].gt {
	pc = 0x828EDDCC; continue 'dispatch;
	}
	// 828EDDC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828EDDCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EDDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDDD4: 409A0014  bne cr6, 0x828edde8
	if !ctx.cr[6].eq {
	pc = 0x828EDDE8; continue 'dispatch;
	}
	// 828EDDD8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828EDDDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828EDDE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EDDE4: 48000008  b 0x828eddec
	pc = 0x828EDDEC; continue 'dispatch;
	// 828EDDE8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828EDDEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EDDF0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828EDDF4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EDDF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EDDFC: 419A0018  beq cr6, 0x828ede14
	if ctx.cr[6].eq {
	pc = 0x828EDE14; continue 'dispatch;
	}
	// 828EDE00: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EDE04: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EDE08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828EDE0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EDE10: 419A0008  beq cr6, 0x828ede18
	if ctx.cr[6].eq {
	pc = 0x828EDE18; continue 'dispatch;
	}
	// 828EDE14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828EDE18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EDE1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDE20: 419A001C  beq cr6, 0x828ede3c
	if ctx.cr[6].eq {
	pc = 0x828EDE3C; continue 'dispatch;
	}
	// 828EDE24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EDE28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDE2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDE30: 4BE40FD9  bl 0x8272ee08
	ctx.lr = 0x828EDE34;
	sub_8272EE08(ctx, base);
	// 828EDE34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDE38: 4BAC2FB1  bl 0x823b0de8
	ctx.lr = 0x828EDE3C;
	sub_823B0DE8(ctx, base);
	// 828EDE3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EDE40: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828EDE44: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828EDE48: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828EDE4C: 38EB0B7C  addi r7, r11, 0xb7c
	ctx.r[7].s64 = ctx.r[11].s64 + 2940;
	// 828EDE50: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828EDE54: 38C87088  addi r6, r8, 0x7088
	ctx.r[6].s64 = ctx.r[8].s64 + 28808;
	// 828EDE58: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828EDE5C: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 828EDE60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EDE64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE68: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EDE6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EDE70: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EDE74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE78: 4082FFE8  bne 0x828ede60
	if !ctx.cr[0].eq {
	pc = 0x828EDE60; continue 'dispatch;
	}
	// 828EDE7C: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 828EDE80: 9BC10074  stb r30, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u8 ) };
	// 828EDE84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EDE88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EDE8C: 81656B38  lwz r11, 0x6b38(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(27448 as u32) ) } as u64;
	// 828EDE90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828EDE94: 91656B38  stw r11, 0x6b38(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(27448 as u32), ctx.r[11].u32 ) };
	// 828EDE98: 4BAC4479  bl 0x823b2310
	ctx.lr = 0x828EDE9C;
	sub_823B2310(ctx, base);
	// 828EDE9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDEA0: 4BAC2F49  bl 0x823b0de8
	ctx.lr = 0x828EDEA4;
	sub_823B0DE8(ctx, base);
	// 828EDEA4: 93DD0018  stw r30, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828EDEA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828EDEAC: 483BB5B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDEB0 size=156
    let mut pc: u32 = 0x828EDEB0;
    'dispatch: loop {
        match pc {
            0x828EDEB0 => {
    //   block [0x828EDEB0..0x828EDF4C)
	// 828EDEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDEB4: 483BB559  bl 0x82ca940c
	ctx.lr = 0x828EDEB8;
	sub_82CA93D0(ctx, base);
	// 828EDEB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDEBC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EDEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDEC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EDEC8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EDECC: 388B46F0  addi r4, r11, 0x46f0
	ctx.r[4].s64 = ctx.r[11].s64 + 18160;
	// 828EDED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDED4: 4B93EFFD  bl 0x8222ced0
	ctx.lr = 0x828EDED8;
	sub_8222CED0(ctx, base);
	// 828EDED8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDEDC: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828EDEE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EDEE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EDEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDEEC: 419A0008  beq cr6, 0x828edef4
	if ctx.cr[6].eq {
	pc = 0x828EDEF4; continue 'dispatch;
	}
	// 828EDEF0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDEF4: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828EDEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDEFC: 4BAA218D  bl 0x82390088
	ctx.lr = 0x828EDF00;
	sub_82390088(ctx, base);
	// 828EDF00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDF04: 4B926ED5  bl 0x82214dd8
	ctx.lr = 0x828EDF08;
	sub_82214DD8(ctx, base);
	// 828EDF08: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EDF0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EDF10: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828EDF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDF18: 4B93EFB9  bl 0x8222ced0
	ctx.lr = 0x828EDF1C;
	sub_8222CED0(ctx, base);
	// 828EDF1C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EDF20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EDF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EDF28: 419A0008  beq cr6, 0x828edf30
	if ctx.cr[6].eq {
	pc = 0x828EDF30; continue 'dispatch;
	}
	// 828EDF2C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDF30: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828EDF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDF38: 4BAA2151  bl 0x82390088
	ctx.lr = 0x828EDF3C;
	sub_82390088(ctx, base);
	// 828EDF3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDF40: 4B926E99  bl 0x82214dd8
	ctx.lr = 0x828EDF44;
	sub_82214DD8(ctx, base);
	// 828EDF44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EDF48: 483BB514  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EDF50 size=16
    let mut pc: u32 = 0x828EDF50;
    'dispatch: loop {
        match pc {
            0x828EDF50 => {
    //   block [0x828EDF50..0x828EDF60)
	// 828EDF50: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDF60 size=100
    let mut pc: u32 = 0x828EDF60;
    'dispatch: loop {
        match pc {
            0x828EDF60 => {
    //   block [0x828EDF60..0x828EDFC4)
	// 828EDF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EDF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EDF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EDF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDF78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EDF7C: 4BFFFF35  bl 0x828edeb0
	ctx.lr = 0x828EDF80;
	sub_828EDEB0(ctx, base);
	// 828EDF80: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EDF84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EDF88: 388B4710  addi r4, r11, 0x4710
	ctx.r[4].s64 = ctx.r[11].s64 + 18192;
	// 828EDF8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDF90: 4B93EF41  bl 0x8222ced0
	ctx.lr = 0x828EDF94;
	sub_8222CED0(ctx, base);
	// 828EDF94: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828EDF98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDFA0: 4812F109  bl 0x82a1d0a8
	ctx.lr = 0x828EDFA4;
	sub_82A1D0A8(ctx, base);
	// 828EDFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EDFA8: 4B926E31  bl 0x82214dd8
	ctx.lr = 0x828EDFAC;
	sub_82214DD8(ctx, base);
	// 828EDFAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EDFB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EDFB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EDFB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EDFBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EDFC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDFC8 size=92
    let mut pc: u32 = 0x828EDFC8;
    'dispatch: loop {
        match pc {
            0x828EDFC8 => {
    //   block [0x828EDFC8..0x828EE024)
	// 828EDFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EDFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EDFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EDFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDFE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EDFE4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828EDFE8: 4BAC2E01  bl 0x823b0de8
	ctx.lr = 0x828EDFEC;
	sub_823B0DE8(ctx, base);
	// 828EDFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDFF0: 4B9AC861  bl 0x8229a850
	ctx.lr = 0x828EDFF4;
	sub_8229A850(ctx, base);
	// 828EDFF4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EDFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDFFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE000: 419A000C  beq cr6, 0x828ee00c
	if ctx.cr[6].eq {
	pc = 0x828EE00C; continue 'dispatch;
	}
	// 828EE004: 4B92DD35  bl 0x8221bd38
	ctx.lr = 0x828EE008;
	sub_8221BD38(ctx, base);
	// 828EE008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE00C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE01C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE028 size=100
    let mut pc: u32 = 0x828EE028;
    'dispatch: loop {
        match pc {
            0x828EE028 => {
    //   block [0x828EE028..0x828EE08C)
	// 828EE028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE03C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE040: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE044: 4BFFFE6D  bl 0x828edeb0
	ctx.lr = 0x828EE048;
	sub_828EDEB0(ctx, base);
	// 828EE048: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828EE04C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EE050: 388B4724  addi r4, r11, 0x4724
	ctx.r[4].s64 = ctx.r[11].s64 + 18212;
	// 828EE054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE058: 4B93EE79  bl 0x8222ced0
	ctx.lr = 0x828EE05C;
	sub_8222CED0(ctx, base);
	// 828EE05C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EE060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EE064: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828EE068: 4BAC2DE1  bl 0x823b0e48
	ctx.lr = 0x828EE06C;
	sub_823B0E48(ctx, base);
	// 828EE06C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE070: 4B926D69  bl 0x82214dd8
	ctx.lr = 0x828EE074;
	sub_82214DD8(ctx, base);
	// 828EE074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE07C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE090 size=60
    let mut pc: u32 = 0x828EE090;
    'dispatch: loop {
        match pc {
            0x828EE090 => {
    //   block [0x828EE090..0x828EE0CC)
	// 828EE090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE09C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE0A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828EE0A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828EE0A8: 388B9780  addi r4, r11, -0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + -26752;
	// 828EE0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE0B0: 4B93EE21  bl 0x8222ced0
	ctx.lr = 0x828EE0B4;
	sub_8222CED0(ctx, base);
	// 828EE0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE0B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EE0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE0C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE0C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE0D0 size=1648
    let mut pc: u32 = 0x828EE0D0;
    'dispatch: loop {
        match pc {
            0x828EE0D0 => {
    //   block [0x828EE0D0..0x828EE740)
	// 828EE0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE0D4: 483BB311  bl 0x82ca93e4
	ctx.lr = 0x828EE0D8;
	sub_82CA93D0(ctx, base);
	// 828EE0D8: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 828EE0DC: 487188D9  bl 0x830069b4
	ctx.lr = 0x828EE0E0;
	sub_83006760(ctx, base);
	// 828EE0E0: 9421FCF0  stwu r1, -0x310(r1)
	ea = ctx.r[1].u32.wrapping_add(-784 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE0E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE740 size=204
    let mut pc: u32 = 0x828EE740;
    'dispatch: loop {
        match pc {
            0x828EE740 => {
    //   block [0x828EE740..0x828EE80C)
	// 828EE740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE744: 483BACB9  bl 0x82ca93fc
	ctx.lr = 0x828EE748;
	sub_82CA93D0(ctx, base);
	// 828EE748: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE74C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828EE750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE754: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828EE758: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828EE75C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 828EE760: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE764: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE768: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE770: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828EE774: 419A0020  beq cr6, 0x828ee794
	if ctx.cr[6].eq {
	pc = 0x828EE794; continue 'dispatch;
	}
	// 828EE778: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE77C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE780: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE784: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE788: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE78C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE790: 4082FFE8  bne 0x828ee778
	if !ctx.cr[0].eq {
	pc = 0x828EE778; continue 'dispatch;
	}
	// 828EE794: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828EE798: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828EE79C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828EE7A0: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 828EE7A4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828EE7A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EE7AC: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 828EE7B0: 483BACD1  bl 0x82ca9480
	ctx.lr = 0x828EE7B4;
	sub_82CA9480(ctx, base);
	// 828EE7B4: 937F0050  stw r27, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828EE7B8: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828EE7BC: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 828EE7C0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828EE7C4: 4B930A95  bl 0x8221f258
	ctx.lr = 0x828EE7C8;
	sub_8221F258(ctx, base);
	// 828EE7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE7CC: 419A0020  beq cr6, 0x828ee7ec
	if ctx.cr[6].eq {
	pc = 0x828EE7EC; continue 'dispatch;
	}
	// 828EE7D0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828EE7D4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE7D8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828EE7DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EE7E0: 4BFC6AF1  bl 0x828b52d0
	ctx.lr = 0x828EE7E4;
	sub_828B52D0(ctx, base);
	// 828EE7E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EE7E8: 48000008  b 0x828ee7f0
	pc = 0x828EE7F0; continue 'dispatch;
	// 828EE7EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EE7F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EE7F4: 4B984865  bl 0x82273058
	ctx.lr = 0x828EE7F8;
	sub_82273058(ctx, base);
	// 828EE7F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828EE7FC: 4B8C931D  bl 0x821b7b18
	ctx.lr = 0x828EE800;
	sub_821B7B18(ctx, base);
	// 828EE800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE804: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828EE808: 483BAC44  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE810 size=88
    let mut pc: u32 = 0x828EE810;
    'dispatch: loop {
        match pc {
            0x828EE810 => {
    //   block [0x828EE810..0x828EE868)
	// 828EE810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE81C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE828: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828EE82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE830: 480000B1  bl 0x828ee8e0
	ctx.lr = 0x828EE834;
	sub_828EE8E0(ctx, base);
	// 828EE834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EE838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE83C: 997F0070  stb r11, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 828EE840: 997F0071  stb r11, 0x71(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 828EE844: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828EE848: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828EE84C: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828EE850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE85C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE868 size=120
    let mut pc: u32 = 0x828EE868;
    'dispatch: loop {
        match pc {
            0x828EE868 => {
    //   block [0x828EE868..0x828EE8E0)
	// 828EE868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE878: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EE87C: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 828EE880: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828EE884: 419A0048  beq cr6, 0x828ee8cc
	if ctx.cr[6].eq {
	pc = 0x828EE8CC; continue 'dispatch;
	}
	// 828EE888: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EE88C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EE890: 419A002C  beq cr6, 0x828ee8bc
	if ctx.cr[6].eq {
	pc = 0x828EE8BC; continue 'dispatch;
	}
	// 828EE894: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828EE898: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828EE89C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EE8A0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EE8A4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE8A8: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EE8AC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE8B0: 80C70028  lwz r6, 0x28(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) } as u64;
	// 828EE8B4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828EE8B8: 4E800421  bctrl
	ctx.lr = 0x828EE8BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EE8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE8C0: 4B8C9259  bl 0x821b7b18
	ctx.lr = 0x828EE8C4;
	sub_821B7B18(ctx, base);
	// 828EE8C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EE8C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE8CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EE8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE8D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE8E0 size=236
    let mut pc: u32 = 0x828EE8E0;
    'dispatch: loop {
        match pc {
            0x828EE8E0 => {
    //   block [0x828EE8E0..0x828EE9CC)
	// 828EE8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE8F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE8F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE8FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE900: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE904: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE90C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828EE910: 419A0020  beq cr6, 0x828ee930
	if ctx.cr[6].eq {
	pc = 0x828EE930; continue 'dispatch;
	}
	// 828EE914: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE918: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE91C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE920: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE924: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE928: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE92C: 4082FFE8  bne 0x828ee914
	if !ctx.cr[0].eq {
	pc = 0x828EE914; continue 'dispatch;
	}
	// 828EE930: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EE934: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828EE938: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EE93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE940: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828EE944: 419A0020  beq cr6, 0x828ee964
	if ctx.cr[6].eq {
	pc = 0x828EE964; continue 'dispatch;
	}
	// 828EE948: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE94C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE950: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE958: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE95C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE960: 4082FFE8  bne 0x828ee948
	if !ctx.cr[0].eq {
	pc = 0x828EE948; continue 'dispatch;
	}
	// 828EE964: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828EE968: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828EE96C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 828EE970: 483BAB11  bl 0x82ca9480
	ctx.lr = 0x828EE974;
	sub_82CA9480(ctx, base);
	// 828EE974: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EE978: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EE97C: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EE980: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828EE984: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EE988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE98C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828EE990: 419A0020  beq cr6, 0x828ee9b0
	if ctx.cr[6].eq {
	pc = 0x828EE9B0; continue 'dispatch;
	}
	// 828EE994: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE998: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE99C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE9A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE9A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE9A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE9AC: 4082FFE8  bne 0x828ee994
	if !ctx.cr[0].eq {
	pc = 0x828EE994; continue 'dispatch;
	}
	// 828EE9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE9B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE9B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE9BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE9C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE9C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE9D0 size=104
    let mut pc: u32 = 0x828EE9D0;
    'dispatch: loop {
        match pc {
            0x828EE9D0 => {
    //   block [0x828EE9D0..0x828EEA38)
	// 828EE9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE9E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE9E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE9EC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828EE9F0: 4B8C9129  bl 0x821b7b18
	ctx.lr = 0x828EE9F4;
	sub_821B7B18(ctx, base);
	// 828EE9F4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828EE9F8: 4BAEDE31  bl 0x823dc828
	ctx.lr = 0x828EE9FC;
	sub_823DC828(ctx, base);
	// 828EE9FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828EEA00: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828EEA04: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828EEA08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EEA0C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828EEA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EEA14: 419A000C  beq cr6, 0x828eea20
	if ctx.cr[6].eq {
	pc = 0x828EEA20; continue 'dispatch;
	}
	// 828EEA18: 4B92D321  bl 0x8221bd38
	ctx.lr = 0x828EEA1C;
	sub_8221BD38(ctx, base);
	// 828EEA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EEA20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EEA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EEA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EEA2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EEA30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EEA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EEA38 size=92
    let mut pc: u32 = 0x828EEA38;
    'dispatch: loop {
        match pc {
            0x828EEA38 => {
    //   block [0x828EEA38..0x828EEA94)
	// 828EEA38: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EEA3C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EEA40: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828EEA44: 419A0030  beq cr6, 0x828eea74
	if ctx.cr[6].eq {
	pc = 0x828EEA74; continue 'dispatch;
	}
	// 828EEA48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEA4C: 810A0080  lwz r8, 0x80(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EEA50: 7D072038  and r7, r8, r4
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[4].u64;
	// 828EEA54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828EEA58: 419A0010  beq cr6, 0x828eea68
	if ctx.cr[6].eq {
	pc = 0x828EEA68; continue 'dispatch;
	}
	// 828EEA5C: 894A0070  lbz r10, 0x70(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 828EEA60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EEA64: 419A0030  beq cr6, 0x828eea94
	if ctx.cr[6].eq {
		sub_828EEA94(ctx, base);
		return;
	}
	// 828EEA68: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828EEA6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828EEA70: 409AFFD8  bne cr6, 0x828eea48
	if !ctx.cr[6].eq {
	pc = 0x828EEA48; continue 'dispatch;
	}
	// 828EEA74: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EEA78: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EEA7C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828EEA80: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828EEA84: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828EEA88: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828EEA8C: 68C30001  xori r3, r6, 1
	ctx.r[3].u64 = ctx.r[6].u64 ^ 1;
	// 828EEA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEA94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EEA94 size=8
    let mut pc: u32 = 0x828EEA94;
    'dispatch: loop {
        match pc {
            0x828EEA94 => {
    //   block [0x828EEA94..0x828EEA9C)
	// 828EEA94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828EEA98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EEAA0 size=52
    let mut pc: u32 = 0x828EEAA0;
    'dispatch: loop {
        match pc {
            0x828EEAA0 => {
    //   block [0x828EEAA0..0x828EEAD4)
	// 828EEAA0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EEAA4: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EEAA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828EEAAC: 419A0020  beq cr6, 0x828eeacc
	if ctx.cr[6].eq {
	pc = 0x828EEACC; continue 'dispatch;
	}
	// 828EEAB0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEAB4: 81090080  lwz r8, 0x80(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EEAB8: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828EEABC: 419A0018  beq cr6, 0x828eead4
	if ctx.cr[6].eq {
		sub_828EEAD4(ctx, base);
		return;
	}
	// 828EEAC0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828EEAC4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828EEAC8: 409AFFE8  bne cr6, 0x828eeab0
	if !ctx.cr[6].eq {
	pc = 0x828EEAB0; continue 'dispatch;
	}
	// 828EEACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828EEAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEAD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EEAD4 size=64
    let mut pc: u32 = 0x828EEAD4;
    'dispatch: loop {
        match pc {
            0x828EEAD4 => {
    //   block [0x828EEAD4..0x828EEB14)
	// 828EEAD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEAD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEADC: 419AFFF0  beq cr6, 0x828eeacc
	if ctx.cr[6].eq {
		sub_828EEAA0(ctx, base);
		return;
	}
	// 828EEAE0: 894B0070  lbz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828EEAE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EEAE8: 419AFFE4  beq cr6, 0x828eeacc
	if ctx.cr[6].eq {
		sub_828EEAA0(ctx, base);
		return;
	}
	// 828EEAEC: 894B0071  lbz r10, 0x71(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(113 as u32) ) } as u64;
	// 828EEAF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EEAF4: 419AFFD8  beq cr6, 0x828eeacc
	if ctx.cr[6].eq {
		sub_828EEAA0(ctx, base);
		return;
	}
	// 828EEAF8: E94B0060  ld r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	// 828EEAFC: 392B0060  addi r9, r11, 0x60
	ctx.r[9].s64 = ctx.r[11].s64 + 96;
	// 828EEB00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828EEB04: F9450000  std r10, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828EEB08: E90B0068  ld r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	// 828EEB0C: F9050008  std r8, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 828EEB10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EEB18 size=324
    let mut pc: u32 = 0x828EEB18;
    'dispatch: loop {
        match pc {
            0x828EEB18 => {
    //   block [0x828EEB18..0x828EEC5C)
	// 828EEB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EEB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EEB20: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EEC60 size=768
    let mut pc: u32 = 0x828EEC60;
    'dispatch: loop {
        match pc {
            0x828EEC60 => {
    //   block [0x828EEC60..0x828EEF60)
	// 828EEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EEC64: 483BA799  bl 0x82ca93fc
	ctx.lr = 0x828EEC68;
	sub_82CA93D0(ctx, base);
	// 828EEC68: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828EEC6C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828EEC70: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828EEC74: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 828EEC78: 48717D55  bl 0x830069cc
	ctx.lr = 0x828EEC7C;
	sub_83006760(ctx, base);
	// 828EEC7C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EEC80: 83E30010  lwz r31, 0x10(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EEC84: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828EEC88: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EEC8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EEC90: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EEC94: 419A0020  beq cr6, 0x828eecb4
	if ctx.cr[6].eq {
	pc = 0x828EECB4; continue 'dispatch;
	}
	// 828EEC98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEC9C: 892A0070  lbz r9, 0x70(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 828EECA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828EECA4: 409A00D4  bne cr6, 0x828eed78
	if !ctx.cr[6].eq {
	pc = 0x828EED78; continue 'dispatch;
	}
	// 828EECA8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828EECAC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828EECB0: 409AFFE8  bne cr6, 0x828eec98
	if !ctx.cr[6].eq {
	pc = 0x828EEC98; continue 'dispatch;
	}
	// 828EECB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EECB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828EECBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EECC0: 419A0280  beq cr6, 0x828eef40
	if ctx.cr[6].eq {
	pc = 0x828EEF40; continue 'dispatch;
	}
	// 828EECC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EEF60 size=1524
    let mut pc: u32 = 0x828EEF60;
    'dispatch: loop {
        match pc {
            0x828EEF60 => {
    //   block [0x828EEF60..0x828EF554)
	// 828EEF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EEF64: 483BA489  bl 0x82ca93ec
	ctx.lr = 0x828EEF68;
	sub_82CA93D0(ctx, base);
	// 828EEF68: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 828EEF6C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 828EEF70: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 828EEF74: 48717A61  bl 0x830069d4
	ctx.lr = 0x828EEF78;
	sub_83006760(ctx, base);
	// 828EEF78: 9421FBF0  stwu r1, -0x410(r1)
	ea = ctx.r[1].u32.wrapping_add(-1040 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EEF7C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828EF558 size=2388
    let mut pc: u32 = 0x828EF558;
    'dispatch: loop {
        match pc {
            0x828EF558 => {
    //   block [0x828EF558..0x828EFEAC)
	// 828EF558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF55C: 483B9E89  bl 0x82ca93e4
	ctx.lr = 0x828EF560;
	sub_82CA93D0(ctx, base);
	// 828EF560: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 828EF564: 483BE769  bl 0x82cadccc
	ctx.lr = 0x828EF568;
	sub_82CADCA0(ctx, base);
	// 828EF568: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFEB0 size=76
    let mut pc: u32 = 0x828EFEB0;
    'dispatch: loop {
        match pc {
            0x828EFEB0 => {
    //   block [0x828EFEB0..0x828EFEFC)
	// 828EFEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFEB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFEB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFEBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFEC4: 4BFFF695  bl 0x828ef558
	ctx.lr = 0x828EFEC8;
	sub_828EF558(ctx, base);
	// 828EFEC8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EFECC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828EFED0: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828EFED4: 995F001E  stb r10, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[10].u8 ) };
	// 828EFED8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828EFEDC: 419A000C  beq cr6, 0x828efee8
	if ctx.cr[6].eq {
	pc = 0x828EFEE8; continue 'dispatch;
	}
	// 828EFEE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EFEE4: 4BA9D5D5  bl 0x8238d4b8
	ctx.lr = 0x828EFEE8;
	sub_8238D4B8(ctx, base);
	// 828EFEE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EFEEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFEF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFEF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFEF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFF00 size=168
    let mut pc: u32 = 0x828EFF00;
    'dispatch: loop {
        match pc {
            0x828EFF00 => {
    //   block [0x828EFF00..0x828EFFA8)
	// 828EFF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFF04: 483B9501  bl 0x82ca9404
	ctx.lr = 0x828EFF08;
	sub_82CA93D0(ctx, base);
	// 828EFF08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFF0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EFF10: 897B001E  lbz r11, 0x1e(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(30 as u32) ) } as u64;
	// 828EFF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EFF18: 419A0088  beq cr6, 0x828effa0
	if ctx.cr[6].eq {
	pc = 0x828EFFA0; continue 'dispatch;
	}
	// 828EFF1C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828EFF20: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EFF24: 813B0010  lwz r9, 0x10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EFF28: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 828EFF2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828EFF30: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828EFF34: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828EFF38: 55070038  rlwinm r7, r8, 0, 0, 0x1c
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 828EFF3C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828EFF40: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EFF44: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EFF48: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EFF4C: 83840018  lwz r28, 0x18(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EFF50: 419A0048  beq cr6, 0x828eff98
	if ctx.cr[6].eq {
	pc = 0x828EFF98; continue 'dispatch;
	}
	// 828EFF54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828EFF58: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EFF5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EFF60: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFF64: 7D2BE82E  lwzx r9, r11, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828EFF68: 810A0024  lwz r8, 0x24(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828EFF6C: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EFF70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828EFF74: 4E800421  bctrl
	ctx.lr = 0x828EFF78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFF78: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EFF7C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EFF80: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828EFF84: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828EFF88: 7CA63850  subf r5, r6, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 828EFF8C: 7CA41E70  srawi r4, r5, 3
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 3) as i64;
	// 828EFF90: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828EFF94: 409AFFC4  bne cr6, 0x828eff58
	if !ctx.cr[6].eq {
	pc = 0x828EFF58; continue 'dispatch;
	}
	// 828EFF98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828EFF9C: 997B001D  stb r11, 0x1d(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 828EFFA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EFFA4: 483B94B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFFA8 size=168
    let mut pc: u32 = 0x828EFFA8;
    'dispatch: loop {
        match pc {
            0x828EFFA8 => {
    //   block [0x828EFFA8..0x828F0050)
	// 828EFFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFFAC: 483B9459  bl 0x82ca9404
	ctx.lr = 0x828EFFB0;
	sub_82CA93D0(ctx, base);
	// 828EFFB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFFB4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EFFB8: 897B001D  lbz r11, 0x1d(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(29 as u32) ) } as u64;
	// 828EFFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EFFC0: 419A0088  beq cr6, 0x828f0048
	if ctx.cr[6].eq {
	pc = 0x828F0048; continue 'dispatch;
	}
	// 828EFFC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828EFFC8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828EFFCC: 813B0010  lwz r9, 0x10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EFFD0: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 828EFFD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828EFFD8: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828EFFDC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828EFFE0: 55070038  rlwinm r7, r8, 0, 0, 0x1c
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 828EFFE4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828EFFE8: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EFFEC: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EFFF0: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EFFF4: 83840018  lwz r28, 0x18(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828EFFF8: 419A0048  beq cr6, 0x828f0040
	if ctx.cr[6].eq {
	pc = 0x828F0040; continue 'dispatch;
	}
	// 828EFFFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F0000: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F0004: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F0008: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F000C: 7D2BE82E  lwzx r9, r11, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828F0010: 810A0028  lwz r8, 0x28(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F0014: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0018: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828F001C: 4E800421  bctrl
	ctx.lr = 0x828F0020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0020: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0024: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0028: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828F002C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828F0030: 7CA63850  subf r5, r6, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 828F0034: 7CA41E70  srawi r4, r5, 3
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 3) as i64;
	// 828F0038: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828F003C: 409AFFC4  bne cr6, 0x828f0000
	if !ctx.cr[6].eq {
	pc = 0x828F0000; continue 'dispatch;
	}
	// 828F0040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0044: 997B001D  stb r11, 0x1d(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 828F0048: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F004C: 483B9408  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0050 size=152
    let mut pc: u32 = 0x828F0050;
    'dispatch: loop {
        match pc {
            0x828F0050 => {
    //   block [0x828F0050..0x828F00E8)
	// 828F0050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0054: 483B93B1  bl 0x82ca9404
	ctx.lr = 0x828F0058;
	sub_82CA93D0(ctx, base);
	// 828F0058: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F005C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F0060: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828F0064: 3BFC000C  addi r31, r28, 0xc
	ctx.r[31].s64 = ctx.r[28].s64 + 12;
	// 828F0068: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828F006C: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F0070: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F0074: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828F0078: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828F007C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828F0080: 419A0034  beq cr6, 0x828f00b4
	if ctx.cr[6].eq {
	pc = 0x828F00B4; continue 'dispatch;
	}
	// 828F0084: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828F0088: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F008C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828F0090: 4BFFE7D9  bl 0x828ee868
	ctx.lr = 0x828F0094;
	sub_828EE868(ctx, base);
	// 828F0094: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0098: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828F009C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F00A0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828F00A4: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828F00A8: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828F00AC: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828F00B0: 409AFFD8  bne cr6, 0x828f0088
	if !ctx.cr[6].eq {
	pc = 0x828F0088; continue 'dispatch;
	}
	// 828F00B4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F00B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F00BC: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 828F00C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F00C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F00C8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828F00CC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828F00D0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828F00D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F00D8: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F00DC: 481C0445  bl 0x82ab0520
	ctx.lr = 0x828F00E0;
	sub_82AB0520(ctx, base);
	// 828F00E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F00E4: 483B9370  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F00E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F00E8 size=104
    let mut pc: u32 = 0x828F00E8;
    'dispatch: loop {
        match pc {
            0x828F00E8 => {
    //   block [0x828F00E8..0x828F0150)
	// 828F00E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F00EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F00F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F00F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F00F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F00FC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F0100: 4B92F159  bl 0x8221f258
	ctx.lr = 0x828F0104;
	sub_8221F258(ctx, base);
	// 828F0104: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F010C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0110: 419A0024  beq cr6, 0x828f0134
	if ctx.cr[6].eq {
	pc = 0x828F0134; continue 'dispatch;
	}
	// 828F0114: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0118: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828F011C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828F0120: 38E90150  addi r7, r9, 0x150
	ctx.r[7].s64 = ctx.r[9].s64 + 336;
	// 828F0124: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F0128: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828F012C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0130: 48000008  b 0x828f0138
	pc = 0x828F0138; continue 'dispatch;
	// 828F0134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0138: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F013C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F014C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0150 size=92
    let mut pc: u32 = 0x828F0150;
    'dispatch: loop {
        match pc {
            0x828F0150 => {
    //   block [0x828F0150..0x828F01AC)
	// 828F0150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F015C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0164: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0168: 419A0030  beq cr6, 0x828f0198
	if ctx.cr[6].eq {
	pc = 0x828F0198; continue 'dispatch;
	}
	// 828F016C: 4BFFE6FD  bl 0x828ee868
	ctx.lr = 0x828F0170;
	sub_828EE868(ctx, base);
	// 828F0170: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 828F0174: 4B8C79A5  bl 0x821b7b18
	ctx.lr = 0x828F0178;
	sub_821B7B18(ctx, base);
	// 828F0178: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828F017C: 4B8C799D  bl 0x821b7b18
	ctx.lr = 0x828F0180;
	sub_821B7B18(ctx, base);
	// 828F0180: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828F0184: 4B8C7995  bl 0x821b7b18
	ctx.lr = 0x828F0188;
	sub_821B7B18(ctx, base);
	// 828F0188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F018C: 4B8C798D  bl 0x821b7b18
	ctx.lr = 0x828F0190;
	sub_821B7B18(ctx, base);
	// 828F0190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0194: 4B92BBA5  bl 0x8221bd38
	ctx.lr = 0x828F0198;
	sub_8221BD38(ctx, base);
	// 828F0198: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F019C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F01A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F01A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F01A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F01B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F01B0 size=584
    let mut pc: u32 = 0x828F01B0;
    'dispatch: loop {
        match pc {
            0x828F01B0 => {
    //   block [0x828F01B0..0x828F03F8)
	// 828F01B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F01B4: 483B924D  bl 0x82ca9400
	ctx.lr = 0x828F01B8;
	sub_82CA93D0(ctx, base);
	// 828F01B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F01BC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F01C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F01C8: 409A0010  bne cr6, 0x828f01d8
	if !ctx.cr[6].eq {
	pc = 0x828F01D8; continue 'dispatch;
	}
	// 828F01CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F01D0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828F01D4: 48000008  b 0x828f01dc
	pc = 0x828F01DC; continue 'dispatch;
	// 828F01D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F01E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F01E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01E8: 4BADE3D9  bl 0x823ce5c0
	ctx.lr = 0x828F01EC;
	sub_823CE5C0(ctx, base);
	// 828F01EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F01F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F01F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F01F8: 4BADE009  bl 0x823ce200
	ctx.lr = 0x828F01FC;
	sub_823CE200(ctx, base);
	// 828F01FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F0200: 4B8C7919  bl 0x821b7b18
	ctx.lr = 0x828F0204;
	sub_821B7B18(ctx, base);
	// 828F0204: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828F0208: 4B92F051  bl 0x8221f258
	ctx.lr = 0x828F020C;
	sub_8221F258(ctx, base);
	// 828F020C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F0210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F0214: 419A0040  beq cr6, 0x828f0254
	if ctx.cr[6].eq {
	pc = 0x828F0254; continue 'dispatch;
	}
	// 828F0218: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828F021C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F0220: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828F0224: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F0228: 4B92F031  bl 0x8221f258
	ctx.lr = 0x828F022C;
	sub_8221F258(ctx, base);
	// 828F022C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F0230: 419A0028  beq cr6, 0x828f0258
	if ctx.cr[6].eq {
	pc = 0x828F0258; continue 'dispatch;
	}
	// 828F0234: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828F0238: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828F023C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0240: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828F0244: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F0248: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F024C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F0250: 4800000C  b 0x828f025c
	pc = 0x828F025C; continue 'dispatch;
	// 828F0254: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F0258: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F025C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0260: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0264: 419A00FC  beq cr6, 0x828f0360
	if ctx.cr[6].eq {
	pc = 0x828F0360; continue 'dispatch;
	}
	// 828F0268: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F026C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F0270: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0274: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F0278: 4B938E91  bl 0x82229108
	ctx.lr = 0x828F027C;
	sub_82229108(ctx, base);
	// 828F027C: 3D60822A  lis r11, -0x7dd6
	ctx.r[11].s64 = -2111176704;
	// 828F0280: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F0284: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F0288: 3BCBC198  addi r30, r11, -0x3e68
	ctx.r[30].s64 = ctx.r[11].s64 + -15976;
	// 828F028C: 4B9375F5  bl 0x82227880
	ctx.lr = 0x828F0290;
	sub_82227880(ctx, base);
	// 828F0290: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0294: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828F0298: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F029C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828F02A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F02A4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F02A8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828F02AC: 4B8AA7D5  bl 0x8219aa80
	ctx.lr = 0x828F02B0;
	sub_8219AA80(ctx, base);
	// 828F02B0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828F02B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F02B8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828F02BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F02C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F02C4: 4BADE15D  bl 0x823ce420
	ctx.lr = 0x828F02C8;
	sub_823CE420(ctx, base);
	// 828F02C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F02CC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F02D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F02D4: 481343F5  bl 0x82a246c8
	ctx.lr = 0x828F02D8;
	sub_82A246C8(ctx, base);
	// 828F02D8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F02DC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F02E0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828F02E4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828F02E8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F02EC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F02F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F02F4: 4B938E15  bl 0x82229108
	ctx.lr = 0x828F02F8;
	sub_82229108(ctx, base);
	// 828F02F8: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828F02FC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F0300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0304: 3BEB6BA0  addi r31, r11, 0x6ba0
	ctx.r[31].s64 = ctx.r[11].s64 + 27552;
	// 828F0308: 4B937579  bl 0x82227880
	ctx.lr = 0x828F030C;
	sub_82227880(ctx, base);
	// 828F030C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828F0310: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828F0314: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F0318: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828F031C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0320: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F0324: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828F0328: 4B8AA759  bl 0x8219aa80
	ctx.lr = 0x828F032C;
	sub_8219AA80(ctx, base);
	// 828F032C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828F0330: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F0334: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828F0338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F033C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F0340: 4BADE0E1  bl 0x823ce420
	ctx.lr = 0x828F0344;
	sub_823CE420(ctx, base);
	// 828F0344: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F0348: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F034C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0350: 48134379  bl 0x82a246c8
	ctx.lr = 0x828F0354;
	sub_82A246C8(ctx, base);
	// 828F0354: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0358: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828F035C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828F0360: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828F0364: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F0368: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828F036C: 419A0020  beq cr6, 0x828f038c
	if ctx.cr[6].eq {
	pc = 0x828F038C; continue 'dispatch;
	}
	// 828F0370: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F0374: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F0378: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F037C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F0380: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F0384: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F0388: 4082FFE8  bne 0x828f0370
	if !ctx.cr[0].eq {
	pc = 0x828F0370; continue 'dispatch;
	}
	// 828F038C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0390: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F0394: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828F0398: 4BA055B1  bl 0x822f5948
	ctx.lr = 0x828F039C;
	sub_822F5948(ctx, base);
	// 828F039C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F03A0: 4B8C7779  bl 0x821b7b18
	ctx.lr = 0x828F03A4;
	sub_821B7B18(ctx, base);
	// 828F03A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F03A8: 419A0040  beq cr6, 0x828f03e8
	if ctx.cr[6].eq {
	pc = 0x828F03E8; continue 'dispatch;
	}
	// 828F03AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F03B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F03B4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F03B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F03BC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F03C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F03C4: 4082FFE8  bne 0x828f03ac
	if !ctx.cr[0].eq {
	pc = 0x828F03AC; continue 'dispatch;
	}
	// 828F03C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F03CC: 409A001C  bne cr6, 0x828f03e8
	if !ctx.cr[6].eq {
	pc = 0x828F03E8; continue 'dispatch;
	}
	// 828F03D0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F03D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F03D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F03DC: 4E800421  bctrl
	ctx.lr = 0x828F03E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F03E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F03E4: 4B92B955  bl 0x8221bd38
	ctx.lr = 0x828F03E8;
	sub_8221BD38(ctx, base);
	// 828F03E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F03EC: 4B8C772D  bl 0x821b7b18
	ctx.lr = 0x828F03F0;
	sub_821B7B18(ctx, base);
	// 828F03F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F03F4: 483B905C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F03F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F03F8 size=516
    let mut pc: u32 = 0x828F03F8;
    'dispatch: loop {
        match pc {
            0x828F03F8 => {
    //   block [0x828F03F8..0x828F05FC)
	// 828F03F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F03FC: 483B9001  bl 0x82ca93fc
	ctx.lr = 0x828F0400;
	sub_82CA93D0(ctx, base);
	// 828F0400: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0404: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F0408: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828F040C: 3D40822A  lis r10, -0x7dd6
	ctx.r[10].s64 = -2111176704;
	// 828F0410: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828F0414: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828F0418: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F041C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828F0420: 3BAADA10  addi r29, r10, -0x25f0
	ctx.r[29].s64 = ctx.r[10].s64 + -9712;
	// 828F0424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0428: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828F042C: 419A0008  beq cr6, 0x828f0434
	if ctx.cr[6].eq {
	pc = 0x828F0434; continue 'dispatch;
	}
	// 828F0430: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0434: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F043C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0440: 4BADE181  bl 0x823ce5c0
	ctx.lr = 0x828F0444;
	sub_823CE5C0(ctx, base);
	// 828F0444: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F0448: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F044C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F0450: 4BADDCC1  bl 0x823ce110
	ctx.lr = 0x828F0454;
	sub_823CE110(ctx, base);
	// 828F0454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F0458: 4B8C76C1  bl 0x821b7b18
	ctx.lr = 0x828F045C;
	sub_821B7B18(ctx, base);
	// 828F045C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0460: 4B92EDF9  bl 0x8221f258
	ctx.lr = 0x828F0464;
	sub_8221F258(ctx, base);
	// 828F0464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0468: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F046C: 419A005C  beq cr6, 0x828f04c8
	if ctx.cr[6].eq {
	pc = 0x828F04C8; continue 'dispatch;
	}
	// 828F0470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F0474: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828F0478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F047C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828F0480: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F0488: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F048C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828F0490: 4B8FFDB1  bl 0x821f0240
	ctx.lr = 0x828F0494;
	sub_821F0240(ctx, base);
	// 828F0494: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F0498: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828F049C: 4B92EDBD  bl 0x8221f258
	ctx.lr = 0x828F04A0;
	sub_8221F258(ctx, base);
	// 828F04A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F04A4: 419A0028  beq cr6, 0x828f04cc
	if ctx.cr[6].eq {
	pc = 0x828F04CC; continue 'dispatch;
	}
	// 828F04A8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828F04AC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828F04B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F04B4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828F04B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F04BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F04C0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F04C4: 4800000C  b 0x828f04d0
	pc = 0x828F04D0; continue 'dispatch;
	// 828F04C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F04CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F04D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F04D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828F04D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F04DC: 419A0008  beq cr6, 0x828f04e4
	if ctx.cr[6].eq {
	pc = 0x828F04E4; continue 'dispatch;
	}
	// 828F04E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F04E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F04E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F04EC: 419A0078  beq cr6, 0x828f0564
	if ctx.cr[6].eq {
	pc = 0x828F0564; continue 'dispatch;
	}
	// 828F04F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F04F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F04F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F04FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F0500: 4B938C09  bl 0x82229108
	ctx.lr = 0x828F0504;
	sub_82229108(ctx, base);
	// 828F0504: 3D60822A  lis r11, -0x7dd6
	ctx.r[11].s64 = -2111176704;
	// 828F0508: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F050C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F0510: 3BCBD880  addi r30, r11, -0x2780
	ctx.r[30].s64 = ctx.r[11].s64 + -10112;
	// 828F0514: 4B93736D  bl 0x82227880
	ctx.lr = 0x828F0518;
	sub_82227880(ctx, base);
	// 828F0518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F051C: 3D40821D  lis r10, -0x7de3
	ctx.r[10].s64 = -2112028672;
	// 828F0520: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F0524: 388A4CE8  addi r4, r10, 0x4ce8
	ctx.r[4].s64 = ctx.r[10].s64 + 19688;
	// 828F0528: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F052C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828F0530: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828F0534: 4B8AA54D  bl 0x8219aa80
	ctx.lr = 0x828F0538;
	sub_8219AA80(ctx, base);
	// 828F0538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F053C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828F0540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F0544: 4BADDEDD  bl 0x823ce420
	ctx.lr = 0x828F0548;
	sub_823CE420(ctx, base);
	// 828F0548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F054C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F0550: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F0554: 48134175  bl 0x82a246c8
	ctx.lr = 0x828F0558;
	sub_82A246C8(ctx, base);
	// 828F0558: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F055C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828F0560: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828F0564: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F0568: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F056C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828F0570: 419A0020  beq cr6, 0x828f0590
	if ctx.cr[6].eq {
	pc = 0x828F0590; continue 'dispatch;
	}
	// 828F0574: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F0578: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F057C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F0580: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F0584: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F0588: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F058C: 4082FFE8  bne 0x828f0574
	if !ctx.cr[0].eq {
	pc = 0x828F0574; continue 'dispatch;
	}
	// 828F0590: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F0598: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828F059C: 4BA053AD  bl 0x822f5948
	ctx.lr = 0x828F05A0;
	sub_822F5948(ctx, base);
	// 828F05A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F05A4: 4B8C7575  bl 0x821b7b18
	ctx.lr = 0x828F05A8;
	sub_821B7B18(ctx, base);
	// 828F05A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F05AC: 419A0040  beq cr6, 0x828f05ec
	if ctx.cr[6].eq {
	pc = 0x828F05EC; continue 'dispatch;
	}
	// 828F05B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F05B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F05B8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F05BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F05C0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F05C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F05C8: 4082FFE8  bne 0x828f05b0
	if !ctx.cr[0].eq {
	pc = 0x828F05B0; continue 'dispatch;
	}
	// 828F05CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F05D0: 409A001C  bne cr6, 0x828f05ec
	if !ctx.cr[6].eq {
	pc = 0x828F05EC; continue 'dispatch;
	}
	// 828F05D4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F05D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F05DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F05E0: 4E800421  bctrl
	ctx.lr = 0x828F05E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F05E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F05E8: 4B92B751  bl 0x8221bd38
	ctx.lr = 0x828F05EC;
	sub_8221BD38(ctx, base);
	// 828F05EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F05F0: 4B8C7529  bl 0x821b7b18
	ctx.lr = 0x828F05F4;
	sub_821B7B18(ctx, base);
	// 828F05F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828F05F8: 483B8E54  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0600 size=184
    let mut pc: u32 = 0x828F0600;
    'dispatch: loop {
        match pc {
            0x828F0600 => {
    //   block [0x828F0600..0x828F06B8)
	// 828F0600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F060C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0614: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0618: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828F061C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0620: 4B92EC39  bl 0x8221f258
	ctx.lr = 0x828F0624;
	sub_8221F258(ctx, base);
	// 828F0624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F0628: 419A0050  beq cr6, 0x828f0678
	if ctx.cr[6].eq {
	pc = 0x828F0678; continue 'dispatch;
	}
	// 828F062C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828F0630: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 828F0634: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828F0638: 390A9C78  addi r8, r10, -0x6388
	ctx.r[8].s64 = ctx.r[10].s64 + -25480;
	// 828F063C: 38E96624  addi r7, r9, 0x6624
	ctx.r[7].s64 = ctx.r[9].s64 + 26148;
	// 828F0640: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F0644: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828F0648: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F064C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828F0650: 38864774  addi r4, r6, 0x4774
	ctx.r[4].s64 = ctx.r[6].s64 + 18292;
	// 828F0654: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F06B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F06B8 size=72
    let mut pc: u32 = 0x828F06B8;
    'dispatch: loop {
        match pc {
            0x828F06B8 => {
    //   block [0x828F06B8..0x828F0700)
	// 828F06B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F06BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F06C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F06C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F06C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F06CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828F06D0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 828F06D4: 392B9C78  addi r9, r11, -0x6388
	ctx.r[9].s64 = ctx.r[11].s64 + -25480;
	// 828F06D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F06DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F06E0: 419A000C  beq cr6, 0x828f06ec
	if ctx.cr[6].eq {
	pc = 0x828F06EC; continue 'dispatch;
	}
	// 828F06E4: 4B92B655  bl 0x8221bd38
	ctx.lr = 0x828F06E8;
	sub_8221BD38(ctx, base);
	// 828F06E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F06EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F06F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F06F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F06F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F06FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F0700 size=8
    let mut pc: u32 = 0x828F0700;
    'dispatch: loop {
        match pc {
            0x828F0700 => {
    //   block [0x828F0700..0x828F0708)
	// 828F0700: 38600013  li r3, 0x13
	ctx.r[3].s64 = 19;
	// 828F0704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0708 size=160
    let mut pc: u32 = 0x828F0708;
    'dispatch: loop {
        match pc {
            0x828F0708 => {
    //   block [0x828F0708..0x828F07A8)
	// 828F0708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F070C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F071C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0720: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828F0724: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0728: 4B92EB31  bl 0x8221f258
	ctx.lr = 0x828F072C;
	sub_8221F258(ctx, base);
	// 828F072C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F0730: 419A0038  beq cr6, 0x828f0768
	if ctx.cr[6].eq {
	pc = 0x828F0768; continue 'dispatch;
	}
	// 828F0734: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828F0738: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828F073C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828F0740: 390B9C78  addi r8, r11, -0x6388
	ctx.r[8].s64 = ctx.r[11].s64 + -25480;
	// 828F0744: 38E94790  addi r7, r9, 0x4790
	ctx.r[7].s64 = ctx.r[9].s64 + 18320;
	// 828F0748: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F074C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0750: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0754: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828F0758: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F07A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F07A8 size=324
    let mut pc: u32 = 0x828F07A8;
    'dispatch: loop {
        match pc {
            0x828F07A8 => {
    //   block [0x828F07A8..0x828F08EC)
	// 828F07A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F07AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F07B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F07B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F07B8: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F07BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F07C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F07C4: 556A57FE  rlwinm r10, r11, 0xa, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x003FFFFFu64;
	// 828F07C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F07CC: 419A00E4  beq cr6, 0x828f08b0
	if ctx.cr[6].eq {
	pc = 0x828F08B0; continue 'dispatch;
	}
	// 828F07D0: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F07D4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F07D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F07DC: 419A001C  beq cr6, 0x828f07f8
	if ctx.cr[6].eq {
	pc = 0x828F07F8; continue 'dispatch;
	}
	// 828F07E0: 896B0076  lbz r11, 0x76(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(118 as u32) ) } as u64;
	// 828F07E4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828F07E8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F07EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F07F0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F07F4: 480000C0  b 0x828f08b4
	pc = 0x828F08B4; continue 'dispatch;
	// 828F07F8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F07FC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828F0800: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F0804: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F0808: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F080C: 40810054  ble 0x828f0860
	if !ctx.cr[0].gt {
	pc = 0x828F0860; continue 'dispatch;
	}
	// 828F0810: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F0814: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F0818: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F081C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0820: 2F070076  cmpwi cr6, r7, 0x76
	ctx.cr[6].compare_i32(ctx.r[7].s32, 118, &mut ctx.xer);
	// 828F0824: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F0828: 41980008  blt cr6, 0x828f0830
	if ctx.cr[6].lt {
	pc = 0x828F0830; continue 'dispatch;
	}
	// 828F082C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828F0830: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F0834: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F0838: 419A0014  beq cr6, 0x828f084c
	if ctx.cr[6].eq {
	pc = 0x828F084C; continue 'dispatch;
	}
	// 828F083C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F0840: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F0844: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F0848: 4800000C  b 0x828f0854
	pc = 0x828F0854; continue 'dispatch;
	// 828F084C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F0850: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F0854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0858: 4199FFB8  bgt cr6, 0x828f0810
	if ctx.cr[6].gt {
	pc = 0x828F0810; continue 'dispatch;
	}
	// 828F085C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F0860: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F0864: 419A003C  beq cr6, 0x828f08a0
	if ctx.cr[6].eq {
	pc = 0x828F08A0; continue 'dispatch;
	}
	// 828F0868: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F086C: 2F0B0076  cmpwi cr6, r11, 0x76
	ctx.cr[6].compare_i32(ctx.r[11].s32, 118, &mut ctx.xer);
	// 828F0870: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F0874: 41990008  bgt cr6, 0x828f087c
	if ctx.cr[6].gt {
	pc = 0x828F087C; continue 'dispatch;
	}
	// 828F0878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F087C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F0880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0884: 409A001C  bne cr6, 0x828f08a0
	if !ctx.cr[6].eq {
	pc = 0x828F08A0; continue 'dispatch;
	}
	// 828F0888: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F088C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F0890: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F0894: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F089C: 48000018  b 0x828f08b4
	pc = 0x828F08B4; continue 'dispatch;
	// 828F08A0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F08A4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F08A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F08AC: 48000008  b 0x828f08b4
	pc = 0x828F08B4; continue 'dispatch;
	// 828F08B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F08B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F08B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F08BC: 419A001C  beq cr6, 0x828f08d8
	if ctx.cr[6].eq {
	pc = 0x828F08D8; continue 'dispatch;
	}
	// 828F08C0: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F08C4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F08F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F08F0 size=16
    let mut pc: u32 = 0x828F08F0;
    'dispatch: loop {
        match pc {
            0x828F08F0 => {
    //   block [0x828F08F0..0x828F0900)
	// 828F08F0: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0900 size=60
    let mut pc: u32 = 0x828F0900;
    'dispatch: loop {
        match pc {
            0x828F0900 => {
    //   block [0x828F0900..0x828F093C)
	// 828F0900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0904: 483B8B09  bl 0x82ca940c
	ctx.lr = 0x828F0908;
	sub_82CA93D0(ctx, base);
	// 828F0908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F090C: 3BE30050  addi r31, r3, 0x50
	ctx.r[31].s64 = ctx.r[3].s64 + 80;
	// 828F0910: 3BC30040  addi r30, r3, 0x40
	ctx.r[30].s64 = ctx.r[3].s64 + 64;
	// 828F0914: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F091C: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 828F0920: 4BFD4E31  bl 0x828c5750
	ctx.lr = 0x828F0924;
	sub_828C5750(ctx, base);
	// 828F0924: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F0928: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F092C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F0930: 4BA9E1A1  bl 0x8238ead0
	ctx.lr = 0x828F0934;
	sub_8238EAD0(ctx, base);
	// 828F0934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0938: 483B8B24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0940 size=124
    let mut pc: u32 = 0x828F0940;
    'dispatch: loop {
        match pc {
            0x828F0940 => {
    //   block [0x828F0940..0x828F09BC)
	// 828F0940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F094C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0950: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0954: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F095C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F0960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0964: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F0968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F096C: 4BC93865  bl 0x825841d0
	ctx.lr = 0x828F0970;
	sub_825841D0(ctx, base);
	// 828F0970: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F0974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F097C: 419A001C  beq cr6, 0x828f0998
	if ctx.cr[6].eq {
	pc = 0x828F0998; continue 'dispatch;
	}
	// 828F0980: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0984: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0988: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F098C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F0990: 4E800421  bctrl
	ctx.lr = 0x828F0994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0994: 4800000C  b 0x828f09a0
	pc = 0x828F09A0; continue 'dispatch;
	// 828F0998: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F099C: 4B901C3D  bl 0x821f25d8
	ctx.lr = 0x828F09A0;
	sub_821F25D8(ctx, base);
	// 828F09A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F09A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F09A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F09AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F09B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F09B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F09B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F09C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F09C0 size=100
    let mut pc: u32 = 0x828F09C0;
    'dispatch: loop {
        match pc {
            0x828F09C0 => {
    //   block [0x828F09C0..0x828F0A24)
	// 828F09C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F09C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F09C8: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 828F09CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F09D0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F09D4: 4B9B928D  bl 0x822a9c60
	ctx.lr = 0x828F09D8;
	sub_822A9C60(ctx, base);
	// 828F09D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F09DC: 419A0034  beq cr6, 0x828f0a10
	if ctx.cr[6].eq {
	pc = 0x828F0A10; continue 'dispatch;
	}
	// 828F09E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F09E4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F09E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F09EC: 419A0024  beq cr6, 0x828f0a10
	if ctx.cr[6].eq {
	pc = 0x828F0A10; continue 'dispatch;
	}
	// 828F09F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F09F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F09F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F09FC: D3E90018  stfs f31, 0x18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F0A00: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828F0A04: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0A08: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828F0A0C: 409AFFE8  bne cr6, 0x828f09f4
	if !ctx.cr[6].eq {
	pc = 0x828F09F4; continue 'dispatch;
	}
	// 828F0A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0A1C: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0A28 size=96
    let mut pc: u32 = 0x828F0A28;
    'dispatch: loop {
        match pc {
            0x828F0A28 => {
    //   block [0x828F0A28..0x828F0A88)
	// 828F0A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0A30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0A34: 4B9B922D  bl 0x822a9c60
	ctx.lr = 0x828F0A38;
	sub_822A9C60(ctx, base);
	// 828F0A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F0A3C: 419A003C  beq cr6, 0x828f0a78
	if ctx.cr[6].eq {
	pc = 0x828F0A78; continue 'dispatch;
	}
	// 828F0A40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0A44: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0A48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F0A4C: 419A002C  beq cr6, 0x828f0a78
	if ctx.cr[6].eq {
	pc = 0x828F0A78; continue 'dispatch;
	}
	// 828F0A50: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828F0A54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0A58: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F0A5C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828F0A60: 409A0008  bne cr6, 0x828f0a68
	if !ctx.cr[6].eq {
	pc = 0x828F0A68; continue 'dispatch;
	}
	// 828F0A64: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 828F0A68: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F0A6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F0A70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F0A74: 409AFFE0  bne cr6, 0x828f0a54
	if !ctx.cr[6].eq {
	pc = 0x828F0A54; continue 'dispatch;
	}
	// 828F0A78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0A84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0A88 size=60
    let mut pc: u32 = 0x828F0A88;
    'dispatch: loop {
        match pc {
            0x828F0A88 => {
    //   block [0x828F0A88..0x828F0AC4)
	// 828F0A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0A98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F0A9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0AA0: 388B9660  addi r4, r11, -0x69a0
	ctx.r[4].s64 = ctx.r[11].s64 + -27040;
	// 828F0AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0AA8: 4B93C429  bl 0x8222ced0
	ctx.lr = 0x828F0AAC;
	sub_8222CED0(ctx, base);
	// 828F0AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F0AC8 size=228
    let mut pc: u32 = 0x828F0AC8;
    'dispatch: loop {
        match pc {
            0x828F0AC8 => {
    //   block [0x828F0AC8..0x828F0BAC)
	// 828F0AC8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F0ACC: 8943000E  lbz r10, 0xe(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(14 as u32) ) } as u64;
	// 828F0AD0: 392BB158  addi r9, r11, -0x4ea8
	ctx.r[9].s64 = ctx.r[11].s64 + -20136;
	// 828F0AD4: 890BB158  lbz r8, -0x4ea8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-20136 as u32) ) } as u64;
	// 828F0AD8: 89690002  lbz r11, 2(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 828F0ADC: 88E90003  lbz r7, 3(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 828F0AE0: 89290001  lbz r9, 1(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 828F0AE4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F0AE8: 409A0038  bne cr6, 0x828f0b20
	if !ctx.cr[6].eq {
	pc = 0x828F0B20; continue 'dispatch;
	}
	// 828F0AEC: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 828F0AF0: 5526063E  clrlwi r6, r9, 0x18
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828F0AF4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F0AF8: 409A0028  bne cr6, 0x828f0b20
	if !ctx.cr[6].eq {
	pc = 0x828F0B20; continue 'dispatch;
	}
	// 828F0AFC: 8943000C  lbz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F0B00: 5506063E  clrlwi r6, r8, 0x18
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828F0B04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F0B08: 409A0018  bne cr6, 0x828f0b20
	if !ctx.cr[6].eq {
	pc = 0x828F0B20; continue 'dispatch;
	}
	// 828F0B0C: 8943000F  lbz r10, 0xf(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(15 as u32) ) } as u64;
	// 828F0B10: 54E6063E  clrlwi r6, r7, 0x18
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F0B14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F0B18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F0B1C: 419A0008  beq cr6, 0x828f0b24
	if ctx.cr[6].eq {
	pc = 0x828F0B24; continue 'dispatch;
	}
	// 828F0B20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0B24: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F0B28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F0B2C: 409A0080  bne cr6, 0x828f0bac
	if !ctx.cr[6].eq {
		sub_828F0BAC(ctx, base);
		return;
	}
	// 828F0B30: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0B34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828F0B38: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 828F0B3C: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0B40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F0B44: 41990068  bgt cr6, 0x828f0bac
	if ctx.cr[6].gt {
		sub_828F0BAC(ctx, base);
		return;
	}
	// 828F0B48: 89430016  lbz r10, 0x16(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(22 as u32) ) } as u64;
	// 828F0B4C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F0B50: 409A0038  bne cr6, 0x828f0b88
	if !ctx.cr[6].eq {
	pc = 0x828F0B88; continue 'dispatch;
	}
	// 828F0B54: 89630015  lbz r11, 0x15(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 828F0B58: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828F0B5C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F0B60: 409A0028  bne cr6, 0x828f0b88
	if !ctx.cr[6].eq {
	pc = 0x828F0B88; continue 'dispatch;
	}
	// 828F0B64: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F0B68: 550A063E  clrlwi r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828F0B6C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F0B70: 409A0018  bne cr6, 0x828f0b88
	if !ctx.cr[6].eq {
	pc = 0x828F0B88; continue 'dispatch;
	}
	// 828F0B74: 89630017  lbz r11, 0x17(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(23 as u32) ) } as u64;
	// 828F0B78: 54EA063E  clrlwi r10, r7, 0x18
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F0B7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F0B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0B84: 419A0008  beq cr6, 0x828f0b8c
	if ctx.cr[6].eq {
	pc = 0x828F0B8C; continue 'dispatch;
	}
	// 828F0B88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F0B8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F0B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0B94: 409A0018  bne cr6, 0x828f0bac
	if !ctx.cr[6].eq {
		sub_828F0BAC(ctx, base);
		return;
	}
	// 828F0B98: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F0B9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F0BA0: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 828F0BA4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 828F0BA8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0BAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F0BAC size=8
    let mut pc: u32 = 0x828F0BAC;
    'dispatch: loop {
        match pc {
            0x828F0BAC => {
    //   block [0x828F0BAC..0x828F0BB4)
	// 828F0BAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828F0BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0BB8 size=60
    let mut pc: u32 = 0x828F0BB8;
    'dispatch: loop {
        match pc {
            0x828F0BB8 => {
    //   block [0x828F0BB8..0x828F0BF4)
	// 828F0BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0BC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0BC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0BC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F0BCC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0BD0: 388B98B0  addi r4, r11, -0x6750
	ctx.r[4].s64 = ctx.r[11].s64 + -26448;
	// 828F0BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0BD8: 4B93C2F9  bl 0x8222ced0
	ctx.lr = 0x828F0BDC;
	sub_8222CED0(ctx, base);
	// 828F0BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0BE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0BF8 size=116
    let mut pc: u32 = 0x828F0BF8;
    'dispatch: loop {
        match pc {
            0x828F0BF8 => {
    //   block [0x828F0BF8..0x828F0C6C)
	// 828F0BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0C00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0C04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0C08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0C10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0C14: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F0C18: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828F0C1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F0C20: 915F003C  stw r10, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 828F0C24: 4B8A3215  bl 0x82193e38
	ctx.lr = 0x828F0C28;
	sub_82193E38(ctx, base);
	// 828F0C28: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828F0C2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F0C30: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828F0C34: 57C607FE  clrlwi r6, r30, 0x1f
	ctx.r[6].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828F0C38: 911F0040  stw r8, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 828F0C3C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828F0C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0C44: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828F0C48: 419A000C  beq cr6, 0x828f0c54
	if ctx.cr[6].eq {
	pc = 0x828F0C54; continue 'dispatch;
	}
	// 828F0C4C: 4B92B0ED  bl 0x8221bd38
	ctx.lr = 0x828F0C50;
	sub_8221BD38(ctx, base);
	// 828F0C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0C54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0C58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0C5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0C60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0C64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F0C70 size=100
    let mut pc: u32 = 0x828F0C70;
    'dispatch: loop {
        match pc {
            0x828F0C70 => {
    //   block [0x828F0C70..0x828F0CD4)
	// 828F0C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0C78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0C7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0C84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0C88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0C8C: 4BA9C82D  bl 0x8238d4b8
	ctx.lr = 0x828F0C90;
	sub_8238D4B8(ctx, base);
	// 828F0C90: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828F0C94: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828F0C98: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 828F0C9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F0CA0: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0CA4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828F0CA8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F0CAC: 997F0011  stb r11, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 828F0CB0: C0083710  lfs f0, 0x3710(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0CB4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F0CB8: C0096D88  lfs f0, 0x6d88(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0CBC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828F0CC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0CD8 size=684
    let mut pc: u32 = 0x828F0CD8;
    'dispatch: loop {
        match pc {
            0x828F0CD8 => {
    //   block [0x828F0CD8..0x828F0F84)
	// 828F0CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0CDC: 483B872D  bl 0x82ca9408
	ctx.lr = 0x828F0CE0;
	sub_82CA93D0(ctx, base);
	// 828F0CE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0CE8: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F0CEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F0CF0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0CF4: 388A47E8  addi r4, r10, 0x47e8
	ctx.r[4].s64 = ctx.r[10].s64 + 18408;
	// 828F0CF8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F0CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D00: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828F0D04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0D08: 4B93C1C9  bl 0x8222ced0
	ctx.lr = 0x828F0D0C;
	sub_8222CED0(ctx, base);
	// 828F0D0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0D10: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828F0D14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0D18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0D20: 419A0008  beq cr6, 0x828f0d28
	if ctx.cr[6].eq {
	pc = 0x828F0D28; continue 'dispatch;
	}
	// 828F0D24: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0D28: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828F0D2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0D30: 4BB8FA99  bl 0x824807c8
	ctx.lr = 0x828F0D34;
	sub_824807C8(ctx, base);
	// 828F0D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D38: 4B9240A1  bl 0x82214dd8
	ctx.lr = 0x828F0D3C;
	sub_82214DD8(ctx, base);
	// 828F0D3C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F0D40: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0D44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0D48: 388B47F4  addi r4, r11, 0x47f4
	ctx.r[4].s64 = ctx.r[11].s64 + 18420;
	// 828F0D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D50: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828F0D54: 4B93C17D  bl 0x8222ced0
	ctx.lr = 0x828F0D58;
	sub_8222CED0(ctx, base);
	// 828F0D58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0D5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0D64: 419A0008  beq cr6, 0x828f0d6c
	if ctx.cr[6].eq {
	pc = 0x828F0D6C; continue 'dispatch;
	}
	// 828F0D68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0D6C: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828F0D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0D74: 4BB8FADD  bl 0x82480850
	ctx.lr = 0x828F0D78;
	sub_82480850(ctx, base);
	// 828F0D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D7C: 4B92405D  bl 0x82214dd8
	ctx.lr = 0x828F0D80;
	sub_82214DD8(ctx, base);
	// 828F0D80: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0D84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0D88: 388B4800  addi r4, r11, 0x4800
	ctx.r[4].s64 = ctx.r[11].s64 + 18432;
	// 828F0D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D90: 4B93C141  bl 0x8222ced0
	ctx.lr = 0x828F0D94;
	sub_8222CED0(ctx, base);
	// 828F0D94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0D98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0DA0: 419A0008  beq cr6, 0x828f0da8
	if ctx.cr[6].eq {
	pc = 0x828F0DA8; continue 'dispatch;
	}
	// 828F0DA4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0DA8: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828F0DAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0DB0: 4BB8FAA1  bl 0x82480850
	ctx.lr = 0x828F0DB4;
	sub_82480850(ctx, base);
	// 828F0DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0DB8: 4B924021  bl 0x82214dd8
	ctx.lr = 0x828F0DBC;
	sub_82214DD8(ctx, base);
	// 828F0DBC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0DC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0DC4: 388B480C  addi r4, r11, 0x480c
	ctx.r[4].s64 = ctx.r[11].s64 + 18444;
	// 828F0DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0DCC: 4B93C105  bl 0x8222ced0
	ctx.lr = 0x828F0DD0;
	sub_8222CED0(ctx, base);
	// 828F0DD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0DD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0DDC: 419A0008  beq cr6, 0x828f0de4
	if ctx.cr[6].eq {
	pc = 0x828F0DE4; continue 'dispatch;
	}
	// 828F0DE0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0DE4: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828F0DE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0DEC: 4BB8FA65  bl 0x82480850
	ctx.lr = 0x828F0DF0;
	sub_82480850(ctx, base);
	// 828F0DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0DF4: 4B923FE5  bl 0x82214dd8
	ctx.lr = 0x828F0DF8;
	sub_82214DD8(ctx, base);
	// 828F0DF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F0DFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0E00: 388B270C  addi r4, r11, 0x270c
	ctx.r[4].s64 = ctx.r[11].s64 + 9996;
	// 828F0E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E08: 4B93C0C9  bl 0x8222ced0
	ctx.lr = 0x828F0E0C;
	sub_8222CED0(ctx, base);
	// 828F0E0C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0E10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0E18: 419A0008  beq cr6, 0x828f0e20
	if ctx.cr[6].eq {
	pc = 0x828F0E20; continue 'dispatch;
	}
	// 828F0E1C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0E20: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828F0E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0E28: 4BB8FA29  bl 0x82480850
	ctx.lr = 0x828F0E2C;
	sub_82480850(ctx, base);
	// 828F0E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E30: 4B923FA9  bl 0x82214dd8
	ctx.lr = 0x828F0E34;
	sub_82214DD8(ctx, base);
	// 828F0E34: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0E38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0E3C: 388B4818  addi r4, r11, 0x4818
	ctx.r[4].s64 = ctx.r[11].s64 + 18456;
	// 828F0E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E44: 4B93C08D  bl 0x8222ced0
	ctx.lr = 0x828F0E48;
	sub_8222CED0(ctx, base);
	// 828F0E48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0E4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0E54: 419A0008  beq cr6, 0x828f0e5c
	if ctx.cr[6].eq {
	pc = 0x828F0E5C; continue 'dispatch;
	}
	// 828F0E58: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0E5C: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828F0E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0E64: 4BB8F9ED  bl 0x82480850
	ctx.lr = 0x828F0E68;
	sub_82480850(ctx, base);
	// 828F0E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E6C: 4B923F6D  bl 0x82214dd8
	ctx.lr = 0x828F0E70;
	sub_82214DD8(ctx, base);
	// 828F0E70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0E74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0E78: 388B4824  addi r4, r11, 0x4824
	ctx.r[4].s64 = ctx.r[11].s64 + 18468;
	// 828F0E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E80: 4B93C051  bl 0x8222ced0
	ctx.lr = 0x828F0E84;
	sub_8222CED0(ctx, base);
	// 828F0E84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0E88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0E90: 419A0008  beq cr6, 0x828f0e98
	if ctx.cr[6].eq {
	pc = 0x828F0E98; continue 'dispatch;
	}
	// 828F0E94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0E98: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828F0E9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0EA0: 4BB8F9B1  bl 0x82480850
	ctx.lr = 0x828F0EA4;
	sub_82480850(ctx, base);
	// 828F0EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0EA8: 4B923F31  bl 0x82214dd8
	ctx.lr = 0x828F0EAC;
	sub_82214DD8(ctx, base);
	// 828F0EAC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0EB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0EB4: 388B4834  addi r4, r11, 0x4834
	ctx.r[4].s64 = ctx.r[11].s64 + 18484;
	// 828F0EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0EBC: 4B93C015  bl 0x8222ced0
	ctx.lr = 0x828F0EC0;
	sub_8222CED0(ctx, base);
	// 828F0EC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F0EC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0ECC: 419A0008  beq cr6, 0x828f0ed4
	if ctx.cr[6].eq {
	pc = 0x828F0ED4; continue 'dispatch;
	}
	// 828F0ED0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0ED4: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 828F0ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0EDC: 4BB8F8ED  bl 0x824807c8
	ctx.lr = 0x828F0EE0;
	sub_824807C8(ctx, base);
	// 828F0EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0EE4: 4B923EF5  bl 0x82214dd8
	ctx.lr = 0x828F0EE8;
	sub_82214DD8(ctx, base);
	// 828F0EE8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F0EEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0EF0: 388B4840  addi r4, r11, 0x4840
	ctx.r[4].s64 = ctx.r[11].s64 + 18496;
	// 828F0EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0EF8: 4B93BFD9  bl 0x8222ced0
	ctx.lr = 0x828F0EFC;
	sub_8222CED0(ctx, base);
	// 828F0EFC: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828F0F00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F0F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F08: 4812BF41  bl 0x82a1ce48
	ctx.lr = 0x828F0F0C;
	sub_82A1CE48(ctx, base);
	// 828F0F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F10: 4B923EC9  bl 0x82214dd8
	ctx.lr = 0x828F0F14;
	sub_82214DD8(ctx, base);
	// 828F0F14: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F0F18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0F1C: 388A4858  addi r4, r10, 0x4858
	ctx.r[4].s64 = ctx.r[10].s64 + 18520;
	// 828F0F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F24: 4B93BFAD  bl 0x8222ced0
	ctx.lr = 0x828F0F28;
	sub_8222CED0(ctx, base);
	// 828F0F28: 38BF0011  addi r5, r31, 0x11
	ctx.r[5].s64 = ctx.r[31].s64 + 17;
	// 828F0F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F0F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F34: 4812BF15  bl 0x82a1ce48
	ctx.lr = 0x828F0F38;
	sub_82A1CE48(ctx, base);
	// 828F0F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F3C: 4B923E9D  bl 0x82214dd8
	ctx.lr = 0x828F0F40;
	sub_82214DD8(ctx, base);
	// 828F0F40: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828F0F44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F0F48: 38894108  addi r4, r9, 0x4108
	ctx.r[4].s64 = ctx.r[9].s64 + 16648;
	// 828F0F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F50: 4B93BF81  bl 0x8222ced0
	ctx.lr = 0x828F0F54;
	sub_8222CED0(ctx, base);
	// 828F0F54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F0F58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F0F5C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828F0F60: 4BBC1859  bl 0x824b27b8
	ctx.lr = 0x828F0F64;
	sub_824B27B8(ctx, base);
	// 828F0F64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0F68: 4B923E71  bl 0x82214dd8
	ctx.lr = 0x828F0F6C;
	sub_82214DD8(ctx, base);
	// 828F0F6C: 5788063E  clrlwi r8, r28, 0x18
	ctx.r[8].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828F0F70: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828F0F74: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828F0F78: 98DF0012  stb r6, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[6].u8 ) };
	// 828F0F7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F0F80: 483B84D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F0F88 size=252
    let mut pc: u32 = 0x828F0F88;
    'dispatch: loop {
        match pc {
            0x828F0F88 => {
    //   block [0x828F0F88..0x828F1084)
	// 828F0F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0FA0: C05F001C  lfs f2, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F0FA4: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F0FA8: 480017C9  bl 0x828f2770
	ctx.lr = 0x828F0FAC;
	sub_828F2770(ctx, base);
	// 828F0FAC: 897F0012  lbz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 828F0FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0FB4: 419A00B8  beq cr6, 0x828f106c
	if ctx.cr[6].eq {
	pc = 0x828F106C; continue 'dispatch;
	}
	// 828F0FB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F0FBC: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 828F0FC0: 9BDF0012  stb r30, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[30].u8 ) };
	// 828F0FC4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F0FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0FCC: 41990014  bgt cr6, 0x828f0fe0
	if ctx.cr[6].gt {
	pc = 0x828F0FE0; continue 'dispatch;
	}
	// 828F0FD0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0FD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828F0FDC: 40990008  ble cr6, 0x828f0fe4
	if !ctx.cr[6].gt {
	pc = 0x828F0FE4; continue 'dispatch;
	}
	// 828F0FE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F0FE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F0FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0FEC: 419A005C  beq cr6, 0x828f1048
	if ctx.cr[6].eq {
	pc = 0x828F1048; continue 'dispatch;
	}
	// 828F0FF0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F0FF4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F0FF8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F0FFC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F1000: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1004: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1008: 4B973481  bl 0x82264488
	ctx.lr = 0x828F100C;
	sub_82264488(ctx, base);
	// 828F100C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828F1010: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F1014: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F1018: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828F101C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1020: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828F1024: 4B923875  bl 0x82214898
	ctx.lr = 0x828F1028;
	sub_82214898(ctx, base);
	// 828F1028: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F102C: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F1030: 4BBE0E99  bl 0x824d1ec8
	ctx.lr = 0x828F1034;
	sub_824D1EC8(ctx, base);
	// 828F1034: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 828F1038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F103C: 38850B7C  addi r4, r5, 0xb7c
	ctx.r[4].s64 = ctx.r[5].s64 + 2940;
	// 828F1040: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828F1044: 4B8A2DF5  bl 0x82193e38
	ctx.lr = 0x828F1048;
	sub_82193E38(ctx, base);
	// 828F1048: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F104C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1050: 419A001C  beq cr6, 0x828f106c
	if ctx.cr[6].eq {
	pc = 0x828F106C; continue 'dispatch;
	}
	// 828F1054: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F1058: 4B882DE1  bl 0x82173e38
	ctx.lr = 0x828F105C;
	sub_82173E38(ctx, base);
	// 828F105C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1060: 419A000C  beq cr6, 0x828f106c
	if ctx.cr[6].eq {
	pc = 0x828F106C; continue 'dispatch;
	}
	// 828F1064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1068: 48000761  bl 0x828f17c8
	ctx.lr = 0x828F106C;
	sub_828F17C8(ctx, base);
	// 828F106C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F107C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1088 size=64
    let mut pc: u32 = 0x828F1088;
    'dispatch: loop {
        match pc {
            0x828F1088 => {
    //   block [0x828F1088..0x828F10C8)
	// 828F1088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F108C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F1090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F1094: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F109C: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F10A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F10A4: 419A0010  beq cr6, 0x828f10b4
	if ctx.cr[6].eq {
	pc = 0x828F10B4; continue 'dispatch;
	}
	// 828F10A8: 48000F39  bl 0x828f1fe0
	ctx.lr = 0x828F10AC;
	sub_828F1FE0(ctx, base);
	// 828F10AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F10B0: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 828F10B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F10B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F10BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F10C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F10C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F10C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F10C8 size=340
    let mut pc: u32 = 0x828F10C8;
    'dispatch: loop {
        match pc {
            0x828F10C8 => {
    //   block [0x828F10C8..0x828F121C)
	// 828F10C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F10CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F10D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F10D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F10D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F10DC: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F10E0: 5528E7FE  rlwinm r8, r9, 0x1c, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 828F10E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F10E8: 419A00F8  beq cr6, 0x828f11e0
	if ctx.cr[6].eq {
	pc = 0x828F11E0; continue 'dispatch;
	}
	// 828F10EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F10F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F10F4: 419A0024  beq cr6, 0x828f1118
	if ctx.cr[6].eq {
	pc = 0x828F1118; continue 'dispatch;
	}
	// 828F10F8: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F10FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1100: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F1104: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F1108: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F110C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F1110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1114: 480000D0  b 0x828f11e4
	pc = 0x828F11E4; continue 'dispatch;
	// 828F1118: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F111C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828F1120: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1124: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828F1128: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F112C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1130: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1134: 40810054  ble 0x828f1188
	if !ctx.cr[0].gt {
	pc = 0x828F1188; continue 'dispatch;
	}
	// 828F1138: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F113C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1140: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1144: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1148: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 828F114C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1150: 41980008  blt cr6, 0x828f1158
	if ctx.cr[6].lt {
	pc = 0x828F1158; continue 'dispatch;
	}
	// 828F1154: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F1158: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F115C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1160: 419A0014  beq cr6, 0x828f1174
	if ctx.cr[6].eq {
	pc = 0x828F1174; continue 'dispatch;
	}
	// 828F1164: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1168: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F116C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1170: 4800000C  b 0x828f117c
	pc = 0x828F117C; continue 'dispatch;
	// 828F1174: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1178: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F117C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1180: 4199FFB8  bgt cr6, 0x828f1138
	if ctx.cr[6].gt {
	pc = 0x828F1138; continue 'dispatch;
	}
	// 828F1184: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1188: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F118C: 419A0040  beq cr6, 0x828f11cc
	if ctx.cr[6].eq {
	pc = 0x828F11CC; continue 'dispatch;
	}
	// 828F1190: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1194: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 828F1198: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F119C: 41990008  bgt cr6, 0x828f11a4
	if ctx.cr[6].gt {
	pc = 0x828F11A4; continue 'dispatch;
	}
	// 828F11A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F11A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F11A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F11AC: 409A0020  bne cr6, 0x828f11cc
	if !ctx.cr[6].eq {
	pc = 0x828F11CC; continue 'dispatch;
	}
	// 828F11B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F11B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F11B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F11BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F11C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F11C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F11C8: 4800001C  b 0x828f11e4
	pc = 0x828F11E4; continue 'dispatch;
	// 828F11CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F11D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F11D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F11D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F11DC: 48000008  b 0x828f11e4
	pc = 0x828F11E4; continue 'dispatch;
	// 828F11E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F11E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F11E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F11EC: 419A0020  beq cr6, 0x828f120c
	if ctx.cr[6].eq {
	pc = 0x828F120C; continue 'dispatch;
	}
	// 828F11F0: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828F11F4: 988A0131  stb r4, 0x131(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(305 as u32), ctx.r[4].u8 ) };
	// 828F11F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F11FC: 419A0010  beq cr6, 0x828f120c
	if ctx.cr[6].eq {
	pc = 0x828F120C; continue 'dispatch;
	}
	// 828F1200: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F1204: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1208: 4BD066F1  bl 0x825f78f8
	ctx.lr = 0x828F120C;
	sub_825F78F8(ctx, base);
	// 828F120C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F1210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F1220 size=68
    let mut pc: u32 = 0x828F1220;
    'dispatch: loop {
        match pc {
            0x828F1220 => {
    //   block [0x828F1220..0x828F1264)
	// 828F1220: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1224: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F1228: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F122C: 5528E7FE  rlwinm r8, r9, 0x1c, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 828F1230: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F1234: 419A00F8  beq cr6, 0x828f132c
	if ctx.cr[6].eq {
		sub_828F132C(ctx, base);
		return;
	}
	// 828F1238: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F123C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1240: 419A0024  beq cr6, 0x828f1264
	if ctx.cr[6].eq {
		sub_828F1264(ctx, base);
		return;
	}
	// 828F1244: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F1248: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F124C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F1250: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F1254: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1258: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F125C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1260: 480000D0  b 0x828f1330
	sub_828F132C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1264(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F1264 size=92
    let mut pc: u32 = 0x828F1264;
    'dispatch: loop {
        match pc {
            0x828F1264 => {
    //   block [0x828F1264..0x828F12C0)
	// 828F1264: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1268: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828F126C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1270: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 828F1274: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1278: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828F127C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1280: 40810054  ble 0x828f12d4
	if !ctx.cr[0].gt {
		sub_828F12C0(ctx, base);
		return;
	}
	// 828F1284: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1288: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F128C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1290: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1294: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 828F1298: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F129C: 41980008  blt cr6, 0x828f12a4
	if ctx.cr[6].lt {
	pc = 0x828F12A4; continue 'dispatch;
	}
	// 828F12A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F12A4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F12A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F12AC: 419A0014  beq cr6, 0x828f12c0
	if ctx.cr[6].eq {
		sub_828F12C0(ctx, base);
		return;
	}
	// 828F12B0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F12B4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F12B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F12BC: 4800000C  b 0x828f12c8
	sub_828F12C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F12C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F12C0 size=88
    let mut pc: u32 = 0x828F12C0;
    'dispatch: loop {
        match pc {
            0x828F12C0 => {
    //   block [0x828F12C0..0x828F1318)
	// 828F12C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F12C4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F12C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F12CC: 4199FFB8  bgt cr6, 0x828f1284
	if ctx.cr[6].gt {
		sub_828F1264(ctx, base);
		return;
	}
	// 828F12D0: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828F12D4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F12D8: 419A0040  beq cr6, 0x828f1318
	if ctx.cr[6].eq {
		sub_828F1318(ctx, base);
		return;
	}
	// 828F12DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F12E0: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 828F12E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F12E8: 41990008  bgt cr6, 0x828f12f0
	if ctx.cr[6].gt {
	pc = 0x828F12F0; continue 'dispatch;
	}
	// 828F12EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F12F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F12F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F12F8: 409A0020  bne cr6, 0x828f1318
	if !ctx.cr[6].eq {
		sub_828F1318(ctx, base);
		return;
	}
	// 828F12FC: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1300: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828F1304: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828F1308: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F130C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F1310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1314: 4800001C  b 0x828f1330
	sub_828F132C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F1318 size=20
    let mut pc: u32 = 0x828F1318;
    'dispatch: loop {
        match pc {
            0x828F1318 => {
    //   block [0x828F1318..0x828F132C)
	// 828F1318: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F131C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1320: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F1324: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1328: 48000008  b 0x828f1330
	sub_828F132C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F132C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F132C size=16
    let mut pc: u32 = 0x828F132C;
    'dispatch: loop {
        match pc {
            0x828F132C => {
    //   block [0x828F132C..0x828F133C)
	// 828F132C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F1330: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1338: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F133C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F133C size=8
    let mut pc: u32 = 0x828F133C;
    'dispatch: loop {
        match pc {
            0x828F133C => {
    //   block [0x828F133C..0x828F1344)
	// 828F133C: 988A0132  stb r4, 0x132(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(306 as u32), ctx.r[4].u8 ) };
	// 828F1340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F1348 size=1152
    let mut pc: u32 = 0x828F1348;
    'dispatch: loop {
        match pc {
            0x828F1348 => {
    //   block [0x828F1348..0x828F1478)
	// 828F1348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F134C: 483B80B1  bl 0x82ca93fc
	ctx.lr = 0x828F1350;
	sub_82CA93D0(ctx, base);
	// 828F1350: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828F1354: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828F1358: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F135C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1360: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F1364: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F1368: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828F136C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 828F1370: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F1374: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 828F1378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F137C: 409A0028  bne cr6, 0x828f13a4
	if !ctx.cr[6].eq {
	pc = 0x828F13A4; continue 'dispatch;
	}
	// 828F1380: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F1384: 4B882AB5  bl 0x82173e38
	ctx.lr = 0x828F1388;
	sub_82173E38(ctx, base);
	// 828F1388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F138C: 419A0018  beq cr6, 0x828f13a4
	if ctx.cr[6].eq {
	pc = 0x828F13A4; continue 'dispatch;
	}
	// 828F1390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1394: 48000435  bl 0x828f17c8
	ctx.lr = 0x828F1398;
	sub_828F17C8(ctx, base);
	// 828F1398: C01E0048  lfs f0, 0x48(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F139C: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828F13A0: 9B7F0010  stb r27, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u8 ) };
	// 828F13A4: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F13A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F13AC: 419A03F8  beq cr6, 0x828f17a4
	if ctx.cr[6].eq {
	pc = 0x828F17A4; continue 'dispatch;
	}
	// 828F13B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F13B4: 4B91643D  bl 0x822077f0
	ctx.lr = 0x828F13B8;
	sub_822077F0(ctx, base);
	// 828F13B8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828F13BC: C3FE0000  lfs f31, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F13C0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F13C4: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828F13C8: FDA10024  fdiv f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828F13CC: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F13D0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F13D4: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828F13D8: 4099001C  ble cr6, 0x828f13f4
	if !ctx.cr[6].gt {
	pc = 0x828F13F4; continue 'dispatch;
	}
	// 828F13DC: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 828F13E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828F13E4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F13E8: 4199000C  bgt cr6, 0x828f13f4
	if ctx.cr[6].gt {
	pc = 0x828F13F4; continue 'dispatch;
	}
	// 828F13EC: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828F13F0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F13F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F13F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F13FC: 419A0014  beq cr6, 0x828f1410
	if ctx.cr[6].eq {
	pc = 0x828F1410; continue 'dispatch;
	}
	// 828F1400: C01E3738  lfs f0, 0x3738(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1408: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828F140C: 48000EB5  bl 0x828f22c0
	ctx.lr = 0x828F1410;
	sub_828F22C0(ctx, base);
	// 828F1410: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1414: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828F1418: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F141C: 4099001C  ble cr6, 0x828f1438
	if !ctx.cr[6].gt {
	pc = 0x828F1438; continue 'dispatch;
	}
	// 828F1420: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 828F1424: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F1428: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F142C: 4199000C  bgt cr6, 0x828f1438
	if ctx.cr[6].gt {
	pc = 0x828F1438; continue 'dispatch;
	}
	// 828F1430: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F1434: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828F1438: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F143C: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 828F1440: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1444: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 828F1448: 419902E0  bgt cr6, 0x828f1728
	if ctx.cr[6].gt {
	pc = 0x828F1728; continue 'dispatch;
	}
	// 828F144C: 3D80828F  lis r12, -0x7d71
	ctx.r[12].s64 = -2104557568;
	// 828F1450: 398C1464  addi r12, r12, 0x1464
	ctx.r[12].s64 = ctx.r[12].s64 + 5220;
	// 828F1454: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828F1458: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828F145C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828F1460: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x828F1478; continue 'dispatch;
		},
		1 => {
	pc = 0x828F14C0; continue 'dispatch;
		},
		2 => {
	pc = 0x828F14FC; continue 'dispatch;
		},
		3 => {
	pc = 0x828F1584; continue 'dispatch;
		},
		4 => {
	pc = 0x828F1700; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 828F1464: 828F1478  lwz r20, 0x1478(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828F1468: 828F14C0  lwz r20, 0x14c0(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828F146C: 828F14FC  lwz r20, 0x14fc(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5372 as u32) ) } as u64;
	// 828F1470: 828F1584  lwz r20, 0x1584(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5508 as u32) ) } as u64;
	// 828F1474: 828F1700  lwz r20, 0x1700(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5888 as u32) ) } as u64;
            }
            0x828F1478 => {
    //   block [0x828F1478..0x828F14C0)
	// 828F1478: 895F0011  lbz r10, 0x11(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828F147C: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828F1480: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1484: 419A001C  beq cr6, 0x828f14a0
	if ctx.cr[6].eq {
	pc = 0x828F14A0; continue 'dispatch;
	}
	// 828F1488: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F148C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1490: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828F1494: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828F1498: C00B8FE8  lfs f0, -0x7018(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F149C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F14A0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F14A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F14A8: 419A0280  beq cr6, 0x828f1728
	if ctx.cr[6].eq {
	pc = 0x828F1728; continue 'dispatch;
	}
	// 828F14AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F14B0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F14B4: 9B7F0011  stb r27, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 828F14B8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828F14BC: 4800026C  b 0x828f1728
	pc = 0x828F1728; continue 'dispatch;
            }
            0x828F14C0 => {
    //   block [0x828F14C0..0x828F14FC)
	// 828F14C0: 895F0011  lbz r10, 0x11(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828F14C4: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828F14C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F14CC: 419A000C  beq cr6, 0x828f14d8
	if ctx.cr[6].eq {
	pc = 0x828F14D8; continue 'dispatch;
	}
	// 828F14D0: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F14D4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F14D8: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F14DC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F14E0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828F14E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F14E8: 419A0240  beq cr6, 0x828f1728
	if ctx.cr[6].eq {
	pc = 0x828F1728; continue 'dispatch;
	}
	// 828F14EC: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F14F0: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 828F14F4: 9B7F0011  stb r27, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 828F14F8: 48000230  b 0x828f1728
	pc = 0x828F1728; continue 'dispatch;
            }
            0x828F14FC => {
    //   block [0x828F14FC..0x828F1584)
	// 828F14FC: 895F0011  lbz r10, 0x11(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828F1500: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828F1504: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1508: 419A005C  beq cr6, 0x828f1564
	if ctx.cr[6].eq {
	pc = 0x828F1564; continue 'dispatch;
	}
	// 828F150C: C01EFE48  lfs f0, -0x1b8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1510: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F1514: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F1518: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F151C: 388B4868  addi r4, r11, 0x4868
	ctx.r[4].s64 = ctx.r[11].s64 + 18536;
	// 828F1520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1524: 4B93B9AD  bl 0x8222ced0
	ctx.lr = 0x828F1528;
	sub_8222CED0(ctx, base);
	// 828F1528: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F152C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F1530: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F1534: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1538: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F153C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828F1540: 4E800421  bctrl
	ctx.lr = 0x828F1544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1544: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828F1548: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F154C: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F1550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            0x828F1584 => {
    //   block [0x828F1584..0x828F1700)
	// 828F1584: 895F0011  lbz r10, 0x11(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828F1588: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828F158C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1590: 419A0150  beq cr6, 0x828f16e0
	if ctx.cr[6].eq {
	pc = 0x828F16E0; continue 'dispatch;
	}
	// 828F1594: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828F1598: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F159C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 828F15A0: C01E3710  lfs f0, 0x3710(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F15A4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828F15A8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828F15AC: C0096D88  lfs f0, 0x6d88(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F15B0: C1A88FE8  lfs f13, -0x7018(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-28696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F15B4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828F15B8: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F15BC: 80EB003C  lwz r7, 0x3c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F15C0: 54E697FE  rlwinm r6, r7, 0x12, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00003FFFu64;
	// 828F15C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828F15C8: 419A00F4  beq cr6, 0x828f16bc
	if ctx.cr[6].eq {
	pc = 0x828F16BC; continue 'dispatch;
	}
	// 828F15CC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F15D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F15D4: 419A0024  beq cr6, 0x828f15f8
	if ctx.cr[6].eq {
	pc = 0x828F15F8; continue 'dispatch;
	}
	// 828F15D8: 894A00CE  lbz r10, 0xce(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(206 as u32) ) } as u64;
	// 828F15DC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F15E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F15E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F15E8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F15EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F15F0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F15F4: 480000CC  b 0x828f16c0
	pc = 0x828F16C0; continue 'dispatch;
	// 828F15F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F15FC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1600: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1604: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1608: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F160C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1610: 40810054  ble 0x828f1664
	if !ctx.cr[0].gt {
	pc = 0x828F1664; continue 'dispatch;
	}
	// 828F1614: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1618: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F161C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1620: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1624: 2F0700CE  cmpwi cr6, r7, 0xce
	ctx.cr[6].compare_i32(ctx.r[7].s32, 206, &mut ctx.xer);
	// 828F1628: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828F162C: 41980008  blt cr6, 0x828f1634
	if ctx.cr[6].lt {
	pc = 0x828F1634; continue 'dispatch;
	}
	// 828F1630: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F1634: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1638: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F163C: 419A0014  beq cr6, 0x828f1650
	if ctx.cr[6].eq {
	pc = 0x828F1650; continue 'dispatch;
	}
	// 828F1640: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1644: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1648: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F164C: 4800000C  b 0x828f1658
	pc = 0x828F1658; continue 'dispatch;
	// 828F1650: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1654: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1658: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F165C: 4199FFB8  bgt cr6, 0x828f1614
	if ctx.cr[6].gt {
	pc = 0x828F1614; continue 'dispatch;
	}
	// 828F1660: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1664: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F1668: 419A0040  beq cr6, 0x828f16a8
	if ctx.cr[6].eq {
	pc = 0x828F16A8; continue 'dispatch;
	}
	// 828F166C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1670: 2F0B00CE  cmpwi cr6, r11, 0xce
	ctx.cr[6].compare_i32(ctx.r[11].s32, 206, &mut ctx.xer);
	// 828F1674: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F1678: 41990008  bgt cr6, 0x828f1680
	if ctx.cr[6].gt {
	pc = 0x828F1680; continue 'dispatch;
	}
	// 828F167C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1680: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1688: 409A0020  bne cr6, 0x828f16a8
	if !ctx.cr[6].eq {
	pc = 0x828F16A8; continue 'dispatch;
	}
	// 828F168C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1690: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1694: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1698: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F169C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F16A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F16A4: 4800001C  b 0x828f16c0
	pc = 0x828F16C0; continue 'dispatch;
	// 828F16A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F16AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F16B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828F16B4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F16B8: 48000008  b 0x828f16c0
	pc = 0x828F16C0; continue 'dispatch;
	// 828F16BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F16C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F16C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F16C8: 419A0018  beq cr6, 0x828f16e0
	if ctx.cr[6].eq {
	pc = 0x828F16E0; continue 'dispatch;
	}
	// 828F16CC: 896A0042  lbz r11, 0x42(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(66 as u32) ) } as u64;
	// 828F16D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F16D4: 409A000C  bne cr6, 0x828f16e0
	if !ctx.cr[6].eq {
	pc = 0x828F16E0; continue 'dispatch;
	}
	// 828F16D8: C01EFE50  lfs f0, -0x1b0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F16DC: D00A0048  stfs f0, 0x48(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828F16E0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F16E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F16E8: 419A0040  beq cr6, 0x828f1728
	if ctx.cr[6].eq {
	pc = 0x828F1728; continue 'dispatch;
	}
	// 828F16EC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828F16F0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F16F4: 9B7F0011  stb r27, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 828F16F8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828F16FC: 4800002C  b 0x828f1728
	pc = 0x828F1728; continue 'dispatch;
            }
            0x828F1700 => {
    //   block [0x828F1700..0x828F17C8)
	// 828F1700: 895F0011  lbz r10, 0x11(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828F1704: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828F1708: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F170C: 419A000C  beq cr6, 0x828f1718
	if ctx.cr[6].eq {
	pc = 0x828F1718; continue 'dispatch;
	}
	// 828F1710: C01E1FFC  lfs f0, 0x1ffc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1714: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F1718: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F171C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1720: 419A0008  beq cr6, 0x828f1728
	if ctx.cr[6].eq {
	pc = 0x828F1728; continue 'dispatch;
	}
	// 828F1724: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 828F1728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F172C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F1730: 48000F69  bl 0x828f2698
	ctx.lr = 0x828F1734;
	sub_828F2698(ctx, base);
	// 828F1734: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F1738: 4B882701  bl 0x82173e38
	ctx.lr = 0x828F173C;
	sub_82173E38(ctx, base);
	// 828F173C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1740: 419A0018  beq cr6, 0x828f1758
	if ctx.cr[6].eq {
	pc = 0x828F1758; continue 'dispatch;
	}
	// 828F1744: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F1748: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F174C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F1750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1754: 409A0008  bne cr6, 0x828f175c
	if !ctx.cr[6].eq {
	pc = 0x828F175C; continue 'dispatch;
	}
	// 828F1758: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F175C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1764: 409A0040  bne cr6, 0x828f17a4
	if !ctx.cr[6].eq {
	pc = 0x828F17A4; continue 'dispatch;
	}
	// 828F1768: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F176C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828F1770: 419A0018  beq cr6, 0x828f1788
	if ctx.cr[6].eq {
	pc = 0x828F1788; continue 'dispatch;
	}
	// 828F1774: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828F1778: 419A0010  beq cr6, 0x828f1788
	if ctx.cr[6].eq {
	pc = 0x828F1788; continue 'dispatch;
	}
	// 828F177C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828F1780: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1784: 409A0008  bne cr6, 0x828f178c
	if !ctx.cr[6].eq {
	pc = 0x828F178C; continue 'dispatch;
	}
	// 828F1788: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F178C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1794: 409A0010  bne cr6, 0x828f17a4
	if !ctx.cr[6].eq {
	pc = 0x828F17A4; continue 'dispatch;
	}
	// 828F1798: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F179C: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 828F17A0: 9B7F0011  stb r27, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 828F17A4: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828F17A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F17AC: 419A000C  beq cr6, 0x828f17b8
	if ctx.cr[6].eq {
	pc = 0x828F17B8; continue 'dispatch;
	}
	// 828F17B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F17B4: 4BA9C075  bl 0x8238d828
	ctx.lr = 0x828F17B8;
	sub_8238D828(ctx, base);
	// 828F17B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F17BC: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828F17C0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828F17C4: 483B7C88  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F17C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F17C8 size=2068
    let mut pc: u32 = 0x828F17C8;
    'dispatch: loop {
        match pc {
            0x828F17C8 => {
    //   block [0x828F17C8..0x828F1FDC)
	// 828F17C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F17CC: 483B7C39  bl 0x82ca9404
	ctx.lr = 0x828F17D0;
	sub_82CA93D0(ctx, base);
	// 828F17D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F17D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F17D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F17DC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F17E0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F17E4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F17E8: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828F17EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F17F0: 419A00F4  beq cr6, 0x828f18e4
	if ctx.cr[6].eq {
	pc = 0x828F18E4; continue 'dispatch;
	}
	// 828F17F4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F17F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F17FC: 419A0024  beq cr6, 0x828f1820
	if ctx.cr[6].eq {
	pc = 0x828F1820; continue 'dispatch;
	}
	// 828F1800: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F1804: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1808: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F180C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F1810: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1814: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F181C: 480000CC  b 0x828f18e8
	pc = 0x828F18E8; continue 'dispatch;
	// 828F1820: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1824: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1828: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F182C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1830: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1834: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1838: 40810054  ble 0x828f188c
	if !ctx.cr[0].gt {
	pc = 0x828F188C; continue 'dispatch;
	}
	// 828F183C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1840: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1844: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828F1848: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F184C: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828F1850: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1854: 41980008  blt cr6, 0x828f185c
	if ctx.cr[6].lt {
	pc = 0x828F185C; continue 'dispatch;
	}
	// 828F1858: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F185C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1860: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1864: 419A0014  beq cr6, 0x828f1878
	if ctx.cr[6].eq {
	pc = 0x828F1878; continue 'dispatch;
	}
	// 828F1868: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F186C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1870: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1874: 4800000C  b 0x828f1880
	pc = 0x828F1880; continue 'dispatch;
	// 828F1878: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F187C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1880: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1884: 4199FFB8  bgt cr6, 0x828f183c
	if ctx.cr[6].gt {
	pc = 0x828F183C; continue 'dispatch;
	}
	// 828F1888: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F188C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F1890: 419A0040  beq cr6, 0x828f18d0
	if ctx.cr[6].eq {
	pc = 0x828F18D0; continue 'dispatch;
	}
	// 828F1894: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1898: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828F189C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F18A0: 41990008  bgt cr6, 0x828f18a8
	if ctx.cr[6].gt {
	pc = 0x828F18A8; continue 'dispatch;
	}
	// 828F18A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F18A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F18AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F18B0: 409A0020  bne cr6, 0x828f18d0
	if !ctx.cr[6].eq {
	pc = 0x828F18D0; continue 'dispatch;
	}
	// 828F18B4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F18B8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F18BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F18C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F18C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F18C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F18CC: 4800001C  b 0x828f18e8
	pc = 0x828F18E8; continue 'dispatch;
	// 828F18D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F18D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F18D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F18DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F18E0: 48000008  b 0x828f18e8
	pc = 0x828F18E8; continue 'dispatch;
	// 828F18E4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F18E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F18EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F18F0: 419A0018  beq cr6, 0x828f1908
	if ctx.cr[6].eq {
	pc = 0x828F1908; continue 'dispatch;
	}
	// 828F18F4: 387B003C  addi r3, r27, 0x3c
	ctx.r[3].s64 = ctx.r[27].s64 + 60;
	// 828F18F8: 4B882541  bl 0x82173e38
	ctx.lr = 0x828F18FC;
	sub_82173E38(ctx, base);
	// 828F18FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F1900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1904: 4BAB6F6D  bl 0x823a8870
	ctx.lr = 0x828F1908;
	sub_823A8870(ctx, base);
	// 828F1908: 817B0040  lwz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F190C: 3BDB003C  addi r30, r27, 0x3c
	ctx.r[30].s64 = ctx.r[27].s64 + 60;
	// 828F1910: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F1914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1918: 419A0020  beq cr6, 0x828f1938
	if ctx.cr[6].eq {
	pc = 0x828F1938; continue 'dispatch;
	}
	// 828F191C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1920: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1924: 419A000C  beq cr6, 0x828f1930
	if ctx.cr[6].eq {
	pc = 0x828F1930; continue 'dispatch;
	}
	// 828F1928: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F192C: 48000010  b 0x828f193c
	pc = 0x828F193C; continue 'dispatch;
	// 828F1930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1934: 4B8A2505  bl 0x82193e38
	ctx.lr = 0x828F1938;
	sub_82193E38(ctx, base);
	// 828F1938: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F193C: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F1940: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828F1944: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1948: 419A00F4  beq cr6, 0x828f1a3c
	if ctx.cr[6].eq {
	pc = 0x828F1A3C; continue 'dispatch;
	}
	// 828F194C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1950: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1954: 419A0024  beq cr6, 0x828f1978
	if ctx.cr[6].eq {
	pc = 0x828F1978; continue 'dispatch;
	}
	// 828F1958: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F195C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1960: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F1964: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F1968: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F196C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1970: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1974: 480000CC  b 0x828f1a40
	pc = 0x828F1A40; continue 'dispatch;
	// 828F1978: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F197C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1980: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1984: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1988: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F198C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1990: 40810054  ble 0x828f19e4
	if !ctx.cr[0].gt {
	pc = 0x828F19E4; continue 'dispatch;
	}
	// 828F1994: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1998: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F199C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828F19A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F19A4: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 828F19A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F19AC: 41980008  blt cr6, 0x828f19b4
	if ctx.cr[6].lt {
	pc = 0x828F19B4; continue 'dispatch;
	}
	// 828F19B0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F19B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F19B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F19BC: 419A0014  beq cr6, 0x828f19d0
	if ctx.cr[6].eq {
	pc = 0x828F19D0; continue 'dispatch;
	}
	// 828F19C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F19C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F19C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F19CC: 4800000C  b 0x828f19d8
	pc = 0x828F19D8; continue 'dispatch;
	// 828F19D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F19D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F19D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F19DC: 4199FFB8  bgt cr6, 0x828f1994
	if ctx.cr[6].gt {
	pc = 0x828F1994; continue 'dispatch;
	}
	// 828F19E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F19E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F19E8: 419A0040  beq cr6, 0x828f1a28
	if ctx.cr[6].eq {
	pc = 0x828F1A28; continue 'dispatch;
	}
	// 828F19EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F19F0: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 828F19F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F19F8: 41990008  bgt cr6, 0x828f1a00
	if ctx.cr[6].gt {
	pc = 0x828F1A00; continue 'dispatch;
	}
	// 828F19FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1A00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1A08: 409A0020  bne cr6, 0x828f1a28
	if !ctx.cr[6].eq {
	pc = 0x828F1A28; continue 'dispatch;
	}
	// 828F1A0C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1A10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1A14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1A18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A1C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1A20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1A24: 4800001C  b 0x828f1a40
	pc = 0x828F1A40; continue 'dispatch;
	// 828F1A28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F1A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A30: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1A34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1A38: 48000008  b 0x828f1a40
	pc = 0x828F1A40; continue 'dispatch;
	// 828F1A3C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1A40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1A48: 419A0010  beq cr6, 0x828f1a58
	if ctx.cr[6].eq {
	pc = 0x828F1A58; continue 'dispatch;
	}
	// 828F1A4C: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 828F1A50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F1A54: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 828F1A58: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1A60: 419A0020  beq cr6, 0x828f1a80
	if ctx.cr[6].eq {
	pc = 0x828F1A80; continue 'dispatch;
	}
	// 828F1A64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1A68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1A6C: 419A000C  beq cr6, 0x828f1a78
	if ctx.cr[6].eq {
	pc = 0x828F1A78; continue 'dispatch;
	}
	// 828F1A70: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828F1A74: 48000010  b 0x828f1a84
	pc = 0x828F1A84; continue 'dispatch;
	// 828F1A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1A7C: 4B8A23BD  bl 0x82193e38
	ctx.lr = 0x828F1A80;
	sub_82193E38(ctx, base);
	// 828F1A80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F1A84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F1A88: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A8C: 4BCD63C5  bl 0x825c7e50
	ctx.lr = 0x828F1A90;
	sub_825C7E50(ctx, base);
	// 828F1A90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1A98: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1A9C: 419A0020  beq cr6, 0x828f1abc
	if ctx.cr[6].eq {
	pc = 0x828F1ABC; continue 'dispatch;
	}
	// 828F1AA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1AA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1AA8: 419A000C  beq cr6, 0x828f1ab4
	if ctx.cr[6].eq {
	pc = 0x828F1AB4; continue 'dispatch;
	}
	// 828F1AAC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828F1AB0: 48000010  b 0x828f1ac0
	pc = 0x828F1AC0; continue 'dispatch;
	// 828F1AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1AB8: 4B8A2381  bl 0x82193e38
	ctx.lr = 0x828F1ABC;
	sub_82193E38(ctx, base);
	// 828F1ABC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F1AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F1AC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1AC8: 4BCD6389  bl 0x825c7e50
	ctx.lr = 0x828F1ACC;
	sub_825C7E50(ctx, base);
	// 828F1ACC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1AD0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828F1AD4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F1AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1ADC: 419A0020  beq cr6, 0x828f1afc
	if ctx.cr[6].eq {
	pc = 0x828F1AFC; continue 'dispatch;
	}
	// 828F1AE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1AE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1AE8: 419A000C  beq cr6, 0x828f1af4
	if ctx.cr[6].eq {
	pc = 0x828F1AF4; continue 'dispatch;
	}
	// 828F1AEC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F1AF0: 48000010  b 0x828f1b00
	pc = 0x828F1B00; continue 'dispatch;
	// 828F1AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1AF8: 4B8A2341  bl 0x82193e38
	ctx.lr = 0x828F1AFC;
	sub_82193E38(ctx, base);
	// 828F1AFC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1B00: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F1B04: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828F1B08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1B0C: 419A00F4  beq cr6, 0x828f1c00
	if ctx.cr[6].eq {
	pc = 0x828F1C00; continue 'dispatch;
	}
	// 828F1B10: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1B14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1B18: 419A0024  beq cr6, 0x828f1b3c
	if ctx.cr[6].eq {
	pc = 0x828F1B3C; continue 'dispatch;
	}
	// 828F1B1C: 894A0085  lbz r10, 0x85(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 828F1B20: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1B24: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F1B28: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F1B2C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1B30: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828F1B34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1B38: 480000CC  b 0x828f1c04
	pc = 0x828F1C04; continue 'dispatch;
	// 828F1B3C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1B40: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1B44: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1B48: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1B4C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1B50: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1B54: 40810054  ble 0x828f1ba8
	if !ctx.cr[0].gt {
	pc = 0x828F1BA8; continue 'dispatch;
	}
	// 828F1B58: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1B5C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1B60: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828F1B64: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1B68: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828F1B6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1B70: 41980008  blt cr6, 0x828f1b78
	if ctx.cr[6].lt {
	pc = 0x828F1B78; continue 'dispatch;
	}
	// 828F1B74: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F1B78: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1B7C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1B80: 419A0014  beq cr6, 0x828f1b94
	if ctx.cr[6].eq {
	pc = 0x828F1B94; continue 'dispatch;
	}
	// 828F1B84: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1B88: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1B8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1B90: 4800000C  b 0x828f1b9c
	pc = 0x828F1B9C; continue 'dispatch;
	// 828F1B94: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1B98: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1B9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1BA0: 4199FFB8  bgt cr6, 0x828f1b58
	if ctx.cr[6].gt {
	pc = 0x828F1B58; continue 'dispatch;
	}
	// 828F1BA4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1BA8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F1BAC: 419A0040  beq cr6, 0x828f1bec
	if ctx.cr[6].eq {
	pc = 0x828F1BEC; continue 'dispatch;
	}
	// 828F1BB0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1BB4: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828F1BB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1BBC: 41990008  bgt cr6, 0x828f1bc4
	if ctx.cr[6].gt {
	pc = 0x828F1BC4; continue 'dispatch;
	}
	// 828F1BC0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1BC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1BCC: 409A0020  bne cr6, 0x828f1bec
	if !ctx.cr[6].eq {
	pc = 0x828F1BEC; continue 'dispatch;
	}
	// 828F1BD0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1BD4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1BD8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1BDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1BE0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828F1BE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1BE8: 4800001C  b 0x828f1c04
	pc = 0x828F1C04; continue 'dispatch;
	// 828F1BEC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F1BF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1BF4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828F1BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1BFC: 48000008  b 0x828f1c04
	pc = 0x828F1C04; continue 'dispatch;
	// 828F1C00: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1C04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1C0C: 419A0124  beq cr6, 0x828f1d30
	if ctx.cr[6].eq {
	pc = 0x828F1D30; continue 'dispatch;
	}
	// 828F1C10: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1C14: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F1C18: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828F1C1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1C20: 419A00F4  beq cr6, 0x828f1d14
	if ctx.cr[6].eq {
	pc = 0x828F1D14; continue 'dispatch;
	}
	// 828F1C24: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1C28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1C2C: 419A0024  beq cr6, 0x828f1c50
	if ctx.cr[6].eq {
	pc = 0x828F1C50; continue 'dispatch;
	}
	// 828F1C30: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 828F1C34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1C38: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828F1C3C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F1C40: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1C44: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1C48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1C4C: 480000CC  b 0x828f1d18
	pc = 0x828F1D18; continue 'dispatch;
	// 828F1C50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1C54: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1C58: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1C5C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1C60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1C64: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1C68: 40810054  ble 0x828f1cbc
	if !ctx.cr[0].gt {
	pc = 0x828F1CBC; continue 'dispatch;
	}
	// 828F1C6C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1C70: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1C74: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1C78: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1C7C: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828F1C80: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1C84: 41980008  blt cr6, 0x828f1c8c
	if ctx.cr[6].lt {
	pc = 0x828F1C8C; continue 'dispatch;
	}
	// 828F1C88: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F1C8C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1C90: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1C94: 419A0014  beq cr6, 0x828f1ca8
	if ctx.cr[6].eq {
	pc = 0x828F1CA8; continue 'dispatch;
	}
	// 828F1C98: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1C9C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1CA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1CA4: 4800000C  b 0x828f1cb0
	pc = 0x828F1CB0; continue 'dispatch;
	// 828F1CA8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1CAC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1CB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1CB4: 4199FFB8  bgt cr6, 0x828f1c6c
	if ctx.cr[6].gt {
	pc = 0x828F1C6C; continue 'dispatch;
	}
	// 828F1CB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1CBC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F1CC0: 419A0040  beq cr6, 0x828f1d00
	if ctx.cr[6].eq {
	pc = 0x828F1D00; continue 'dispatch;
	}
	// 828F1CC4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1CC8: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828F1CCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1CD0: 41990008  bgt cr6, 0x828f1cd8
	if ctx.cr[6].gt {
	pc = 0x828F1CD8; continue 'dispatch;
	}
	// 828F1CD4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1CD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1CE0: 409A0020  bne cr6, 0x828f1d00
	if !ctx.cr[6].eq {
	pc = 0x828F1D00; continue 'dispatch;
	}
	// 828F1CE4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1CE8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1CEC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1CF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1CF4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1CF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1CFC: 4800001C  b 0x828f1d18
	pc = 0x828F1D18; continue 'dispatch;
	// 828F1D00: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F1D04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1D08: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F1D0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1D10: 48000008  b 0x828f1d18
	pc = 0x828F1D18; continue 'dispatch;
	// 828F1D14: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1D18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1D20: 419A0010  beq cr6, 0x828f1d30
	if ctx.cr[6].eq {
	pc = 0x828F1D30; continue 'dispatch;
	}
	// 828F1D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1D28: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F1D2C: 4BBE0CE5  bl 0x824d2a10
	ctx.lr = 0x828F1D30;
	sub_824D2A10(ctx, base);
	// 828F1D30: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1D34: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828F1D38: 388A8F14  addi r4, r10, -0x70ec
	ctx.r[4].s64 = ctx.r[10].s64 + -28908;
	// 828F1D3C: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F1D40: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1D44: 8109006C  lwz r8, 0x6c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F1D48: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828F1D4C: 4E800421  bctrl
	ctx.lr = 0x828F1D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1D50: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1D54: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1D58: 80E60028  lwz r7, 0x28(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F1D5C: 54E527FE  rlwinm r5, r7, 4, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x0FFFFFFFu64;
	// 828F1D60: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828F1D64: 419A00E4  beq cr6, 0x828f1e48
	if ctx.cr[6].eq {
	pc = 0x828F1E48; continue 'dispatch;
	}
	// 828F1D68: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1D6C: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1D74: 419A001C  beq cr6, 0x828f1d90
	if ctx.cr[6].eq {
	pc = 0x828F1D90; continue 'dispatch;
	}
	// 828F1D78: 896B003C  lbz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F1D7C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828F1D80: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F1D84: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1D88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1D8C: 480000C0  b 0x828f1e4c
	pc = 0x828F1E4C; continue 'dispatch;
	// 828F1D90: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1D94: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1D98: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828F1D9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1DA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1DA4: 40810054  ble 0x828f1df8
	if !ctx.cr[0].gt {
	pc = 0x828F1DF8; continue 'dispatch;
	}
	// 828F1DA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1DAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1DB0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1DB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1DB8: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 828F1DBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1DC0: 41980008  blt cr6, 0x828f1dc8
	if ctx.cr[6].lt {
	pc = 0x828F1DC8; continue 'dispatch;
	}
	// 828F1DC4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F1DC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1DCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1DD0: 419A0014  beq cr6, 0x828f1de4
	if ctx.cr[6].eq {
	pc = 0x828F1DE4; continue 'dispatch;
	}
	// 828F1DD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1DD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1DDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1DE0: 4800000C  b 0x828f1dec
	pc = 0x828F1DEC; continue 'dispatch;
	// 828F1DE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1DE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1DEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1DF0: 4199FFB8  bgt cr6, 0x828f1da8
	if ctx.cr[6].gt {
	pc = 0x828F1DA8; continue 'dispatch;
	}
	// 828F1DF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1DF8: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828F1DFC: 419A003C  beq cr6, 0x828f1e38
	if ctx.cr[6].eq {
	pc = 0x828F1E38; continue 'dispatch;
	}
	// 828F1E00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1E04: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 828F1E08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1E0C: 41990008  bgt cr6, 0x828f1e14
	if ctx.cr[6].gt {
	pc = 0x828F1E14; continue 'dispatch;
	}
	// 828F1E10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1E14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1E1C: 409A001C  bne cr6, 0x828f1e38
	if !ctx.cr[6].eq {
	pc = 0x828F1E38; continue 'dispatch;
	}
	// 828F1E20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1E24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1E28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1E2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1E30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1E34: 48000018  b 0x828f1e4c
	pc = 0x828F1E4C; continue 'dispatch;
	// 828F1E38: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828F1E3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1E40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1E44: 48000008  b 0x828f1e4c
	pc = 0x828F1E4C; continue 'dispatch;
	// 828F1E48: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828F1E4C: 5549063E  clrlwi r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F1E50: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828F1E54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1E58: 38AA9484  addi r5, r10, -0x6b7c
	ctx.r[5].s64 = ctx.r[10].s64 + -27516;
	// 828F1E5C: 419A0020  beq cr6, 0x828f1e7c
	if ctx.cr[6].eq {
	pc = 0x828F1E7C; continue 'dispatch;
	}
	// 828F1E60: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828F1E64: C0051FE8  lfs f0, 0x1fe8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1E68: 892AEB29  lbz r9, -0x14d7(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-5335 as u32) ) } as u64;
	// 828F1E6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1E70: 419A0008  beq cr6, 0x828f1e78
	if ctx.cr[6].eq {
	pc = 0x828F1E78; continue 'dispatch;
	}
	// 828F1E74: C005FE54  lfs f0, -0x1ac(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1E78: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828F1E7C: 81460028  lwz r10, 0x28(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F1E80: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1E84: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828F1E88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F1E8C: 419A00E4  beq cr6, 0x828f1f70
	if ctx.cr[6].eq {
	pc = 0x828F1F70; continue 'dispatch;
	}
	// 828F1E90: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1E94: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F1E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1E9C: 419A001C  beq cr6, 0x828f1eb8
	if ctx.cr[6].eq {
	pc = 0x828F1EB8; continue 'dispatch;
	}
	// 828F1EA0: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828F1EA4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828F1EA8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F1EAC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1EB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1EB4: 480000C0  b 0x828f1f74
	pc = 0x828F1F74; continue 'dispatch;
	// 828F1EB8: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F1EBC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F1EC0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F1EC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1EC8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1ECC: 40810054  ble 0x828f1f20
	if !ctx.cr[0].gt {
	pc = 0x828F1F20; continue 'dispatch;
	}
	// 828F1ED0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F1ED4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F1ED8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F1EDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1EE0: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828F1EE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F1EE8: 41980008  blt cr6, 0x828f1ef0
	if ctx.cr[6].lt {
	pc = 0x828F1EF0; continue 'dispatch;
	}
	// 828F1EEC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F1EF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F1EF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F1EF8: 419A0014  beq cr6, 0x828f1f0c
	if ctx.cr[6].eq {
	pc = 0x828F1F0C; continue 'dispatch;
	}
	// 828F1EFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F1F00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F1F04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F1F08: 4800000C  b 0x828f1f14
	pc = 0x828F1F14; continue 'dispatch;
	// 828F1F0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F1F10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F1F14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F1F18: 4199FFB8  bgt cr6, 0x828f1ed0
	if ctx.cr[6].gt {
	pc = 0x828F1ED0; continue 'dispatch;
	}
	// 828F1F1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F1F20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F1F24: 419A003C  beq cr6, 0x828f1f60
	if ctx.cr[6].eq {
	pc = 0x828F1F60; continue 'dispatch;
	}
	// 828F1F28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1F2C: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828F1F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F1F34: 41990008  bgt cr6, 0x828f1f3c
	if ctx.cr[6].gt {
	pc = 0x828F1F3C; continue 'dispatch;
	}
	// 828F1F38: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F1F3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F1F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1F44: 409A001C  bne cr6, 0x828f1f60
	if !ctx.cr[6].eq {
	pc = 0x828F1F60; continue 'dispatch;
	}
	// 828F1F48: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F1F4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1F50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F1F54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1F58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1F5C: 48000018  b 0x828f1f74
	pc = 0x828F1F74; continue 'dispatch;
	// 828F1F60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F1F64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1F68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1F6C: 48000008  b 0x828f1f74
	pc = 0x828F1F74; continue 'dispatch;
	// 828F1F70: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828F1F74: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F1F78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1F7C: 419A004C  beq cr6, 0x828f1fc8
	if ctx.cr[6].eq {
	pc = 0x828F1FC8; continue 'dispatch;
	}
	// 828F1F80: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1F84: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F1F88: C0051FFC  lfs f0, 0x1ffc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1F8C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F1F90: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828F1F94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F1F98: 419A0030  beq cr6, 0x828f1fc8
	if ctx.cr[6].eq {
	pc = 0x828F1FC8; continue 'dispatch;
	}
	// 828F1F9C: 816A007C  lwz r11, 0x7c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F1FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1FA4: 419A0024  beq cr6, 0x828f1fc8
	if ctx.cr[6].eq {
	pc = 0x828F1FC8; continue 'dispatch;
	}
	// 828F1FA8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1FAC: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F1FB0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828F1FB4: 41980008  blt cr6, 0x828f1fbc
	if ctx.cr[6].lt {
	pc = 0x828F1FBC; continue 'dispatch;
	}
	// 828F1FB8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 828F1FBC: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 828F1FC0: 409AFFF0  bne cr6, 0x828f1fb0
	if !ctx.cr[6].eq {
	pc = 0x828F1FB0; continue 'dispatch;
	}
	// 828F1FC4: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828F1FC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1FCC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F1FD0: 480001C9  bl 0x828f2198
	ctx.lr = 0x828F1FD4;
	sub_828F2198(ctx, base);
	// 828F1FD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F1FD8: 483B747C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1FE0 size=440
    let mut pc: u32 = 0x828F1FE0;
    'dispatch: loop {
        match pc {
            0x828F1FE0 => {
    //   block [0x828F1FE0..0x828F2198)
	// 828F1FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1FE4: 483B7429  bl 0x82ca940c
	ctx.lr = 0x828F1FE8;
	sub_82CA93D0(ctx, base);
	// 828F1FE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1FEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1FF0: 3BDD003C  addi r30, r29, 0x3c
	ctx.r[30].s64 = ctx.r[29].s64 + 60;
	// 828F1FF4: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F1FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1FFC: 419A0194  beq cr6, 0x828f2190
	if ctx.cr[6].eq {
	pc = 0x828F2190; continue 'dispatch;
	}
	// 828F2000: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2008: 419A0058  beq cr6, 0x828f2060
	if ctx.cr[6].eq {
	pc = 0x828F2060; continue 'dispatch;
	}
	// 828F200C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F2010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2014: 419A017C  beq cr6, 0x828f2190
	if ctx.cr[6].eq {
	pc = 0x828F2190; continue 'dispatch;
	}
	// 828F2018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F201C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F2020: 4B881E19  bl 0x82173e38
	ctx.lr = 0x828F2024;
	sub_82173E38(ctx, base);
	// 828F2024: 89630028  lbz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F2028: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828F202C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2030: 419A0104  beq cr6, 0x828f2134
	if ctx.cr[6].eq {
	pc = 0x828F2134; continue 'dispatch;
	}
	// 828F2034: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F203C: 419A0034  beq cr6, 0x828f2070
	if ctx.cr[6].eq {
	pc = 0x828F2070; continue 'dispatch;
	}
	// 828F2040: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F2044: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2048: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F204C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F2050: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2054: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2058: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F205C: 480000DC  b 0x828f2138
	pc = 0x828F2138; continue 'dispatch;
	// 828F2060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2064: 4B8A1DD5  bl 0x82193e38
	ctx.lr = 0x828F2068;
	sub_82193E38(ctx, base);
	// 828F2068: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F206C: 483B73F0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828F2070: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2074: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F2078: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828F207C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F2080: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2084: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2088: 40810054  ble 0x828f20dc
	if !ctx.cr[0].gt {
	pc = 0x828F20DC; continue 'dispatch;
	}
	// 828F208C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2090: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2094: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F2098: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F209C: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 828F20A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F20A4: 41980008  blt cr6, 0x828f20ac
	if ctx.cr[6].lt {
	pc = 0x828F20AC; continue 'dispatch;
	}
	// 828F20A8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828F20AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F20B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F20B4: 419A0014  beq cr6, 0x828f20c8
	if ctx.cr[6].eq {
	pc = 0x828F20C8; continue 'dispatch;
	}
	// 828F20B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F20BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F20C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F20C4: 4800000C  b 0x828f20d0
	pc = 0x828F20D0; continue 'dispatch;
	// 828F20C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F20CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F20D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F20D4: 4199FFB8  bgt cr6, 0x828f208c
	if ctx.cr[6].gt {
	pc = 0x828F208C; continue 'dispatch;
	}
	// 828F20D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F20DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F20E0: 419A0040  beq cr6, 0x828f2120
	if ctx.cr[6].eq {
	pc = 0x828F2120; continue 'dispatch;
	}
	// 828F20E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F20E8: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 828F20EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F20F0: 41990008  bgt cr6, 0x828f20f8
	if ctx.cr[6].gt {
	pc = 0x828F20F8; continue 'dispatch;
	}
	// 828F20F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F20F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F20FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2100: 409A0020  bne cr6, 0x828f2120
	if !ctx.cr[6].eq {
	pc = 0x828F2120; continue 'dispatch;
	}
	// 828F2104: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F2108: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F210C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F2110: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2114: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2118: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F211C: 4800001C  b 0x828f2138
	pc = 0x828F2138; continue 'dispatch;
	// 828F2120: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2124: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2128: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F212C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2130: 48000008  b 0x828f2138
	pc = 0x828F2138; continue 'dispatch;
	// 828F2134: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F2138: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F213C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2140: 419A0010  beq cr6, 0x828f2150
	if ctx.cr[6].eq {
	pc = 0x828F2150; continue 'dispatch;
	}
	// 828F2144: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 828F2148: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F214C: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 828F2150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2154: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2158: 4B881CE1  bl 0x82173e38
	ctx.lr = 0x828F215C;
	sub_82173E38(ctx, base);
	// 828F215C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2164: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F2168: 4BCD5CE9  bl 0x825c7e50
	ctx.lr = 0x828F216C;
	sub_825C7E50(ctx, base);
	// 828F216C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2170: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2174: 4B881CC5  bl 0x82173e38
	ctx.lr = 0x828F2178;
	sub_82173E38(ctx, base);
	// 828F2178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F217C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F2180: 4BCD5CD1  bl 0x825c7e50
	ctx.lr = 0x828F2184;
	sub_825C7E50(ctx, base);
	// 828F2184: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F2188: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F218C: 4800000D  bl 0x828f2198
	ctx.lr = 0x828F2190;
	sub_828F2198(ctx, base);
	// 828F2190: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F2194: 483B72C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2198 size=296
    let mut pc: u32 = 0x828F2198;
    'dispatch: loop {
        match pc {
            0x828F2198 => {
    //   block [0x828F2198..0x828F22C0)
	// 828F2198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F219C: 483B726D  bl 0x82ca9408
	ctx.lr = 0x828F21A0;
	sub_82CA93D0(ctx, base);
	// 828F21A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F21A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F21A8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828F21AC: 3BFD003C  addi r31, r29, 0x3c
	ctx.r[31].s64 = ctx.r[29].s64 + 60;
	// 828F21B0: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F21B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F21B8: 419A0020  beq cr6, 0x828f21d8
	if ctx.cr[6].eq {
	pc = 0x828F21D8; continue 'dispatch;
	}
	// 828F21BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F21C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F21C4: 419A000C  beq cr6, 0x828f21d0
	if ctx.cr[6].eq {
	pc = 0x828F21D0; continue 'dispatch;
	}
	// 828F21C8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828F21CC: 48000010  b 0x828f21dc
	pc = 0x828F21DC; continue 'dispatch;
	// 828F21D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F21D4: 4B8A1C65  bl 0x82193e38
	ctx.lr = 0x828F21D8;
	sub_82193E38(ctx, base);
	// 828F21D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F21DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F21E0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F21E4: 4BD07A55  bl 0x825f9c38
	ctx.lr = 0x828F21E8;
	sub_825F9C38(ctx, base);
	// 828F21E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F21EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F21F0: 419A0020  beq cr6, 0x828f2210
	if ctx.cr[6].eq {
	pc = 0x828F2210; continue 'dispatch;
	}
	// 828F21F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F21F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F21FC: 419A000C  beq cr6, 0x828f2208
	if ctx.cr[6].eq {
	pc = 0x828F2208; continue 'dispatch;
	}
	// 828F2200: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828F2204: 48000010  b 0x828f2214
	pc = 0x828F2214; continue 'dispatch;
	// 828F2208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F220C: 4B8A1C2D  bl 0x82193e38
	ctx.lr = 0x828F2210;
	sub_82193E38(ctx, base);
	// 828F2210: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F2214: 4BD0A825  bl 0x825fca38
	ctx.lr = 0x828F2218;
	sub_825FCA38(ctx, base);
	// 828F2218: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F221C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2224: 419A0020  beq cr6, 0x828f2244
	if ctx.cr[6].eq {
	pc = 0x828F2244; continue 'dispatch;
	}
	// 828F2228: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F222C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2230: 419A000C  beq cr6, 0x828f223c
	if ctx.cr[6].eq {
	pc = 0x828F223C; continue 'dispatch;
	}
	// 828F2234: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828F2238: 48000010  b 0x828f2248
	pc = 0x828F2248; continue 'dispatch;
	// 828F223C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2240: 4B8A1BF9  bl 0x82193e38
	ctx.lr = 0x828F2244;
	sub_82193E38(ctx, base);
	// 828F2244: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F2248: 4BD0A869  bl 0x825fcab0
	ctx.lr = 0x828F224C;
	sub_825FCAB0(ctx, base);
	// 828F224C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828F2250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2254: 409A0018  bne cr6, 0x828f226c
	if !ctx.cr[6].eq {
	pc = 0x828F226C; continue 'dispatch;
	}
	// 828F2258: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F225C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2260: 419A0058  beq cr6, 0x828f22b8
	if ctx.cr[6].eq {
	pc = 0x828F22B8; continue 'dispatch;
	}
	// 828F2264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2268: 419A0024  beq cr6, 0x828f228c
	if ctx.cr[6].eq {
	pc = 0x828F228C; continue 'dispatch;
	}
	// 828F226C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F2270: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F2274: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F2278: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F227C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2280: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2284: 4BFF37F5  bl 0x828e5a78
	ctx.lr = 0x828F2288;
	sub_828E5A78(ctx, base);
	// 828F2288: 48000020  b 0x828f22a8
	pc = 0x828F22A8; continue 'dispatch;
	// 828F228C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F2290: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F2294: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F2298: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F229C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F22A0: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F22A4: 4B939F15  bl 0x8222c1b8
	ctx.lr = 0x828F22A8;
	sub_8222C1B8(ctx, base);
	// 828F22A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F22AC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F22B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F22B4: 4BD07985  bl 0x825f9c38
	ctx.lr = 0x828F22B8;
	sub_825F9C38(ctx, base);
	// 828F22B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F22BC: 483B719C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F22C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F22C0 size=896
    let mut pc: u32 = 0x828F22C0;
    'dispatch: loop {
        match pc {
            0x828F22C0 => {
    //   block [0x828F22C0..0x828F2640)
	// 828F22C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F22C4: 483B7139  bl 0x82ca93fc
	ctx.lr = 0x828F22C8;
	sub_82CA93D0(ctx, base);
	// 828F22C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F22CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F22D0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828F22D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F22D8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F22DC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F22E0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F22E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828F22E8: 4E800421  bctrl
	ctx.lr = 0x828F22EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F22EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828F22F0: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 828F22F4: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828F22F8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 828F22FC: 936100A8  stw r27, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 828F2300: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828F2304: 936100AC  stw r27, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[27].u32 ) };
	// 828F2308: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2640 size=84
    let mut pc: u32 = 0x828F2640;
    'dispatch: loop {
        match pc {
            0x828F2640 => {
    //   block [0x828F2640..0x828F2694)
	// 828F2640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F264C: 3863003C  addi r3, r3, 0x3c
	ctx.r[3].s64 = ctx.r[3].s64 + 60;
	// 828F2650: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2658: 419A0028  beq cr6, 0x828f2680
	if ctx.cr[6].eq {
	pc = 0x828F2680; continue 'dispatch;
	}
	// 828F265C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2664: 419A0018  beq cr6, 0x828f267c
	if ctx.cr[6].eq {
	pc = 0x828F267C; continue 'dispatch;
	}
	// 828F2668: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828F266C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F2670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2678: 4E800020  blr
	return;
	// 828F267C: 4B8A17BD  bl 0x82193e38
	ctx.lr = 0x828F2680;
	sub_82193E38(ctx, base);
	// 828F2680: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F2684: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F2688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F268C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F2698 size=104
    let mut pc: u32 = 0x828F2698;
    'dispatch: loop {
        match pc {
            0x828F2698 => {
    //   block [0x828F2698..0x828F2700)
	// 828F2698: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828F269C: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F26A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F26A4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F26A8: C123001C  lfs f9, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828F26AC: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	// 828F26B0: 396BB840  addi r11, r11, -0x47c0
	ctx.r[11].s64 = ctx.r[11].s64 + -18368;
	// 828F26B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F26B8: C14A8FE8  lfs f10, -0x7018(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28696 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828F26BC: 419A0048  beq cr6, 0x828f2704
	if ctx.cr[6].eq {
		sub_828F2700(ctx, base);
		return;
	}
	// 828F26C0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828F26C4: C18BDC50  lfs f12, -0x23b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F26C8: ECED0028  fsubs f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 828F26CC: C16A6D88  lfs f11, 0x6d88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28040 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F26D0: ECCC5828  fsubs f6, f12, f11
	ctx.f[6].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 828F26D4: FCA03A10  fabs f5, f7
	ctx.f[5].u64 = ctx.f[7].u64 & !0x8000_0000_0000_0000u64;
	// 828F26D8: EC865024  fdivs f4, f6, f10
	ctx.f[4].f64 = ((ctx.f[6].f64 / ctx.f[10].f64) as f32) as f64;
	// 828F26DC: ED840072  fmuls f12, f4, f1
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[1].f64) as f32) as f64);
	// 828F26E0: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 828F26E4: 4099001C  ble cr6, 0x828f2700
	if !ctx.cr[6].gt {
		sub_828F2700(ctx, base);
		return;
	}
	// 828F26E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F26EC: 41990008  bgt cr6, 0x828f26f4
	if ctx.cr[6].gt {
	pc = 0x828F26F4; continue 'dispatch;
	}
	// 828F26F0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 828F26F4: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 828F26F8: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828F26FC: 48000008  b 0x828f2704
	sub_828F2700(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F2700 size=68
    let mut pc: u32 = 0x828F2700;
    'dispatch: loop {
        match pc {
            0x828F2700 => {
    //   block [0x828F2700..0x828F2744)
	// 828F2700: D1A30020  stfs f13, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828F2704: C1A30024  lfs f13, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F2708: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 828F270C: 419A003C  beq cr6, 0x828f2748
	if ctx.cr[6].eq {
		sub_828F2744(ctx, base);
		return;
	}
	// 828F2710: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F2714: ED8D4828  fsubs f12, f13, f9
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 828F2718: ED605024  fdivs f11, f0, f10
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 828F271C: FD406210  fabs f10, f12
	ctx.f[10].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 828F2720: EC0B0072  fmuls f0, f11, f1
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 828F2724: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 828F2728: 4099001C  ble cr6, 0x828f2744
	if !ctx.cr[6].gt {
		sub_828F2744(ctx, base);
		return;
	}
	// 828F272C: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 828F2730: 41990008  bgt cr6, 0x828f2738
	if ctx.cr[6].gt {
	pc = 0x828F2738; continue 'dispatch;
	}
	// 828F2734: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 828F2738: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 828F273C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F2740: 48000008  b 0x828f2748
	sub_828F2744(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2744(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F2744 size=28
    let mut pc: u32 = 0x828F2744;
    'dispatch: loop {
        match pc {
            0x828F2744 => {
    //   block [0x828F2744..0x828F2760)
	// 828F2744: D1A3001C  stfs f13, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F2748: C0230020  lfs f1, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F274C: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 828F2750: 409A0010  bne cr6, 0x828f2760
	if !ctx.cr[6].eq {
		sub_828F2760(ctx, base);
		return;
	}
	// 828F2754: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F2758: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 828F275C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F2760 size=8
    let mut pc: u32 = 0x828F2760;
    'dispatch: loop {
        match pc {
            0x828F2760 => {
    //   block [0x828F2760..0x828F2768)
	// 828F2760: C043001C  lfs f2, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F2764: 4800000C  b 0x828f2770
	sub_828F2770(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2768 size=4
    let mut pc: u32 = 0x828F2768;
    'dispatch: loop {
        match pc {
            0x828F2768 => {
    //   block [0x828F2768..0x828F276C)
	// 828F2768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2770 size=2020
    let mut pc: u32 = 0x828F2770;
    'dispatch: loop {
        match pc {
            0x828F2770 => {
    //   block [0x828F2770..0x828F2F54)
	// 828F2770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2774: 483B6C95  bl 0x82ca9408
	ctx.lr = 0x828F2778;
	sub_82CA93D0(ctx, base);
	// 828F2778: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828F277C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828F2780: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2784: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2788: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F278C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F2790: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F2794: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2798: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F279C: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828F27A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F27A4: 419A00F4  beq cr6, 0x828f2898
	if ctx.cr[6].eq {
	pc = 0x828F2898; continue 'dispatch;
	}
	// 828F27A8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F27AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F27B0: 419A0024  beq cr6, 0x828f27d4
	if ctx.cr[6].eq {
	pc = 0x828F27D4; continue 'dispatch;
	}
	// 828F27B4: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828F27B8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F27BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F27C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F27C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F27C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F27CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F27D0: 480000CC  b 0x828f289c
	pc = 0x828F289C; continue 'dispatch;
	// 828F27D4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F27D8: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F27DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F27E0: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828F27E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F27E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F27EC: 40810054  ble 0x828f2840
	if !ctx.cr[0].gt {
	pc = 0x828F2840; continue 'dispatch;
	}
	// 828F27F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F27F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F27F8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828F27FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2800: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828F2804: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2808: 41980008  blt cr6, 0x828f2810
	if ctx.cr[6].lt {
	pc = 0x828F2810; continue 'dispatch;
	}
	// 828F280C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2810: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2814: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2818: 419A0014  beq cr6, 0x828f282c
	if ctx.cr[6].eq {
	pc = 0x828F282C; continue 'dispatch;
	}
	// 828F281C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2820: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2824: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2828: 4800000C  b 0x828f2834
	pc = 0x828F2834; continue 'dispatch;
	// 828F282C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2830: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2834: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2838: 4199FFB8  bgt cr6, 0x828f27f0
	if ctx.cr[6].gt {
	pc = 0x828F27F0; continue 'dispatch;
	}
	// 828F283C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2840: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828F2844: 419A0040  beq cr6, 0x828f2884
	if ctx.cr[6].eq {
	pc = 0x828F2884; continue 'dispatch;
	}
	// 828F2848: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F284C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828F2850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2854: 41990008  bgt cr6, 0x828f285c
	if ctx.cr[6].gt {
	pc = 0x828F285C; continue 'dispatch;
	}
	// 828F2858: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F285C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2864: 409A0020  bne cr6, 0x828f2884
	if !ctx.cr[6].eq {
	pc = 0x828F2884; continue 'dispatch;
	}
	// 828F2868: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F286C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F2870: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F2874: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2878: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F287C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2880: 4800001C  b 0x828f289c
	pc = 0x828F289C; continue 'dispatch;
	// 828F2884: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828F2888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F288C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2890: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2894: 48000008  b 0x828f289c
	pc = 0x828F289C; continue 'dispatch;
	// 828F2898: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F289C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F28A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F28A4: 419A06A0  beq cr6, 0x828f2f44
	if ctx.cr[6].eq {
	pc = 0x828F2F44; continue 'dispatch;
	}
	// 828F28A8: 81460040  lwz r10, 0x40(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F28AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F28B0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828F28B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F28B8: 419A00E8  beq cr6, 0x828f29a0
	if ctx.cr[6].eq {
	pc = 0x828F29A0; continue 'dispatch;
	}
	// 828F28BC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F28C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F28C4: 419A0020  beq cr6, 0x828f28e4
	if ctx.cr[6].eq {
	pc = 0x828F28E4; continue 'dispatch;
	}
	// 828F28C8: 894B00E5  lbz r10, 0xe5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(229 as u32) ) } as u64;
	// 828F28CC: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F28D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F28D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F28D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F28DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F28E0: 480000C4  b 0x828f29a4
	pc = 0x828F29A4; continue 'dispatch;
	// 828F28E4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F28E8: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F28EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F28F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F28F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F28F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F28FC: 40810054  ble 0x828f2950
	if !ctx.cr[0].gt {
	pc = 0x828F2950; continue 'dispatch;
	}
	// 828F2900: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2904: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2908: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F290C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2910: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 828F2914: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2918: 41980008  blt cr6, 0x828f2920
	if ctx.cr[6].lt {
	pc = 0x828F2920; continue 'dispatch;
	}
	// 828F291C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2920: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2924: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2928: 419A0014  beq cr6, 0x828f293c
	if ctx.cr[6].eq {
	pc = 0x828F293C; continue 'dispatch;
	}
	// 828F292C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2930: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2934: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2938: 4800000C  b 0x828f2944
	pc = 0x828F2944; continue 'dispatch;
	// 828F293C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2940: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2948: 4199FFB8  bgt cr6, 0x828f2900
	if ctx.cr[6].gt {
	pc = 0x828F2900; continue 'dispatch;
	}
	// 828F294C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2950: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F2954: 419A003C  beq cr6, 0x828f2990
	if ctx.cr[6].eq {
	pc = 0x828F2990; continue 'dispatch;
	}
	// 828F2958: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F295C: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 828F2960: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2964: 41990008  bgt cr6, 0x828f296c
	if ctx.cr[6].gt {
	pc = 0x828F296C; continue 'dispatch;
	}
	// 828F2968: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F296C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2974: 409A001C  bne cr6, 0x828f2990
	if !ctx.cr[6].eq {
	pc = 0x828F2990; continue 'dispatch;
	}
	// 828F2978: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F297C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2980: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F2984: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F2988: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F298C: 48000018  b 0x828f29a4
	pc = 0x828F29A4; continue 'dispatch;
	// 828F2990: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2994: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2998: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F299C: 48000008  b 0x828f29a4
	pc = 0x828F29A4; continue 'dispatch;
	// 828F29A0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828F29A4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F29A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F29AC: 419A000C  beq cr6, 0x828f29b8
	if ctx.cr[6].eq {
	pc = 0x828F29B8; continue 'dispatch;
	}
	// 828F29B0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F29B4: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828F29B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F29BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F29C0: 4BC80861  bl 0x82573220
	ctx.lr = 0x828F29C4;
	sub_82573220(ctx, base);
	// 828F29C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F29C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F29CC: C3CB9490  lfs f30, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F29D0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F29D4: 4BC806A5  bl 0x82573078
	ctx.lr = 0x828F29D8;
	sub_82573078(ctx, base);
	// 828F29D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F29DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F29E0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F29E4: 554957FE  rlwinm r9, r10, 0xa, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x003FFFFFu64;
	// 828F29E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F29EC: 419A00F4  beq cr6, 0x828f2ae0
	if ctx.cr[6].eq {
	pc = 0x828F2AE0; continue 'dispatch;
	}
	// 828F29F0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F29F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F29F8: 419A0024  beq cr6, 0x828f2a1c
	if ctx.cr[6].eq {
	pc = 0x828F2A1C; continue 'dispatch;
	}
	// 828F29FC: 894A0016  lbz r10, 0x16(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(22 as u32) ) } as u64;
	// 828F2A00: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2A04: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F2A08: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F2A0C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2A10: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828F2A14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2A18: 480000CC  b 0x828f2ae4
	pc = 0x828F2AE4; continue 'dispatch;
	// 828F2A1C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2A20: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F2A24: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F2A28: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F2A2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2A30: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2A34: 40810054  ble 0x828f2a88
	if !ctx.cr[0].gt {
	pc = 0x828F2A88; continue 'dispatch;
	}
	// 828F2A38: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2A3C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2A40: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F2A44: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2A48: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 828F2A4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2A50: 41980008  blt cr6, 0x828f2a58
	if ctx.cr[6].lt {
	pc = 0x828F2A58; continue 'dispatch;
	}
	// 828F2A54: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2A58: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2A5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2A60: 419A0014  beq cr6, 0x828f2a74
	if ctx.cr[6].eq {
	pc = 0x828F2A74; continue 'dispatch;
	}
	// 828F2A64: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2A68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2A6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2A70: 4800000C  b 0x828f2a7c
	pc = 0x828F2A7C; continue 'dispatch;
	// 828F2A74: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2A78: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2A7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2A80: 4199FFB8  bgt cr6, 0x828f2a38
	if ctx.cr[6].gt {
	pc = 0x828F2A38; continue 'dispatch;
	}
	// 828F2A84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2A88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F2A8C: 419A0040  beq cr6, 0x828f2acc
	if ctx.cr[6].eq {
	pc = 0x828F2ACC; continue 'dispatch;
	}
	// 828F2A90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2A94: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 828F2A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2A9C: 41990008  bgt cr6, 0x828f2aa4
	if ctx.cr[6].gt {
	pc = 0x828F2AA4; continue 'dispatch;
	}
	// 828F2AA0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2AA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2AAC: 409A0020  bne cr6, 0x828f2acc
	if !ctx.cr[6].eq {
	pc = 0x828F2ACC; continue 'dispatch;
	}
	// 828F2AB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F2AB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F2AB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F2ABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2AC0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828F2AC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2AC8: 4800001C  b 0x828f2ae4
	pc = 0x828F2AE4; continue 'dispatch;
	// 828F2ACC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2AD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2AD4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828F2AD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2ADC: 48000008  b 0x828f2ae4
	pc = 0x828F2AE4; continue 'dispatch;
	// 828F2AE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2AEC: 419A0198  beq cr6, 0x828f2c84
	if ctx.cr[6].eq {
	pc = 0x828F2C84; continue 'dispatch;
	}
	// 828F2AF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F2AF4: 4BCFC92D  bl 0x825ef420
	ctx.lr = 0x828F2AF8;
	sub_825EF420(ctx, base);
	// 828F2AF8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828F2AFC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2B00: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F2B04: 419A0178  beq cr6, 0x828f2c7c
	if ctx.cr[6].eq {
	pc = 0x828F2C7C; continue 'dispatch;
	}
	// 828F2B08: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F2B0C: 4B88132D  bl 0x82173e38
	ctx.lr = 0x828F2B10;
	sub_82173E38(ctx, base);
	// 828F2B10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F2B14: 419A0018  beq cr6, 0x828f2b2c
	if ctx.cr[6].eq {
	pc = 0x828F2B2C; continue 'dispatch;
	}
	// 828F2B18: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F2B1C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2B20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2B24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2B28: 409A0008  bne cr6, 0x828f2b30
	if !ctx.cr[6].eq {
	pc = 0x828F2B30; continue 'dispatch;
	}
	// 828F2B2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2B30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2B38: 419A012C  beq cr6, 0x828f2c64
	if ctx.cr[6].eq {
	pc = 0x828F2C64; continue 'dispatch;
	}
	// 828F2B3C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F2B40: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F2B44: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828F2B48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2B4C: 419A00F0  beq cr6, 0x828f2c3c
	if ctx.cr[6].eq {
	pc = 0x828F2C3C; continue 'dispatch;
	}
	// 828F2B50: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2B54: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2B5C: 419A0020  beq cr6, 0x828f2b7c
	if ctx.cr[6].eq {
	pc = 0x828F2B7C; continue 'dispatch;
	}
	// 828F2B60: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828F2B64: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828F2B68: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F2B6C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2B70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2B78: 480000C8  b 0x828f2c40
	pc = 0x828F2C40; continue 'dispatch;
	// 828F2B7C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F2B80: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F2B84: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F2B88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2B8C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2B90: 40810054  ble 0x828f2be4
	if !ctx.cr[0].gt {
	pc = 0x828F2BE4; continue 'dispatch;
	}
	// 828F2B94: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2B98: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2B9C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F2BA0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2BA4: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828F2BA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2BAC: 41980008  blt cr6, 0x828f2bb4
	if ctx.cr[6].lt {
	pc = 0x828F2BB4; continue 'dispatch;
	}
	// 828F2BB0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2BB4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2BB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2BBC: 419A0014  beq cr6, 0x828f2bd0
	if ctx.cr[6].eq {
	pc = 0x828F2BD0; continue 'dispatch;
	}
	// 828F2BC0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2BC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2BC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2BCC: 4800000C  b 0x828f2bd8
	pc = 0x828F2BD8; continue 'dispatch;
	// 828F2BD0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2BD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2BD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2BDC: 4199FFB8  bgt cr6, 0x828f2b94
	if ctx.cr[6].gt {
	pc = 0x828F2B94; continue 'dispatch;
	}
	// 828F2BE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2BE4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F2BE8: 419A0040  beq cr6, 0x828f2c28
	if ctx.cr[6].eq {
	pc = 0x828F2C28; continue 'dispatch;
	}
	// 828F2BEC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2BF0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828F2BF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2BF8: 41990008  bgt cr6, 0x828f2c00
	if ctx.cr[6].gt {
	pc = 0x828F2C00; continue 'dispatch;
	}
	// 828F2BFC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2C00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2C08: 409A0020  bne cr6, 0x828f2c28
	if !ctx.cr[6].eq {
	pc = 0x828F2C28; continue 'dispatch;
	}
	// 828F2C0C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F2C10: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828F2C14: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F2C18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2C1C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2C20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2C24: 4800001C  b 0x828f2c40
	pc = 0x828F2C40; continue 'dispatch;
	// 828F2C28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2C2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2C30: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2C34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2C38: 48000008  b 0x828f2c40
	pc = 0x828F2C40; continue 'dispatch;
	// 828F2C3C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2C40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2C48: 419A001C  beq cr6, 0x828f2c64
	if ctx.cr[6].eq {
	pc = 0x828F2C64; continue 'dispatch;
	}
	// 828F2C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2C50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F2C54: 4BC805CD  bl 0x82573220
	ctx.lr = 0x828F2C58;
	sub_82573220(ctx, base);
	// 828F2C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2C5C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F2C60: 4BC80419  bl 0x82573078
	ctx.lr = 0x828F2C64;
	sub_82573078(ctx, base);
	// 828F2C64: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828F2C68: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F2C6C: 409A0008  bne cr6, 0x828f2c74
	if !ctx.cr[6].eq {
	pc = 0x828F2C74; continue 'dispatch;
	}
	// 828F2C70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828F2C74: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2C78: 4BFFFE88  b 0x828f2b00
	pc = 0x828F2B00; continue 'dispatch;
	// 828F2C7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F2C80: 4BD954A9  bl 0x82688128
	ctx.lr = 0x828F2C84;
	sub_82688128(ctx, base);
	// 828F2C84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2C88: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F2C8C: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F2C90: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828F2C94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F2C98: 419A00F4  beq cr6, 0x828f2d8c
	if ctx.cr[6].eq {
	pc = 0x828F2D8C; continue 'dispatch;
	}
	// 828F2C9C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2CA4: 419A0024  beq cr6, 0x828f2cc8
	if ctx.cr[6].eq {
	pc = 0x828F2CC8; continue 'dispatch;
	}
	// 828F2CA8: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F2CAC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2CB0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828F2CB4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F2CB8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2CBC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2CC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2CC4: 480000CC  b 0x828f2d90
	pc = 0x828F2D90; continue 'dispatch;
	// 828F2CC8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2CCC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F2CD0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F2CD4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F2CD8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2CDC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2CE0: 40810054  ble 0x828f2d34
	if !ctx.cr[0].gt {
	pc = 0x828F2D34; continue 'dispatch;
	}
	// 828F2CE4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2CE8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2CEC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F2CF0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2CF4: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 828F2CF8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2CFC: 41980008  blt cr6, 0x828f2d04
	if ctx.cr[6].lt {
	pc = 0x828F2D04; continue 'dispatch;
	}
	// 828F2D00: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2D04: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2D08: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2D0C: 419A0014  beq cr6, 0x828f2d20
	if ctx.cr[6].eq {
	pc = 0x828F2D20; continue 'dispatch;
	}
	// 828F2D10: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2D14: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2D18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2D1C: 4800000C  b 0x828f2d28
	pc = 0x828F2D28; continue 'dispatch;
	// 828F2D20: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2D24: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2D28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2D2C: 4199FFB8  bgt cr6, 0x828f2ce4
	if ctx.cr[6].gt {
	pc = 0x828F2CE4; continue 'dispatch;
	}
	// 828F2D30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2D34: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F2D38: 419A0040  beq cr6, 0x828f2d78
	if ctx.cr[6].eq {
	pc = 0x828F2D78; continue 'dispatch;
	}
	// 828F2D3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2D40: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 828F2D44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2D48: 41990008  bgt cr6, 0x828f2d50
	if ctx.cr[6].gt {
	pc = 0x828F2D50; continue 'dispatch;
	}
	// 828F2D4C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2D50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2D58: 409A0020  bne cr6, 0x828f2d78
	if !ctx.cr[6].eq {
	pc = 0x828F2D78; continue 'dispatch;
	}
	// 828F2D5C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F2D60: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828F2D64: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F2D68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2D6C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2D74: 4800001C  b 0x828f2d90
	pc = 0x828F2D90; continue 'dispatch;
	// 828F2D78: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2D7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2D80: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2D84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2D88: 48000008  b 0x828f2d90
	pc = 0x828F2D90; continue 'dispatch;
	// 828F2D8C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2D90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2D98: 419A01AC  beq cr6, 0x828f2f44
	if ctx.cr[6].eq {
	pc = 0x828F2F44; continue 'dispatch;
	}
	// 828F2D9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F2DA0: 4BA2DDE9  bl 0x82320b88
	ctx.lr = 0x828F2DA4;
	sub_82320B88(ctx, base);
	// 828F2DA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F2DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2DAC: 4BC0B5F5  bl 0x824fe3a0
	ctx.lr = 0x828F2DB0;
	sub_824FE3A0(ctx, base);
	// 828F2DB0: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2DB4: 83C50000  lwz r30, 0(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2DB8: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828F2DBC: 419A0178  beq cr6, 0x828f2f34
	if ctx.cr[6].eq {
	pc = 0x828F2F34; continue 'dispatch;
	}
	// 828F2DC0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F2DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2DC8: 419A0018  beq cr6, 0x828f2de0
	if ctx.cr[6].eq {
	pc = 0x828F2DE0; continue 'dispatch;
	}
	// 828F2DCC: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F2DD0: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2DD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2DD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F2DDC: 409A0008  bne cr6, 0x828f2de4
	if !ctx.cr[6].eq {
	pc = 0x828F2DE4; continue 'dispatch;
	}
	// 828F2DE0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828F2DE4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F2DE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2DEC: 419A0134  beq cr6, 0x828f2f20
	if ctx.cr[6].eq {
	pc = 0x828F2F20; continue 'dispatch;
	}
	// 828F2DF0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F2DF4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828F2DF8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828F2DFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F2E00: 419A00F4  beq cr6, 0x828f2ef4
	if ctx.cr[6].eq {
	pc = 0x828F2EF4; continue 'dispatch;
	}
	// 828F2E04: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2E08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F2E0C: 419A0024  beq cr6, 0x828f2e30
	if ctx.cr[6].eq {
	pc = 0x828F2E30; continue 'dispatch;
	}
	// 828F2E10: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828F2E14: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2E18: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828F2E1C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F2E20: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2E24: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2E28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2E2C: 480000CC  b 0x828f2ef8
	pc = 0x828F2EF8; continue 'dispatch;
	// 828F2E30: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F2E34: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F2E38: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F2E3C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F2E40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2E44: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2E48: 40810054  ble 0x828f2e9c
	if !ctx.cr[0].gt {
	pc = 0x828F2E9C; continue 'dispatch;
	}
	// 828F2E4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F2E50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F2E54: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F2E58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2E5C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828F2E60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F2E64: 41980008  blt cr6, 0x828f2e6c
	if ctx.cr[6].lt {
	pc = 0x828F2E6C; continue 'dispatch;
	}
	// 828F2E68: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F2E6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F2E70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F2E74: 419A0014  beq cr6, 0x828f2e88
	if ctx.cr[6].eq {
	pc = 0x828F2E88; continue 'dispatch;
	}
	// 828F2E78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F2E7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F2E80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F2E84: 4800000C  b 0x828f2e90
	pc = 0x828F2E90; continue 'dispatch;
	// 828F2E88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F2E8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F2E90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2E94: 4199FFB8  bgt cr6, 0x828f2e4c
	if ctx.cr[6].gt {
	pc = 0x828F2E4C; continue 'dispatch;
	}
	// 828F2E98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F2E9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F2EA0: 419A0040  beq cr6, 0x828f2ee0
	if ctx.cr[6].eq {
	pc = 0x828F2EE0; continue 'dispatch;
	}
	// 828F2EA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2EA8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828F2EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2EB0: 41990008  bgt cr6, 0x828f2eb8
	if ctx.cr[6].gt {
	pc = 0x828F2EB8; continue 'dispatch;
	}
	// 828F2EB4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2EB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2EC0: 409A0020  bne cr6, 0x828f2ee0
	if !ctx.cr[6].eq {
	pc = 0x828F2EE0; continue 'dispatch;
	}
	// 828F2EC4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F2EC8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828F2ECC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F2ED0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2ED4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2ED8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2EDC: 4800001C  b 0x828f2ef8
	pc = 0x828F2EF8; continue 'dispatch;
	// 828F2EE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F2EE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2EE8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F2EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2EF0: 48000008  b 0x828f2ef8
	pc = 0x828F2EF8; continue 'dispatch;
	// 828F2EF4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828F2EF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F2EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2F00: 419A0020  beq cr6, 0x828f2f20
	if ctx.cr[6].eq {
	pc = 0x828F2F20; continue 'dispatch;
	}
	// 828F2F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2F08: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F2F0C: 4BC80315  bl 0x82573220
	ctx.lr = 0x828F2F10;
	sub_82573220(ctx, base);
	// 828F2F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2F14: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F2F18: 4BC80161  bl 0x82573078
	ctx.lr = 0x828F2F1C;
	sub_82573078(ctx, base);
	// 828F2F1C: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2F20: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828F2F24: 409A0008  bne cr6, 0x828f2f2c
	if !ctx.cr[6].eq {
	pc = 0x828F2F2C; continue 'dispatch;
	}
	// 828F2F28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828F2F2C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2F30: 4BFFFE88  b 0x828f2db8
	pc = 0x828F2DB8; continue 'dispatch;
	// 828F2F34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F2F38: 48121E59  bl 0x82a14d90
	ctx.lr = 0x828F2F3C;
	sub_82A14D90(ctx, base);
	// 828F2F3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2F40: 4B928DF9  bl 0x8221bd38
	ctx.lr = 0x828F2F44;
	sub_8221BD38(ctx, base);
	// 828F2F44: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F2F48: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F2F4C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828F2F50: 483B6508  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2F58 size=584
    let mut pc: u32 = 0x828F2F58;
    'dispatch: loop {
        match pc {
            0x828F2F58 => {
    //   block [0x828F2F58..0x828F31A0)
	// 828F2F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2F5C: 483B64A5  bl 0x82ca9400
	ctx.lr = 0x828F2F60;
	sub_82CA93D0(ctx, base);
	// 828F2F60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2F64: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2F68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F2F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F2F70: 409A0010  bne cr6, 0x828f2f80
	if !ctx.cr[6].eq {
	pc = 0x828F2F80; continue 'dispatch;
	}
	// 828F2F74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F2F78: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828F2F7C: 48000008  b 0x828f2f84
	pc = 0x828F2F84; continue 'dispatch;
	// 828F2F80: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2F84: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2F88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F2F8C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2F90: 4BADB631  bl 0x823ce5c0
	ctx.lr = 0x828F2F94;
	sub_823CE5C0(ctx, base);
	// 828F2F94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2F9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F2FA0: 4BADB261  bl 0x823ce200
	ctx.lr = 0x828F2FA4;
	sub_823CE200(ctx, base);
	// 828F2FA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F2FA8: 4B8C4B71  bl 0x821b7b18
	ctx.lr = 0x828F2FAC;
	sub_821B7B18(ctx, base);
	// 828F2FAC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828F2FB0: 4B92C2A9  bl 0x8221f258
	ctx.lr = 0x828F2FB4;
	sub_8221F258(ctx, base);
	// 828F2FB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2FB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F2FBC: 419A0040  beq cr6, 0x828f2ffc
	if ctx.cr[6].eq {
	pc = 0x828F2FFC; continue 'dispatch;
	}
	// 828F2FC0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828F2FC4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F2FC8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828F2FCC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F2FD0: 4B92C289  bl 0x8221f258
	ctx.lr = 0x828F2FD4;
	sub_8221F258(ctx, base);
	// 828F2FD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F2FD8: 419A0028  beq cr6, 0x828f3000
	if ctx.cr[6].eq {
	pc = 0x828F3000; continue 'dispatch;
	}
	// 828F2FDC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828F2FE0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828F2FE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2FE8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828F2FEC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F2FF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F2FF4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F2FF8: 4800000C  b 0x828f3004
	pc = 0x828F3004; continue 'dispatch;
	// 828F2FFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F3000: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F3004: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F300C: 419A00FC  beq cr6, 0x828f3108
	if ctx.cr[6].eq {
	pc = 0x828F3108; continue 'dispatch;
	}
	// 828F3010: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3014: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F3018: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F301C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F3020: 4B9360E9  bl 0x82229108
	ctx.lr = 0x828F3024;
	sub_82229108(ctx, base);
	// 828F3024: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828F3028: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F302C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F3030: 3BCB33A8  addi r30, r11, 0x33a8
	ctx.r[30].s64 = ctx.r[11].s64 + 13224;
	// 828F3034: 4B93484D  bl 0x82227880
	ctx.lr = 0x828F3038;
	sub_82227880(ctx, base);
	// 828F3038: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F303C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828F3040: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F3044: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828F3048: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F304C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F3050: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828F3054: 4B8A7A2D  bl 0x8219aa80
	ctx.lr = 0x828F3058;
	sub_8219AA80(ctx, base);
	// 828F3058: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828F305C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F3060: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828F3064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3068: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F306C: 4BADB3B5  bl 0x823ce420
	ctx.lr = 0x828F3070;
	sub_823CE420(ctx, base);
	// 828F3070: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F3074: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F3078: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F307C: 4813164D  bl 0x82a246c8
	ctx.lr = 0x828F3080;
	sub_82A246C8(ctx, base);
	// 828F3080: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3084: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F3088: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828F308C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828F3090: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3094: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F309C: 4B93606D  bl 0x82229108
	ctx.lr = 0x828F30A0;
	sub_82229108(ctx, base);
	// 828F30A0: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 828F30A4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F30A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F30AC: 3BEB2250  addi r31, r11, 0x2250
	ctx.r[31].s64 = ctx.r[11].s64 + 8784;
	// 828F30B0: 4B9347D1  bl 0x82227880
	ctx.lr = 0x828F30B4;
	sub_82227880(ctx, base);
	// 828F30B4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828F30B8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828F30BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F30C0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828F30C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F30C8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F30CC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828F30D0: 4B8A79B1  bl 0x8219aa80
	ctx.lr = 0x828F30D4;
	sub_8219AA80(ctx, base);
	// 828F30D4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828F30D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F30DC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828F30E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F30E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F30E8: 4BADB339  bl 0x823ce420
	ctx.lr = 0x828F30EC;
	sub_823CE420(ctx, base);
	// 828F30EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F30F0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F30F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F30F8: 481315D1  bl 0x82a246c8
	ctx.lr = 0x828F30FC;
	sub_82A246C8(ctx, base);
	// 828F30FC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3100: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828F3104: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828F3108: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828F310C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F3110: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828F3114: 419A0020  beq cr6, 0x828f3134
	if ctx.cr[6].eq {
	pc = 0x828F3134; continue 'dispatch;
	}
	// 828F3118: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F311C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3120: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F3124: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F3128: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F312C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3130: 4082FFE8  bne 0x828f3118
	if !ctx.cr[0].eq {
	pc = 0x828F3118; continue 'dispatch;
	}
	// 828F3134: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3138: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F313C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828F3140: 4BA02809  bl 0x822f5948
	ctx.lr = 0x828F3144;
	sub_822F5948(ctx, base);
	// 828F3144: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F3148: 4B8C49D1  bl 0x821b7b18
	ctx.lr = 0x828F314C;
	sub_821B7B18(ctx, base);
	// 828F314C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F3150: 419A0040  beq cr6, 0x828f3190
	if ctx.cr[6].eq {
	pc = 0x828F3190; continue 'dispatch;
	}
	// 828F3154: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F3158: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F315C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F3160: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F3164: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F3168: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F316C: 4082FFE8  bne 0x828f3154
	if !ctx.cr[0].eq {
	pc = 0x828F3154; continue 'dispatch;
	}
	// 828F3170: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3174: 409A001C  bne cr6, 0x828f3190
	if !ctx.cr[6].eq {
	pc = 0x828F3190; continue 'dispatch;
	}
	// 828F3178: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F317C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3184: 4E800421  bctrl
	ctx.lr = 0x828F3188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3188: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F318C: 4B928BAD  bl 0x8221bd38
	ctx.lr = 0x828F3190;
	sub_8221BD38(ctx, base);
	// 828F3190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3194: 4B8C4985  bl 0x821b7b18
	ctx.lr = 0x828F3198;
	sub_821B7B18(ctx, base);
	// 828F3198: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F319C: 483B62B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F31A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F31A0 size=516
    let mut pc: u32 = 0x828F31A0;
    'dispatch: loop {
        match pc {
            0x828F31A0 => {
    //   block [0x828F31A0..0x828F33A4)
	// 828F31A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F31A4: 483B6259  bl 0x82ca93fc
	ctx.lr = 0x828F31A8;
	sub_82CA93D0(ctx, base);
	// 828F31A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F31AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F31B0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828F31B4: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828F31B8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828F31BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828F31C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F31C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828F31C8: 3BAA2640  addi r29, r10, 0x2640
	ctx.r[29].s64 = ctx.r[10].s64 + 9792;
	// 828F31CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F31D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828F31D4: 419A0008  beq cr6, 0x828f31dc
	if ctx.cr[6].eq {
	pc = 0x828F31DC; continue 'dispatch;
	}
	// 828F31D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F31DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F31E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F31E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F31E8: 4BADB3D9  bl 0x823ce5c0
	ctx.lr = 0x828F31EC;
	sub_823CE5C0(ctx, base);
	// 828F31EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F31F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F31F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F31F8: 4BADAF19  bl 0x823ce110
	ctx.lr = 0x828F31FC;
	sub_823CE110(ctx, base);
	// 828F31FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F3200: 4B8C4919  bl 0x821b7b18
	ctx.lr = 0x828F3204;
	sub_821B7B18(ctx, base);
	// 828F3204: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F3208: 4B92C051  bl 0x8221f258
	ctx.lr = 0x828F320C;
	sub_8221F258(ctx, base);
	// 828F320C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3210: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F3214: 419A005C  beq cr6, 0x828f3270
	if ctx.cr[6].eq {
	pc = 0x828F3270; continue 'dispatch;
	}
	// 828F3218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F321C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828F3220: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F3224: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828F3228: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F322C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3230: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F3234: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828F3238: 4B8FD009  bl 0x821f0240
	ctx.lr = 0x828F323C;
	sub_821F0240(ctx, base);
	// 828F323C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F3240: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828F3244: 4B92C015  bl 0x8221f258
	ctx.lr = 0x828F3248;
	sub_8221F258(ctx, base);
	// 828F3248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F324C: 419A0028  beq cr6, 0x828f3274
	if ctx.cr[6].eq {
	pc = 0x828F3274; continue 'dispatch;
	}
	// 828F3250: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828F3254: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828F3258: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F325C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828F3260: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F3264: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F3268: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F326C: 4800000C  b 0x828f3278
	pc = 0x828F3278; continue 'dispatch;
	// 828F3270: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F3274: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F3278: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F327C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828F3280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3284: 419A0008  beq cr6, 0x828f328c
	if ctx.cr[6].eq {
	pc = 0x828F328C; continue 'dispatch;
	}
	// 828F3288: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F328C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F3290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3294: 419A0078  beq cr6, 0x828f330c
	if ctx.cr[6].eq {
	pc = 0x828F330C; continue 'dispatch;
	}
	// 828F3298: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F329C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828F32A0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F32A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F32A8: 4B935E61  bl 0x82229108
	ctx.lr = 0x828F32AC;
	sub_82229108(ctx, base);
	// 828F32AC: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828F32B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828F32B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F32B8: 3BCB33E8  addi r30, r11, 0x33e8
	ctx.r[30].s64 = ctx.r[11].s64 + 13288;
	// 828F32BC: 4B9345C5  bl 0x82227880
	ctx.lr = 0x828F32C0;
	sub_82227880(ctx, base);
	// 828F32C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F32C4: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828F32C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F32CC: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828F32D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F32D4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828F32D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828F32DC: 4B8A77A5  bl 0x8219aa80
	ctx.lr = 0x828F32E0;
	sub_8219AA80(ctx, base);
	// 828F32E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F32E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828F32E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F32EC: 4BADB135  bl 0x823ce420
	ctx.lr = 0x828F32F0;
	sub_823CE420(ctx, base);
	// 828F32F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F32F4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828F32F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F32FC: 481313CD  bl 0x82a246c8
	ctx.lr = 0x828F3300;
	sub_82A246C8(ctx, base);
	// 828F3300: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3304: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828F3308: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828F330C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F3310: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3314: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828F3318: 419A0020  beq cr6, 0x828f3338
	if ctx.cr[6].eq {
	pc = 0x828F3338; continue 'dispatch;
	}
	// 828F331C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F3320: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3324: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F3328: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F332C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F3330: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3334: 4082FFE8  bne 0x828f331c
	if !ctx.cr[0].eq {
	pc = 0x828F331C; continue 'dispatch;
	}
	// 828F3338: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F333C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3340: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828F3344: 4BA02605  bl 0x822f5948
	ctx.lr = 0x828F3348;
	sub_822F5948(ctx, base);
	// 828F3348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F334C: 4B8C47CD  bl 0x821b7b18
	ctx.lr = 0x828F3350;
	sub_821B7B18(ctx, base);
	// 828F3350: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3354: 419A0040  beq cr6, 0x828f3394
	if ctx.cr[6].eq {
	pc = 0x828F3394; continue 'dispatch;
	}
	// 828F3358: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F335C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3360: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F3364: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F3368: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F336C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3370: 4082FFE8  bne 0x828f3358
	if !ctx.cr[0].eq {
	pc = 0x828F3358; continue 'dispatch;
	}
	// 828F3374: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3378: 409A001C  bne cr6, 0x828f3394
	if !ctx.cr[6].eq {
	pc = 0x828F3394; continue 'dispatch;
	}
	// 828F337C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3380: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3388: 4E800421  bctrl
	ctx.lr = 0x828F338C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F338C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F3390: 4B9289A9  bl 0x8221bd38
	ctx.lr = 0x828F3394;
	sub_8221BD38(ctx, base);
	// 828F3394: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F3398: 4B8C4781  bl 0x821b7b18
	ctx.lr = 0x828F339C;
	sub_821B7B18(ctx, base);
	// 828F339C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828F33A0: 483B60AC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F33A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F33A8 size=56
    let mut pc: u32 = 0x828F33A8;
    'dispatch: loop {
        match pc {
            0x828F33A8 => {
    //   block [0x828F33A8..0x828F33E0)
	// 828F33A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F33AC: 419A0018  beq cr6, 0x828f33c4
	if ctx.cr[6].eq {
	pc = 0x828F33C4; continue 'dispatch;
	}
	// 828F33B0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F33B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F33B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F33BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F33C0: 409A0008  bne cr6, 0x828f33c8
	if !ctx.cr[6].eq {
	pc = 0x828F33C8; continue 'dispatch;
	}
	// 828F33C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F33C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F33CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F33D0: 419A0010  beq cr6, 0x828f33e0
	if ctx.cr[6].eq {
		sub_828F33E0(ctx, base);
		return;
	}
	// 828F33D4: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F33D8: 55638FFE  rlwinm r3, r11, 0x11, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 828F33DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F33E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F33E0 size=8
    let mut pc: u32 = 0x828F33E0;
    'dispatch: loop {
        match pc {
            0x828F33E0 => {
    //   block [0x828F33E0..0x828F33E8)
	// 828F33E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F33E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F33E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F33E8 size=372
    let mut pc: u32 = 0x828F33E8;
    'dispatch: loop {
        match pc {
            0x828F33E8 => {
    //   block [0x828F33E8..0x828F355C)
	// 828F33E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F33EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F33F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F33F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F33F8: 419A0018  beq cr6, 0x828f3410
	if ctx.cr[6].eq {
	pc = 0x828F3410; continue 'dispatch;
	}
	// 828F33FC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F3400: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F3404: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F3408: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F340C: 409A0008  bne cr6, 0x828f3414
	if !ctx.cr[6].eq {
	pc = 0x828F3414; continue 'dispatch;
	}
	// 828F3410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3414: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F3418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F341C: 419A012C  beq cr6, 0x828f3548
	if ctx.cr[6].eq {
	pc = 0x828F3548; continue 'dispatch;
	}
	// 828F3420: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F3424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3428: 55498FFE  rlwinm r9, r10, 0x11, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 828F342C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F3430: 419A00E8  beq cr6, 0x828f3518
	if ctx.cr[6].eq {
	pc = 0x828F3518; continue 'dispatch;
	}
	// 828F3434: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F3438: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F343C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3440: 419A001C  beq cr6, 0x828f345c
	if ctx.cr[6].eq {
	pc = 0x828F345C; continue 'dispatch;
	}
	// 828F3444: 896B00CF  lbz r11, 0xcf(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(207 as u32) ) } as u64;
	// 828F3448: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828F344C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F3450: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3454: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F3458: 480000C4  b 0x828f351c
	pc = 0x828F351C; continue 'dispatch;
	// 828F345C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F3460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3464: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F3468: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F346C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F3470: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3474: 40810054  ble 0x828f34c8
	if !ctx.cr[0].gt {
	pc = 0x828F34C8; continue 'dispatch;
	}
	// 828F3478: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F347C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F3480: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F3484: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3488: 2F0700CF  cmpwi cr6, r7, 0xcf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 207, &mut ctx.xer);
	// 828F348C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F3490: 41980008  blt cr6, 0x828f3498
	if ctx.cr[6].lt {
	pc = 0x828F3498; continue 'dispatch;
	}
	// 828F3494: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F3498: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F349C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F34A0: 419A0014  beq cr6, 0x828f34b4
	if ctx.cr[6].eq {
	pc = 0x828F34B4; continue 'dispatch;
	}
	// 828F34A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F34A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F34AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F34B0: 4800000C  b 0x828f34bc
	pc = 0x828F34BC; continue 'dispatch;
	// 828F34B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F34B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F34BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F34C0: 4199FFB8  bgt cr6, 0x828f3478
	if ctx.cr[6].gt {
	pc = 0x828F3478; continue 'dispatch;
	}
	// 828F34C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F34C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F34CC: 419A003C  beq cr6, 0x828f3508
	if ctx.cr[6].eq {
	pc = 0x828F3508; continue 'dispatch;
	}
	// 828F34D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F34D4: 2F0B00CF  cmpwi cr6, r11, 0xcf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 207, &mut ctx.xer);
	// 828F34D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F34DC: 41990008  bgt cr6, 0x828f34e4
	if ctx.cr[6].gt {
	pc = 0x828F34E4; continue 'dispatch;
	}
	// 828F34E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F34E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F34E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F34EC: 409A001C  bne cr6, 0x828f3508
	if !ctx.cr[6].eq {
	pc = 0x828F3508; continue 'dispatch;
	}
	// 828F34F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F34F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F34F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F34FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3500: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3504: 48000018  b 0x828f351c
	pc = 0x828F351C; continue 'dispatch;
	// 828F3508: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F350C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F3510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3514: 48000008  b 0x828f351c
	pc = 0x828F351C; continue 'dispatch;
	// 828F3518: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F351C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F3520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F3524: 419A0024  beq cr6, 0x828f3548
	if ctx.cr[6].eq {
	pc = 0x828F3548; continue 'dispatch;
	}
	// 828F3528: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F352C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828F3530: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F3534: 4E800421  bctrl
	ctx.lr = 0x828F3538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3538: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F353C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3540: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3544: 4E800020  blr
	return;
	// 828F3548: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F354C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F3550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3560 size=520
    let mut pc: u32 = 0x828F3560;
    'dispatch: loop {
        match pc {
            0x828F3560 => {
    //   block [0x828F3560..0x828F3768)
	// 828F3560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3564: 483B5E6D  bl 0x82ca93d0
	ctx.lr = 0x828F3568;
	sub_82CA93D0(ctx, base);
	// 828F3568: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F356C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3570: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828F3574: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828F3578: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828F357C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828F3580: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828F3584: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3588: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828F358C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828F3590: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828F3594: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3598: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828F359C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F35A0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F35A4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828F35A8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828F35AC: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828F35B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F35B4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F35B8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828F35BC: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F35C0: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828F35C4: 4B972465  bl 0x82265a28
	ctx.lr = 0x828F35C8;
	sub_82265A28(ctx, base);
	// 828F35C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F35CC: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828F35D0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828F35D4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828F35D8: 40990188  ble cr6, 0x828f3760
	if !ctx.cr[6].gt {
	pc = 0x828F3760; continue 'dispatch;
	}
	// 828F35DC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F35E0: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828F35E4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F35E8: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828F35EC: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F35F0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F35F4: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828F35F8: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	// 828F35FC: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828F3600: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F3604: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828F3608: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828F360C: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828F3610: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828F3614: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828F3618: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828F361C: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828F3620: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828F3624: 41820120  beq 0x828f3744
	if ctx.cr[0].eq {
	pc = 0x828F3744; continue 'dispatch;
	}
	// 828F3628: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F362C: 41820118  beq 0x828f3744
	if ctx.cr[0].eq {
	pc = 0x828F3744; continue 'dispatch;
	}
	// 828F3630: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828F3634: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828F3638: 4098010C  bge cr6, 0x828f3744
	if !ctx.cr[6].lt {
	pc = 0x828F3744; continue 'dispatch;
	}
	// 828F363C: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3640: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828F3644: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F3648: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828F364C: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828F3650: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3654: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3658: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[23].s32 as i64);
	// 828F365C: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828F3660: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F3664: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F3668: 409800C8  bge cr6, 0x828f3730
	if !ctx.cr[6].lt {
	pc = 0x828F3730; continue 'dispatch;
	}
	// 828F366C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 828F3670: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3674: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3678: 419A00AC  beq cr6, 0x828f3724
	if ctx.cr[6].eq {
	pc = 0x828F3724; continue 'dispatch;
	}
	// 828F367C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3680: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F3684: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828F3688: 40980090  bge cr6, 0x828f3718
	if !ctx.cr[6].lt {
	pc = 0x828F3718; continue 'dispatch;
	}
	// 828F368C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828F3690: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3694: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F369C: 4B90FF45  bl 0x822035e0
	ctx.lr = 0x828F36A0;
	sub_822035E0(ctx, base);
	// 828F36A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F36A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F36A8: 419A006C  beq cr6, 0x828f3714
	if ctx.cr[6].eq {
	pc = 0x828F3714; continue 'dispatch;
	}
	// 828F36AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F36B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F36B4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F36B8: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828F36BC: 419A0038  beq cr6, 0x828f36f4
	if ctx.cr[6].eq {
	pc = 0x828F36F4; continue 'dispatch;
	}
	// 828F36C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F36C4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F36C8: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828F36CC: 419A0028  beq cr6, 0x828f36f4
	if ctx.cr[6].eq {
	pc = 0x828F36F4; continue 'dispatch;
	}
	// 828F36D0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F36D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F36D8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F36DC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F36E0: 4BD0C3F9  bl 0x825ffad8
	ctx.lr = 0x828F36E4;
	sub_825FFAD8(ctx, base);
	// 828F36E4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F36E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F36EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F36F0: 409A0008  bne cr6, 0x828f36f8
	if !ctx.cr[6].eq {
	pc = 0x828F36F8; continue 'dispatch;
	}
	// 828F36F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F36F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F36FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3700: 419A0014  beq cr6, 0x828f3714
	if ctx.cr[6].eq {
	pc = 0x828F3714; continue 'dispatch;
	}
	// 828F3704: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828F3708: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F370C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3710: 48256041  bl 0x82b49750
	ctx.lr = 0x828F3714;
	sub_82B49750(ctx, base);
	// 828F3714: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828F3718: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F371C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3720: 409AFF5C  bne cr6, 0x828f367c
	if !ctx.cr[6].eq {
	pc = 0x828F367C; continue 'dispatch;
	}
	// 828F3724: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828F3728: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828F372C: 4082FF44  bne 0x828f3670
	if !ctx.cr[0].eq {
	pc = 0x828F3670; continue 'dispatch;
	}
	// 828F3730: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828F3734: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828F3738: 4198FF04  blt cr6, 0x828f363c
	if ctx.cr[6].lt {
	pc = 0x828F363C; continue 'dispatch;
	}
	// 828F373C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F3740: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828F3744: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3748: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828F374C: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828F3750: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828F3754: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F3758: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828F375C: 4198FEA0  blt cr6, 0x828f35fc
	if ctx.cr[6].lt {
	pc = 0x828F35FC; continue 'dispatch;
	}
	// 828F3760: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828F3764: 483B5CBC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3768 size=60
    let mut pc: u32 = 0x828F3768;
    'dispatch: loop {
        match pc {
            0x828F3768 => {
    //   block [0x828F3768..0x828F37A4)
	// 828F3768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F376C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3774: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3778: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F377C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3780: 388B98C0  addi r4, r11, -0x6740
	ctx.r[4].s64 = ctx.r[11].s64 + -26432;
	// 828F3784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3788: 4B939749  bl 0x8222ced0
	ctx.lr = 0x828F378C;
	sub_8222CED0(ctx, base);
	// 828F378C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3790: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F3794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F379C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F37A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F37A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F37A8 size=388
    let mut pc: u32 = 0x828F37A8;
    'dispatch: loop {
        match pc {
            0x828F37A8 => {
    //   block [0x828F37A8..0x828F392C)
	// 828F37A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F37AC: 483B5C51  bl 0x82ca93fc
	ctx.lr = 0x828F37B0;
	sub_82CA93D0(ctx, base);
	// 828F37B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F37B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F37B8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828F37BC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828F37C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F37C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F37C8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828F37CC: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828F37D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828F37D4: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F37D8: 38C74B48  addi r6, r7, 0x4b48
	ctx.r[6].s64 = ctx.r[7].s64 + 19272;
	// 828F37DC: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F37E0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 828F37E4: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828F37E8: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F37EC: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 828F37F0: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828F37F4: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828F37F8: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828F37FC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828F3800: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828F3804: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828F3808: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828F380C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828F3810: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F3814: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828F3818: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 828F381C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 828F3820: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828F3824: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 828F3828: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 828F382C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 828F3830: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 828F3834: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 828F3838: 9BDF0061  stb r30, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 828F383C: 9BDF0062  stb r30, 0x62(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(98 as u32), ctx.r[30].u8 ) };
	// 828F3840: 9BDF0063  stb r30, 0x63(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(99 as u32), ctx.r[30].u8 ) };
	// 828F3844: 9BDF0064  stb r30, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 828F3848: 9BDF0065  stb r30, 0x65(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(101 as u32), ctx.r[30].u8 ) };
	// 828F384C: 9BDF0067  stb r30, 0x67(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(103 as u32), ctx.r[30].u8 ) };
	// 828F3850: 993F0068  stb r9, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u8 ) };
	// 828F3854: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828F3858: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828F385C: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828F3860: 937F0074  stw r27, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828F3864: 4B8A05D5  bl 0x82193e38
	ctx.lr = 0x828F3868;
	sub_82193E38(ctx, base);
	// 828F3868: 937F007C  stw r27, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 828F386C: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828F3870: 3BBF007C  addi r29, r31, 0x7c
	ctx.r[29].s64 = ctx.r[31].s64 + 124;
	// 828F3874: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828F3878: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 828F387C: 93DF0090  stw r30, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 828F3880: 937F008C  stw r27, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 828F3884: 48003195  bl 0x828f6a18
	ctx.lr = 0x828F3888;
	sub_828F6A18(ctx, base);
	// 828F3888: 48003459  bl 0x828f6ce0
	ctx.lr = 0x828F388C;
	sub_828F6CE0(ctx, base);
	// 828F388C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F3890: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 828F3894: 3B2B0B7C  addi r25, r11, 0xb7c
	ctx.r[25].s64 = ctx.r[11].s64 + 2940;
	// 828F3898: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828F389C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F38A0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F38A4: 4B8A0595  bl 0x82193e38
	ctx.lr = 0x828F38A8;
	sub_82193E38(ctx, base);
	// 828F38A8: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F38AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F38B0: 419A0024  beq cr6, 0x828f38d4
	if ctx.cr[6].eq {
	pc = 0x828F38D4; continue 'dispatch;
	}
	// 828F38B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F38B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F38BC: 419A000C  beq cr6, 0x828f38c8
	if ctx.cr[6].eq {
	pc = 0x828F38C8; continue 'dispatch;
	}
	// 828F38C0: 5564003E  slwi r4, r11, 0
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828F38C4: 48000014  b 0x828f38d8
	pc = 0x828F38D8; continue 'dispatch;
	// 828F38C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F38CC: 4B8A056D  bl 0x82193e38
	ctx.lr = 0x828F38D0;
	sub_82193E38(ctx, base);
	// 828F38D0: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F38D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F38D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F38DC: 4B920FBD  bl 0x82214898
	ctx.lr = 0x828F38E0;
	sub_82214898(ctx, base);
	// 828F38E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F38E4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828F38E8: 419A0028  beq cr6, 0x828f3910
	if ctx.cr[6].eq {
	pc = 0x828F3910; continue 'dispatch;
	}
	// 828F38EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F38F0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F38F4: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F38F8: 40820018  bne 0x828f3910
	if !ctx.cr[0].eq {
	pc = 0x828F3910; continue 'dispatch;
	}
	// 828F38FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3904: 409A000C  bne cr6, 0x828f3910
	if !ctx.cr[6].eq {
	pc = 0x828F3910; continue 'dispatch;
	}
	// 828F3908: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F390C: 4B92842D  bl 0x8221bd38
	ctx.lr = 0x828F3910;
	sub_8221BD38(ctx, base);
	// 828F3910: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828F3914: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F3918: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828F391C: 4082FF7C  bne 0x828f3898
	if !ctx.cr[0].eq {
	pc = 0x828F3898; continue 'dispatch;
	}
	// 828F3920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3924: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F3928: 483B5B24  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3930 size=180
    let mut pc: u32 = 0x828F3930;
    'dispatch: loop {
        match pc {
            0x828F3930 => {
    //   block [0x828F3930..0x828F39E4)
	// 828F3930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3934: 483B5ACD  bl 0x82ca9400
	ctx.lr = 0x828F3938;
	sub_82CA93D0(ctx, base);
	// 828F3938: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F393C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F3940: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F3944: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828F3948: 3BFE0094  addi r31, r30, 0x94
	ctx.r[31].s64 = ctx.r[30].s64 + 148;
	// 828F394C: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 828F3950: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F3954: 3B6B0B7C  addi r27, r11, 0xb7c
	ctx.r[27].s64 = ctx.r[11].s64 + 2940;
	// 828F3958: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 828F395C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3960: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828F3964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3968: 419A0034  beq cr6, 0x828f399c
	if ctx.cr[6].eq {
	pc = 0x828F399C; continue 'dispatch;
	}
	// 828F396C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3970: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828F3974: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F3978: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F397C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3980: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F3984: 409A0014  bne cr6, 0x828f3998
	if !ctx.cr[6].eq {
	pc = 0x828F3998; continue 'dispatch;
	}
	// 828F3988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F398C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3990: 409A0008  bne cr6, 0x828f3998
	if !ctx.cr[6].eq {
	pc = 0x828F3998; continue 'dispatch;
	}
	// 828F3994: 4B9283A5  bl 0x8221bd38
	ctx.lr = 0x828F3998;
	sub_8221BD38(ctx, base);
	// 828F3998: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828F399C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828F39A0: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828F39A4: 4080FFB4  bge 0x828f3958
	if !ctx.cr[0].lt {
	pc = 0x828F3958; continue 'dispatch;
	}
	// 828F39A8: 937E0074  stw r27, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828F39AC: 387E0074  addi r3, r30, 0x74
	ctx.r[3].s64 = ctx.r[30].s64 + 116;
	// 828F39B0: 4B8A0489  bl 0x82193e38
	ctx.lr = 0x828F39B4;
	sub_82193E38(ctx, base);
	// 828F39B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828F39B8: 574A07FE  clrlwi r10, r26, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 828F39BC: 939E0078  stw r28, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 828F39C0: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828F39C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F39C8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F39CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F39D0: 419A000C  beq cr6, 0x828f39dc
	if ctx.cr[6].eq {
	pc = 0x828F39DC; continue 'dispatch;
	}
	// 828F39D4: 4B928365  bl 0x8221bd38
	ctx.lr = 0x828F39D8;
	sub_8221BD38(ctx, base);
	// 828F39D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F39DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F39E0: 483B5A70  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F39E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F39E8 size=1252
    let mut pc: u32 = 0x828F39E8;
    'dispatch: loop {
        match pc {
            0x828F39E8 => {
    //   block [0x828F39E8..0x828F3ECC)
	// 828F39E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F39EC: 483B5A1D  bl 0x82ca9408
	ctx.lr = 0x828F39F0;
	sub_82CA93D0(ctx, base);
	// 828F39F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F39F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F39F8: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F39FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F3A00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3A04: 388A47E8  addi r4, r10, 0x47e8
	ctx.r[4].s64 = ctx.r[10].s64 + 18408;
	// 828F3A08: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F3A0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3A10: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828F3A14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F3A18: 4B9394B9  bl 0x8222ced0
	ctx.lr = 0x828F3A1C;
	sub_8222CED0(ctx, base);
	// 828F3A1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3A20: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828F3A24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3A28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3A30: 419A0008  beq cr6, 0x828f3a38
	if ctx.cr[6].eq {
	pc = 0x828F3A38; continue 'dispatch;
	}
	// 828F3A34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3A38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F3A3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3A40: 4BB8CD89  bl 0x824807c8
	ctx.lr = 0x828F3A44;
	sub_824807C8(ctx, base);
	// 828F3A44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3A48: 4B921391  bl 0x82214dd8
	ctx.lr = 0x828F3A4C;
	sub_82214DD8(ctx, base);
	// 828F3A4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3A50: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F3A54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3A58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3A5C: 388B48E0  addi r4, r11, 0x48e0
	ctx.r[4].s64 = ctx.r[11].s64 + 18656;
	// 828F3A60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3A64: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828F3A68: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828F3A6C: 4B939465  bl 0x8222ced0
	ctx.lr = 0x828F3A70;
	sub_8222CED0(ctx, base);
	// 828F3A70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3A74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3A7C: 419A0008  beq cr6, 0x828f3a84
	if ctx.cr[6].eq {
	pc = 0x828F3A84; continue 'dispatch;
	}
	// 828F3A80: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3A84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F3A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3A8C: 4BB8CD3D  bl 0x824807c8
	ctx.lr = 0x828F3A90;
	sub_824807C8(ctx, base);
	// 828F3A90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3A94: 4B921345  bl 0x82214dd8
	ctx.lr = 0x828F3A98;
	sub_82214DD8(ctx, base);
	// 828F3A98: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3A9C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3AA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3AA4: 388B48EC  addi r4, r11, 0x48ec
	ctx.r[4].s64 = ctx.r[11].s64 + 18668;
	// 828F3AA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3AAC: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828F3AB0: 4B939421  bl 0x8222ced0
	ctx.lr = 0x828F3AB4;
	sub_8222CED0(ctx, base);
	// 828F3AB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3AB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3AC0: 419A0008  beq cr6, 0x828f3ac8
	if ctx.cr[6].eq {
	pc = 0x828F3AC8; continue 'dispatch;
	}
	// 828F3AC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3AC8: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828F3ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3AD0: 4BB8CCF9  bl 0x824807c8
	ctx.lr = 0x828F3AD4;
	sub_824807C8(ctx, base);
	// 828F3AD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3AD8: 4B921301  bl 0x82214dd8
	ctx.lr = 0x828F3ADC;
	sub_82214DD8(ctx, base);
	// 828F3ADC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3AE0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3AE4: 388B4904  addi r4, r11, 0x4904
	ctx.r[4].s64 = ctx.r[11].s64 + 18692;
	// 828F3AE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3AEC: 4B9393E5  bl 0x8222ced0
	ctx.lr = 0x828F3AF0;
	sub_8222CED0(ctx, base);
	// 828F3AF0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3AF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3AFC: 419A0008  beq cr6, 0x828f3b04
	if ctx.cr[6].eq {
	pc = 0x828F3B04; continue 'dispatch;
	}
	// 828F3B00: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3B04: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828F3B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3B0C: 4BB8CCBD  bl 0x824807c8
	ctx.lr = 0x828F3B10;
	sub_824807C8(ctx, base);
	// 828F3B10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B14: 4B9212C5  bl 0x82214dd8
	ctx.lr = 0x828F3B18;
	sub_82214DD8(ctx, base);
	// 828F3B18: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3B1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3B20: 388B491C  addi r4, r11, 0x491c
	ctx.r[4].s64 = ctx.r[11].s64 + 18716;
	// 828F3B24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B28: 4B9393A9  bl 0x8222ced0
	ctx.lr = 0x828F3B2C;
	sub_8222CED0(ctx, base);
	// 828F3B2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3B30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3B38: 419A0008  beq cr6, 0x828f3b40
	if ctx.cr[6].eq {
	pc = 0x828F3B40; continue 'dispatch;
	}
	// 828F3B3C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3B40: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828F3B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3B48: 4BB8CC81  bl 0x824807c8
	ctx.lr = 0x828F3B4C;
	sub_824807C8(ctx, base);
	// 828F3B4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B50: 4B921289  bl 0x82214dd8
	ctx.lr = 0x828F3B54;
	sub_82214DD8(ctx, base);
	// 828F3B54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3B58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3B5C: 388B4928  addi r4, r11, 0x4928
	ctx.r[4].s64 = ctx.r[11].s64 + 18728;
	// 828F3B60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B64: 4B93936D  bl 0x8222ced0
	ctx.lr = 0x828F3B68;
	sub_8222CED0(ctx, base);
	// 828F3B68: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 828F3B6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3B70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B74: 481292D5  bl 0x82a1ce48
	ctx.lr = 0x828F3B78;
	sub_82A1CE48(ctx, base);
	// 828F3B78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B7C: 4B92125D  bl 0x82214dd8
	ctx.lr = 0x828F3B80;
	sub_82214DD8(ctx, base);
	// 828F3B80: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F3B84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3B88: 388A4938  addi r4, r10, 0x4938
	ctx.r[4].s64 = ctx.r[10].s64 + 18744;
	// 828F3B8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B90: 4B939341  bl 0x8222ced0
	ctx.lr = 0x828F3B94;
	sub_8222CED0(ctx, base);
	// 828F3B94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3B98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3BA0: 419A0008  beq cr6, 0x828f3ba8
	if ctx.cr[6].eq {
	pc = 0x828F3BA8; continue 'dispatch;
	}
	// 828F3BA4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3BA8: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 828F3BAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3BB0: 4BB8CCA1  bl 0x82480850
	ctx.lr = 0x828F3BB4;
	sub_82480850(ctx, base);
	// 828F3BB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3BB8: 4B921221  bl 0x82214dd8
	ctx.lr = 0x828F3BBC;
	sub_82214DD8(ctx, base);
	// 828F3BBC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3BC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3BC4: 388B4944  addi r4, r11, 0x4944
	ctx.r[4].s64 = ctx.r[11].s64 + 18756;
	// 828F3BC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3BCC: 4B939305  bl 0x8222ced0
	ctx.lr = 0x828F3BD0;
	sub_8222CED0(ctx, base);
	// 828F3BD0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3BD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3BDC: 419A0008  beq cr6, 0x828f3be4
	if ctx.cr[6].eq {
	pc = 0x828F3BE4; continue 'dispatch;
	}
	// 828F3BE0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3BE4: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 828F3BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3BEC: 4BB8CC65  bl 0x82480850
	ctx.lr = 0x828F3BF0;
	sub_82480850(ctx, base);
	// 828F3BF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3BF4: 4B9211E5  bl 0x82214dd8
	ctx.lr = 0x828F3BF8;
	sub_82214DD8(ctx, base);
	// 828F3BF8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3BFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3C00: 388B4950  addi r4, r11, 0x4950
	ctx.r[4].s64 = ctx.r[11].s64 + 18768;
	// 828F3C04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3C08: 4B9392C9  bl 0x8222ced0
	ctx.lr = 0x828F3C0C;
	sub_8222CED0(ctx, base);
	// 828F3C0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3C18: 419A0008  beq cr6, 0x828f3c20
	if ctx.cr[6].eq {
	pc = 0x828F3C20; continue 'dispatch;
	}
	// 828F3C1C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3C20: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828F3C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3C28: 4BB8CC29  bl 0x82480850
	ctx.lr = 0x828F3C2C;
	sub_82480850(ctx, base);
	// 828F3C2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3C30: 4B9211A9  bl 0x82214dd8
	ctx.lr = 0x828F3C34;
	sub_82214DD8(ctx, base);
	// 828F3C34: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3C38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3C3C: 388B4968  addi r4, r11, 0x4968
	ctx.r[4].s64 = ctx.r[11].s64 + 18792;
	// 828F3C40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3C44: 4B93928D  bl 0x8222ced0
	ctx.lr = 0x828F3C48;
	sub_8222CED0(ctx, base);
	// 828F3C48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3C4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3C54: 419A0008  beq cr6, 0x828f3c5c
	if ctx.cr[6].eq {
	pc = 0x828F3C5C; continue 'dispatch;
	}
	// 828F3C58: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3C5C: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828F3C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3C64: 4BB8CBED  bl 0x82480850
	ctx.lr = 0x828F3C68;
	sub_82480850(ctx, base);
	// 828F3C68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3C6C: 4B92116D  bl 0x82214dd8
	ctx.lr = 0x828F3C70;
	sub_82214DD8(ctx, base);
	// 828F3C70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3C74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3C78: 388B4974  addi r4, r11, 0x4974
	ctx.r[4].s64 = ctx.r[11].s64 + 18804;
	// 828F3C7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3C80: 4B939251  bl 0x8222ced0
	ctx.lr = 0x828F3C84;
	sub_8222CED0(ctx, base);
	// 828F3C84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3C88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3C90: 419A0008  beq cr6, 0x828f3c98
	if ctx.cr[6].eq {
	pc = 0x828F3C98; continue 'dispatch;
	}
	// 828F3C94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3C98: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828F3C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3CA0: 4BB8CBB1  bl 0x82480850
	ctx.lr = 0x828F3CA4;
	sub_82480850(ctx, base);
	// 828F3CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3CA8: 4B921131  bl 0x82214dd8
	ctx.lr = 0x828F3CAC;
	sub_82214DD8(ctx, base);
	// 828F3CAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F3CB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3CB4: 388B35C0  addi r4, r11, 0x35c0
	ctx.r[4].s64 = ctx.r[11].s64 + 13760;
	// 828F3CB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3CBC: 4B939215  bl 0x8222ced0
	ctx.lr = 0x828F3CC0;
	sub_8222CED0(ctx, base);
	// 828F3CC0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3CC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3CCC: 419A0008  beq cr6, 0x828f3cd4
	if ctx.cr[6].eq {
	pc = 0x828F3CD4; continue 'dispatch;
	}
	// 828F3CD0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3CD4: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828F3CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3CDC: 4BB8CB75  bl 0x82480850
	ctx.lr = 0x828F3CE0;
	sub_82480850(ctx, base);
	// 828F3CE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3CE4: 4B9210F5  bl 0x82214dd8
	ctx.lr = 0x828F3CE8;
	sub_82214DD8(ctx, base);
	// 828F3CE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F3CEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3CF0: 388B4300  addi r4, r11, 0x4300
	ctx.r[4].s64 = ctx.r[11].s64 + 17152;
	// 828F3CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3CF8: 4B9391D9  bl 0x8222ced0
	ctx.lr = 0x828F3CFC;
	sub_8222CED0(ctx, base);
	// 828F3CFC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3D00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3D08: 419A0008  beq cr6, 0x828f3d10
	if ctx.cr[6].eq {
	pc = 0x828F3D10; continue 'dispatch;
	}
	// 828F3D0C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3D10: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828F3D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3D18: 4BB8CB39  bl 0x82480850
	ctx.lr = 0x828F3D1C;
	sub_82480850(ctx, base);
	// 828F3D1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D20: 4B9210B9  bl 0x82214dd8
	ctx.lr = 0x828F3D24;
	sub_82214DD8(ctx, base);
	// 828F3D24: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3D28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3D2C: 388B40DC  addi r4, r11, 0x40dc
	ctx.r[4].s64 = ctx.r[11].s64 + 16604;
	// 828F3D30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D34: 4B93919D  bl 0x8222ced0
	ctx.lr = 0x828F3D38;
	sub_8222CED0(ctx, base);
	// 828F3D38: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3D3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3D44: 419A0008  beq cr6, 0x828f3d4c
	if ctx.cr[6].eq {
	pc = 0x828F3D4C; continue 'dispatch;
	}
	// 828F3D48: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3D4C: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 828F3D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3D54: 4BB8CAFD  bl 0x82480850
	ctx.lr = 0x828F3D58;
	sub_82480850(ctx, base);
	// 828F3D58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D5C: 4B92107D  bl 0x82214dd8
	ctx.lr = 0x828F3D60;
	sub_82214DD8(ctx, base);
	// 828F3D60: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3D64: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3D68: 388B4980  addi r4, r11, 0x4980
	ctx.r[4].s64 = ctx.r[11].s64 + 18816;
	// 828F3D6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D70: 4B939161  bl 0x8222ced0
	ctx.lr = 0x828F3D74;
	sub_8222CED0(ctx, base);
	// 828F3D74: 38BF0061  addi r5, r31, 0x61
	ctx.r[5].s64 = ctx.r[31].s64 + 97;
	// 828F3D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3D7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D80: 481290C9  bl 0x82a1ce48
	ctx.lr = 0x828F3D84;
	sub_82A1CE48(ctx, base);
	// 828F3D84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D88: 4B921051  bl 0x82214dd8
	ctx.lr = 0x828F3D8C;
	sub_82214DD8(ctx, base);
	// 828F3D8C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F3D90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3D94: 388A498C  addi r4, r10, 0x498c
	ctx.r[4].s64 = ctx.r[10].s64 + 18828;
	// 828F3D98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D9C: 4B939135  bl 0x8222ced0
	ctx.lr = 0x828F3DA0;
	sub_8222CED0(ctx, base);
	// 828F3DA0: 38BF0062  addi r5, r31, 0x62
	ctx.r[5].s64 = ctx.r[31].s64 + 98;
	// 828F3DA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3DA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DAC: 4812909D  bl 0x82a1ce48
	ctx.lr = 0x828F3DB0;
	sub_82A1CE48(ctx, base);
	// 828F3DB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DB4: 4B921025  bl 0x82214dd8
	ctx.lr = 0x828F3DB8;
	sub_82214DD8(ctx, base);
	// 828F3DB8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828F3DBC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3DC0: 3889499C  addi r4, r9, 0x499c
	ctx.r[4].s64 = ctx.r[9].s64 + 18844;
	// 828F3DC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DC8: 4B939109  bl 0x8222ced0
	ctx.lr = 0x828F3DCC;
	sub_8222CED0(ctx, base);
	// 828F3DCC: 38BF0063  addi r5, r31, 0x63
	ctx.r[5].s64 = ctx.r[31].s64 + 99;
	// 828F3DD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3DD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DD8: 48129071  bl 0x82a1ce48
	ctx.lr = 0x828F3DDC;
	sub_82A1CE48(ctx, base);
	// 828F3DDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DE0: 4B920FF9  bl 0x82214dd8
	ctx.lr = 0x828F3DE4;
	sub_82214DD8(ctx, base);
	// 828F3DE4: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828F3DE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3DEC: 388849AC  addi r4, r8, 0x49ac
	ctx.r[4].s64 = ctx.r[8].s64 + 18860;
	// 828F3DF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DF4: 4B9390DD  bl 0x8222ced0
	ctx.lr = 0x828F3DF8;
	sub_8222CED0(ctx, base);
	// 828F3DF8: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 828F3DFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3E00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E04: 48129045  bl 0x82a1ce48
	ctx.lr = 0x828F3E08;
	sub_82A1CE48(ctx, base);
	// 828F3E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E0C: 4B920FCD  bl 0x82214dd8
	ctx.lr = 0x828F3E10;
	sub_82214DD8(ctx, base);
	// 828F3E10: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828F3E14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3E18: 388749B8  addi r4, r7, 0x49b8
	ctx.r[4].s64 = ctx.r[7].s64 + 18872;
	// 828F3E1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E20: 4B9390B1  bl 0x8222ced0
	ctx.lr = 0x828F3E24;
	sub_8222CED0(ctx, base);
	// 828F3E24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3E28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3E30: 419A0008  beq cr6, 0x828f3e38
	if ctx.cr[6].eq {
	pc = 0x828F3E38; continue 'dispatch;
	}
	// 828F3E34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3E38: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828F3E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3E40: 4BA9C249  bl 0x82390088
	ctx.lr = 0x828F3E44;
	sub_82390088(ctx, base);
	// 828F3E44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E48: 4B920F91  bl 0x82214dd8
	ctx.lr = 0x828F3E4C;
	sub_82214DD8(ctx, base);
	// 828F3E4C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3E50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3E54: 388B49CC  addi r4, r11, 0x49cc
	ctx.r[4].s64 = ctx.r[11].s64 + 18892;
	// 828F3E58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E5C: 4B939075  bl 0x8222ced0
	ctx.lr = 0x828F3E60;
	sub_8222CED0(ctx, base);
	// 828F3E60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3E64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F3E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3E6C: 419A0008  beq cr6, 0x828f3e74
	if ctx.cr[6].eq {
	pc = 0x828F3E74; continue 'dispatch;
	}
	// 828F3E70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3E74: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828F3E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3E7C: 4BB8C94D  bl 0x824807c8
	ctx.lr = 0x828F3E80;
	sub_824807C8(ctx, base);
	// 828F3E80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E84: 4B920F55  bl 0x82214dd8
	ctx.lr = 0x828F3E88;
	sub_82214DD8(ctx, base);
	// 828F3E88: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F3E8C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F3E90: 388B49E0  addi r4, r11, 0x49e0
	ctx.r[4].s64 = ctx.r[11].s64 + 18912;
	// 828F3E94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E98: 4B939039  bl 0x8222ced0
	ctx.lr = 0x828F3E9C;
	sub_8222CED0(ctx, base);
	// 828F3E9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F3EA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F3EA4: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 828F3EA8: 4BBBE911  bl 0x824b27b8
	ctx.lr = 0x828F3EAC;
	sub_824B27B8(ctx, base);
	// 828F3EAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3EB0: 4B920F29  bl 0x82214dd8
	ctx.lr = 0x828F3EB4;
	sub_82214DD8(ctx, base);
	// 828F3EB4: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828F3EB8: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828F3EBC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828F3EC0: 991F0065  stb r8, 0x65(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(101 as u32), ctx.r[8].u8 ) };
	// 828F3EC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F3EC8: 483B5590  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3ED0 size=648
    let mut pc: u32 = 0x828F3ED0;
    'dispatch: loop {
        match pc {
            0x828F3ED0 => {
    //   block [0x828F3ED0..0x828F4158)
	// 828F3ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3ED4: 483B5539  bl 0x82ca940c
	ctx.lr = 0x828F3ED8;
	sub_82CA93D0(ctx, base);
	// 828F3ED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3EE0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3EE4: 4BD08CCD  bl 0x825fcbb0
	ctx.lr = 0x828F3EE8;
	sub_825FCBB0(ctx, base);
	// 828F3EE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F3EEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3EF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F3EF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F3EF8: 9BDF0066  stb r30, 0x66(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(102 as u32), ctx.r[30].u8 ) };
	// 828F3EFC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828F3F00: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F3F04: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F3F08: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F3F0C: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F3F10: 4BD09801  bl 0x825fd710
	ctx.lr = 0x828F3F14;
	sub_825FD710(ctx, base);
	// 828F3F14: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828F3F18: 57A8063E  clrlwi r8, r29, 0x18
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F3F1C: 987F0068  stb r3, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u8 ) };
	// 828F3F20: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 828F3F24: 81096AB8  lwz r8, 0x6ab8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F3F28: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828F3F2C: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 828F3F30: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828F3F34: 80A8000C  lwz r5, 0xc(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F3F38: 80850058  lwz r4, 0x58(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F3F3C: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3F40: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F3F44: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828F3F48: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828F3F4C: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 828F3F50: 88FF0065  lbz r7, 0x65(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(101 as u32) ) } as u64;
	// 828F3F54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F3F58: 419A0098  beq cr6, 0x828f3ff0
	if ctx.cr[6].eq {
	pc = 0x828F3FF0; continue 'dispatch;
	}
	// 828F3F5C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F3F60: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 828F3F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3F68: 41990014  bgt cr6, 0x828f3f7c
	if ctx.cr[6].gt {
	pc = 0x828F3F7C; continue 'dispatch;
	}
	// 828F3F6C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3F74: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828F3F78: 40990008  ble cr6, 0x828f3f80
	if !ctx.cr[6].gt {
	pc = 0x828F3F80; continue 'dispatch;
	}
	// 828F3F7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F3F80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F3F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3F88: 419A0054  beq cr6, 0x828f3fdc
	if ctx.cr[6].eq {
	pc = 0x828F3FDC; continue 'dispatch;
	}
	// 828F3F8C: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F3F90: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F3F94: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3F98: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3F9C: 4B9704ED  bl 0x82264488
	ctx.lr = 0x828F3FA0;
	sub_82264488(ctx, base);
	// 828F3FA0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828F3FA4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F3FA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3FAC: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828F3FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3FB4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828F3FB8: 4B9208E1  bl 0x82214898
	ctx.lr = 0x828F3FBC;
	sub_82214898(ctx, base);
	// 828F3FBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3FC0: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 828F3FC4: 4BBDDF05  bl 0x824d1ec8
	ctx.lr = 0x828F3FC8;
	sub_824D1EC8(ctx, base);
	// 828F3FC8: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 828F3FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3FD0: 38A60B7C  addi r5, r6, 0xb7c
	ctx.r[5].s64 = ctx.r[6].s64 + 2940;
	// 828F3FD4: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828F3FD8: 4B89FE61  bl 0x82193e38
	ctx.lr = 0x828F3FDC;
	sub_82193E38(ctx, base);
	// 828F3FDC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F3FE0: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 828F3FE4: 4199000C  bgt cr6, 0x828f3ff0
	if ctx.cr[6].gt {
	pc = 0x828F3FF0; continue 'dispatch;
	}
	// 828F3FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3FEC: 48001015  bl 0x828f5000
	ctx.lr = 0x828F3FF0;
	sub_828F5000(ctx, base);
	// 828F3FF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3FF4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828F3FF8: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F3FFC: 552897FE  rlwinm r8, r9, 0x12, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00003FFFu64;
	// 828F4000: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F4004: 419A00E8  beq cr6, 0x828f40ec
	if ctx.cr[6].eq {
	pc = 0x828F40EC; continue 'dispatch;
	}
	// 828F4008: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F400C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4010: 419A0020  beq cr6, 0x828f4030
	if ctx.cr[6].eq {
	pc = 0x828F4030; continue 'dispatch;
	}
	// 828F4014: 894A00AE  lbz r10, 0xae(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(174 as u32) ) } as u64;
	// 828F4018: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F401C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F4020: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F4024: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F4028: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F402C: 480000C4  b 0x828f40f0
	pc = 0x828F40F0; continue 'dispatch;
	// 828F4030: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F4034: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F4038: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828F403C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F4040: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F4044: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4048: 40810054  ble 0x828f409c
	if !ctx.cr[0].gt {
	pc = 0x828F409C; continue 'dispatch;
	}
	// 828F404C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F4050: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F4054: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F4058: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F405C: 2F0700AE  cmpwi cr6, r7, 0xae
	ctx.cr[6].compare_i32(ctx.r[7].s32, 174, &mut ctx.xer);
	// 828F4060: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F4064: 41980008  blt cr6, 0x828f406c
	if ctx.cr[6].lt {
	pc = 0x828F406C; continue 'dispatch;
	}
	// 828F4068: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828F406C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F4070: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F4074: 419A0014  beq cr6, 0x828f4088
	if ctx.cr[6].eq {
	pc = 0x828F4088; continue 'dispatch;
	}
	// 828F4078: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F407C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F4080: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F4084: 4800000C  b 0x828f4090
	pc = 0x828F4090; continue 'dispatch;
	// 828F4088: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F408C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F4090: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4094: 4199FFB8  bgt cr6, 0x828f404c
	if ctx.cr[6].gt {
	pc = 0x828F404C; continue 'dispatch;
	}
	// 828F4098: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F409C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F40A0: 419A003C  beq cr6, 0x828f40dc
	if ctx.cr[6].eq {
	pc = 0x828F40DC; continue 'dispatch;
	}
	// 828F40A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F40A8: 2F0B00AE  cmpwi cr6, r11, 0xae
	ctx.cr[6].compare_i32(ctx.r[11].s32, 174, &mut ctx.xer);
	// 828F40AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F40B0: 41990008  bgt cr6, 0x828f40b8
	if ctx.cr[6].gt {
	pc = 0x828F40B8; continue 'dispatch;
	}
	// 828F40B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828F40B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F40BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F40C0: 409A001C  bne cr6, 0x828f40dc
	if !ctx.cr[6].eq {
	pc = 0x828F40DC; continue 'dispatch;
	}
	// 828F40C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F40C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F40CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F40D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F40D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F40D8: 48000018  b 0x828f40f0
	pc = 0x828F40F0; continue 'dispatch;
	// 828F40DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F40E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F40E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F40E8: 48000008  b 0x828f40f0
	pc = 0x828F40F0; continue 'dispatch;
	// 828F40EC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828F40F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F40F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F40F8: 419A0058  beq cr6, 0x828f4150
	if ctx.cr[6].eq {
	pc = 0x828F4150; continue 'dispatch;
	}
	// 828F40FC: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F4100: 997F0067  stb r11, 0x67(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(103 as u32), ctx.r[11].u8 ) };
	// 828F4104: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4108: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F410C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4110: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828F4114: 4098000C  bge cr6, 0x828f4120
	if !ctx.cr[6].lt {
	pc = 0x828F4120; continue 'dispatch;
	}
	// 828F4118: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 828F411C: 48000014  b 0x828f4130
	pc = 0x828F4130; continue 'dispatch;
	// 828F4120: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 828F4124: 4099000C  ble cr6, 0x828f4130
	if !ctx.cr[6].gt {
	pc = 0x828F4130; continue 'dispatch;
	}
	// 828F4128: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 828F412C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 828F4130: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F4134: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828F4138: 392AF038  addi r9, r10, -0xfc8
	ctx.r[9].s64 = ctx.r[10].s64 + -4040;
	// 828F413C: 55682036  slwi r8, r11, 4
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F4140: 7CE848AE  lbzx r7, r8, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828F4144: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F4148: 409A0008  bne cr6, 0x828f4150
	if !ctx.cr[6].eq {
	pc = 0x828F4150; continue 'dispatch;
	}
	// 828F414C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 828F4150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F4154: 483B5308  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4158 size=192
    let mut pc: u32 = 0x828F4158;
    'dispatch: loop {
        match pc {
            0x828F4158 => {
    //   block [0x828F4158..0x828F4218)
	// 828F4158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F415C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F4160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F4164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F4168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F416C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F4170: 48002709  bl 0x828f6878
	ctx.lr = 0x828F4174;
	sub_828F6878(ctx, base);
	// 828F4174: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F4178: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F417C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F4184: 48001C1D  bl 0x828f5da0
	ctx.lr = 0x828F4188;
	sub_828F5DA0(ctx, base);
	// 828F4188: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828F418C: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 828F4190: 4198FFE8  blt cr6, 0x828f4178
	if ctx.cr[6].lt {
	pc = 0x828F4178; continue 'dispatch;
	}
	// 828F4194: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F4198: 895E0068  lbz r10, 0x68(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F419C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F41A0: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F41A4: D01E0054  stfs f0, 0x54(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F41A8: D01E0058  stfs f0, 0x58(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F41AC: D01E005C  stfs f0, 0x5c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F41B0: 419A001C  beq cr6, 0x828f41cc
	if ctx.cr[6].eq {
	pc = 0x828F41CC; continue 'dispatch;
	}
	// 828F41B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F41B8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F41BC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 828F41C0: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 828F41C4: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 828F41C8: 4BD05119  bl 0x825f92e0
	ctx.lr = 0x828F41CC;
	sub_825F92E0(ctx, base);
	// 828F41CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F41D0: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F41D4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828F41D8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F41DC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F41E0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F41E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F41E8: 81460038  lwz r10, 0x38(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F41EC: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828F41F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F41F4: 4099000C  ble cr6, 0x828f4200
	if !ctx.cr[6].gt {
	pc = 0x828F4200; continue 'dispatch;
	}
	// 828F41F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F41FC: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 828F4200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F4204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F4208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F420C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F4210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F4214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F4218 size=448
    let mut pc: u32 = 0x828F4218;
    'dispatch: loop {
        match pc {
            0x828F4218 => {
    //   block [0x828F4218..0x828F43D8)
	// 828F4218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F421C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F4220: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F4224: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F4228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F422C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F4230: 480027E9  bl 0x828f6a18
	ctx.lr = 0x828F4234;
	sub_828F6A18(ctx, base);
	// 828F4234: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F4238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F423C: 83CB8F00  lwz r30, -0x7100(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28928 as u32) ) } as u64;
	// 828F4240: 4BD08971  bl 0x825fcbb0
	ctx.lr = 0x828F4244;
	sub_825FCBB0(ctx, base);
	// 828F4244: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F4248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F424C: 419A0170  beq cr6, 0x828f43bc
	if ctx.cr[6].eq {
	pc = 0x828F43BC; continue 'dispatch;
	}
	// 828F4250: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4254: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828F4258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F425C: 554867FE  rlwinm r8, r10, 0xc, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828F4260: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F4264: 80698F04  lwz r3, -0x70fc(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28924 as u32) ) } as u64;
	// 828F4268: 419A00EC  beq cr6, 0x828f4354
	if ctx.cr[6].eq {
	pc = 0x828F4354; continue 'dispatch;
	}
	// 828F426C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F4270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4274: 419A0020  beq cr6, 0x828f4294
	if ctx.cr[6].eq {
	pc = 0x828F4294; continue 'dispatch;
	}
	// 828F4278: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F427C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F4280: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F4284: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F4288: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F428C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4290: 480000C8  b 0x828f4358
	pc = 0x828F4358; continue 'dispatch;
	// 828F4294: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F4298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F429C: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F42A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F42A4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F42A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F42AC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F42B0: 40810054  ble 0x828f4304
	if !ctx.cr[0].gt {
	pc = 0x828F4304; continue 'dispatch;
	}
	// 828F42B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F42B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F42BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F42C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F42C4: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828F42C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F42CC: 41980008  blt cr6, 0x828f42d4
	if ctx.cr[6].lt {
	pc = 0x828F42D4; continue 'dispatch;
	}
	// 828F42D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F42D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F42D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F42DC: 419A0014  beq cr6, 0x828f42f0
	if ctx.cr[6].eq {
	pc = 0x828F42F0; continue 'dispatch;
	}
	// 828F42E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F42E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F42E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F42EC: 4800000C  b 0x828f42f8
	pc = 0x828F42F8; continue 'dispatch;
	// 828F42F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F42F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F42F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F42FC: 4199FFB8  bgt cr6, 0x828f42b4
	if ctx.cr[6].gt {
	pc = 0x828F42B4; continue 'dispatch;
	}
	// 828F4300: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F4304: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F4308: 419A003C  beq cr6, 0x828f4344
	if ctx.cr[6].eq {
	pc = 0x828F4344; continue 'dispatch;
	}
	// 828F430C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4310: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828F4314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F4318: 41990008  bgt cr6, 0x828f4320
	if ctx.cr[6].gt {
	pc = 0x828F4320; continue 'dispatch;
	}
	// 828F431C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F4320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F4324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4328: 409A001C  bne cr6, 0x828f4344
	if !ctx.cr[6].eq {
	pc = 0x828F4344; continue 'dispatch;
	}
	// 828F432C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F4330: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F4334: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F4338: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F433C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4340: 48000018  b 0x828f4358
	pc = 0x828F4358; continue 'dispatch;
	// 828F4344: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F4348: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F434C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4350: 48000008  b 0x828f4358
	pc = 0x828F4358; continue 'dispatch;
	// 828F4354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F4358: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828F435C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4360: 419A0060  beq cr6, 0x828f43c0
	if ctx.cr[6].eq {
	pc = 0x828F43C0; continue 'dispatch;
	}
	// 828F4364: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828F4368: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F436C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F4370: 81296D8C  lwz r9, 0x6d8c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28044 as u32) ) } as u64;
	// 828F4374: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828F4378: 40990048  ble cr6, 0x828f43c0
	if !ctx.cr[6].gt {
	pc = 0x828F43C0; continue 'dispatch;
	}
	// 828F437C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F4380: 396BF138  addi r11, r11, -0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + -3784;
	// 828F4384: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F4388: 88EBFFFD  lbz r7, -3(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-3 as u32) ) } as u64;
	// 828F438C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F4390: 419A0010  beq cr6, 0x828f43a0
	if ctx.cr[6].eq {
	pc = 0x828F43A0; continue 'dispatch;
	}
	// 828F4394: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4398: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828F439C: 419A0018  beq cr6, 0x828f43b4
	if ctx.cr[6].eq {
	pc = 0x828F43B4; continue 'dispatch;
	}
	// 828F43A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F43A4: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 828F43A8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828F43AC: 4198FFDC  blt cr6, 0x828f4388
	if ctx.cr[6].lt {
	pc = 0x828F4388; continue 'dispatch;
	}
	// 828F43B0: 48000010  b 0x828f43c0
	pc = 0x828F43C0; continue 'dispatch;
	// 828F43B4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828F43B8: 48000008  b 0x828f43c0
	pc = 0x828F43C0; continue 'dispatch;
	// 828F43BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F43C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F43C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F43C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F43CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F43D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F43D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F43D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F43D8 size=328
    let mut pc: u32 = 0x828F43D8;
    'dispatch: loop {
        match pc {
            0x828F43D8 => {
    //   block [0x828F43D8..0x828F4520)
	// 828F43D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F43DC: 483B5031  bl 0x82ca940c
	ctx.lr = 0x828F43E0;
	sub_82CA93D0(ctx, base);
	// 828F43E0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828F43E4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828F43E8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F4520 size=184
    let mut pc: u32 = 0x828F4520;
    'dispatch: loop {
        match pc {
            0x828F4520 => {
    //   block [0x828F4520..0x828F45D8)
	// 828F4520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F4528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F452C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F4530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F4538: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F453C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828F4540: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F4544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F4548: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828F454C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4550: 4B920349  bl 0x82214898
	ctx.lr = 0x828F4554;
	sub_82214898(ctx, base);
	// 828F4554: 3BFE0074  addi r31, r30, 0x74
	ctx.r[31].s64 = ctx.r[30].s64 + 116;
	// 828F4558: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F455C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4560: 4BBDD969  bl 0x824d1ec8
	ctx.lr = 0x828F4564;
	sub_824D1EC8(ctx, base);
	// 828F4564: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828F4568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F456C: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828F4570: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828F4574: 4B89F8C5  bl 0x82193e38
	ctx.lr = 0x828F4578;
	sub_82193E38(ctx, base);
	// 828F4578: 817E0078  lwz r11, 0x78(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 828F457C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4580: 419A0034  beq cr6, 0x828f45b4
	if ctx.cr[6].eq {
	pc = 0x828F45B4; continue 'dispatch;
	}
	// 828F4584: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F458C: 419A0040  beq cr6, 0x828f45cc
	if ctx.cr[6].eq {
	pc = 0x828F45CC; continue 'dispatch;
	}
	// 828F4590: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F4594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4598: 419A001C  beq cr6, 0x828f45b4
	if ctx.cr[6].eq {
	pc = 0x828F45B4; continue 'dispatch;
	}
	// 828F459C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F45A0: 4B87F899  bl 0x82173e38
	ctx.lr = 0x828F45A4;
	sub_82173E38(ctx, base);
	// 828F45A4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F45A8: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828F45AC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F45B0: 915E0070  stw r10, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828F45B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F45B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F45BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F45C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F45C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F45C8: 4E800020  blr
	return;
	// 828F45CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F45D0: 4B89F869  bl 0x82193e38
	ctx.lr = 0x828F45D4;
	sub_82193E38(ctx, base);
	// 828F45D4: 4BFFFFE0  b 0x828f45b4
	pc = 0x828F45B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F45D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F45D8 size=60
    let mut pc: u32 = 0x828F45D8;
    'dispatch: loop {
        match pc {
            0x828F45D8 => {
    //   block [0x828F45D8..0x828F4614)
	// 828F45D8: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F45DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F45E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F45E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828F45E8: 409A0020  bne cr6, 0x828f4608
	if !ctx.cr[6].eq {
	pc = 0x828F4608; continue 'dispatch;
	}
	// 828F45EC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F45F0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828F45F4: 409A0014  bne cr6, 0x828f4608
	if !ctx.cr[6].eq {
	pc = 0x828F4608; continue 'dispatch;
	}
	// 828F45F8: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F45FC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 828F4600: 41980008  blt cr6, 0x828f4608
	if ctx.cr[6].lt {
	pc = 0x828F4608; continue 'dispatch;
	}
	// 828F4604: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F4608: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F460C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4610: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4614(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F4614 size=152
    let mut pc: u32 = 0x828F4614;
    'dispatch: loop {
        match pc {
            0x828F4614 => {
    //   block [0x828F4614..0x828F46AC)
	// 828F4614: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828F4618: 81230024  lwz r9, 0x24(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F461C: D0230044  stfs f1, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828F4620: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4624: 394AF138  addi r10, r10, -0xec8
	ctx.r[10].s64 = ctx.r[10].s64 + -3784;
	// 828F4628: D0430048  stfs f2, 0x48(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828F462C: 1D09001C  mulli r8, r9, 0x1c
	ctx.r[8].s64 = ctx.r[9].s64 * 28;
	// 828F4630: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 828F4634: 7CA838AE  lbzx r5, r8, r7
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828F4638: 98A30062  stb r5, 0x62(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(98 as u32), ctx.r[5].u8 ) };
	// 828F463C: 98A30063  stb r5, 0x63(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(99 as u32), ctx.r[5].u8 ) };
	// 828F4640: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F4644: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828F4648: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F464C: 419A0078  beq cr6, 0x828f46c4
	if ctx.cr[6].eq {
		sub_828F46C4(ctx, base);
		return;
	}
	// 828F4650: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F4654: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4658: 409A0064  bne cr6, 0x828f46bc
	if !ctx.cr[6].eq {
		sub_828F46AC(ctx, base);
		return;
	}
	// 828F465C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F4660: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F4664: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828F4668: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F466C: 40810050  ble 0x828f46bc
	if !ctx.cr[0].gt {
		sub_828F46AC(ctx, base);
		return;
	}
	// 828F4670: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F4674: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F4678: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F467C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4680: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 828F4684: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F4688: 41980008  blt cr6, 0x828f4690
	if ctx.cr[6].lt {
	pc = 0x828F4690; continue 'dispatch;
	}
	// 828F468C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 828F4690: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F4694: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F4698: 419A0014  beq cr6, 0x828f46ac
	if ctx.cr[6].eq {
		sub_828F46AC(ctx, base);
		return;
	}
	// 828F469C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F46A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F46A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F46A8: 4800000C  b 0x828f46b4
	sub_828F46AC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F46AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F46AC size=24
    let mut pc: u32 = 0x828F46AC;
    'dispatch: loop {
        match pc {
            0x828F46AC => {
    //   block [0x828F46AC..0x828F46C4)
	// 828F46AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F46B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F46B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F46B8: 4199FFB8  bgt cr6, 0x828f4670
	if ctx.cr[6].gt {
		sub_828F4614(ctx, base);
		return;
	}
	// 828F46BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F46C0: 48000008  b 0x828f46c8
	sub_828F46C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F46C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F46C4 size=92
    let mut pc: u32 = 0x828F46C4;
    'dispatch: loop {
        match pc {
            0x828F46C4 => {
    //   block [0x828F46C4..0x828F4720)
	// 828F46C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828F46C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F46CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F46D0: 419A000C  beq cr6, 0x828f46dc
	if ctx.cr[6].eq {
	pc = 0x828F46DC; continue 'dispatch;
	}
	// 828F46D4: 98830062  stb r4, 0x62(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(98 as u32), ctx.r[4].u8 ) };
	// 828F46D8: 98830063  stb r4, 0x63(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(99 as u32), ctx.r[4].u8 ) };
	// 828F46DC: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 828F46E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F46E4: 409A0008  bne cr6, 0x828f46ec
	if !ctx.cr[6].eq {
	pc = 0x828F46EC; continue 'dispatch;
	}
	// 828F46E8: 98830062  stb r4, 0x62(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(98 as u32), ctx.r[4].u8 ) };
	// 828F46EC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 828F46F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F46F4: 419A0014  beq cr6, 0x828f4708
	if ctx.cr[6].eq {
	pc = 0x828F4708; continue 'dispatch;
	}
	// 828F46F8: 89630062  lbz r11, 0x62(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(98 as u32) ) } as u64;
	// 828F46FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4700: 409A0008  bne cr6, 0x828f4708
	if !ctx.cr[6].eq {
	pc = 0x828F4708; continue 'dispatch;
	}
	// 828F4704: 98830063  stb r4, 0x63(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(99 as u32), ctx.r[4].u8 ) };
	// 828F4708: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F470C: C1A30050  lfs f13, 0x50(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4710: 396B94CC  addi r11, r11, -0x6b34
	ctx.r[11].s64 = ctx.r[11].s64 + -27444;
	// 828F4714: C00BFFB8  lfs f0, -0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4718: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F471C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F4720 size=12
    let mut pc: u32 = 0x828F4720;
    'dispatch: loop {
        match pc {
            0x828F4720 => {
    //   block [0x828F4720..0x828F472C)
	// 828F4720: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4724: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F4728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4730 size=248
    let mut pc: u32 = 0x828F4730;
    'dispatch: loop {
        match pc {
            0x828F4730 => {
    //   block [0x828F4730..0x828F4828)
	// 828F4730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4734: 483B4CD1  bl 0x82ca9404
	ctx.lr = 0x828F4738;
	sub_82CA93D0(ctx, base);
	// 828F4738: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 828F473C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828F4740: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4744: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828F4748: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F474C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F4750: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 828F4754: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 828F4758: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828F475C: 3969F138  addi r11, r9, -0xec8
	ctx.r[11].s64 = ctx.r[9].s64 + -3784;
	// 828F4760: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4764: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828F4768: D07F004C  stfs f3, 0x4c(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828F476C: 90BF0024  stw r5, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 828F4770: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828F4774: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 828F4778: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 828F477C: 1CE5001C  mulli r7, r5, 0x1c
	ctx.r[7].s64 = ctx.r[5].s64 * 28;
	// 828F4780: C04821CC  lfs f2, 0x21cc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8652 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F4784: 38CB0018  addi r6, r11, 0x18
	ctx.r[6].s64 = ctx.r[11].s64 + 24;
	// 828F4788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F478C: 7C27342E  lfsx f1, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F4790: 4BD02791  bl 0x825f6f20
	ctx.lr = 0x828F4794;
	sub_825F6F20(ctx, base);
	// 828F4794: D03F0040  stfs f1, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828F4798: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 828F479C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F47A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F47A4: 4BFFFD7D  bl 0x828f4520
	ctx.lr = 0x828F47A8;
	sub_828F4520(ctx, base);
	// 828F47A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F47AC: 939F002C  stw r28, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	// 828F47B0: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 828F47B4: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 828F47B8: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 828F47BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F47C0: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 828F47C4: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 828F47C8: 419A001C  beq cr6, 0x828f47e4
	if ctx.cr[6].eq {
	pc = 0x828F47E4; continue 'dispatch;
	}
	// 828F47CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F47D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F47D4: 419A000C  beq cr6, 0x828f47e0
	if ctx.cr[6].eq {
	pc = 0x828F47E0; continue 'dispatch;
	}
	// 828F47D8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828F47DC: 4800000C  b 0x828f47e8
	pc = 0x828F47E8; continue 'dispatch;
	// 828F47E0: 4B89F659  bl 0x82193e38
	ctx.lr = 0x828F47E4;
	sub_82193E38(ctx, base);
	// 828F47E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F47E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828F47EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F47F0: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 828F47F4: 4BE5251D  bl 0x82746d10
	ctx.lr = 0x828F47F8;
	sub_82746D10(ctx, base);
	// 828F47F8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F47FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F4800: 88C100FF  lbz r6, 0xff(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(255 as u32) ) } as u64;
	// 828F4804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4808: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F480C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4810: 997F0061  stb r11, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 828F4814: 4BFFFDC5  bl 0x828f45d8
	ctx.lr = 0x828F4818;
	sub_828F45D8(ctx, base);
	// 828F4818: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F481C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828F4820: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F4824: 483B4C30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4828 size=208
    let mut pc: u32 = 0x828F4828;
    'dispatch: loop {
        match pc {
            0x828F4828 => {
    //   block [0x828F4828..0x828F48F8)
	// 828F4828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F482C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F4830: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4834: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F4838: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828F483C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F4840: 394AF138  addi r10, r10, -0xec8
	ctx.r[10].s64 = ctx.r[10].s64 + -3784;
	// 828F4844: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4848: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 828F484C: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4850: 1D29001C  mulli r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 * 28;
	// 828F4854: 7DA9442E  lfsx f13, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4858: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F485C: 41980058  blt cr6, 0x828f48b4
	if ctx.cr[6].lt {
	pc = 0x828F48B4; continue 'dispatch;
	}
	// 828F4860: 890B0061  lbz r8, 0x61(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 828F4864: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F4868: 419A0080  beq cr6, 0x828f48e8
	if ctx.cr[6].eq {
	pc = 0x828F48E8; continue 'dispatch;
	}
	// 828F486C: 88EB0062  lbz r7, 0x62(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(98 as u32) ) } as u64;
	// 828F4870: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 828F4874: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F4878: 419A006C  beq cr6, 0x828f48e4
	if ctx.cr[6].eq {
	pc = 0x828F48E4; continue 'dispatch;
	}
	// 828F487C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 828F4880: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4884: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F4888: 4198005C  blt cr6, 0x828f48e4
	if ctx.cr[6].lt {
	pc = 0x828F48E4; continue 'dispatch;
	}
	// 828F488C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4890: 4BD08551  bl 0x825fcde0
	ctx.lr = 0x828F4894;
	sub_825FCDE0(ctx, base);
	// 828F4894: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F4898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F489C: 409A0048  bne cr6, 0x828f48e4
	if !ctx.cr[6].eq {
	pc = 0x828F48E4; continue 'dispatch;
	}
	// 828F48A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828F48A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F48A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F48AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F48B0: 4E800020  blr
	return;
	// 828F48B4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 828F48B8: 7DA9542E  lfsx f13, r9, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F48BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F48C0: 41980028  blt cr6, 0x828f48e8
	if ctx.cr[6].lt {
	pc = 0x828F48E8; continue 'dispatch;
	}
	// 828F48C4: 896B0064  lbz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F48C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F48CC: 419A001C  beq cr6, 0x828f48e8
	if ctx.cr[6].eq {
	pc = 0x828F48E8; continue 'dispatch;
	}
	// 828F48D0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 828F48D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F48D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F48DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F48E0: 4E800020  blr
	return;
	// 828F48E4: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 828F48E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F48EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F48F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F48F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F48F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F48F8 size=1800
    //   switch @ 0x828F4B8C: r11 with 4 label(s)
    //       case  0  0x828F4BA0
    //       case  1  0x828F4BC4
    //       case  2  0x828F4C48
    //       case  3  0x828F4CB0
    let mut pc: u32 = 0x828F48F8;
    'dispatch: loop {
        match pc {
            0x828F48F8 => {
    //   block [0x828F48F8..0x828F4BA0)
	// 828F48F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F48FC: 483B4B01  bl 0x82ca93fc
	ctx.lr = 0x828F4900;
	sub_82CA93D0(ctx, base);
	// 828F4900: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828F4904: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4908: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F490C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828F4910: 3BFD0074  addi r31, r29, 0x74
	ctx.r[31].s64 = ctx.r[29].s64 + 116;
	// 828F4914: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828F4918: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 828F491C: 817D0078  lwz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 828F4920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4924: 419A00A4  beq cr6, 0x828f49c8
	if ctx.cr[6].eq {
	pc = 0x828F49C8; continue 'dispatch;
	}
	// 828F4928: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F492C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4930: 419A0100  beq cr6, 0x828f4a30
	if ctx.cr[6].eq {
	pc = 0x828F4A30; continue 'dispatch;
	}
	// 828F4934: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F4938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F493C: 419A008C  beq cr6, 0x828f49c8
	if ctx.cr[6].eq {
	pc = 0x828F49C8; continue 'dispatch;
	}
	// 828F4940: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4948: 419A0038  beq cr6, 0x828f4980
	if ctx.cr[6].eq {
	pc = 0x828F4980; continue 'dispatch;
	}
	// 828F494C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4950: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4954: 419A00E4  beq cr6, 0x828f4a38
	if ctx.cr[6].eq {
	pc = 0x828F4A38; continue 'dispatch;
	}
	// 828F4958: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F495C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4960: 419A0020  beq cr6, 0x828f4980
	if ctx.cr[6].eq {
	pc = 0x828F4980; continue 'dispatch;
	}
	// 828F4964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4968: 4B87F4D1  bl 0x82173e38
	ctx.lr = 0x828F496C;
	sub_82173E38(ctx, base);
	// 828F496C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F4970: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F4974: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828F4978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F497C: 409A0008  bne cr6, 0x828f4984
	if !ctx.cr[6].eq {
	pc = 0x828F4984; continue 'dispatch;
	}
	// 828F4980: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F4984: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F4988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F498C: 409A003C  bne cr6, 0x828f49c8
	if !ctx.cr[6].eq {
	pc = 0x828F49C8; continue 'dispatch;
	}
	// 828F4990: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F4994: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828F4998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F499C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828F49A0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F49A4: 4B89F495  bl 0x82193e38
	ctx.lr = 0x828F49A8;
	sub_82193E38(ctx, base);
	// 828F49A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F49AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F49B0: 4BBDD519  bl 0x824d1ec8
	ctx.lr = 0x828F49B4;
	sub_824D1EC8(ctx, base);
	// 828F49B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828F49B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F49BC: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828F49C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828F49C4: 4B89F475  bl 0x82193e38
	ctx.lr = 0x828F49C8;
	sub_82193E38(ctx, base);
	// 828F49C8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F49CC: 4B912E25  bl 0x822077f0
	ctx.lr = 0x828F49D0;
	sub_822077F0(ctx, base);
	// 828F49D0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828F49D4: C1BD0034  lfs f13, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F49D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F49DC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828F49E0: 3BEB9490  addi r31, r11, -0x6b70
	ctx.r[31].s64 = ctx.r[11].s64 + -27504;
	// 828F49E4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F49E8: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828F49EC: FD810024  fdiv f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828F49F0: 3B8BF138  addi r28, r11, -0xec8
	ctx.r[28].s64 = ctx.r[11].s64 + -3784;
	// 828F49F4: C01FFFF4  lfs f0, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F49F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F49FC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 828F4A00: 419A0044  beq cr6, 0x828f4a44
	if ctx.cr[6].eq {
	pc = 0x828F4A44; continue 'dispatch;
	}
	// 828F4A04: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F4A08: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F4A0C: 4099001C  ble cr6, 0x828f4a28
	if !ctx.cr[6].gt {
	pc = 0x828F4A28; continue 'dispatch;
	}
	// 828F4A10: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 828F4A14: D1BD0034  stfs f13, 0x34(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F4A18: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F4A1C: 4199000C  bgt cr6, 0x828f4a28
	if ctx.cr[6].gt {
	pc = 0x828F4A28; continue 'dispatch;
	}
	// 828F4A20: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F4A24: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828F4A28: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828F4A2C: 4800006C  b 0x828f4a98
	pc = 0x828F4A98; continue 'dispatch;
	// 828F4A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4A34: 4BFFFF90  b 0x828f49c4
	pc = 0x828F49C4; continue 'dispatch;
	// 828F4A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4A3C: 4B89F3FD  bl 0x82193e38
	ctx.lr = 0x828F4A40;
	sub_82193E38(ctx, base);
	// 828F4A40: 4BFFFF40  b 0x828f4980
	pc = 0x828F4980; continue 'dispatch;
	// 828F4A44: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4A48: C01D0040  lfs f0, 0x40(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4A4C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 828F4A50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4A54: 409A0038  bne cr6, 0x828f4a8c
	if !ctx.cr[6].eq {
	pc = 0x828F4A8C; continue 'dispatch;
	}
	// 828F4A58: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4A5C: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 828F4A60: C1BFFE44  lfs f13, -0x1bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-444 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4A64: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 828F4A68: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828F4A6C: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828F4A70: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F4A74: 409A0018  bne cr6, 0x828f4a8c
	if !ctx.cr[6].eq {
	pc = 0x828F4A8C; continue 'dispatch;
	}
	// 828F4A78: 897D0067  lbz r11, 0x67(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(103 as u32) ) } as u64;
	// 828F4A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4A80: 419A000C  beq cr6, 0x828f4a8c
	if ctx.cr[6].eq {
	pc = 0x828F4A8C; continue 'dispatch;
	}
	// 828F4A84: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4A88: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828F4A8C: C1BD003C  lfs f13, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4A90: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 828F4A94: D19D003C  stfs f12, 0x3c(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F4A98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4A9C: 48000A35  bl 0x828f54d0
	ctx.lr = 0x828F4AA0;
	sub_828F54D0(ctx, base);
	// 828F4AA0: C01FFFF4  lfs f0, -0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4AA4: C1BD003C  lfs f13, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4AA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F4AAC: 40990524  ble cr6, 0x828f4fd0
	if !ctx.cr[6].gt {
	pc = 0x828F4FD0; continue 'dispatch;
	}
	// 828F4AB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4AB4: 4BFFFD75  bl 0x828f4828
	ctx.lr = 0x828F4AB8;
	sub_828F4828(ctx, base);
	// 828F4AB8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4ABC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828F4AC0: 419A0010  beq cr6, 0x828f4ad0
	if ctx.cr[6].eq {
	pc = 0x828F4AD0; continue 'dispatch;
	}
	// 828F4AC4: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828F4AC8: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828F4ACC: 9B5D0060  stb r26, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[26].u8 ) };
	// 828F4AD0: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4AD4: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 828F4AD8: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 828F4ADC: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828F4AE0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F4AE4: 419A0088  beq cr6, 0x828f4b6c
	if ctx.cr[6].eq {
	pc = 0x828F4B6C; continue 'dispatch;
	}
	// 828F4AE8: 897D0060  lbz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F4AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4AF0: 419A007C  beq cr6, 0x828f4b6c
	if ctx.cr[6].eq {
	pc = 0x828F4B6C; continue 'dispatch;
	}
	// 828F4AF4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4AF8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828F4AFC: 419A000C  beq cr6, 0x828f4b08
	if ctx.cr[6].eq {
	pc = 0x828F4B08; continue 'dispatch;
	}
	// 828F4B00: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828F4B04: 409A0068  bne cr6, 0x828f4b6c
	if !ctx.cr[6].eq {
	pc = 0x828F4B6C; continue 'dispatch;
	}
	// 828F4B08: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F4B0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828F4B10: 419A000C  beq cr6, 0x828f4b1c
	if ctx.cr[6].eq {
	pc = 0x828F4B1C; continue 'dispatch;
	}
	// 828F4B14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4B18: 409A0054  bne cr6, 0x828f4b6c
	if !ctx.cr[6].eq {
	pc = 0x828F4B6C; continue 'dispatch;
	}
	// 828F4B1C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F4B20: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F4B24: 388B49F8  addi r4, r11, 0x49f8
	ctx.r[4].s64 = ctx.r[11].s64 + 18936;
	// 828F4B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4B2C: 4B9383A5  bl 0x8222ced0
	ctx.lr = 0x828F4B30;
	sub_8222CED0(ctx, base);
	// 828F4B30: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4B34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F4B38: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F4B3C: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4B40: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F4B44: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828F4B48: 4E800421  bctrl
	ctx.lr = 0x828F4B4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F4B4C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828F4B50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F4B54: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F4B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            0x828F4BA0 => {
    //   block [0x828F4BA0..0x828F4BC4)
	// 828F4BA0: 895D0060  lbz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F4BA4: 9B7D0060  stb r27, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[27].u8 ) };
	// 828F4BA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4BAC: 419A0120  beq cr6, 0x828f4ccc
	if ctx.cr[6].eq {
	pc = 0x828F4CCC; continue 'dispatch;
	}
	// 828F4BB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F4BB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4BB8: 48000449  bl 0x828f5000
	ctx.lr = 0x828F4BBC;
	sub_828F5000(ctx, base);
	// 828F4BBC: 9B7D0064  stb r27, 0x64(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[27].u8 ) };
	// 828F4BC0: 4800010C  b 0x828f4ccc
	pc = 0x828F4CCC; continue 'dispatch;
            }
            0x828F4BC4 => {
    //   block [0x828F4BC4..0x828F4C48)
	// 828F4BC4: 895D0060  lbz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F4BC8: 9B7D0060  stb r27, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[27].u8 ) };
	// 828F4BCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4BD0: 419A0044  beq cr6, 0x828f4c14
	if ctx.cr[6].eq {
	pc = 0x828F4C14; continue 'dispatch;
	}
	// 828F4BD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F4BD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4BDC: 48000425  bl 0x828f5000
	ctx.lr = 0x828F4BE0;
	sub_828F5000(ctx, base);
	// 828F4BE0: C19FFFF4  lfs f12, -0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F4BE4: C01D0038  lfs f0, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4BE8: 9B5D0064  stb r26, 0x64(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[26].u8 ) };
	// 828F4BEC: C1BD0044  lfs f13, 0x44(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F4BF0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828F4BF4: 419A0008  beq cr6, 0x828f4bfc
	if ctx.cr[6].eq {
	pc = 0x828F4BFC; continue 'dispatch;
	}
	// 828F4BF8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 828F4BFC: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4C00: 395C0008  addi r10, r28, 8
	ctx.r[10].s64 = ctx.r[28].s64 + 8;
	// 828F4C04: D1BD0034  stfs f13, 0x34(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F4C08: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 828F4C0C: 7C09542E  lfsx f0, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4C10: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F4C14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4C18: 48000791  bl 0x828f53a8
	ctx.lr = 0x828F4C1C;
	sub_828F53A8(ctx, base);
	// 828F4C1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4C20: 48000691  bl 0x828f52b0
	ctx.lr = 0x828F4C24;
	sub_828F52B0(ctx, base);
	// 828F4C24: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828F4C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4C2C: 419A00A0  beq cr6, 0x828f4ccc
	if ctx.cr[6].eq {
	pc = 0x828F4CCC; continue 'dispatch;
	}
	// 828F4C30: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4C34: 395C000C  addi r10, r28, 0xc
	ctx.r[10].s64 = ctx.r[28].s64 + 12;
	// 828F4C38: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 828F4C3C: 7C09542E  lfsx f0, r9, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4C40: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F4C44: 48000088  b 0x828f4ccc
	pc = 0x828F4CCC; continue 'dispatch;
            }
            0x828F4C48 => {
    //   block [0x828F4C48..0x828F4CB0)
	// 828F4C48: 895D0060  lbz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F4C4C: 9B7D0060  stb r27, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[27].u8 ) };
	// 828F4C50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4C54: 419A001C  beq cr6, 0x828f4c70
	if ctx.cr[6].eq {
	pc = 0x828F4C70; continue 'dispatch;
	}
	// 828F4C58: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F4C5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4C60: 480003A1  bl 0x828f5000
	ctx.lr = 0x828F4C64;
	sub_828F5000(ctx, base);
	// 828F4C64: C01D0038  lfs f0, 0x38(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4C68: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F4C6C: 9B5D0064  stb r26, 0x64(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[26].u8 ) };
	// 828F4C70: 897D0062  lbz r11, 0x62(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(98 as u32) ) } as u64;
	// 828F4C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4C78: 409A000C  bne cr6, 0x828f4c84
	if !ctx.cr[6].eq {
	pc = 0x828F4C84; continue 'dispatch;
	}
	// 828F4C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4C80: 48000729  bl 0x828f53a8
	ctx.lr = 0x828F4C84;
	sub_828F53A8(ctx, base);
	// 828F4C84: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828F4C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4C8C: 419A0018  beq cr6, 0x828f4ca4
	if ctx.cr[6].eq {
	pc = 0x828F4CA4; continue 'dispatch;
	}
	// 828F4C90: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4C94: 395C0010  addi r10, r28, 0x10
	ctx.r[10].s64 = ctx.r[28].s64 + 16;
	// 828F4C98: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 828F4C9C: 7C09542E  lfsx f0, r9, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4CA0: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F4CA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4CA8: 48000609  bl 0x828f52b0
	ctx.lr = 0x828F4CAC;
	sub_828F52B0(ctx, base);
	// 828F4CAC: 48000020  b 0x828f4ccc
	pc = 0x828F4CCC; continue 'dispatch;
            }
            0x828F4CB0 => {
    //   block [0x828F4CB0..0x828F5000)
	// 828F4CB0: 895D0060  lbz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F4CB4: 9B7D0060  stb r27, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[27].u8 ) };
	// 828F4CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F4CBC: 419A0010  beq cr6, 0x828f4ccc
	if ctx.cr[6].eq {
	pc = 0x828F4CCC; continue 'dispatch;
	}
	// 828F4CC0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828F4CC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4CC8: 48000339  bl 0x828f5000
	ctx.lr = 0x828F4CCC;
	sub_828F5000(ctx, base);
	// 828F4CCC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4CD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F4CD4: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F4CD8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4CDC: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F4CE0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828F4CE4: 4E800421  bctrl
	ctx.lr = 0x828F4CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F4CE8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828F4CEC: 81686AB8  lwz r11, 0x6ab8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F4CF0: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4CF4: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F4CF8: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4CFC: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F4D00: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4D04: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F4D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4D0C: 419A002C  beq cr6, 0x828f4d38
	if ctx.cr[6].eq {
	pc = 0x828F4D38; continue 'dispatch;
	}
	// 828F4D10: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828F4D14: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F5000 size=688
    let mut pc: u32 = 0x828F5000;
    'dispatch: loop {
        match pc {
            0x828F5000 => {
    //   block [0x828F5000..0x828F52B0)
	// 828F5000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F500C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5018: 3D80828F  lis r12, -0x7d71
	ctx.r[12].s64 = -2104557568;
	// 828F501C: 398C5030  addi r12, r12, 0x5030
	ctx.r[12].s64 = ctx.r[12].s64 + 20528;
	// 828F5020: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828F5024: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828F5028: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828F502C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 828F5030: 828F5040  lwz r20, 0x5040(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20544 as u32) ) } as u64;
	// 828F5034: 828F50A8  lwz r20, 0x50a8(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20648 as u32) ) } as u64;
	// 828F5038: 828F5188  lwz r20, 0x5188(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20872 as u32) ) } as u64;
	// 828F503C: 828F5210  lwz r20, 0x5210(r15)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(21008 as u32) ) } as u64;
	// 828F5040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5044: 48001835  bl 0x828f6878
	ctx.lr = 0x828F5048;
	sub_828F6878(ctx, base);
	// 828F5048: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F504C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828F5050: 419A0048  beq cr6, 0x828f5098
	if ctx.cr[6].eq {
	pc = 0x828F5098; continue 'dispatch;
	}
	// 828F5054: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 828F5058: 419A0020  beq cr6, 0x828f5078
	if ctx.cr[6].eq {
	pc = 0x828F5078; continue 'dispatch;
	}
	// 828F505C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F5060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5064: 48000D3D  bl 0x828f5da0
	ctx.lr = 0x828F5068;
	sub_828F5DA0(ctx, base);
	// 828F5068: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F506C: 394B949C  addi r10, r11, -0x6b64
	ctx.r[10].s64 = ctx.r[11].s64 + -27492;
	// 828F5070: C00AFFE8  lfs f0, -0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5074: 48000220  b 0x828f5294
	pc = 0x828F5294; continue 'dispatch;
	// 828F5078: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F507C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F5080: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F5084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5088: 48000D19  bl 0x828f5da0
	ctx.lr = 0x828F508C;
	sub_828F5DA0(ctx, base);
	// 828F508C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828F5090: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 828F5094: 4198FFE8  blt cr6, 0x828f507c
	if ctx.cr[6].lt {
	pc = 0x828F507C; continue 'dispatch;
	}
	// 828F5098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F509C: 394B949C  addi r10, r11, -0x6b64
	ctx.r[10].s64 = ctx.r[11].s64 + -27492;
	// 828F50A0: C00AFFE8  lfs f0, -0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F50A4: 480001F0  b 0x828f5294
	pc = 0x828F5294; continue 'dispatch;
	// 828F50A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F50AC: 48001625  bl 0x828f66d0
	ctx.lr = 0x828F50B0;
	sub_828F66D0(ctx, base);
	// 828F50B0: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F50B4: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828F50B8: 419A003C  beq cr6, 0x828f50f4
	if ctx.cr[6].eq {
	pc = 0x828F50F4; continue 'dispatch;
	}
	// 828F50BC: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 828F50C0: 419A0014  beq cr6, 0x828f50d4
	if ctx.cr[6].eq {
	pc = 0x828F50D4; continue 'dispatch;
	}
	// 828F50C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F50C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F50CC: 48000CD5  bl 0x828f5da0
	ctx.lr = 0x828F50D0;
	sub_828F5DA0(ctx, base);
	// 828F50D0: 48000024  b 0x828f50f4
	pc = 0x828F50F4; continue 'dispatch;
	// 828F50D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F50D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F50DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F50E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F50E4: 48000CBD  bl 0x828f5da0
	ctx.lr = 0x828F50E8;
	sub_828F5DA0(ctx, base);
	// 828F50E8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828F50EC: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 828F50F0: 4198FFE8  blt cr6, 0x828f50d8
	if ctx.cr[6].lt {
	pc = 0x828F50D8; continue 'dispatch;
	}
	// 828F50F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F50F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F50FC: 480005B5  bl 0x828f56b0
	ctx.lr = 0x828F5100;
	sub_828F56B0(ctx, base);
	// 828F5100: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5104: 4BD06215  bl 0x825fb318
	ctx.lr = 0x828F5108;
	sub_825FB318(ctx, base);
	// 828F5108: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F510C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828F5110: 419A0018  beq cr6, 0x828f5128
	if ctx.cr[6].eq {
	pc = 0x828F5128; continue 'dispatch;
	}
	// 828F5114: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F5118: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F511C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5120: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F5124: 409A0008  bne cr6, 0x828f512c
	if !ctx.cr[6].eq {
	pc = 0x828F512C; continue 'dispatch;
	}
	// 828F5128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F512C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F5130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5134: 419A0028  beq cr6, 0x828f515c
	if ctx.cr[6].eq {
	pc = 0x828F515C; continue 'dispatch;
	}
	// 828F5138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F513C: 4BE4D67D  bl 0x827427b8
	ctx.lr = 0x828F5140;
	sub_827427B8(ctx, base);
	// 828F5140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F5144: 4BE54DF5  bl 0x82749f38
	ctx.lr = 0x828F5148;
	sub_82749F38(ctx, base);
	// 828F5148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F514C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F5150: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F5154: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 828F5158: 4BD029A9  bl 0x825f7b00
	ctx.lr = 0x828F515C;
	sub_825F7B00(ctx, base);
	// 828F515C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F5160: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F5164: 396BF138  addi r11, r11, -0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + -3784;
	// 828F5168: 1D2A001C  mulli r9, r10, 0x1c
	ctx.r[9].s64 = ctx.r[10].s64 * 28;
	// 828F516C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 828F5170: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F5174: 7CE940AE  lbzx r7, r9, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828F5178: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F517C: 419A0110  beq cr6, 0x828f528c
	if ctx.cr[6].eq {
	pc = 0x828F528C; continue 'dispatch;
	}
	// 828F5180: C00B949C  lfs f0, -0x6b64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5184: 48000110  b 0x828f5294
	pc = 0x828F5294; continue 'dispatch;
	// 828F5188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F518C: 480016ED  bl 0x828f6878
	ctx.lr = 0x828F5190;
	sub_828F6878(ctx, base);
	// 828F5190: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F5194: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828F5198: 419A003C  beq cr6, 0x828f51d4
	if ctx.cr[6].eq {
	pc = 0x828F51D4; continue 'dispatch;
	}
	// 828F519C: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 828F51A0: 419A0014  beq cr6, 0x828f51b4
	if ctx.cr[6].eq {
	pc = 0x828F51B4; continue 'dispatch;
	}
	// 828F51A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F51A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F51AC: 48000BF5  bl 0x828f5da0
	ctx.lr = 0x828F51B0;
	sub_828F5DA0(ctx, base);
	// 828F51B0: 48000024  b 0x828f51d4
	pc = 0x828F51D4; continue 'dispatch;
	// 828F51B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F51B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F51BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F51C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F51C4: 48000BDD  bl 0x828f5da0
	ctx.lr = 0x828F51C8;
	sub_828F5DA0(ctx, base);
	// 828F51C8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828F51CC: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 828F51D0: 4198FFE8  blt cr6, 0x828f51b8
	if ctx.cr[6].lt {
	pc = 0x828F51B8; continue 'dispatch;
	}
	// 828F51D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F51D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F51DC: 480004D5  bl 0x828f56b0
	ctx.lr = 0x828F51E0;
	sub_828F56B0(ctx, base);
	// 828F51E0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F51E4: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F51E8: 396BF138  addi r11, r11, -0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + -3784;
	// 828F51EC: 1D09001C  mulli r8, r9, 0x1c
	ctx.r[8].s64 = ctx.r[9].s64 * 28;
	// 828F51F0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828F51F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F51F8: 7CE850AE  lbzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828F51FC: 394B949C  addi r10, r11, -0x6b64
	ctx.r[10].s64 = ctx.r[11].s64 + -27492;
	// 828F5200: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F5204: 419A008C  beq cr6, 0x828f5290
	if ctx.cr[6].eq {
	pc = 0x828F5290; continue 'dispatch;
	}
	// 828F5208: C00AFFE8  lfs f0, -0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F520C: 48000088  b 0x828f5294
	pc = 0x828F5294; continue 'dispatch;
	// 828F5210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5214: 48001665  bl 0x828f6878
	ctx.lr = 0x828F5218;
	sub_828F6878(ctx, base);
	// 828F5218: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F521C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828F5220: 419A003C  beq cr6, 0x828f525c
	if ctx.cr[6].eq {
	pc = 0x828F525C; continue 'dispatch;
	}
	// 828F5224: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 828F5228: 419A0014  beq cr6, 0x828f523c
	if ctx.cr[6].eq {
	pc = 0x828F523C; continue 'dispatch;
	}
	// 828F522C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F5230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5234: 48000B6D  bl 0x828f5da0
	ctx.lr = 0x828F5238;
	sub_828F5DA0(ctx, base);
	// 828F5238: 48000024  b 0x828f525c
	pc = 0x828F525C; continue 'dispatch;
	// 828F523C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F5240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F5244: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F5248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F524C: 48000B55  bl 0x828f5da0
	ctx.lr = 0x828F5250;
	sub_828F5DA0(ctx, base);
	// 828F5250: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828F5254: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 828F5258: 4198FFE8  blt cr6, 0x828f5240
	if ctx.cr[6].lt {
	pc = 0x828F5240; continue 'dispatch;
	}
	// 828F525C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F5260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5264: 4800044D  bl 0x828f56b0
	ctx.lr = 0x828F5268;
	sub_828F56B0(ctx, base);
	// 828F5268: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F526C: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F5270: 396BF138  addi r11, r11, -0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + -3784;
	// 828F5274: 1D09001C  mulli r8, r9, 0x1c
	ctx.r[8].s64 = ctx.r[9].s64 * 28;
	// 828F5278: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828F527C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F5280: 7CE850AE  lbzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828F5284: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F5288: 409AFE14  bne cr6, 0x828f509c
	if !ctx.cr[6].eq {
	pc = 0x828F509C; continue 'dispatch;
	}
	// 828F528C: 394B949C  addi r10, r11, -0x6b64
	ctx.r[10].s64 = ctx.r[11].s64 + -27492;
	// 828F5290: C00A22DC  lfs f0, 0x22dc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8924 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5294: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F5298: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F529C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F52A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F52A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F52A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F52AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F52B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F52B0 size=248
    let mut pc: u32 = 0x828F52B0;
    'dispatch: loop {
        match pc {
            0x828F52B0 => {
    //   block [0x828F52B0..0x828F53A8)
	// 828F52B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F52B4: 483B4149  bl 0x82ca93fc
	ctx.lr = 0x828F52B8;
	sub_82CA93D0(ctx, base);
	// 828F52B8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828F52BC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F53A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F53A8 size=292
    let mut pc: u32 = 0x828F53A8;
    'dispatch: loop {
        match pc {
            0x828F53A8 => {
    //   block [0x828F53A8..0x828F54CC)
	// 828F53A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F53AC: 483B4059  bl 0x82ca9404
	ctx.lr = 0x828F53B0;
	sub_82CA93D0(ctx, base);
	// 828F53B0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828F53B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F53B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F53BC: 897F0063  lbz r11, 0x63(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(99 as u32) ) } as u64;
	// 828F53C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F53C4: 419A00FC  beq cr6, 0x828f54c0
	if ctx.cr[6].eq {
	pc = 0x828F54C0; continue 'dispatch;
	}
	// 828F53C8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F53CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F53D0: 4B912421  bl 0x822077f0
	ctx.lr = 0x828F53D4;
	sub_822077F0(ctx, base);
	// 828F53D4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828F53D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F53DC: C1BF0050  lfs f13, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F53E0: 3BCB9490  addi r30, r11, -0x6b70
	ctx.r[30].s64 = ctx.r[11].s64 + -27504;
	// 828F53E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F53E8: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828F53EC: FD810024  fdiv f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828F53F0: C01EFFF4  lfs f0, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F53F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F53F8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 828F53FC: 4099001C  ble cr6, 0x828f5418
	if !ctx.cr[6].gt {
	pc = 0x828F5418; continue 'dispatch;
	}
	// 828F5400: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 828F5404: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F5408: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F540C: 4199000C  bgt cr6, 0x828f5418
	if ctx.cr[6].gt {
	pc = 0x828F5418; continue 'dispatch;
	}
	// 828F5410: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F5414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5418: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F541C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5420: 419A0008  beq cr6, 0x828f5428
	if ctx.cr[6].eq {
	pc = 0x828F5428; continue 'dispatch;
	}
	// 828F5424: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F5428: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 828F542C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5430: 419A0090  beq cr6, 0x828f54c0
	if ctx.cr[6].eq {
	pc = 0x828F54C0; continue 'dispatch;
	}
	// 828F5434: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F5438: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F543C: C3FEFE44  lfs f31, -0x1bc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-444 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F5440: 396BF138  addi r11, r11, -0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + -3784;
	// 828F5444: 1D2A001C  mulli r9, r10, 0x1c
	ctx.r[9].s64 = ctx.r[10].s64 * 28;
	// 828F5448: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 828F544C: 7CE940AE  lbzx r7, r9, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828F5450: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F5454: 419A0028  beq cr6, 0x828f547c
	if ctx.cr[6].eq {
	pc = 0x828F547C; continue 'dispatch;
	}
	// 828F5458: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F545C: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F5460: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 828F5464: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F5468: 419A0008  beq cr6, 0x828f5470
	if ctx.cr[6].eq {
	pc = 0x828F5470; continue 'dispatch;
	}
	// 828F546C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 828F5470: EFEB6824  fdivs f31, f11, f13
	ctx.f[31].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 828F5474: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828F5478: 40990040  ble cr6, 0x828f54b8
	if !ctx.cr[6].gt {
	pc = 0x828F54B8; continue 'dispatch;
	}
	// 828F547C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 828F5480: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5484: 839F002C  lwz r28, 0x2c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828F5488: 837F0028  lwz r27, 0x28(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828F548C: 4B87E9AD  bl 0x82173e38
	ctx.lr = 0x828F5490;
	sub_82173E38(ctx, base);
	// 828F5490: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5494: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5498: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F549C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828F54A0: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 828F54A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828F54A8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F54AC: 39001000  li r8, 0x1000
	ctx.r[8].s64 = 4096;
	// 828F54B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F54B4: 4BD05FCD  bl 0x825fb480
	ctx.lr = 0x828F54B8;
	sub_825FB480(ctx, base);
	// 828F54B8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F54BC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F54C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F54C4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F54C8: 483B3F8C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F54D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F54D0 size=476
    let mut pc: u32 = 0x828F54D0;
    'dispatch: loop {
        match pc {
            0x828F54D0 => {
    //   block [0x828F54D0..0x828F56AC)
	// 828F54D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F54D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F54D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F54DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F54E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F54E4: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F54E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F54EC: 419A01AC  beq cr6, 0x828f5698
	if ctx.cr[6].eq {
	pc = 0x828F5698; continue 'dispatch;
	}
	// 828F54F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F54F4: 4B9122FD  bl 0x822077f0
	ctx.lr = 0x828F54F8;
	sub_822077F0(ctx, base);
	// 828F54F8: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 828F54FC: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F5500: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F5504: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828F5508: 392BF138  addi r9, r11, -0xec8
	ctx.r[9].s64 = ctx.r[11].s64 + -3784;
	// 828F550C: 1CC7001C  mulli r6, r7, 0x1c
	ctx.r[6].s64 = ctx.r[7].s64 * 28;
	// 828F5510: C8089660  lfd f0, -0x69a0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(-27040 as u32) ) };
	// 828F5514: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828F5518: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 828F551C: 394AB970  addi r10, r10, -0x4690
	ctx.r[10].s64 = ctx.r[10].s64 + -18064;
	// 828F5520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F5524: FD200018  frsp f9, f0
	ctx.f[9].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828F5528: 7C8628AE  lbzx r4, r6, r5
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 828F552C: C18ADB14  lfs f12, -0x24ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F5530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F5534: 419A0038  beq cr6, 0x828f556c
	if ctx.cr[6].eq {
	pc = 0x828F556C; continue 'dispatch;
	}
	// 828F5538: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F553C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5540: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828F5544: 40990038  ble cr6, 0x828f557c
	if !ctx.cr[6].gt {
	pc = 0x828F557C; continue 'dispatch;
	}
	// 828F5548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F554C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828F5550: 4099002C  ble cr6, 0x828f557c
	if !ctx.cr[6].gt {
	pc = 0x828F557C; continue 'dispatch;
	}
	// 828F5554: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 828F5558: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F555C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 828F5560: 4199001C  bgt cr6, 0x828f557c
	if ctx.cr[6].gt {
	pc = 0x828F557C; continue 'dispatch;
	}
	// 828F5564: D19F005C  stfs f12, 0x5c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F5568: 48000014  b 0x828f557c
	pc = 0x828F557C; continue 'dispatch;
	// 828F556C: 891F0067  lbz r8, 0x67(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(103 as u32) ) } as u64;
	// 828F5570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828F5574: 419A0008  beq cr6, 0x828f557c
	if ctx.cr[6].eq {
	pc = 0x828F557C; continue 'dispatch;
	}
	// 828F5578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F557C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F5580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5584: 419A00C0  beq cr6, 0x828f5644
	if ctx.cr[6].eq {
	pc = 0x828F5644; continue 'dispatch;
	}
	// 828F5588: C15F0058  lfs f10, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828F558C: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F5590: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 828F5594: 419A00B0  beq cr6, 0x828f5644
	if ctx.cr[6].eq {
	pc = 0x828F5644; continue 'dispatch;
	}
	// 828F5598: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F559C: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 828F55A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F55A4: EDAA5828  fsubs f13, f10, f11
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 828F55A8: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 828F55AC: 98FF0066  stb r7, 0x66(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(102 as u32), ctx.r[7].u8 ) };
	// 828F55B0: 7CCB40AE  lbzx r6, r11, r8
	ctx.r[6].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828F55B4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828F55B8: 409A0040  bne cr6, 0x828f55f8
	if !ctx.cr[6].eq {
	pc = 0x828F55F8; continue 'dispatch;
	}
	// 828F55BC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 828F55C0: 41990030  bgt cr6, 0x828f55f0
	if ctx.cr[6].gt {
	pc = 0x828F55F0; continue 'dispatch;
	}
	// 828F55C4: 39290014  addi r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 + 20;
	// 828F55C8: C00A1C50  lfs f0, 0x1c50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F55CC: C11F003C  lfs f8, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828F55D0: 7CEB4C2E  lfsx f7, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828F55D4: ECC70032  fmuls f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F55D8: FF083000  fcmpu cr6, f8, f6
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[6].f64);
	// 828F55DC: 4098000C  bge cr6, 0x828f55e8
	if !ctx.cr[6].lt {
	pc = 0x828F55E8; continue 'dispatch;
	}
	// 828F55E0: C00AD95C  lfs f0, -0x26a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9892 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F55E4: 48000018  b 0x828f55fc
	pc = 0x828F55FC; continue 'dispatch;
	// 828F55E8: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 828F55EC: 48000010  b 0x828f55fc
	pc = 0x828F55FC; continue 'dispatch;
	// 828F55F0: C00AD964  lfs f0, -0x269c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9884 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F55F4: 48000008  b 0x828f55fc
	pc = 0x828F55FC; continue 'dispatch;
	// 828F55F8: C00A124C  lfs f0, 0x124c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F55FC: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 828F5600: FD206A10  fabs f9, f13
	ctx.f[9].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 828F5604: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 828F5608: 40990038  ble cr6, 0x828f5640
	if !ctx.cr[6].gt {
	pc = 0x828F5640; continue 'dispatch;
	}
	// 828F560C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 828F5610: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828F5614: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 828F5618: 5569DF7A  rlwinm r9, r11, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828F561C: 5568F77A  rlwinm r8, r11, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828F5620: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 828F5624: 7D264378  or r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 828F5628: 38A70E68  addi r5, r7, 0xe68
	ctx.r[5].s64 = ctx.r[7].s64 + 3688;
	// 828F562C: 7D85342E  lfsx f12, r5, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F5630: FD4C682E  fsel f10, f12, f0, f13
	ctx.f[10].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 828F5634: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 828F5638: D13F0054  stfs f9, 0x54(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F563C: 48000008  b 0x828f5644
	pc = 0x828F5644; continue 'dispatch;
	// 828F5640: D15F0054  stfs f10, 0x54(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F5644: 897F0066  lbz r11, 0x66(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(102 as u32) ) } as u64;
	// 828F5648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F564C: 419A004C  beq cr6, 0x828f5698
	if ctx.cr[6].eq {
	pc = 0x828F5698; continue 'dispatch;
	}
	// 828F5650: C00ADB20  lfs f0, -0x24e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5654: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F5658: C1BF0054  lfs f13, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F565C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F5660: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5664: 997F0066  stb r11, 0x66(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(102 as u32), ctx.r[11].u8 ) };
	// 828F5668: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F566C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 828F5670: D9410050  stfd f10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[10].u64 ) };
	// 828F5674: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F5678: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 828F567C: 40980008  bge cr6, 0x828f5684
	if !ctx.cr[6].lt {
	pc = 0x828F5684; continue 'dispatch;
	}
	// 828F5680: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828F5684: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F5688: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F568C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828F5690: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828F5694: 4BD03C4D  bl 0x825f92e0
	ctx.lr = 0x828F5698;
	sub_825F92E0(ctx, base);
	// 828F5698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F569C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F56A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F56A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F56A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F56B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F56B0 size=1776
    let mut pc: u32 = 0x828F56B0;
    'dispatch: loop {
        match pc {
            0x828F56B0 => {
    //   block [0x828F56B0..0x828F5DA0)
	// 828F56B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F56B4: 483B3D49  bl 0x82ca93fc
	ctx.lr = 0x828F56B8;
	sub_82CA93D0(ctx, base);
	// 828F56B8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828F56BC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F5DA0 size=520
    let mut pc: u32 = 0x828F5DA0;
    'dispatch: loop {
        match pc {
            0x828F5DA0 => {
    //   block [0x828F5DA0..0x828F5FA8)
	// 828F5DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5DA4: 483B365D  bl 0x82ca9400
	ctx.lr = 0x828F5DA8;
	sub_82CA93D0(ctx, base);
	// 828F5DA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5DAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F5DB0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828F5DB4: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F5DB8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828F5DBC: 3B8B007C  addi r28, r11, 0x7c
	ctx.r[28].s64 = ctx.r[11].s64 + 124;
	// 828F5DC0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F5DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5DC8: 419A01D8  beq cr6, 0x828f5fa0
	if ctx.cr[6].eq {
	pc = 0x828F5FA0; continue 'dispatch;
	}
	// 828F5DCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5DD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F5DD4: 419A0060  beq cr6, 0x828f5e34
	if ctx.cr[6].eq {
	pc = 0x828F5E34; continue 'dispatch;
	}
	// 828F5DD8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F5DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5DE0: 419A01C0  beq cr6, 0x828f5fa0
	if ctx.cr[6].eq {
	pc = 0x828F5FA0; continue 'dispatch;
	}
	// 828F5DE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F5DE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5DEC: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 828F5DF0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828F5DF4: 4B87E045  bl 0x82173e38
	ctx.lr = 0x828F5DF8;
	sub_82173E38(ctx, base);
	// 828F5DF8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828F5DFC: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828F5E00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F5E04: 419A0104  beq cr6, 0x828f5f08
	if ctx.cr[6].eq {
	pc = 0x828F5F08; continue 'dispatch;
	}
	// 828F5E08: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F5E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5E10: 419A0034  beq cr6, 0x828f5e44
	if ctx.cr[6].eq {
	pc = 0x828F5E44; continue 'dispatch;
	}
	// 828F5E14: 894B0055  lbz r10, 0x55(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(85 as u32) ) } as u64;
	// 828F5E18: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F5E1C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F5E20: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F5E24: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5E28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F5E2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5E30: 480000DC  b 0x828f5f0c
	pc = 0x828F5F0C; continue 'dispatch;
	// 828F5E34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5E38: 4B89E001  bl 0x82193e38
	ctx.lr = 0x828F5E3C;
	sub_82193E38(ctx, base);
	// 828F5E3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F5E40: 483B3610  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828F5E44: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F5E48: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F5E4C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F5E50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F5E54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F5E58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F5E5C: 40810054  ble 0x828f5eb0
	if !ctx.cr[0].gt {
	pc = 0x828F5EB0; continue 'dispatch;
	}
	// 828F5E60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F5E64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F5E68: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F5E6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5E70: 2F070055  cmpwi cr6, r7, 0x55
	ctx.cr[6].compare_i32(ctx.r[7].s32, 85, &mut ctx.xer);
	// 828F5E74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F5E78: 41980008  blt cr6, 0x828f5e80
	if ctx.cr[6].lt {
	pc = 0x828F5E80; continue 'dispatch;
	}
	// 828F5E7C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828F5E80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F5E84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F5E88: 419A0014  beq cr6, 0x828f5e9c
	if ctx.cr[6].eq {
	pc = 0x828F5E9C; continue 'dispatch;
	}
	// 828F5E8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F5E90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F5E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F5E98: 4800000C  b 0x828f5ea4
	pc = 0x828F5EA4; continue 'dispatch;
	// 828F5E9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F5EA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F5EA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F5EA8: 4199FFB8  bgt cr6, 0x828f5e60
	if ctx.cr[6].gt {
	pc = 0x828F5E60; continue 'dispatch;
	}
	// 828F5EAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F5EB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F5EB4: 419A0040  beq cr6, 0x828f5ef4
	if ctx.cr[6].eq {
	pc = 0x828F5EF4; continue 'dispatch;
	}
	// 828F5EB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5EBC: 2F0B0055  cmpwi cr6, r11, 0x55
	ctx.cr[6].compare_i32(ctx.r[11].s32, 85, &mut ctx.xer);
	// 828F5EC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5EC4: 41990008  bgt cr6, 0x828f5ecc
	if ctx.cr[6].gt {
	pc = 0x828F5ECC; continue 'dispatch;
	}
	// 828F5EC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828F5ECC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F5ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5ED4: 409A0020  bne cr6, 0x828f5ef4
	if !ctx.cr[6].eq {
	pc = 0x828F5EF4; continue 'dispatch;
	}
	// 828F5ED8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F5EDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F5EE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F5EE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5EE8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F5EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5EF0: 4800001C  b 0x828f5f0c
	pc = 0x828F5F0C; continue 'dispatch;
	// 828F5EF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F5EF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5EFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F5F00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F5F04: 48000008  b 0x828f5f0c
	pc = 0x828F5F0C; continue 'dispatch;
	// 828F5F08: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828F5F0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F5F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5F14: 419A003C  beq cr6, 0x828f5f50
	if ctx.cr[6].eq {
	pc = 0x828F5F50; continue 'dispatch;
	}
	// 828F5F18: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828F5F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5F20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F5F24: 409A0020  bne cr6, 0x828f5f44
	if !ctx.cr[6].eq {
	pc = 0x828F5F44; continue 'dispatch;
	}
	// 828F5F28: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 828F5F2C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828F5F30: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 828F5F34: C02B1FE8  lfs f1, 0x1fe8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8168 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F5F38: 40980010  bge cr6, 0x828f5f48
	if !ctx.cr[6].lt {
	pc = 0x828F5F48; continue 'dispatch;
	}
	// 828F5F3C: C02B22DC  lfs f1, 0x22dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8924 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F5F40: 48000008  b 0x828f5f48
	pc = 0x828F5F48; continue 'dispatch;
	// 828F5F44: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F5F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5F4C: 4BC73FD5  bl 0x82569f20
	ctx.lr = 0x828F5F50;
	sub_82569F20(ctx, base);
	// 828F5F50: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 828F5F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5F58: 409A0048  bne cr6, 0x828f5fa0
	if !ctx.cr[6].eq {
	pc = 0x828F5FA0; continue 'dispatch;
	}
	// 828F5F5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5F60: 4B87DED9  bl 0x82173e38
	ctx.lr = 0x828F5F64;
	sub_82173E38(ctx, base);
	// 828F5F64: 4BA978C5  bl 0x8238d828
	ctx.lr = 0x828F5F68;
	sub_8238D828(ctx, base);
	// 828F5F68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F5F6C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828F5F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5F74: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828F5F78: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F5F7C: 4B89DEBD  bl 0x82193e38
	ctx.lr = 0x828F5F80;
	sub_82193E38(ctx, base);
	// 828F5F80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F5F84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5F88: 4BBDBF41  bl 0x824d1ec8
	ctx.lr = 0x828F5F8C;
	sub_824D1EC8(ctx, base);
	// 828F5F8C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828F5F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5F94: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828F5F98: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828F5F9C: 4B89DE9D  bl 0x82193e38
	ctx.lr = 0x828F5FA0;
	sub_82193E38(ctx, base);
	// 828F5FA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F5FA4: 483B34AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F5FA8 size=1828
    let mut pc: u32 = 0x828F5FA8;
    'dispatch: loop {
        match pc {
            0x828F5FA8 => {
    //   block [0x828F5FA8..0x828F66CC)
	// 828F5FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5FAC: 483B3429  bl 0x82ca93d4
	ctx.lr = 0x828F5FB0;
	sub_82CA93D0(ctx, base);
	// 828F5FB0: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 828F5FB4: 483B7D21  bl 0x82cadcd4
	ctx.lr = 0x828F5FB8;
	sub_82CADCA0(ctx, base);
	// 828F5FB8: 3980FF10  li r12, -0xf0
	ctx.r[12].s64 = -240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F66D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F66D0 size=424
    let mut pc: u32 = 0x828F66D0;
    'dispatch: loop {
        match pc {
            0x828F66D0 => {
    //   block [0x828F66D0..0x828F6878)
	// 828F66D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F66D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F66D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F66DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F66E0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F66E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F66E8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F66EC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F66F0: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F66F4: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F66F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F66FC: 419A0014  beq cr6, 0x828f6710
	if ctx.cr[6].eq {
	pc = 0x828F6710; continue 'dispatch;
	}
	// 828F6700: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 828F6704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6708: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F670C: 409A0008  bne cr6, 0x828f6714
	if !ctx.cr[6].eq {
	pc = 0x828F6714; continue 'dispatch;
	}
	// 828F6710: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F6714: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F6718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F671C: 419A0148  beq cr6, 0x828f6864
	if ctx.cr[6].eq {
	pc = 0x828F6864; continue 'dispatch;
	}
	// 828F6720: 89630062  lbz r11, 0x62(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(98 as u32) ) } as u64;
	// 828F6724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6728: 419A013C  beq cr6, 0x828f6864
	if ctx.cr[6].eq {
	pc = 0x828F6864; continue 'dispatch;
	}
	// 828F672C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6730: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F6734: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828F6738: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F673C: 419A00F4  beq cr6, 0x828f6830
	if ctx.cr[6].eq {
	pc = 0x828F6830; continue 'dispatch;
	}
	// 828F6740: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F6744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F6748: 419A0024  beq cr6, 0x828f676c
	if ctx.cr[6].eq {
	pc = 0x828F676C; continue 'dispatch;
	}
	// 828F674C: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828F6750: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F6754: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F6758: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F675C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6760: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F6764: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F6768: 480000CC  b 0x828f6834
	pc = 0x828F6834; continue 'dispatch;
	// 828F676C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F6770: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F6774: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828F6778: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F677C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F6780: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F6784: 40810054  ble 0x828f67d8
	if !ctx.cr[0].gt {
	pc = 0x828F67D8; continue 'dispatch;
	}
	// 828F6788: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F678C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F6790: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F6794: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6798: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828F679C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F67A0: 41980008  blt cr6, 0x828f67a8
	if ctx.cr[6].lt {
	pc = 0x828F67A8; continue 'dispatch;
	}
	// 828F67A4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828F67A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F67AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F67B0: 419A0014  beq cr6, 0x828f67c4
	if ctx.cr[6].eq {
	pc = 0x828F67C4; continue 'dispatch;
	}
	// 828F67B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F67B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F67BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F67C0: 4800000C  b 0x828f67cc
	pc = 0x828F67CC; continue 'dispatch;
	// 828F67C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F67C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F67CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F67D0: 4199FFB8  bgt cr6, 0x828f6788
	if ctx.cr[6].gt {
	pc = 0x828F6788; continue 'dispatch;
	}
	// 828F67D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F67D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F67DC: 419A0040  beq cr6, 0x828f681c
	if ctx.cr[6].eq {
	pc = 0x828F681C; continue 'dispatch;
	}
	// 828F67E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F67E4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828F67E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F67EC: 41990008  bgt cr6, 0x828f67f4
	if ctx.cr[6].gt {
	pc = 0x828F67F4; continue 'dispatch;
	}
	// 828F67F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F67F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F67F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F67FC: 409A0020  bne cr6, 0x828f681c
	if !ctx.cr[6].eq {
	pc = 0x828F681C; continue 'dispatch;
	}
	// 828F6800: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F6804: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F6808: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F680C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6810: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F6814: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F6818: 4800001C  b 0x828f6834
	pc = 0x828F6834; continue 'dispatch;
	// 828F681C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F6820: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6824: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F6828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F682C: 48000008  b 0x828f6834
	pc = 0x828F6834; continue 'dispatch;
	// 828F6830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F6834: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F6838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F683C: 419A0028  beq cr6, 0x828f6864
	if ctx.cr[6].eq {
	pc = 0x828F6864; continue 'dispatch;
	}
	// 828F6840: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 828F6844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6848: 4B908D81  bl 0x821ff5c8
	ctx.lr = 0x828F684C;
	sub_821FF5C8(ctx, base);
	// 828F684C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F6850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6854: 409A0010  bne cr6, 0x828f6864
	if !ctx.cr[6].eq {
	pc = 0x828F6864; continue 'dispatch;
	}
	// 828F6858: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 828F685C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6860: 4BB29149  bl 0x8241f9a8
	ctx.lr = 0x828F6864;
	sub_8241F9A8(ctx, base);
	// 828F6864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F6868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F686C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F6870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F6874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F6878 size=412
    let mut pc: u32 = 0x828F6878;
    'dispatch: loop {
        match pc {
            0x828F6878 => {
    //   block [0x828F6878..0x828F6A14)
	// 828F6878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F687C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F6880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F6884: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6888: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F688C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F6890: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F6894: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F6898: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F689C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F68A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F68A4: 419A0014  beq cr6, 0x828f68b8
	if ctx.cr[6].eq {
	pc = 0x828F68B8; continue 'dispatch;
	}
	// 828F68A8: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 828F68AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F68B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F68B4: 409A0008  bne cr6, 0x828f68bc
	if !ctx.cr[6].eq {
	pc = 0x828F68BC; continue 'dispatch;
	}
	// 828F68B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F68BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F68C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F68C4: 419A013C  beq cr6, 0x828f6a00
	if ctx.cr[6].eq {
	pc = 0x828F6A00; continue 'dispatch;
	}
	// 828F68C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F68CC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F68D0: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828F68D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F68D8: 419A00F4  beq cr6, 0x828f69cc
	if ctx.cr[6].eq {
	pc = 0x828F69CC; continue 'dispatch;
	}
	// 828F68DC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F68E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F68E4: 419A0024  beq cr6, 0x828f6908
	if ctx.cr[6].eq {
	pc = 0x828F6908; continue 'dispatch;
	}
	// 828F68E8: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828F68EC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F68F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F68F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F68F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F68FC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F6900: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F6904: 480000CC  b 0x828f69d0
	pc = 0x828F69D0; continue 'dispatch;
	// 828F6908: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F690C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F6910: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828F6914: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F6918: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F691C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F6920: 40810054  ble 0x828f6974
	if !ctx.cr[0].gt {
	pc = 0x828F6974; continue 'dispatch;
	}
	// 828F6924: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F6928: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F692C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F6930: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6934: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828F6938: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F693C: 41980008  blt cr6, 0x828f6944
	if ctx.cr[6].lt {
	pc = 0x828F6944; continue 'dispatch;
	}
	// 828F6940: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828F6944: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F6948: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F694C: 419A0014  beq cr6, 0x828f6960
	if ctx.cr[6].eq {
	pc = 0x828F6960; continue 'dispatch;
	}
	// 828F6950: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F6954: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F6958: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F695C: 4800000C  b 0x828f6968
	pc = 0x828F6968; continue 'dispatch;
	// 828F6960: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F6964: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F6968: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F696C: 4199FFB8  bgt cr6, 0x828f6924
	if ctx.cr[6].gt {
	pc = 0x828F6924; continue 'dispatch;
	}
	// 828F6970: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F6974: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F6978: 419A0040  beq cr6, 0x828f69b8
	if ctx.cr[6].eq {
	pc = 0x828F69B8; continue 'dispatch;
	}
	// 828F697C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6980: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828F6984: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F6988: 41990008  bgt cr6, 0x828f6990
	if ctx.cr[6].gt {
	pc = 0x828F6990; continue 'dispatch;
	}
	// 828F698C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F6990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F6994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6998: 409A0020  bne cr6, 0x828f69b8
	if !ctx.cr[6].eq {
	pc = 0x828F69B8; continue 'dispatch;
	}
	// 828F699C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F69A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F69A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F69A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F69AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F69B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F69B4: 4800001C  b 0x828f69d0
	pc = 0x828F69D0; continue 'dispatch;
	// 828F69B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F69BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F69C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F69C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F69C8: 48000008  b 0x828f69d0
	pc = 0x828F69D0; continue 'dispatch;
	// 828F69CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F69D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F69D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F69D8: 419A0028  beq cr6, 0x828f6a00
	if ctx.cr[6].eq {
	pc = 0x828F6A00; continue 'dispatch;
	}
	// 828F69DC: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 828F69E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F69E4: 4B908BE5  bl 0x821ff5c8
	ctx.lr = 0x828F69E8;
	sub_821FF5C8(ctx, base);
	// 828F69E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F69EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F69F0: 419A0010  beq cr6, 0x828f6a00
	if ctx.cr[6].eq {
	pc = 0x828F6A00; continue 'dispatch;
	}
	// 828F69F4: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 828F69F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F69FC: 4BB298A5  bl 0x824202a0
	ctx.lr = 0x828F6A00;
	sub_824202A0(ctx, base);
	// 828F6A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F6A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F6A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F6A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F6A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F6A18 size=708
    let mut pc: u32 = 0x828F6A18;
    'dispatch: loop {
        match pc {
            0x828F6A18 => {
    //   block [0x828F6A18..0x828F6CDC)
	// 828F6A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6A1C: 483B29B5  bl 0x82ca93d0
	ctx.lr = 0x828F6A20;
	sub_82CA93D0(ctx, base);
	// 828F6A20: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6A24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F6A28: 896B6D85  lbz r11, 0x6d85(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28037 as u32) ) } as u64;
	// 828F6A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6A30: 409A02A4  bne cr6, 0x828f6cd4
	if !ctx.cr[6].eq {
	pc = 0x828F6CD4; continue 'dispatch;
	}
	// 828F6A34: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 828F6A38: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828F6A3C: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 828F6A40: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 828F6A44: 617D9DC5  ori r29, r11, 0x9dc5
	ctx.r[29].u64 = ctx.r[11].u64 | 40389;
	// 828F6A48: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828F6A4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F6A50: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 828F6A54: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 828F6A58: 91686D8C  stw r11, 0x6d8c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28044 as u32), ctx.r[11].u32 ) };
	// 828F6A5C: 38654A18  addi r3, r5, 0x4a18
	ctx.r[3].s64 = ctx.r[5].s64 + 18968;
	// 828F6A60: 91478F00  stw r10, -0x7100(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-28928 as u32), ctx.r[10].u32 ) };
	// 828F6A64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6A68: 91268F04  stw r9, -0x70fc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-28924 as u32), ctx.r[9].u32 ) };
	// 828F6A6C: 4B8FD2ED  bl 0x821f3d58
	ctx.lr = 0x828F6A70;
	sub_821F3D58(ctx, base);
	// 828F6A70: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 828F6A74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6A78: 807F6DA0  lwz r3, 0x6da0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828F6A7C: 481093DD  bl 0x829ffe58
	ctx.lr = 0x828F6A80;
	sub_829FFE58(ctx, base);
	// 828F6A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6A84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F6A88: 419A0240  beq cr6, 0x828f6cc8
	if ctx.cr[6].eq {
	pc = 0x828F6CC8; continue 'dispatch;
	}
	// 828F6A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6A90: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 828F6A94: 48109EFD  bl 0x82a00990
	ctx.lr = 0x828F6A98;
	sub_82A00990(ctx, base);
	// 828F6A98: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F6A9C: 82610060  lwz r19, 0x60(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F6AA0: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F6AA4: 419A0214  beq cr6, 0x828f6cb8
	if ctx.cr[6].eq {
	pc = 0x828F6CB8; continue 'dispatch;
	}
	// 828F6AA8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F6AAC: 825F6DA0  lwz r18, 0x6da0(r31)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828F6AB0: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 828F6AB4: 3B8BF138  addi r28, r11, -0xec8
	ctx.r[28].s64 = ctx.r[11].s64 + -3784;
	// 828F6AB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828F6ABC: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828F6AC0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828F6AC4: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828F6AC8: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828F6ACC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828F6AD0: 820BE454  lwz r16, -0x1bac(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828F6AD4: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828F6AD8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828F6ADC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F6AE0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F6AE4: 3BDC000C  addi r30, r28, 0xc
	ctx.r[30].s64 = ctx.r[28].s64 + 12;
	// 828F6AE8: 3A23E460  addi r17, r3, -0x1ba0
	ctx.r[17].s64 = ctx.r[3].s64 + -7072;
	// 828F6AEC: 3B643E48  addi r27, r4, 0x3e48
	ctx.r[27].s64 = ctx.r[4].s64 + 15944;
	// 828F6AF0: 3B454974  addi r26, r5, 0x4974
	ctx.r[26].s64 = ctx.r[5].s64 + 18804;
	// 828F6AF4: 3B264A74  addi r25, r6, 0x4a74
	ctx.r[25].s64 = ctx.r[6].s64 + 19060;
	// 828F6AF8: 3B074A64  addi r24, r7, 0x4a64
	ctx.r[24].s64 = ctx.r[7].s64 + 19044;
	// 828F6AFC: 3AE84A54  addi r23, r8, 0x4a54
	ctx.r[23].s64 = ctx.r[8].s64 + 19028;
	// 828F6B00: 3AC94A44  addi r22, r9, 0x4a44
	ctx.r[22].s64 = ctx.r[9].s64 + 19012;
	// 828F6B04: 3AAA4A38  addi r21, r10, 0x4a38
	ctx.r[21].s64 = ctx.r[10].s64 + 19000;
	// 828F6B08: 3A8B4A28  addi r20, r11, 0x4a28
	ctx.r[20].s64 = ctx.r[11].s64 + 18984;
	// 828F6B0C: 397C007C  addi r11, r28, 0x7c
	ctx.r[11].s64 = ctx.r[28].s64 + 124;
	// 828F6B10: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828F6B14: 409801A4  bge cr6, 0x828f6cb8
	if !ctx.cr[6].lt {
	pc = 0x828F6CB8; continue 'dispatch;
	}
	// 828F6B18: 566B083C  slwi r11, r19, 1
	ctx.r[11].u32 = ctx.r[19].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F6B1C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F6B20: 7D335A14  add r9, r19, r11
	ctx.r[9].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 828F6B24: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F6B28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F6B2C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F6B30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6B34: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828F6B38: 419A001C  beq cr6, 0x828f6b54
	if ctx.cr[6].eq {
	pc = 0x828F6B54; continue 'dispatch;
	}
	// 828F6B3C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828F6B40: 409A0014  bne cr6, 0x828f6b54
	if !ctx.cr[6].eq {
	pc = 0x828F6B54; continue 'dispatch;
	}
	// 828F6B44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6B48: 7F0B8040  cmplw cr6, r11, r16
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[16].u32, &mut ctx.xer);
	// 828F6B4C: 409A0008  bne cr6, 0x828f6b54
	if !ctx.cr[6].eq {
	pc = 0x828F6B54; continue 'dispatch;
	}
	// 828F6B50: 7E2A8B78  mr r10, r17
	ctx.r[10].u64 = ctx.r[17].u64;
	// 828F6B54: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828F6B58: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6B5C: 4B8ED6F5  bl 0x821e4250
	ctx.lr = 0x828F6B60;
	sub_821E4250(ctx, base);
	// 828F6B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F6B64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F6B68: 419A0140  beq cr6, 0x828f6ca8
	if ctx.cr[6].eq {
	pc = 0x828F6CA8; continue 'dispatch;
	}
	// 828F6B6C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828F6B70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6B74: 3B9EFFF4  addi r28, r30, -0xc
	ctx.r[28].s64 = ctx.r[30].s64 + -12;
	// 828F6B78: 4B8FD1E1  bl 0x821f3d58
	ctx.lr = 0x828F6B7C;
	sub_821F3D58(ctx, base);
	// 828F6B7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6B84: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F6B88: 48109829  bl 0x82a003b0
	ctx.lr = 0x828F6B8C;
	sub_82A003B0(ctx, base);
	// 828F6B8C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828F6B90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6B94: 3B9EFFF5  addi r28, r30, -0xb
	ctx.r[28].s64 = ctx.r[30].s64 + -11;
	// 828F6B98: 4B8FD1C1  bl 0x821f3d58
	ctx.lr = 0x828F6B9C;
	sub_821F3D58(ctx, base);
	// 828F6B9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6BA4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F6BA8: 48109809  bl 0x82a003b0
	ctx.lr = 0x828F6BAC;
	sub_82A003B0(ctx, base);
	// 828F6BAC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828F6BB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6BB4: 39DEFFFC  addi r14, r30, -4
	ctx.r[14].s64 = ctx.r[30].s64 + -4;
	// 828F6BB8: 4B8FD1A1  bl 0x821f3d58
	ctx.lr = 0x828F6BBC;
	sub_821F3D58(ctx, base);
	// 828F6BBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6BC4: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F6BC8: 4B8EECB1  bl 0x821e5878
	ctx.lr = 0x828F6BCC;
	sub_821E5878(ctx, base);
	// 828F6BCC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828F6BD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6BD4: 4B8FD185  bl 0x821f3d58
	ctx.lr = 0x828F6BD8;
	sub_821F3D58(ctx, base);
	// 828F6BD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6BE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F6BE4: 4B8EEC95  bl 0x821e5878
	ctx.lr = 0x828F6BE8;
	sub_821E5878(ctx, base);
	// 828F6BE8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828F6BEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6BF0: 39DE0004  addi r14, r30, 4
	ctx.r[14].s64 = ctx.r[30].s64 + 4;
	// 828F6BF4: 4B8FD165  bl 0x821f3d58
	ctx.lr = 0x828F6BF8;
	sub_821F3D58(ctx, base);
	// 828F6BF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6C00: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F6C04: 4B8EEC75  bl 0x821e5878
	ctx.lr = 0x828F6C08;
	sub_821E5878(ctx, base);
	// 828F6C08: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828F6C0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6C10: 39DE0008  addi r14, r30, 8
	ctx.r[14].s64 = ctx.r[30].s64 + 8;
	// 828F6C14: 4B8FD145  bl 0x821f3d58
	ctx.lr = 0x828F6C18;
	sub_821F3D58(ctx, base);
	// 828F6C18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6C20: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F6C24: 4B8EEC55  bl 0x821e5878
	ctx.lr = 0x828F6C28;
	sub_821E5878(ctx, base);
	// 828F6C28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F6C2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6C30: 39DE000C  addi r14, r30, 0xc
	ctx.r[14].s64 = ctx.r[30].s64 + 12;
	// 828F6C34: 4B8FD125  bl 0x821f3d58
	ctx.lr = 0x828F6C38;
	sub_821F3D58(ctx, base);
	// 828F6C38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6C40: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F6C44: 4B8EEC35  bl 0x821e5878
	ctx.lr = 0x828F6C48;
	sub_821E5878(ctx, base);
	// 828F6C48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F6C4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6C50: 39C10050  addi r14, r1, 0x50
	ctx.r[14].s64 = ctx.r[1].s64 + 80;
	// 828F6C54: 4B8FD105  bl 0x821f3d58
	ctx.lr = 0x828F6C58;
	sub_821F3D58(ctx, base);
	// 828F6C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6C60: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F6C64: 481097B5  bl 0x82a00418
	ctx.lr = 0x828F6C68;
	sub_82A00418(ctx, base);
	// 828F6C68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F6C6C: 895EFFF4  lbz r10, -0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828F6C70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F6C74: 917EFFF8  stw r11, -8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 828F6C78: 419A0024  beq cr6, 0x828f6c9c
	if ctx.cr[6].eq {
	pc = 0x828F6C9C; continue 'dispatch;
	}
	// 828F6C7C: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6C84: 419A0010  beq cr6, 0x828f6c94
	if ctx.cr[6].eq {
	pc = 0x828F6C94; continue 'dispatch;
	}
	// 828F6C88: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F6C8C: 91EB8F04  stw r15, -0x70fc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28924 as u32), ctx.r[15].u32 ) };
	// 828F6C90: 4800000C  b 0x828f6c9c
	pc = 0x828F6C9C; continue 'dispatch;
	// 828F6C94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F6C98: 91EB8F00  stw r15, -0x7100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28928 as u32), ctx.r[15].u32 ) };
	// 828F6C9C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F6CA0: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 828F6CA4: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 828F6CA8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F6CAC: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 828F6CB0: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828F6CB4: 409AFE58  bne cr6, 0x828f6b0c
	if !ctx.cr[6].eq {
	pc = 0x828F6B0C; continue 'dispatch;
	}
	// 828F6CB8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F6CBC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F6CC0: 91EB6D8C  stw r15, 0x6d8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28044 as u32), ctx.r[15].u32 ) };
	// 828F6CC4: 4B925075  bl 0x8221bd38
	ctx.lr = 0x828F6CC8;
	sub_8221BD38(ctx, base);
	// 828F6CC8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828F6CCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F6CD0: 996A6D85  stb r11, 0x6d85(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28037 as u32), ctx.r[11].u8 ) };
	// 828F6CD4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828F6CD8: 483B2748  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F6CE0 size=600
    let mut pc: u32 = 0x828F6CE0;
    'dispatch: loop {
        match pc {
            0x828F6CE0 => {
    //   block [0x828F6CE0..0x828F6F38)
	// 828F6CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6CE4: 483B26F5  bl 0x82ca93d8
	ctx.lr = 0x828F6CE8;
	sub_82CA93D0(ctx, base);
	// 828F6CE8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6CEC: 3E008349  lis r16, -0x7cb7
	ctx.r[16].s64 = -2092367872;
	// 828F6CF0: 89706D86  lbz r11, 0x6d86(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[16].u32.wrapping_add(28038 as u32) ) } as u64;
	// 828F6CF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6CF8: 409A0238  bne cr6, 0x828f6f30
	if !ctx.cr[6].eq {
	pc = 0x828F6F30; continue 'dispatch;
	}
	// 828F6CFC: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 828F6D00: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 828F6D04: 617A9DC5  ori r26, r11, 0x9dc5
	ctx.r[26].u64 = ctx.r[11].u64 | 40389;
	// 828F6D08: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F6D0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F6D10: 386A4A84  addi r3, r10, 0x4a84
	ctx.r[3].s64 = ctx.r[10].s64 + 19076;
	// 828F6D14: 83F26DA0  lwz r31, 0x6da0(r18)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828F6D18: 4B8FD041  bl 0x821f3d58
	ctx.lr = 0x828F6D1C;
	sub_821F3D58(ctx, base);
	// 828F6D1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6D24: 48109135  bl 0x829ffe58
	ctx.lr = 0x828F6D28;
	sub_829FFE58(ctx, base);
	// 828F6D28: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 828F6D2C: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 828F6D30: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828F6D34: 419A01F4  beq cr6, 0x828f6f28
	if ctx.cr[6].eq {
	pc = 0x828F6F28; continue 'dispatch;
	}
	// 828F6D38: 3FC0834C  lis r30, -0x7cb4
	ctx.r[30].s64 = -2092171264;
	// 828F6D3C: 3EA0834C  lis r21, -0x7cb4
	ctx.r[21].s64 = -2092171264;
	// 828F6D40: 83FE3690  lwz r31, 0x3690(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(13968 as u32) ) } as u64;
	// 828F6D44: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 828F6D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6D4C: 409A0020  bne cr6, 0x828f6d6c
	if !ctx.cr[6].eq {
	pc = 0x828F6D6C; continue 'dispatch;
	}
	// 828F6D50: 63FF0001  ori r31, r31, 1
	ctx.r[31].u64 = ctx.r[31].u64 | 1;
	// 828F6D54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F6D58: 93FE3690  stw r31, 0x3690(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(13968 as u32), ctx.r[31].u32 ) };
	// 828F6D5C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F6D60: 386B4A98  addi r3, r11, 0x4a98
	ctx.r[3].s64 = ctx.r[11].s64 + 19096;
	// 828F6D64: 4B8FCFF5  bl 0x821f3d58
	ctx.lr = 0x828F6D68;
	sub_821F3D58(ctx, base);
	// 828F6D68: 9075368C  stw r3, 0x368c(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(13964 as u32), ctx.r[3].u32 ) };
	// 828F6D6C: 57EB07BC  rlwinm r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F6D70: 3E80834C  lis r20, -0x7cb4
	ctx.r[20].s64 = -2092171264;
	// 828F6D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6D78: 409A0020  bne cr6, 0x828f6d98
	if !ctx.cr[6].eq {
	pc = 0x828F6D98; continue 'dispatch;
	}
	// 828F6D7C: 63FF0002  ori r31, r31, 2
	ctx.r[31].u64 = ctx.r[31].u64 | 2;
	// 828F6D80: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F6D84: 93FE3690  stw r31, 0x3690(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(13968 as u32), ctx.r[31].u32 ) };
	// 828F6D88: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F6D8C: 386B4AA8  addi r3, r11, 0x4aa8
	ctx.r[3].s64 = ctx.r[11].s64 + 19112;
	// 828F6D90: 4B8FCFC9  bl 0x821f3d58
	ctx.lr = 0x828F6D94;
	sub_821F3D58(ctx, base);
	// 828F6D94: 90743688  stw r3, 0x3688(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(13960 as u32), ctx.r[3].u32 ) };
	// 828F6D98: 57EB077A  rlwinm r11, r31, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F6D9C: 3EC0834C  lis r22, -0x7cb4
	ctx.r[22].s64 = -2092171264;
	// 828F6DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6DA4: 409A0020  bne cr6, 0x828f6dc4
	if !ctx.cr[6].eq {
	pc = 0x828F6DC4; continue 'dispatch;
	}
	// 828F6DA8: 63EB0004  ori r11, r31, 4
	ctx.r[11].u64 = ctx.r[31].u64 | 4;
	// 828F6DAC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F6DB0: 917E3690  stw r11, 0x3690(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(13968 as u32), ctx.r[11].u32 ) };
	// 828F6DB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F6DB8: 386A4ABC  addi r3, r10, 0x4abc
	ctx.r[3].s64 = ctx.r[10].s64 + 19132;
	// 828F6DBC: 4B8FCF9D  bl 0x821f3d58
	ctx.lr = 0x828F6DC0;
	sub_821F3D58(ctx, base);
	// 828F6DC0: 90763684  stw r3, 0x3684(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(13956 as u32), ctx.r[3].u32 ) };
	// 828F6DC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828F6DC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F6DCC: 3B0BF038  addi r24, r11, -0xfc8
	ctx.r[24].s64 = ctx.r[11].s64 + -4040;
	// 828F6DD0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828F6DD4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F6DD8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F6DDC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828F6DE0: 3BD80004  addi r30, r24, 4
	ctx.r[30].s64 = ctx.r[24].s64 + 4;
	// 828F6DE4: 3B297088  addi r25, r9, 0x7088
	ctx.r[25].s64 = ctx.r[9].s64 + 28808;
	// 828F6DE8: 3AEAFFDF  addi r23, r10, -0x21
	ctx.r[23].s64 = ctx.r[10].s64 + -33;
	// 828F6DEC: 3B6B4AC8  addi r27, r11, 0x4ac8
	ctx.r[27].s64 = ctx.r[11].s64 + 19144;
	// 828F6DF0: 9BBEFFFC  stb r29, -4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[29].u8 ) };
	// 828F6DF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828F6DF8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F6DFC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F6E00: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828F6E04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F6E08: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828F6E0C: 4B948A95  bl 0x8223f8a0
	ctx.lr = 0x828F6E10;
	sub_8223F8A0(ctx, base);
	// 828F6E10: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F6E14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F6E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E1C: 4B9360B5  bl 0x8222ced0
	ctx.lr = 0x828F6E20;
	sub_8222CED0(ctx, base);
	// 828F6E20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6E24: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828F6E28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6E2C: 419A0008  beq cr6, 0x828f6e34
	if ctx.cr[6].eq {
	pc = 0x828F6E34; continue 'dispatch;
	}
	// 828F6E30: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6E34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F6E38: 4B8FCF21  bl 0x821f3d58
	ctx.lr = 0x828F6E3C;
	sub_821F3D58(ctx, base);
	// 828F6E3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F6E40: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828F6E44: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828F6E48: 48109881  bl 0x82a006c8
	ctx.lr = 0x828F6E4C;
	sub_82A006C8(ctx, base);
	// 828F6E4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F6E50: 419A000C  beq cr6, 0x828f6e5c
	if ctx.cr[6].eq {
	pc = 0x828F6E5C; continue 'dispatch;
	}
	// 828F6E54: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6E58: 48000008  b 0x828f6e60
	pc = 0x828F6E60; continue 'dispatch;
	// 828F6E5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F6E60: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F6E64: 419A0014  beq cr6, 0x828f6e78
	if ctx.cr[6].eq {
	pc = 0x828F6E78; continue 'dispatch;
	}
	// 828F6E68: 80726DA0  lwz r3, 0x6da0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828F6E6C: 4B8ED3E5  bl 0x821e4250
	ctx.lr = 0x828F6E70;
	sub_821E4250(ctx, base);
	// 828F6E70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F6E74: 48000008  b 0x828f6e7c
	pc = 0x828F6E7C; continue 'dispatch;
	// 828F6E78: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828F6E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E80: 4B8CF8E9  bl 0x821c6768
	ctx.lr = 0x828F6E84;
	sub_821C6768(ctx, base);
	// 828F6E84: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 828F6E88: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828F6E8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6E90: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828F6E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F6E98: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F6E9C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6EA0: 4082FFE8  bne 0x828f6e88
	if !ctx.cr[0].eq {
	pc = 0x828F6E88; continue 'dispatch;
	}
	// 828F6EA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F6EA8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F6EAC: 419A0068  beq cr6, 0x828f6f14
	if ctx.cr[6].eq {
	pc = 0x828F6F14; continue 'dispatch;
	}
	// 828F6EB0: 9A3EFFFC  stb r17, -4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[17].u8 ) };
	// 828F6EB4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828F6EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6EBC: 8095368C  lwz r4, 0x368c(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(13964 as u32) ) } as u64;
	// 828F6EC0: 48109809  bl 0x82a006c8
	ctx.lr = 0x828F6EC4;
	sub_82A006C8(ctx, base);
	// 828F6EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F6EC8: 419A000C  beq cr6, 0x828f6ed4
	if ctx.cr[6].eq {
	pc = 0x828F6ED4; continue 'dispatch;
	}
	// 828F6ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6ED0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F6ED4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828F6ED8: 80943688  lwz r4, 0x3688(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(13960 as u32) ) } as u64;
	// 828F6EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6EE0: 481097E9  bl 0x82a006c8
	ctx.lr = 0x828F6EE4;
	sub_82A006C8(ctx, base);
	// 828F6EE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F6EE8: 419A000C  beq cr6, 0x828f6ef4
	if ctx.cr[6].eq {
	pc = 0x828F6EF4; continue 'dispatch;
	}
	// 828F6EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6EF0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F6EF4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828F6EF8: 80963684  lwz r4, 0x3684(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(13956 as u32) ) } as u64;
	// 828F6EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6F00: 481097C9  bl 0x82a006c8
	ctx.lr = 0x828F6F04;
	sub_82A006C8(ctx, base);
	// 828F6F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F6F08: 419A000C  beq cr6, 0x828f6f14
	if ctx.cr[6].eq {
	pc = 0x828F6F14; continue 'dispatch;
	}
	// 828F6F0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6F10: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828F6F14: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828F6F18: 39780104  addi r11, r24, 0x104
	ctx.r[11].s64 = ctx.r[24].s64 + 260;
	// 828F6F1C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828F6F20: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828F6F24: 4198FECC  blt cr6, 0x828f6df0
	if ctx.cr[6].lt {
	pc = 0x828F6DF0; continue 'dispatch;
	}
	// 828F6F28: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 828F6F2C: 99706D86  stb r11, 0x6d86(r16)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[16].u32.wrapping_add(28038 as u32), ctx.r[11].u8 ) };
	// 828F6F30: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828F6F34: 483B24F4  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F6F38 size=200
    let mut pc: u32 = 0x828F6F38;
    'dispatch: loop {
        match pc {
            0x828F6F38 => {
    //   block [0x828F6F38..0x828F7000)
	// 828F6F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F6F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6F44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6F48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6F4C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6F50: 4BAD7671  bl 0x823ce5c0
	ctx.lr = 0x828F6F54;
	sub_823CE5C0(ctx, base);
	// 828F6F54: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828F6F58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6F5C: 38AACCA8  addi r5, r10, -0x3358
	ctx.r[5].s64 = ctx.r[10].s64 + -13144;
	// 828F6F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6F64: 4BAD729D  bl 0x823ce200
	ctx.lr = 0x828F6F68;
	sub_823CE200(ctx, base);
	// 828F6F68: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828F6F6C: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828F6F70: 38A97000  addi r5, r9, 0x7000
	ctx.r[5].s64 = ctx.r[9].s64 + 28672;
	// 828F6F74: 38884AD8  addi r4, r8, 0x4ad8
	ctx.r[4].s64 = ctx.r[8].s64 + 19160;
	// 828F6F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6F7C: 4BA12495  bl 0x82309410
	ctx.lr = 0x828F6F80;
	sub_82309410(ctx, base);
	// 828F6F80: 3CE0828F  lis r7, -0x7d71
	ctx.r[7].s64 = -2104557568;
	// 828F6F84: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828F6F88: 38A77080  addi r5, r7, 0x7080
	ctx.r[5].s64 = ctx.r[7].s64 + 28800;
	// 828F6F8C: 38864AEC  addi r4, r6, 0x4aec
	ctx.r[4].s64 = ctx.r[6].s64 + 19180;
	// 828F6F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6F94: 4BA1247D  bl 0x82309410
	ctx.lr = 0x828F6F98;
	sub_82309410(ctx, base);
	// 828F6F98: 3CA0828F  lis r5, -0x7d71
	ctx.r[5].s64 = -2104557568;
	// 828F6F9C: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828F6FA0: 38A57100  addi r5, r5, 0x7100
	ctx.r[5].s64 = ctx.r[5].s64 + 28928;
	// 828F6FA4: 38844B00  addi r4, r4, 0x4b00
	ctx.r[4].s64 = ctx.r[4].s64 + 19200;
	// 828F6FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6FAC: 4BA12465  bl 0x82309410
	ctx.lr = 0x828F6FB0;
	sub_82309410(ctx, base);
	// 828F6FB0: 3C60828F  lis r3, -0x7d71
	ctx.r[3].s64 = -2104557568;
	// 828F6FB4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F6FB8: 38A37180  addi r5, r3, 0x7180
	ctx.r[5].s64 = ctx.r[3].s64 + 29056;
	// 828F6FBC: 388B4B14  addi r4, r11, 0x4b14
	ctx.r[4].s64 = ctx.r[11].s64 + 19220;
	// 828F6FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6FC4: 4BC4E685  bl 0x82545648
	ctx.lr = 0x828F6FC8;
	sub_82545648(ctx, base);
	// 828F6FC8: 3D40828F  lis r10, -0x7d71
	ctx.r[10].s64 = -2104557568;
	// 828F6FCC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828F6FD0: 38AA71C0  addi r5, r10, 0x71c0
	ctx.r[5].s64 = ctx.r[10].s64 + 29120;
	// 828F6FD4: 38894B2C  addi r4, r9, 0x4b2c
	ctx.r[4].s64 = ctx.r[9].s64 + 19244;
	// 828F6FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6FDC: 4BA12435  bl 0x82309410
	ctx.lr = 0x828F6FE0;
	sub_82309410(ctx, base);
	// 828F6FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6FE4: 4B8C0B35  bl 0x821b7b18
	ctx.lr = 0x828F6FE8;
	sub_821B7B18(ctx, base);
	// 828F6FE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6FEC: 4B8C0B2D  bl 0x821b7b18
	ctx.lr = 0x828F6FF0;
	sub_821B7B18(ctx, base);
	// 828F6FF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F6FF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F6FF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F6FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7000 size=124
    let mut pc: u32 = 0x828F7000;
    'dispatch: loop {
        match pc {
            0x828F7000 => {
    //   block [0x828F7000..0x828F707C)
	// 828F7000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7008: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F700C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7010: 480001E1  bl 0x828f71f0
	ctx.lr = 0x828F7014;
	sub_828F71F0(ctx, base);
	// 828F7014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F7018: 419A0054  beq cr6, 0x828f706c
	if ctx.cr[6].eq {
	pc = 0x828F706C; continue 'dispatch;
	}
	// 828F701C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F7020: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7024: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828F7028: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F702C: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 828F7030: 394AF138  addi r10, r10, -0xec8
	ctx.r[10].s64 = ctx.r[10].s64 + -3784;
	// 828F7034: 1D68001C  mulli r11, r8, 0x1c
	ctx.r[11].s64 = ctx.r[8].s64 * 28;
	// 828F7038: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F703C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F7040: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F7044: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F7048: EC0C02F2  fmuls f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 828F704C: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F7050: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7054: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F7058: 41990010  bgt cr6, 0x828f7068
	if ctx.cr[6].gt {
	pc = 0x828F7068; continue 'dispatch;
	}
	// 828F705C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7060: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F7064: 40980008  bge cr6, 0x828f706c
	if !ctx.cr[6].lt {
	pc = 0x828F706C; continue 'dispatch;
	}
	// 828F7068: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F706C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F7070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7080 size=128
    let mut pc: u32 = 0x828F7080;
    'dispatch: loop {
        match pc {
            0x828F7080 => {
    //   block [0x828F7080..0x828F7100)
	// 828F7080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F708C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7090: 48000161  bl 0x828f71f0
	ctx.lr = 0x828F7094;
	sub_828F71F0(ctx, base);
	// 828F7094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F7098: 419A0058  beq cr6, 0x828f70f0
	if ctx.cr[6].eq {
	pc = 0x828F70F0; continue 'dispatch;
	}
	// 828F709C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F70A0: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F70A4: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 828F70A8: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F70AC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 828F70B0: 3969F138  addi r11, r9, -0xec8
	ctx.r[11].s64 = ctx.r[9].s64 + -3784;
	// 828F70B4: 1CE8001C  mulli r7, r8, 0x1c
	ctx.r[7].s64 = ctx.r[8].s64 * 28;
	// 828F70B8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F70BC: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F70C0: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 828F70C4: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828F70C8: 7D67342E  lfsx f11, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F70CC: EC0C02F2  fmuls f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 828F70D0: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F70D4: 7DA72C2E  lfsx f13, r7, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F70D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F70DC: 41990010  bgt cr6, 0x828f70ec
	if ctx.cr[6].gt {
	pc = 0x828F70EC; continue 'dispatch;
	}
	// 828F70E0: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F70E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F70E8: 40980008  bge cr6, 0x828f70f0
	if !ctx.cr[6].lt {
	pc = 0x828F70F0; continue 'dispatch;
	}
	// 828F70EC: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F70F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F70F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F70F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F70FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7100 size=128
    let mut pc: u32 = 0x828F7100;
    'dispatch: loop {
        match pc {
            0x828F7100 => {
    //   block [0x828F7100..0x828F7180)
	// 828F7100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7108: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F710C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7110: 480000E1  bl 0x828f71f0
	ctx.lr = 0x828F7114;
	sub_828F71F0(ctx, base);
	// 828F7114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F7118: 419A0058  beq cr6, 0x828f7170
	if ctx.cr[6].eq {
	pc = 0x828F7170; continue 'dispatch;
	}
	// 828F711C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F7120: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7124: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 828F7128: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F712C: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 828F7130: 3969F138  addi r11, r9, -0xec8
	ctx.r[11].s64 = ctx.r[9].s64 + -3784;
	// 828F7134: 1CE8001C  mulli r7, r8, 0x1c
	ctx.r[7].s64 = ctx.r[8].s64 * 28;
	// 828F7138: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F713C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F7140: 38CB0014  addi r6, r11, 0x14
	ctx.r[6].s64 = ctx.r[11].s64 + 20;
	// 828F7144: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 828F7148: 7D67342E  lfsx f11, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F714C: EC0C02F2  fmuls f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 828F7150: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F7154: 7DA72C2E  lfsx f13, r7, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7158: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F715C: 41990010  bgt cr6, 0x828f716c
	if ctx.cr[6].gt {
	pc = 0x828F716C; continue 'dispatch;
	}
	// 828F7160: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7164: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F7168: 40980008  bge cr6, 0x828f7170
	if !ctx.cr[6].lt {
	pc = 0x828F7170; continue 'dispatch;
	}
	// 828F716C: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F7170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F7174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F717C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7180 size=60
    let mut pc: u32 = 0x828F7180;
    'dispatch: loop {
        match pc {
            0x828F7180 => {
    //   block [0x828F7180..0x828F71BC)
	// 828F7180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7188: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 828F718C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7190: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7194: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F7198: 48000059  bl 0x828f71f0
	ctx.lr = 0x828F719C;
	sub_828F71F0(ctx, base);
	// 828F719C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F71A0: 419A0008  beq cr6, 0x828f71a8
	if ctx.cr[6].eq {
	pc = 0x828F71A8; continue 'dispatch;
	}
	// 828F71A4: D3E30038  stfs f31, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828F71A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F71AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F71B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F71B4: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F71B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F71C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F71C0 size=48
    let mut pc: u32 = 0x828F71C0;
    'dispatch: loop {
        match pc {
            0x828F71C0 => {
    //   block [0x828F71C0..0x828F71F0)
	// 828F71C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F71C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F71C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F71CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F71D0: 48000021  bl 0x828f71f0
	ctx.lr = 0x828F71D4;
	sub_828F71F0(ctx, base);
	// 828F71D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F71D8: 419A0008  beq cr6, 0x828f71e0
	if ctx.cr[6].eq {
	pc = 0x828F71E0; continue 'dispatch;
	}
	// 828F71DC: 4BFFD1FD  bl 0x828f43d8
	ctx.lr = 0x828F71E0;
	sub_828F43D8(ctx, base);
	// 828F71E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F71E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F71E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F71EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F71F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F71F0 size=564
    let mut pc: u32 = 0x828F71F0;
    'dispatch: loop {
        match pc {
            0x828F71F0 => {
    //   block [0x828F71F0..0x828F7424)
	// 828F71F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F71F4: 483B2211  bl 0x82ca9404
	ctx.lr = 0x828F71F8;
	sub_82CA93D0(ctx, base);
	// 828F71F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F71FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7200: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F7204: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828F7208: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828F720C: 419A0018  beq cr6, 0x828f7224
	if ctx.cr[6].eq {
	pc = 0x828F7224; continue 'dispatch;
	}
	// 828F7210: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828F7214: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F7218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F721C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F7220: 409A0008  bne cr6, 0x828f7228
	if !ctx.cr[6].eq {
	pc = 0x828F7228; continue 'dispatch;
	}
	// 828F7224: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F7228: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F722C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7230: 419A01E8  beq cr6, 0x828f7418
	if ctx.cr[6].eq {
	pc = 0x828F7418; continue 'dispatch;
	}
	// 828F7234: A17E003C  lhz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F7238: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828F723C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828F7240: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828F7244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F7248: 409A0068  bne cr6, 0x828f72b0
	if !ctx.cr[6].eq {
	pc = 0x828F72B0; continue 'dispatch;
	}
	// 828F724C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828F7250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7254: 419A0038  beq cr6, 0x828f728c
	if ctx.cr[6].eq {
	pc = 0x828F728C; continue 'dispatch;
	}
	// 828F7258: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F725C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7260: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F7264: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F7268: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F726C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7270: 83680038  lwz r27, 0x38(r8)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F7274: 4BD0593D  bl 0x825fcbb0
	ctx.lr = 0x828F7278;
	sub_825FCBB0(ctx, base);
	// 828F7278: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F727C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F7280: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 828F7284: 54C4DFFE  rlwinm r4, r6, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 828F7288: 4BD16701  bl 0x8260d988
	ctx.lr = 0x828F728C;
	sub_8260D988(ctx, base);
	// 828F728C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F7290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7294: 419A001C  beq cr6, 0x828f72b0
	if ctx.cr[6].eq {
	pc = 0x828F72B0; continue 'dispatch;
	}
	// 828F7298: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F729C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F72A0: 388B98C0  addi r4, r11, -0x6740
	ctx.r[4].s64 = ctx.r[11].s64 + -26432;
	// 828F72A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F72A8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828F72AC: 4BA95ABD  bl 0x8238cd68
	ctx.lr = 0x828F72B0;
	sub_8238CD68(ctx, base);
	// 828F72B0: A17E003C  lhz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F72B4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828F72B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F72BC: 419A00F4  beq cr6, 0x828f73b0
	if ctx.cr[6].eq {
	pc = 0x828F73B0; continue 'dispatch;
	}
	// 828F72C0: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F72C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F72C8: 419A0024  beq cr6, 0x828f72ec
	if ctx.cr[6].eq {
	pc = 0x828F72EC; continue 'dispatch;
	}
	// 828F72CC: 894B00D0  lbz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F72D0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F72D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F72D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F72DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F72E0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F72E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F72E8: 480000CC  b 0x828f73b4
	pc = 0x828F73B4; continue 'dispatch;
	// 828F72EC: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F72F0: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F72F4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828F72F8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F72FC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F7300: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7304: 40810054  ble 0x828f7358
	if !ctx.cr[0].gt {
	pc = 0x828F7358; continue 'dispatch;
	}
	// 828F7308: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F730C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F7310: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F7314: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7318: 2F0700D0  cmpwi cr6, r7, 0xd0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 208, &mut ctx.xer);
	// 828F731C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F7320: 41980008  blt cr6, 0x828f7328
	if ctx.cr[6].lt {
	pc = 0x828F7328; continue 'dispatch;
	}
	// 828F7324: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828F7328: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F732C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F7330: 419A0014  beq cr6, 0x828f7344
	if ctx.cr[6].eq {
	pc = 0x828F7344; continue 'dispatch;
	}
	// 828F7334: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F7338: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F733C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F7340: 4800000C  b 0x828f734c
	pc = 0x828F734C; continue 'dispatch;
	// 828F7344: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F7348: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828F734C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7350: 4199FFB8  bgt cr6, 0x828f7308
	if ctx.cr[6].gt {
	pc = 0x828F7308; continue 'dispatch;
	}
	// 828F7354: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F7358: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F735C: 419A0040  beq cr6, 0x828f739c
	if ctx.cr[6].eq {
	pc = 0x828F739C; continue 'dispatch;
	}
	// 828F7360: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7364: 2F0B00D0  cmpwi cr6, r11, 0xd0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 208, &mut ctx.xer);
	// 828F7368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F736C: 41990008  bgt cr6, 0x828f7374
	if ctx.cr[6].gt {
	pc = 0x828F7374; continue 'dispatch;
	}
	// 828F7370: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F7374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F7378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F737C: 409A0020  bne cr6, 0x828f739c
	if !ctx.cr[6].eq {
	pc = 0x828F739C; continue 'dispatch;
	}
	// 828F7380: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828F7384: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828F7388: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F738C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7390: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F7394: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F7398: 4800001C  b 0x828f73b4
	pc = 0x828F73B4; continue 'dispatch;
	// 828F739C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828F73A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F73A4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828F73A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F73AC: 48000008  b 0x828f73b4
	pc = 0x828F73B4; continue 'dispatch;
	// 828F73B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828F73B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F73B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F73BC: 419A005C  beq cr6, 0x828f7418
	if ctx.cr[6].eq {
	pc = 0x828F7418; continue 'dispatch;
	}
	// 828F73C0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828F73C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F73C8: 419A0044  beq cr6, 0x828f740c
	if ctx.cr[6].eq {
	pc = 0x828F740C; continue 'dispatch;
	}
	// 828F73CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F73D0: 4BFFCE49  bl 0x828f4218
	ctx.lr = 0x828F73D4;
	sub_828F4218(ctx, base);
	// 828F73D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F73D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F73DC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 828F73E0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828F73E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F73E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F73EC: C06B9484  lfs f3, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828F73F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F73F4: 9921005F  stb r9, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[9].u8 ) };
	// 828F73F8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 828F73FC: C02A2980  lfs f1, 0x2980(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10624 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F7400: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F7404: C04A223C  lfs f2, 0x223c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8764 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F7408: 4BFFD329  bl 0x828f4730
	ctx.lr = 0x828F740C;
	sub_828F4730(ctx, base);
	// 828F740C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7410: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F7414: 483B2040  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828F7418: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F741C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F7420: 483B2034  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7428 size=60
    let mut pc: u32 = 0x828F7428;
    'dispatch: loop {
        match pc {
            0x828F7428 => {
    //   block [0x828F7428..0x828F7464)
	// 828F7428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F742C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7430: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7434: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7438: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F743C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F7440: 388B98A4  addi r4, r11, -0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + -26460;
	// 828F7444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7448: 4B935A89  bl 0x8222ced0
	ctx.lr = 0x828F744C;
	sub_8222CED0(ctx, base);
	// 828F744C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F7454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F745C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7468 size=268
    let mut pc: u32 = 0x828F7468;
    'dispatch: loop {
        match pc {
            0x828F7468 => {
    //   block [0x828F7468..0x828F7574)
	// 828F7468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F746C: 483B1FA1  bl 0x82ca940c
	ctx.lr = 0x828F7470;
	sub_82CA93D0(ctx, base);
	// 828F7470: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828F7474: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7478: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F747C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 828F7480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7484: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 828F7488: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F748C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828F7490: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F7494: C16B9490  lfs f11, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F7498: 38EA4C50  addi r7, r10, 0x4c50
	ctx.r[7].s64 = ctx.r[10].s64 + 19536;
	// 828F749C: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828F74A0: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 828F74A4: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 828F74A8: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828F74AC: C3E9FFF4  lfs f31, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F74B0: C0094138  lfs f0, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F74B4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828F74B8: C1A91FDC  lfs f13, 0x1fdc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F74BC: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 828F74C0: C189FE3C  lfs f12, -0x1c4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F74C4: 3BA60B7C  addi r29, r6, 0xb7c
	ctx.r[29].s64 = ctx.r[6].s64 + 2940;
	// 828F74C8: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828F74CC: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828F74D0: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828F74D4: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 828F74D8: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828F74DC: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828F74E0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F74E4: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F74E8: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7578 size=124
    let mut pc: u32 = 0x828F7578;
    'dispatch: loop {
        match pc {
            0x828F7578 => {
    //   block [0x828F7578..0x828F75F4)
	// 828F7578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F757C: 483B1E8D  bl 0x82ca9408
	ctx.lr = 0x828F7580;
	sub_82CA93D0(ctx, base);
	// 828F7580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7588: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F758C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 828F7590: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 828F7594: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828F7598: 939F0074  stw r28, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828F759C: 4B89C89D  bl 0x82193e38
	ctx.lr = 0x828F75A0;
	sub_82193E38(ctx, base);
	// 828F75A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F75A4: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 828F75A8: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828F75AC: 939F006C  stw r28, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828F75B0: 4B89C889  bl 0x82193e38
	ctx.lr = 0x828F75B4;
	sub_82193E38(ctx, base);
	// 828F75B4: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828F75B8: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828F75BC: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828F75C0: 4B89C879  bl 0x82193e38
	ctx.lr = 0x828F75C4;
	sub_82193E38(ctx, base);
	// 828F75C4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828F75C8: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828F75CC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828F75D0: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 828F75D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F75D8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F75DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F75E0: 419A000C  beq cr6, 0x828f75ec
	if ctx.cr[6].eq {
	pc = 0x828F75EC; continue 'dispatch;
	}
	// 828F75E4: 4B924755  bl 0x8221bd38
	ctx.lr = 0x828F75E8;
	sub_8221BD38(ctx, base);
	// 828F75E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F75EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F75F0: 483B1E68  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F75F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F75F8 size=8
    let mut pc: u32 = 0x828F75F8;
    'dispatch: loop {
        match pc {
            0x828F75F8 => {
    //   block [0x828F75F8..0x828F7600)
	// 828F75F8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828F75FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7600 size=240
    let mut pc: u32 = 0x828F7600;
    'dispatch: loop {
        match pc {
            0x828F7600 => {
    //   block [0x828F7600..0x828F76F0)
	// 828F7600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F760C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7614: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F7618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F761C: 3BCB4B88  addi r30, r11, 0x4b88
	ctx.r[30].s64 = ctx.r[11].s64 + 19336;
	// 828F7620: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F7624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F762C: 4B9358A5  bl 0x8222ced0
	ctx.lr = 0x828F7630;
	sub_8222CED0(ctx, base);
	// 828F7630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7638: 48001EB9  bl 0x828f94f0
	ctx.lr = 0x828F763C;
	sub_828F94F0(ctx, base);
	// 828F763C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7640: 4B91D799  bl 0x82214dd8
	ctx.lr = 0x828F7644;
	sub_82214DD8(ctx, base);
	// 828F7644: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F7648: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F764C: 388A4B90  addi r4, r10, 0x4b90
	ctx.r[4].s64 = ctx.r[10].s64 + 19344;
	// 828F7650: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F7654: 4B93587D  bl 0x8222ced0
	ctx.lr = 0x828F7658;
	sub_8222CED0(ctx, base);
	// 828F7658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F765C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F7660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7664: 4B93586D  bl 0x8222ced0
	ctx.lr = 0x828F7668;
	sub_8222CED0(ctx, base);
	// 828F7668: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828F766C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F7670: 38C97A10  addi r6, r9, 0x7a10
	ctx.r[6].s64 = ctx.r[9].s64 + 31248;
	// 828F7674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F767C: 480020BD  bl 0x828f9738
	ctx.lr = 0x828F7680;
	sub_828F9738(ctx, base);
	// 828F7680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7684: 4B91D755  bl 0x82214dd8
	ctx.lr = 0x828F7688;
	sub_82214DD8(ctx, base);
	// 828F7688: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F768C: 4B91D74D  bl 0x82214dd8
	ctx.lr = 0x828F7690;
	sub_82214DD8(ctx, base);
	// 828F7690: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7698: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F769C: 4BAD6F25  bl 0x823ce5c0
	ctx.lr = 0x828F76A0;
	sub_823CE5C0(ctx, base);
	// 828F76A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F76A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F76A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F76AC: 4BAD6B55  bl 0x823ce200
	ctx.lr = 0x828F76B0;
	sub_823CE200(ctx, base);
	// 828F76B0: 3CE0822D  lis r7, -0x7dd3
	ctx.r[7].s64 = -2110980096;
	// 828F76B4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828F76B8: 38A73398  addi r5, r7, 0x3398
	ctx.r[5].s64 = ctx.r[7].s64 + 13208;
	// 828F76BC: 38864B9C  addi r4, r6, 0x4b9c
	ctx.r[4].s64 = ctx.r[6].s64 + 19356;
	// 828F76C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F76C4: 4BD21435  bl 0x82618af8
	ctx.lr = 0x828F76C8;
	sub_82618AF8(ctx, base);
	// 828F76C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F76CC: 4B8C044D  bl 0x821b7b18
	ctx.lr = 0x828F76D0;
	sub_821B7B18(ctx, base);
	// 828F76D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F76D4: 4B8C0445  bl 0x821b7b18
	ctx.lr = 0x828F76D8;
	sub_821B7B18(ctx, base);
	// 828F76D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F76DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F76E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F76E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F76E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F76EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F76F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F76F0 size=264
    let mut pc: u32 = 0x828F76F0;
    'dispatch: loop {
        match pc {
            0x828F76F0 => {
    //   block [0x828F76F0..0x828F77F8)
	// 828F76F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F76F4: 483B1D15  bl 0x82ca9408
	ctx.lr = 0x828F76F8;
	sub_82CA93D0(ctx, base);
	// 828F76F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F76FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F7700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7704: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F7708: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F770C: 388B4824  addi r4, r11, 0x4824
	ctx.r[4].s64 = ctx.r[11].s64 + 18468;
	// 828F7710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7714: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828F7718: 4B9357B9  bl 0x8222ced0
	ctx.lr = 0x828F771C;
	sub_8222CED0(ctx, base);
	// 828F771C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7720: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828F7724: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F7728: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F772C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7730: 419A0008  beq cr6, 0x828f7738
	if ctx.cr[6].eq {
	pc = 0x828F7738; continue 'dispatch;
	}
	// 828F7734: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7738: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828F773C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7740: 4BB89111  bl 0x82480850
	ctx.lr = 0x828F7744;
	sub_82480850(ctx, base);
	// 828F7744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7748: 4B91D691  bl 0x82214dd8
	ctx.lr = 0x828F774C;
	sub_82214DD8(ctx, base);
	// 828F774C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F7750: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F7754: 388B4BB8  addi r4, r11, 0x4bb8
	ctx.r[4].s64 = ctx.r[11].s64 + 19384;
	// 828F7758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F775C: 4B935775  bl 0x8222ced0
	ctx.lr = 0x828F7760;
	sub_8222CED0(ctx, base);
	// 828F7760: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F7764: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F7768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F776C: 419A0008  beq cr6, 0x828f7774
	if ctx.cr[6].eq {
	pc = 0x828F7774; continue 'dispatch;
	}
	// 828F7770: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7774: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 828F7778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F777C: 4BB890D5  bl 0x82480850
	ctx.lr = 0x828F7780;
	sub_82480850(ctx, base);
	// 828F7780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7784: 4B91D655  bl 0x82214dd8
	ctx.lr = 0x828F7788;
	sub_82214DD8(ctx, base);
	// 828F7788: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F778C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F7790: 388B4BDC  addi r4, r11, 0x4bdc
	ctx.r[4].s64 = ctx.r[11].s64 + 19420;
	// 828F7794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7798: 4B935739  bl 0x8222ced0
	ctx.lr = 0x828F779C;
	sub_8222CED0(ctx, base);
	// 828F779C: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828F77A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F77A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F77A8: 481256A1  bl 0x82a1ce48
	ctx.lr = 0x828F77AC;
	sub_82A1CE48(ctx, base);
	// 828F77AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F77B0: 4B91D629  bl 0x82214dd8
	ctx.lr = 0x828F77B4;
	sub_82214DD8(ctx, base);
	// 828F77B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828F77B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F77BC: 388A4108  addi r4, r10, 0x4108
	ctx.r[4].s64 = ctx.r[10].s64 + 16648;
	// 828F77C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F77C4: 4B93570D  bl 0x8222ced0
	ctx.lr = 0x828F77C8;
	sub_8222CED0(ctx, base);
	// 828F77C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F77CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F77D0: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 828F77D4: 4BBBAFE5  bl 0x824b27b8
	ctx.lr = 0x828F77D8;
	sub_824B27B8(ctx, base);
	// 828F77D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F77DC: 4B91D5FD  bl 0x82214dd8
	ctx.lr = 0x828F77E0;
	sub_82214DD8(ctx, base);
	// 828F77E0: 5789063E  clrlwi r9, r28, 0x18
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828F77E4: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828F77E8: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828F77EC: 98FF0041  stb r7, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[7].u8 ) };
	// 828F77F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F77F4: 483B1C64  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F77F8 size=268
    let mut pc: u32 = 0x828F77F8;
    'dispatch: loop {
        match pc {
            0x828F77F8 => {
    //   block [0x828F77F8..0x828F7904)
	// 828F77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F77FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F7804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F780C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7810: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 828F7814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7818: 419A00D4  beq cr6, 0x828f78ec
	if ctx.cr[6].eq {
	pc = 0x828F78EC; continue 'dispatch;
	}
	// 828F781C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F7820: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 828F7824: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F7828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F782C: 41990014  bgt cr6, 0x828f7840
	if ctx.cr[6].gt {
	pc = 0x828F7840; continue 'dispatch;
	}
	// 828F7830: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7838: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828F783C: 40990008  ble cr6, 0x828f7844
	if !ctx.cr[6].gt {
	pc = 0x828F7844; continue 'dispatch;
	}
	// 828F7840: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F7844: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F7848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F784C: 419A005C  beq cr6, 0x828f78a8
	if ctx.cr[6].eq {
	pc = 0x828F78A8; continue 'dispatch;
	}
	// 828F7850: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828F7854: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828F7858: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F785C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F7860: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7864: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7868: 4B96CC21  bl 0x82264488
	ctx.lr = 0x828F786C;
	sub_82264488(ctx, base);
	// 828F786C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828F7870: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F7874: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F7878: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828F787C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7880: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828F7884: 4B91D015  bl 0x82214898
	ctx.lr = 0x828F7888;
	sub_82214898(ctx, base);
	// 828F7888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F788C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828F7890: 4BBDA639  bl 0x824d1ec8
	ctx.lr = 0x828F7894;
	sub_824D1EC8(ctx, base);
	// 828F7894: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 828F7898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F789C: 38850B7C  addi r4, r5, 0xb7c
	ctx.r[4].s64 = ctx.r[5].s64 + 2940;
	// 828F78A0: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828F78A4: 4B89C595  bl 0x82193e38
	ctx.lr = 0x828F78A8;
	sub_82193E38(ctx, base);
	// 828F78A8: 9BDF0041  stb r30, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[30].u8 ) };
	// 828F78AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F78B0: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 828F78B4: 4800019D  bl 0x828f7a50
	ctx.lr = 0x828F78B8;
	sub_828F7A50(ctx, base);
	// 828F78B8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 828F78BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F78C0: 419A002C  beq cr6, 0x828f78ec
	if ctx.cr[6].eq {
	pc = 0x828F78EC; continue 'dispatch;
	}
	// 828F78C4: 897F0046  lbz r11, 0x46(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(70 as u32) ) } as u64;
	// 828F78C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F78CC: 409A0020  bne cr6, 0x828f78ec
	if !ctx.cr[6].eq {
	pc = 0x828F78EC; continue 'dispatch;
	}
	// 828F78D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F78D4: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F78D8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F78DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F78E0: 997F0046  stb r11, 0x46(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(70 as u32), ctx.r[11].u8 ) };
	// 828F78E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F78E8: 480004C1  bl 0x828f7da8
	ctx.lr = 0x828F78EC;
	sub_828F7DA8(ctx, base);
	// 828F78EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F78F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F78F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F78F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F78FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


