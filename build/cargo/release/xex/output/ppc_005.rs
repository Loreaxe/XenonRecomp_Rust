pub fn sub_821DF458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF458 size=200
    let mut pc: u32 = 0x821DF458;
    'dispatch: loop {
        match pc {
            0x821DF458 => {
    //   block [0x821DF458..0x821DF520)
	// 821DF458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DF464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DF468: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821DF46C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DF478: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DF47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DF480: 419A0080  beq cr6, 0x821df500
	if ctx.cr[6].eq {
	pc = 0x821DF500; continue 'dispatch;
	}
	// 821DF484: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF488: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821DF48C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF494: 48049C75  bl 0x82229108
	ctx.lr = 0x821DF498;
	sub_82229108(ctx, base);
	// 821DF498: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821DF49C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821DF4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF4A4: 48048EE5  bl 0x82228388
	ctx.lr = 0x821DF4A8;
	sub_82228388(ctx, base);
	// 821DF4A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DF4AC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821DF4B0: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821DF4B4: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 821DF4B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DF4BC: 419A003C  beq cr6, 0x821df4f8
	if ctx.cr[6].eq {
	pc = 0x821DF4F8; continue 'dispatch;
	}
	// 821DF4C0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF4C4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821DF4C8: 409A0030  bne cr6, 0x821df4f8
	if !ctx.cr[6].eq {
	pc = 0x821DF4F8; continue 'dispatch;
	}
	// 821DF4CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DF4D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DF4D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DF4D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DF4DC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821DF4E0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DF4E4: 48122A15  bl 0x82301ef8
	ctx.lr = 0x821DF4E8;
	sub_82301EF8(ctx, base);
	// 821DF4E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DF4EC: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821DF4F0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DF4F4: 48000010  b 0x821df504
	pc = 0x821DF504; continue 'dispatch;
	// 821DF4F8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821DF4FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821DF500: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DF504: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DF508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DF50C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DF510: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821DF514: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DF518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DF51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF520 size=172
    let mut pc: u32 = 0x821DF520;
    'dispatch: loop {
        match pc {
            0x821DF520 => {
    //   block [0x821DF520..0x821DF5CC)
	// 821DF520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF52C: 10410C84  vmr v2, v1
	ctx.v[2] = ctx.v[1];
	// 821DF530: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DF534: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DF5D0 size=20
    let mut pc: u32 = 0x821DF5D0;
    'dispatch: loop {
        match pc {
            0x821DF5D0 => {
    //   block [0x821DF5D0..0x821DF5E4)
	// 821DF5D0: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DF5D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF5D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DF5DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DF5E0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF5E8 size=132
    let mut pc: u32 = 0x821DF5E8;
    'dispatch: loop {
        match pc {
            0x821DF5E8 => {
    //   block [0x821DF5E8..0x821DF66C)
	// 821DF5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF5F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DF5F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DF5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF5FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DF600: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DF604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF60C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DF614: 4E800421  bctrl
	ctx.lr = 0x821DF618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DF618: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 821DF61C: 409A0010  bne cr6, 0x821df62c
	if !ctx.cr[6].eq {
	pc = 0x821DF62C; continue 'dispatch;
	}
	// 821DF620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DF624: 48694215  bl 0x82873838
	ctx.lr = 0x821DF628;
	sub_82873838(ctx, base);
	// 821DF628: 4800002C  b 0x821df654
	pc = 0x821DF654; continue 'dispatch;
	// 821DF62C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF634: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF638: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DF63C: 4E800421  bctrl
	ctx.lr = 0x821DF640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DF640: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 821DF644: 409A0010  bne cr6, 0x821df654
	if !ctx.cr[6].eq {
	pc = 0x821DF654; continue 'dispatch;
	}
	// 821DF648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DF64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DF650: 48694091  bl 0x828736e0
	ctx.lr = 0x821DF654;
	sub_828736E0(ctx, base);
	// 821DF654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DF658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DF65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DF660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DF664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DF668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DF670 size=1884
    let mut pc: u32 = 0x821DF670;
    'dispatch: loop {
        match pc {
            0x821DF670 => {
    //   block [0x821DF670..0x821DFDCC)
	// 821DF670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF674: 48AC9D85  bl 0x82ca93f8
	ctx.lr = 0x821DF678;
	sub_82CA93D0(ctx, base);
	// 821DF678: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821DF67C: 48ACE64D  bl 0x82cadcc8
	ctx.lr = 0x821DF680;
	sub_82CADCA0(ctx, base);
	// 821DF680: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DFDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DFDD0 size=1100
    let mut pc: u32 = 0x821DFDD0;
    'dispatch: loop {
        match pc {
            0x821DFDD0 => {
    //   block [0x821DFDD0..0x821E021C)
	// 821DFDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DFDD4: 48AC9629  bl 0x82ca93fc
	ctx.lr = 0x821DFDD8;
	sub_82CA93D0(ctx, base);
	// 821DFDD8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821DFDDC: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 821DFDE0: 9421EE90  stwu r1, -0x1170(r1)
	ea = ctx.r[1].u32.wrapping_add(-4464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DFDE4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DFDE8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DFDEC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821DFDF0: 807A0018  lwz r3, 0x18(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DFDF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DFDF8: 419A0024  beq cr6, 0x821dfe1c
	if ctx.cr[6].eq {
	pc = 0x821DFE1C; continue 'dispatch;
	}
	// 821DFDFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFE00: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DFE04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DFE08: 4E800421  bctrl
	ctx.lr = 0x821DFE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DFE0C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DFE10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DFE14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DFE18: 409A0008  bne cr6, 0x821dfe20
	if !ctx.cr[6].eq {
	pc = 0x821DFE20; continue 'dispatch;
	}
	// 821DFE1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DFE20: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DFE24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFE28: 419A00A8  beq cr6, 0x821dfed0
	if ctx.cr[6].eq {
	pc = 0x821DFED0; continue 'dispatch;
	}
	// 821DFE2C: 807A003C  lwz r3, 0x3c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DFE30: 4BFE9071  bl 0x821c8ea0
	ctx.lr = 0x821DFE34;
	sub_821C8EA0(ctx, base);
	// 821DFE34: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DFE38: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFE40: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE44: 40990008  ble cr6, 0x821dfe4c
	if !ctx.cr[6].gt {
	pc = 0x821DFE4C; continue 'dispatch;
	}
	// 821DFE48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFE4C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821DFE50: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE54: 40990008  ble cr6, 0x821dfe5c
	if !ctx.cr[6].gt {
	pc = 0x821DFE5C; continue 'dispatch;
	}
	// 821DFE58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFE5C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE60: 419A0018  beq cr6, 0x821dfe78
	if ctx.cr[6].eq {
	pc = 0x821DFE78; continue 'dispatch;
	}
	// 821DFE64: 4198000C  blt cr6, 0x821dfe70
	if ctx.cr[6].lt {
	pc = 0x821DFE70; continue 'dispatch;
	}
	// 821DFE68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFE6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFE70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821DFE74: 4BFFFFDC  b 0x821dfe50
	pc = 0x821DFE50; continue 'dispatch;
	// 821DFE78: 83DA0044  lwz r30, 0x44(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DFE7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE80: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFE84: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE88: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE8C: 419A0044  beq cr6, 0x821dfed0
	if ctx.cr[6].eq {
	pc = 0x821DFED0; continue 'dispatch;
	}
	// 821DFE90: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DFE94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE98: 409A0008  bne cr6, 0x821dfea0
	if !ctx.cr[6].eq {
	pc = 0x821DFEA0; continue 'dispatch;
	}
	// 821DFE9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFEA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFEA4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFEA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFEAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DFEB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DFEB4: 4E800421  bctrl
	ctx.lr = 0x821DFEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DFEB8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFEBC: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DFEC0: 409A0008  bne cr6, 0x821dfec8
	if !ctx.cr[6].eq {
	pc = 0x821DFEC8; continue 'dispatch;
	}
	// 821DFEC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFEC8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFECC: 4BFFFFB8  b 0x821dfe84
	pc = 0x821DFE84; continue 'dispatch;
	// 821DFED0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DFED4: 480EA495  bl 0x822ca368
	ctx.lr = 0x821DFED8;
	sub_822CA368(ctx, base);
	// 821DFED8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFEDC: 419A007C  beq cr6, 0x821dff58
	if ctx.cr[6].eq {
	pc = 0x821DFF58; continue 'dispatch;
	}
	// 821DFEE0: 817A0050  lwz r11, 0x50(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DFEE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DFEE8: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFEEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DFEF0: 3BCA16D8  addi r30, r10, 0x16d8
	ctx.r[30].s64 = ctx.r[10].s64 + 5848;
	// 821DFEF4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DFEF8: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DFEFC: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 821DFF00: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 821DFF04: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821DFF08: 48007721  bl 0x821e7628
	ctx.lr = 0x821DFF0C;
	sub_821E7628(ctx, base);
	// 821DFF0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DFF10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DFF14: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821DFF18: 4BFFE3D1  bl 0x821de2e8
	ctx.lr = 0x821DFF1C;
	sub_821DE2E8(ctx, base);
	// 821DFF1C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821DFF20: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DFF24: 4805D015  bl 0x8223cf38
	ctx.lr = 0x821DFF28;
	sub_8223CF38(ctx, base);
	// 821DFF28: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821DFF2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF30: 807A0054  lwz r3, 0x54(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DFF34: 38E86A70  addi r7, r8, 0x6a70
	ctx.r[7].s64 = ctx.r[8].s64 + 27248;
	// 821DFF38: 90E100A0  stw r7, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 821DFF3C: 480BB85D  bl 0x8229b798
	ctx.lr = 0x821DFF40;
	sub_8229B798(ctx, base);
	// 821DFF40: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF44: 807A0058  lwz r3, 0x58(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DFF48: 480E5BC9  bl 0x822c5b10
	ctx.lr = 0x821DFF4C;
	sub_822C5B10(ctx, base);
	// 821DFF4C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF50: 807A005C  lwz r3, 0x5c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DFF54: 4BFFF71D  bl 0x821df670
	ctx.lr = 0x821DFF58;
	sub_821DF670(ctx, base);
	// 821DFF58: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFF5C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF60: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFF64: 4813D325  bl 0x8231d288
	ctx.lr = 0x821DFF68;
	sub_8231D288(ctx, base);
	// 821DFF68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFF6C: 419A0020  beq cr6, 0x821dff8c
	if ctx.cr[6].eq {
	pc = 0x821DFF8C; continue 'dispatch;
	}
	// 821DFF70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF74: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFF78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DFF7C: 480353C5  bl 0x82215340
	ctx.lr = 0x821DFF80;
	sub_82215340(ctx, base);
	// 821DFF80: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DFF88: 480D51C9  bl 0x822b5150
	ctx.lr = 0x821DFF8C;
	sub_822B5150(ctx, base);
	// 821DFF8C: 817A00B8  lwz r11, 0xb8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DFF90: 3B9A00B4  addi r28, r26, 0xb4
	ctx.r[28].s64 = ctx.r[26].s64 + 180;
	// 821DFF94: 83790000  lwz r27, 0(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFF98: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821DFF9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFFA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DFFA4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DFFA8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821DFFAC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DFFB0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DFFB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFFB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DFFBC: 419A000C  beq cr6, 0x821dffc8
	if ctx.cr[6].eq {
	pc = 0x821DFFC8; continue 'dispatch;
	}
	// 821DFFC0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DFFC4: 419A0008  beq cr6, 0x821dffcc
	if ctx.cr[6].eq {
	pc = 0x821DFFCC; continue 'dispatch;
	}
	// 821DFFC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFFCC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFFD0: 419A005C  beq cr6, 0x821e002c
	if ctx.cr[6].eq {
	pc = 0x821E002C; continue 'dispatch;
	}
	// 821DFFD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DFFD8: 409A0008  bne cr6, 0x821dffe0
	if !ctx.cr[6].eq {
	pc = 0x821DFFE0; continue 'dispatch;
	}
	// 821DFFDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFFE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFFE4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFFE8: 409A0008  bne cr6, 0x821dfff0
	if !ctx.cr[6].eq {
	pc = 0x821DFFF0; continue 'dispatch;
	}
	// 821DFFEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821DFFF0: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFFF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFFF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821DFFFC: 409A0018  bne cr6, 0x821e0014
	if !ctx.cr[6].eq {
	pc = 0x821E0014; continue 'dispatch;
	}
	// 821E0000: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E0004: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0008: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E000C: 4BFFE2DD  bl 0x821de2e8
	ctx.lr = 0x821E0010;
	sub_821DE2E8(ctx, base);
	// 821E0010: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821E0014: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0018: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E001C: 409A0008  bne cr6, 0x821e0024
	if !ctx.cr[6].eq {
	pc = 0x821E0024; continue 'dispatch;
	}
	// 821E0020: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0024: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0028: 4BFFFF8C  b 0x821dffb4
	pc = 0x821DFFB4; continue 'dispatch;
	// 821E002C: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821E0030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0034: 419A009C  beq cr6, 0x821e00d0
	if ctx.cr[6].eq {
	pc = 0x821E00D0; continue 'dispatch;
	}
	// 821E0038: 3BBA00CC  addi r29, r26, 0xcc
	ctx.r[29].s64 = ctx.r[26].s64 + 204;
	// 821E003C: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 821E0040: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821E0044: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E004C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E0050: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E0054: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E0058: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E005C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0060: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0064: 419A000C  beq cr6, 0x821e0070
	if ctx.cr[6].eq {
	pc = 0x821E0070; continue 'dispatch;
	}
	// 821E0068: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821E006C: 419A0008  beq cr6, 0x821e0074
	if ctx.cr[6].eq {
	pc = 0x821E0074; continue 'dispatch;
	}
	// 821E0070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0074: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E0078: 419A0050  beq cr6, 0x821e00c8
	if ctx.cr[6].eq {
	pc = 0x821E00C8; continue 'dispatch;
	}
	// 821E007C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0080: 409A0008  bne cr6, 0x821e0088
	if !ctx.cr[6].eq {
	pc = 0x821E0088; continue 'dispatch;
	}
	// 821E0084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0088: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E008C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E0090: 409A0008  bne cr6, 0x821e0098
	if !ctx.cr[6].eq {
	pc = 0x821E0098; continue 'dispatch;
	}
	// 821E0094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0098: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E009C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E00A0: 419A0010  beq cr6, 0x821e00b0
	if ctx.cr[6].eq {
	pc = 0x821E00B0; continue 'dispatch;
	}
	// 821E00A4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E00A8: 906B0040  stw r3, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 821E00AC: 49054155  bl 0x83234200
	ctx.lr = 0x821E00B0;
	sub_83234200(ctx, base);
	// 821E00B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E00B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E00B8: 409A0008  bne cr6, 0x821e00c0
	if !ctx.cr[6].eq {
	pc = 0x821E00C0; continue 'dispatch;
	}
	// 821E00BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E00C0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00C4: 4BFFFF98  b 0x821e005c
	pc = 0x821E005C; continue 'dispatch;
	// 821E00C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E00CC: 485C0D4D  bl 0x827a0e18
	ctx.lr = 0x821E00D0;
	sub_827A0E18(ctx, base);
	// 821E00D0: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821E00D4: 807F6AB8  lwz r3, 0x6ab8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E00D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00DC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E00E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E00E4: 4E800421  bctrl
	ctx.lr = 0x821E00E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E00E8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E00EC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00F0: 490541C1  bl 0x832342b0
	ctx.lr = 0x821E00F4;
	sub_832342B0(ctx, base);
	// 821E00F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E00F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E00FC: 419A0044  beq cr6, 0x821e0140
	if ctx.cr[6].eq {
	pc = 0x821E0140; continue 'dispatch;
	}
	// 821E0100: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E0104: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E0108: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821E010C: 480186BD  bl 0x821f87c8
	ctx.lr = 0x821E0110;
	sub_821F87C8(ctx, base);
	// 821E0110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0114: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E0118: 419A0028  beq cr6, 0x821e0140
	if ctx.cr[6].eq {
	pc = 0x821E0140; continue 'dispatch;
	}
	// 821E011C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0120: 4BFFD291  bl 0x821dd3b0
	ctx.lr = 0x821E0124;
	sub_821DD3B0(ctx, base);
	// 821E0124: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821E0128: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821E012C: C0210090  lfs f1, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E0130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0220 size=360
    let mut pc: u32 = 0x821E0220;
    'dispatch: loop {
        match pc {
            0x821E0220 => {
    //   block [0x821E0220..0x821E0388)
	// 821E0220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0224: 48AC91C1  bl 0x82ca93e4
	ctx.lr = 0x821E0228;
	sub_82CA93D0(ctx, base);
	// 821E0228: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E022C: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 821E0230: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E0234: 39770070  addi r11, r23, 0x70
	ctx.r[11].s64 = ctx.r[23].s64 + 112;
	// 821E0238: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E023C: 557D1838  slwi r29, r11, 3
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821E0240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0244: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 821E0248: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 821E024C: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 821E0250: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821E0254: 7D334B78  mr r19, r9
	ctx.r[19].u64 = ctx.r[9].u64;
	// 821E0258: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E025C: 836B036C  lwz r27, 0x36c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(876 as u32) ) } as u64;
	// 821E0260: 577CF0BE  srwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shr(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821E0264: 389C0005  addi r4, r28, 5
	ctx.r[4].s64 = ctx.r[28].s64 + 5;
	// 821E0268: 48033871  bl 0x82213ad8
	ctx.lr = 0x821E026C;
	sub_82213AD8(ctx, base);
	// 821E026C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E0270: 41820110  beq 0x821e0380
	if ctx.cr[0].eq {
	pc = 0x821E0380; continue 'dispatch;
	}
	// 821E0274: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821E0278: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 821E027C: 616B3B00  ori r11, r11, 0x3b00
	ctx.r[11].u64 = ctx.r[11].u64 | 15104;
	// 821E0280: 3D20C000  lis r9, -0x4000
	ctx.r[9].s64 = -1073741824;
	// 821E0284: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821E0288: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 821E028C: 61292B00  ori r9, r9, 0x2b00
	ctx.r[9].u64 = ctx.r[9].u64 | 11008;
	// 821E0290: 578804BE  clrlwi r8, r28, 0x12
	ctx.r[8].u64 = ctx.r[28].u32 as u64 & 0x00003FFFu64;
	// 821E0294: 5169809E  rlwimi r9, r11, 0x10, 2, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000003FFF0000) | (ctx.r[9].u64 & 0xFFFFFFFFC000FFFF);
	// 821E0298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E029C: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A0: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A4: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821E02AC: 95190004  stwu r8, 4(r25)
	ea = ctx.r[25].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[25].u32 = ea;
	// 821E02B0: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821E02B4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E02B8: 3B590004  addi r26, r25, 4
	ctx.r[26].s64 = ctx.r[25].s64 + 4;
	// 821E02BC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E02C0: 816B0368  lwz r11, 0x368(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(872 as u32) ) } as u64;
	// 821E02C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E02C8: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E02CC: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821E02D0: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821E02D4: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E02D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E02DC: 3FABC000  addis r29, r11, -0x4000
	ctx.r[29].s64 = ctx.r[11].s64 + -1073741824;
	// 821E02E0: 7C0004AC  sync
	// 821E02E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E02E8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E02EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E02F0: 48AC9191  bl 0x82ca9480
	ctx.lr = 0x821E02F4;
	sub_82CA9480(ctx, base);
	// 821E02F4: 7C9DDA14  add r4, r29, r27
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[27].u64;
	// 821E02F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E02FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E0300: 4BFF1209  bl 0x821d1508
	ctx.lr = 0x821E0304;
	sub_821D1508(ctx, base);
	// 821E0304: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 821E0308: 419A0028  beq cr6, 0x821e0330
	if ctx.cr[6].eq {
	pc = 0x821E0330; continue 'dispatch;
	}
	// 821E030C: 89750008  lbz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E0310: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821E0314: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821E0318: 419A0018  beq cr6, 0x821e0330
	if ctx.cr[6].eq {
	pc = 0x821E0330; continue 'dispatch;
	}
	// 821E031C: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 821E0320: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 821E0324: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821E0328: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821E032C: 489C3A5D  bl 0x82ba3d88
	ctx.lr = 0x821E0330;
	sub_82BA3D88(ctx, base);
	// 821E0330: 7F0B0034  cntlzw r11, r24
	ctx.r[11].u64 = if ctx.r[24].u32 == 0 { 32 } else { ctx.r[24].u32.leading_zeros() as u64 };
	// 821E0334: 895E2ABE  lbz r10, 0x2abe(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10942 as u32) ) } as u64;
	// 821E0338: 38DE30F0  addi r6, r30, 0x30f0
	ctx.r[6].s64 = ctx.r[30].s64 + 12528;
	// 821E033C: 556B1630  rlwinm r11, r11, 2, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821E0340: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821E0344: 696B0080  xori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 ^ 128;
	// 821E0348: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821E034C: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821E0350: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821E0354: 997E2ABE  stb r11, 0x2abe(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(10942 as u32), ctx.r[11].u8 ) };
	// 821E0358: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821E035C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E0360: 4BFF3211  bl 0x821d3570
	ctx.lr = 0x821E0364;
	sub_821D3570(ctx, base);
	// 821E0364: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E0368: E95E30F8  ld r10, 0x30f8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(12536 as u32) ) };
	// 821E036C: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 821E0370: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821E0374: F95E2E40  std r10, 0x2e40(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(11840 as u32), ctx.r[10].u64 ) };
	// 821E0378: E97E30F0  ld r11, 0x30f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(12528 as u32) ) };
	// 821E037C: F97E2E38  std r11, 0x2e38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(11832 as u32), ctx.r[11].u64 ) };
	// 821E0380: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E0384: 48AC90B0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0388 size=96
    let mut pc: u32 = 0x821E0388;
    'dispatch: loop {
        match pc {
            0x821E0388 => {
    //   block [0x821E0388..0x821E03E8)
	// 821E0388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E038C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0390: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0394: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E0398: 48843D49  bl 0x82a240e0
	ctx.lr = 0x821E039C;
	sub_82A240E0(ctx, base);
	// 821E039C: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03A0: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821E03A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E03A8: 40980024  bge cr6, 0x821e03cc
	if !ctx.cr[6].lt {
	pc = 0x821E03CC; continue 'dispatch;
	}
	// 821E03AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E03B0: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 821E03B4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E03B8: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 821E03BC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E03C0: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03C4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E03C8: 4198FFE4  blt cr6, 0x821e03ac
	if ctx.cr[6].lt {
	pc = 0x821E03AC; continue 'dispatch;
	}
	// 821E03CC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03D0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821E03D4: 91650008  stw r11, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E03D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E03DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E03E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E03E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E03E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E03E8 size=2060
    let mut pc: u32 = 0x821E03E8;
    'dispatch: loop {
        match pc {
            0x821E03E8 => {
    //   block [0x821E03E8..0x821E0BF4)
	// 821E03E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E03EC: 48AC9005  bl 0x82ca93f0
	ctx.lr = 0x821E03F0;
	sub_82CA93D0(ctx, base);
	// 821E03F0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821E03F4: 48ACD8E5  bl 0x82cadcd8
	ctx.lr = 0x821E03F8;
	sub_82CADCA0(ctx, base);
	// 821E03F8: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821E03FC: 48E265D1  bl 0x830069cc
	ctx.lr = 0x821E0400;
	sub_83006760(ctx, base);
	// 821E0400: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0404: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E0408: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821E040C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E0410: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821E0414: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 821E0418: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821E041C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821E0420: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821E0424: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 821E0428: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821E042C: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 821E0430: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821E0434: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821E0438: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821E043C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821E0440: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 821E0444: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 821E0448: 4800CB29  bl 0x821ecf70
	ctx.lr = 0x821E044C;
	sub_821ECF70(ctx, base);
	// 821E044C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821E0450: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821E0454: 3B4BDED4  addi r26, r11, -0x212c
	ctx.r[26].s64 = ctx.r[11].s64 + -8492;
	// 821E0458: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 821E045C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E0460: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821E0464: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0468: 80AB02AC  lwz r5, 0x2ac(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) } as u64;
	// 821E046C: 48087F95  bl 0x82268400
	ctx.lr = 0x821E0470;
	sub_82268400(ctx, base);
	// 821E0470: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0474: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821E0478: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821E047C: 394A0190  addi r10, r10, 0x190
	ctx.r[10].s64 = ctx.r[10].s64 + 400;
	// 821E0480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821E0484: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821E0488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E048C: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821E0490: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E0494: 4200FFF0  bdnz 0x821e0484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E0484; continue 'dispatch;
	}
	// 821E0498: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E049C: 480AE2ED  bl 0x8228e788
	ctx.lr = 0x821E04A0;
	sub_8228E788(ctx, base);
	// 821E04A0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E04A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821E04A8: 48090829  bl 0x82270cd0
	ctx.lr = 0x821E04AC;
	sub_82270CD0(ctx, base);
	// 821E04AC: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 821E04B0: 7BAA0020  clrldi r10, r29, 0x20
	ctx.r[10].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 821E04B4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E04B8: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04BC: 7B890020  clrldi r9, r28, 0x20
	ctx.r[9].u64 = ctx.r[28].u64 & 0x00000000FFFFFFFFu64;
	// 821E04C0: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821E04C4: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04C8: 7BE80020  clrldi r8, r31, 0x20
	ctx.r[8].u64 = ctx.r[31].u64 & 0x00000000FFFFFFFFu64;
	// 821E04CC: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821E04D0: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04D4: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821E04D8: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04DC: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 821E04E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E04E4: FCA04818  frsp f5, f9
	ctx.f[5].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821E04E8: 3AEB9484  addi r23, r11, -0x6b7c
	ctx.r[23].s64 = ctx.r[11].s64 + -27516;
	// 821E04EC: FCE06E9C  fcfid f7, f13
	ctx.f[7].f64 = (ctx.f[13].s64 as f64);
	// 821E04F0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821E04F4: FD00669C  fcfid f8, f12
	ctx.f[8].f64 = (ctx.f[12].s64 as f64);
	// 821E04F8: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 821E04FC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821E0500: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E0504: C397000C  lfs f28, 0xc(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821E0508: EC7C2824  fdivs f3, f28, f5
	ctx.f[3].f64 = ((ctx.f[28].f64 / ctx.f[5].f64) as f32) as f64;
	// 821E050C: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E0510: FFA03818  frsp f29, f7
	ctx.f[29].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E0514: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821E0518: FFC04018  frsp f30, f8
	ctx.f[30].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E051C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821E0520: FCC05018  frsp f6, f10
	ctx.f[6].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821E0524: EC9C3024  fdivs f4, f28, f6
	ctx.f[4].f64 = ((ctx.f[28].f64 / ctx.f[6].f64) as f32) as f64;
	// 821E0528: D0810054  stfs f4, 0x54(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821E052C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E0530: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E0534: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E0538: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E053C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E0540: 4200FFF0  bdnz 0x821e0530
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E0530; continue 'dispatch;
	}
	// 821E0544: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E0548: 38600075  li r3, 0x75
	ctx.r[3].s64 = 117;
	// 821E054C: 480A6F2D  bl 0x82287478
	ctx.lr = 0x821E0550;
	sub_82287478(ctx, base);
	// 821E0550: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E0554: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821E0558: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821E055C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821E0560: 386000CF  li r3, 0xcf
	ctx.r[3].s64 = 207;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E0BF8 size=28
    let mut pc: u32 = 0x821E0BF8;
    'dispatch: loop {
        match pc {
            0x821E0BF8 => {
    //   block [0x821E0BF8..0x821E0C14)
	// 821E0BF8: 81632940  lwz r11, 0x2940(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10560 as u32) ) } as u64;
	// 821E0BFC: 508B2EB4  rlwimi r11, r4, 5, 0x1a, 0x1a
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(5) as u64) & 0x0000000000000020) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFDF);
	// 821E0C00: 91632940  stw r11, 0x2940(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10560 as u32), ctx.r[11].u32 ) };
	// 821E0C04: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821E0C08: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 821E0C0C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E0C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0C18 size=96
    let mut pc: u32 = 0x821E0C18;
    'dispatch: loop {
        match pc {
            0x821E0C18 => {
    //   block [0x821E0C18..0x821E0C78)
	// 821E0C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E0C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E0C2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E0C30: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 821E0C34: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 821E0C38: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 821E0C3C: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821E0C40: 4BFB31F9  bl 0x82193e38
	ctx.lr = 0x821E0C44;
	sub_82193E38(ctx, base);
	// 821E0C44: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 821E0C48: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 821E0C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E0C50: 38A82B14  addi r5, r8, 0x2b14
	ctx.r[5].s64 = ctx.r[8].s64 + 11028;
	// 821E0C54: 38879950  addi r4, r7, -0x66b0
	ctx.r[4].s64 = ctx.r[7].s64 + -26288;
	// 821E0C58: 90DF0084  stw r6, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821E0C5C: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 821E0C60: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821E0C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E0C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E0C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E0C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E0C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E0C78 size=168
    let mut pc: u32 = 0x821E0C78;
    'dispatch: loop {
        match pc {
            0x821E0C78 => {
    //   block [0x821E0C78..0x821E0D20)
	// 821E0C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E0C84: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E0C88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0C8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E0C90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E0C94: 38830038  addi r4, r3, 0x38
	ctx.r[4].s64 = ctx.r[3].s64 + 56;
	// 821E0C98: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821E0C9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0CA0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E0CA4: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E0CA8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E0CAC: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E0CB0: ED806FFA  fmadds f12, f0, f31, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E0CB4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E0CB8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E0CBC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821E0CC0: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821E0CC4: 4882CF95  bl 0x82a0dc58
	ctx.lr = 0x821E0CC8;
	sub_82A0DC58(ctx, base);
	// 821E0CC8: 88E10068  lbz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821E0CCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E0CD0: 409A0038  bne cr6, 0x821e0d08
	if !ctx.cr[6].eq {
	pc = 0x821E0D08; continue 'dispatch;
	}
	// 821E0CD4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E0CD8: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E0CDC: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E0CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0CE4: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E0CE8: 409A0008  bne cr6, 0x821e0cf0
	if !ctx.cr[6].eq {
	pc = 0x821E0CF0; continue 'dispatch;
	}
	// 821E0CEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0CF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0CF4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E0CF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E0CFC: 409A0008  bne cr6, 0x821e0d04
	if !ctx.cr[6].eq {
	pc = 0x821E0D04; continue 'dispatch;
	}
	// 821E0D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E0D04: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E0D08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E0D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E0D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E0D14: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E0D18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E0D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0D20 size=552
    let mut pc: u32 = 0x821E0D20;
    'dispatch: loop {
        match pc {
            0x821E0D20 => {
    //   block [0x821E0D20..0x821E0F48)
	// 821E0D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0D24: 48AC86D5  bl 0x82ca93f8
	ctx.lr = 0x821E0D28;
	sub_82CA93D0(ctx, base);
	// 821E0D28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0D2C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821E0D30: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 821E0D34: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 821E0D38: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E0D3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0D40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E0D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E0D48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0D4C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821E0D50: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 821E0D54: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 821E0D58: 480AB7D1  bl 0x8228c528
	ctx.lr = 0x821E0D5C;
	sub_8228C528(ctx, base);
	// 821E0D5C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821E0D60: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E0D64: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E0D68: 419900B4  bgt cr6, 0x821e0e1c
	if ctx.cr[6].gt {
	pc = 0x821E0E1C; continue 'dispatch;
	}
	// 821E0D6C: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821E0D70: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821E0D74: 41980008  blt cr6, 0x821e0d7c
	if ctx.cr[6].lt {
	pc = 0x821E0D7C; continue 'dispatch;
	}
	// 821E0D78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E0D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0D80: 409A000C  bne cr6, 0x821e0d8c
	if !ctx.cr[6].eq {
	pc = 0x821E0D8C; continue 'dispatch;
	}
	// 821E0D84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821E0D88: 48000090  b 0x821e0e18
	pc = 0x821E0E18; continue 'dispatch;
	// 821E0D8C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 821E0D90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E0D94: 4198000C  blt cr6, 0x821e0da0
	if ctx.cr[6].lt {
	pc = 0x821E0DA0; continue 'dispatch;
	}
	// 821E0D98: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821E0D9C: 4800007C  b 0x821e0e18
	pc = 0x821E0E18; continue 'dispatch;
	// 821E0DA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E0DA4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821E0DA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E0DAC: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821E0DB0: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821E0DB4: 54E906F6  rlwinm r9, r7, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DB8: 38C90008  addi r6, r9, 8
	ctx.r[6].s64 = ctx.r[9].s64 + 8;
	// 821E0DBC: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DC0: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821E0DC4: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821E0DC8: 54680738  rlwinm r8, r3, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DCC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0DD0: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 821E0DD4: 7D474030  slw r7, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DD8: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821E0DDC: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821E0DE0: 54A8077A  rlwinm r8, r5, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DE4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0DE8: 38890002  addi r4, r9, 2
	ctx.r[4].s64 = ctx.r[9].s64 + 2;
	// 821E0DEC: 7D432030  slw r3, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DF0: 7D0B1850  subf r8, r11, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E0DF4: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821E0DF8: 54E807BC  rlwinm r8, r7, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DFC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0E00: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E0E04: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0E08: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821E0E0C: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821E0E10: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 821E0E14: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E0E18: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 821E0E1C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821E0E20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E0E24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E0E28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E0E2C: 480A5675  bl 0x822864a0
	ctx.lr = 0x821E0E30;
	sub_822864A0(ctx, base);
	// 821E0E30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0E34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E0E38: 480AB681  bl 0x8228c4b8
	ctx.lr = 0x821E0E3C;
	sub_8228C4B8(ctx, base);
	// 821E0E3C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821E0E40: 419A00FC  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E44: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 821E0E48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821E0E4C: 1D6B004C  mulli r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 * 76;
	// 821E0E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E0E54: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E0E58: 4BFED261  bl 0x821ce0b8
	ctx.lr = 0x821E0E5C;
	sub_821CE0B8(ctx, base);
	// 821E0E5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0E60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0E64: 419A00D8  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E0E6C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821E0E70: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E0E74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E0E78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E0E7C: 4897ED2D  bl 0x82b5fba8
	ctx.lr = 0x821E0E80;
	sub_82B5FBA8(ctx, base);
	// 821E0E80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E0E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0E88: 419A00B4  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E8C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E0E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0E94: 419A0010  beq cr6, 0x821e0ea4
	if ctx.cr[6].eq {
	pc = 0x821E0EA4; continue 'dispatch;
	}
	// 821E0E98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0E9C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821E0EA0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E0EA4: 933E0038  stw r25, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 821E0EA8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821E0EAC: 419A0010  beq cr6, 0x821e0ebc
	if ctx.cr[6].eq {
	pc = 0x821E0EBC; continue 'dispatch;
	}
	// 821E0EB0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E0EB8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E0EBC: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E0EC4: 419A0044  beq cr6, 0x821e0f08
	if ctx.cr[6].eq {
	pc = 0x821E0F08; continue 'dispatch;
	}
	// 821E0EC8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821E0ECC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E0ED0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0ED4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E0ED8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E0EDC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E0EE0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0EE4: 4082FFE8  bne 0x821e0ecc
	if !ctx.cr[0].eq {
	pc = 0x821E0ECC; continue 'dispatch;
	}
	// 821E0EE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E0EEC: 409A0014  bne cr6, 0x821e0f00
	if !ctx.cr[6].eq {
	pc = 0x821E0F00; continue 'dispatch;
	}
	// 821E0EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0EF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E0EFC: 4E800421  bctrl
	ctx.lr = 0x821E0F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E0F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E0F04: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E0F08: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E0F0C: 93D80004  stw r30, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821E0F10: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821E0F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E0F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0F1C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E0F20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E0F24: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E0F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0F2C: 4082FFE8  bne 0x821e0f14
	if !ctx.cr[0].eq {
	pc = 0x821E0F14; continue 'dispatch;
	}
	// 821E0F30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E0F34: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E0F38: 48AC8510  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 821E0F3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E0F40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E0F44: 48AC8504  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0F48 size=476
    let mut pc: u32 = 0x821E0F48;
    'dispatch: loop {
        match pc {
            0x821E0F48 => {
    //   block [0x821E0F48..0x821E1124)
	// 821E0F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0F4C: 48AC84B5  bl 0x82ca9400
	ctx.lr = 0x821E0F50;
	sub_82CA93D0(ctx, base);
	// 821E0F50: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0F54: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E0F58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E0F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E0F60: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E0F64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E0F68: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 821E0F6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0F70: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821E0F74: 4801F7FD  bl 0x82200770
	ctx.lr = 0x821E0F78;
	sub_82200770(ctx, base);
	// 821E0F78: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E0F7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E0F80: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 821E0F84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E0F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E0F8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E0F90: 409A00B4  bne cr6, 0x821e1044
	if !ctx.cr[6].eq {
	pc = 0x821E1044; continue 'dispatch;
	}
	// 821E0F94: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E0F98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0F9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0FA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0FA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E0FA8: 4E800421  bctrl
	ctx.lr = 0x821E0FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E0FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E0FB4: 48A30D15  bl 0x82c11cc8
	ctx.lr = 0x821E0FB8;
	sub_82C11CC8(ctx, base);
	// 821E0FB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0FBC: 48A24F3D  bl 0x82c05ef8
	ctx.lr = 0x821E0FC0;
	sub_82C05EF8(ctx, base);
	// 821E0FC0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E0FC4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821E0FC8: 38A99170  addi r5, r9, -0x6e90
	ctx.r[5].s64 = ctx.r[9].s64 + -28304;
	// 821E0FCC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821E0FD0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821E0FD4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E0FD8: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1128 size=16
    let mut pc: u32 = 0x821E1128;
    'dispatch: loop {
        match pc {
            0x821E1128 => {
    //   block [0x821E1128..0x821E1138)
	// 821E1128: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E112C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E1130: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E1134: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1138 size=12
    let mut pc: u32 = 0x821E1138;
    'dispatch: loop {
        match pc {
            0x821E1138 => {
    //   block [0x821E1138..0x821E1144)
	// 821E1138: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E113C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E1140: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1144(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1144 size=20
    let mut pc: u32 = 0x821E1144;
    'dispatch: loop {
        match pc {
            0x821E1144 => {
    //   block [0x821E1144..0x821E1158)
	// 821E1144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1148: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821E114C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1150: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1154: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1158 size=4
    let mut pc: u32 = 0x821E1158;
    'dispatch: loop {
        match pc {
            0x821E1158 => {
    //   block [0x821E1158..0x821E115C)
	// 821E1158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1160 size=628
    let mut pc: u32 = 0x821E1160;
    'dispatch: loop {
        match pc {
            0x821E1160 => {
    //   block [0x821E1160..0x821E13D4)
	// 821E1160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1164: 48AC82A9  bl 0x82ca940c
	ctx.lr = 0x821E1168;
	sub_82CA93D0(ctx, base);
	// 821E1168: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821E116C: 48ACCB6D  bl 0x82cadcd8
	ctx.lr = 0x821E1170;
	sub_82CADCA0(ctx, base);
	// 821E1170: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E13D8 size=276
    let mut pc: u32 = 0x821E13D8;
    'dispatch: loop {
        match pc {
            0x821E13D8 => {
    //   block [0x821E13D8..0x821E14EC)
	// 821E13D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E13DC: 48AC801D  bl 0x82ca93f8
	ctx.lr = 0x821E13E0;
	sub_82CA93D0(ctx, base);
	// 821E13E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E13E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821E13E8: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821E13EC: 3BFA09F4  addi r31, r26, 0x9f4
	ctx.r[31].s64 = ctx.r[26].s64 + 2548;
	// 821E13F0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821E13F4: 817A09FC  lwz r11, 0x9fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2556 as u32) ) } as u64;
	// 821E13F8: 815A09F8  lwz r10, 0x9f8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E13FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E1400: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821E1404: 418200E0  beq 0x821e14e4
	if ctx.cr[0].eq {
	pc = 0x821E14E4; continue 'dispatch;
	}
	// 821E1408: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E140C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 821E1410: 817A09F8  lwz r11, 0x9f8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E1414: 7D4BE214  add r10, r11, r28
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E1418: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821E141C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E1420: 41990098  bgt cr6, 0x821e14b8
	if ctx.cr[6].gt {
	pc = 0x821E14B8; continue 'dispatch;
	}
	// 821E1424: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E1428: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 821E142C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1430: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E1434: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1438: 4816F489  bl 0x823508c0
	ctx.lr = 0x821E143C;
	sub_823508C0(ctx, base);
	// 821E143C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1440: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1444: 815A09F8  lwz r10, 0x9f8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E1448: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821E144C: 7C7C5214  add r3, r28, r10
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E1450: 7D67DBD6  divw r11, r7, r27
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	// 821E1454: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E1458: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E145C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1460: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E1464: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 821E1468: 489442E9  bl 0x82b25750
	ctx.lr = 0x821E146C;
	sub_82B25750(ctx, base);
	// 821E146C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1470: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1474: 7C85F050  subf r4, r5, r30
	ctx.r[4].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 821E1478: 7C64DBD7  divw. r3, r4, r27
	ctx.r[3].s32 = ctx.r[4].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821E147C: 41820030  beq 0x821e14ac
	if ctx.cr[0].eq {
	pc = 0x821E14AC; continue 'dispatch;
	}
	// 821E1480: 3BBEFFF4  addi r29, r30, -0xc
	ctx.r[29].s64 = ctx.r[30].s64 + -12;
	// 821E1484: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E1488: 419A0018  beq cr6, 0x821e14a0
	if ctx.cr[6].eq {
	pc = 0x821E14A0; continue 'dispatch;
	}
	// 821E148C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 821E1490: 4BFD6689  bl 0x821b7b18
	ctx.lr = 0x821E1494;
	sub_821B7B18(ctx, base);
	// 821E1494: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 821E1498: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E149C: 409AFFF0  bne cr6, 0x821e148c
	if !ctx.cr[6].eq {
	pc = 0x821E148C; continue 'dispatch;
	}
	// 821E14A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E14A4: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 821E14A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E14AC: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 821E14B0: 3B9CFFF4  addi r28, r28, -0xc
	ctx.r[28].s64 = ctx.r[28].s64 + -12;
	// 821E14B4: 48000010  b 0x821e14c4
	pc = 0x821E14C4; continue 'dispatch;
	// 821E14B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E14BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E14C0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E14C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E14C8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821E14CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E14D0: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 821E14D4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E14D8: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821E14DC: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E14E0: 4198FF30  blt cr6, 0x821e1410
	if ctx.cr[6].lt {
	pc = 0x821E1410; continue 'dispatch;
	}
	// 821E14E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E14E8: 48AC7F60  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E14F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E14F0 size=776
    let mut pc: u32 = 0x821E14F0;
    'dispatch: loop {
        match pc {
            0x821E14F0 => {
    //   block [0x821E14F0..0x821E17F8)
	// 821E14F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E14F4: 48AC7F01  bl 0x82ca93f4
	ctx.lr = 0x821E14F8;
	sub_82CA93D0(ctx, base);
	// 821E14F8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E14FC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E1500: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821E1504: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821E1508: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821E150C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821E1510: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821E1514: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E1518: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E151C: 38A6AC38  addi r5, r6, -0x53c8
	ctx.r[5].s64 = ctx.r[6].s64 + -21448;
	// 821E1520: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821E1524: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1528: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E152C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821E1530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E1534: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E1538: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 821E153C: 7D0BF92E  stwx r8, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 821E1540: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E1544: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E1548: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E154C: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821E1550: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821E1554: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1558: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821E155C: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821E1560: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821E1564: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E1568: 815F4008  lwz r10, 0x4008(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821E156C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1570: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E1574: 915F4008  stw r10, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821E1578: 917F400C  stw r11, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821E157C: 48039225  bl 0x8221a7a0
	ctx.lr = 0x821E1580;
	sub_8221A7A0(ctx, base);
	// 821E1580: 817E06FC  lwz r11, 0x6fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E1584: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821E1588: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E158C: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 821E1590: 831E06F8  lwz r24, 0x6f8(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1784 as u32) ) } as u64;
	// 821E1594: 935E06F8  stw r26, 0x6f8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1784 as u32), ctx.r[26].u32 ) };
	// 821E1598: 419A000C  beq cr6, 0x821e15a4
	if ctx.cr[6].eq {
	pc = 0x821E15A4; continue 'dispatch;
	}
	// 821E159C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E15A0: 409A002C  bne cr6, 0x821e15cc
	if !ctx.cr[6].eq {
	pc = 0x821E15CC; continue 'dispatch;
	}
	// 821E15A4: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E15A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E15AC: 409A0020  bne cr6, 0x821e15cc
	if !ctx.cr[6].eq {
	pc = 0x821E15CC; continue 'dispatch;
	}
	// 821E15B0: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E15B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E15B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E15BC: 388B0110  addi r4, r11, 0x110
	ctx.r[4].s64 = ctx.r[11].s64 + 272;
	// 821E15C0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821E15C4: 838B0128  lwz r28, 0x128(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(296 as u32) ) } as u64;
	// 821E15C8: 4803F651  bl 0x82220c18
	ctx.lr = 0x821E15CC;
	sub_82220C18(ctx, base);
	// 821E15CC: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E15D0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E15D4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821E15D8: 7D1C5A14  add r8, r28, r11
	ctx.r[8].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821E15DC: 39694F30  addi r11, r9, 0x4f30
	ctx.r[11].s64 = ctx.r[9].s64 + 20272;
	// 821E15E0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E15E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E15E8: 7CC75A14  add r6, r7, r11
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821E15EC: 80FD0024  lwz r7, 0x24(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E15F0: 390A0050  addi r8, r10, 0x50
	ctx.r[8].s64 = ctx.r[10].s64 + 80;
	// 821E15F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E15F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E15FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E1600: 4802A4F9  bl 0x8220baf8
	ctx.lr = 0x821E1604;
	sub_8220BAF8(ctx, base);
	// 821E1604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1608: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E160C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1610: 480414A1  bl 0x82222ab0
	ctx.lr = 0x821E1614;
	sub_82222AB0(ctx, base);
	// 821E1614: 80FE06FC  lwz r7, 0x6fc(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E1618: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 821E161C: 409A0014  bne cr6, 0x821e1630
	if !ctx.cr[6].eq {
	pc = 0x821E1630; continue 'dispatch;
	}
	// 821E1620: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E1624: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1628: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821E162C: 48000068  b 0x821e1694
	pc = 0x821E1694; continue 'dispatch;
	// 821E1630: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E1634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1638: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E163C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821E1640: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E1644: 409A000C  bne cr6, 0x821e1650
	if !ctx.cr[6].eq {
	pc = 0x821E1650; continue 'dispatch;
	}
	// 821E1648: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 821E164C: 48000018  b 0x821e1664
	pc = 0x821E1664; continue 'dispatch;
	// 821E1650: 896B009B  lbz r11, 0x9b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 821E1654: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821E1658: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821E165C: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 821E1660: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821E1664: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1668: 554AF7FE  rlwinm r10, r10, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E166C: 811B0034  lwz r8, 0x34(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E1670: 38EB001C  addi r7, r11, 0x1c
	ctx.r[7].s64 = ctx.r[11].s64 + 28;
	// 821E1674: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E167C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1680: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E1684: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E1688: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E168C: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821E1690: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 821E1694: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1698: 4802A3F1  bl 0x8220ba88
	ctx.lr = 0x821E169C;
	sub_8220BA88(ctx, base);
	// 821E169C: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 821E16A0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E16A4: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E16A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E16AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E16B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E16B4: 997C05A1  stb r11, 0x5a1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821E16B8: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E16BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E16C0: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E16C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E16C8: 4E800421  bctrl
	ctx.lr = 0x821E16CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E16CC: 891C05A1  lbz r8, 0x5a1(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1441 as u32) ) } as u64;
	// 821E16D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E16D4: 419A00A4  beq cr6, 0x821e1778
	if ctx.cr[6].eq {
	pc = 0x821E1778; continue 'dispatch;
	}
	// 821E16D8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E16DC: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821E16E0: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821E16E4: 392A6FAC  addi r9, r10, 0x6fac
	ctx.r[9].s64 = ctx.r[10].s64 + 28588;
	// 821E16E8: 890B1A25  lbz r8, 0x1a25(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6693 as u32) ) } as u64;
	// 821E16EC: 80E90008  lwz r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E16F0: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s64 = ctx.r[8].s64 * 8200;
	// 821E16F4: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821E16F8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821E16FC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E1700: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821E1704: 419A006C  beq cr6, 0x821e1770
	if ctx.cr[6].eq {
	pc = 0x821E1770; continue 'dispatch;
	}
	// 821E1708: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E170C: 810B1A18  lwz r8, 0x1a18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6680 as u32) ) } as u64;
	// 821E1710: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821E1714: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E1718: 409A003C  bne cr6, 0x821e1754
	if !ctx.cr[6].eq {
	pc = 0x821E1754; continue 'dispatch;
	}
	// 821E171C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E1720: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821E1724: 38AB1A10  addi r5, r11, 0x1a10
	ctx.r[5].s64 = ctx.r[11].s64 + 6672;
	// 821E1728: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E172C: 912B1A18  stw r9, 0x1a18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6680 as u32), ctx.r[9].u32 ) };
	// 821E1730: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821E1734: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821E1738: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E173C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E1740: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E1744: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1748: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E174C: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E1750: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821E1754: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821E1758: 90EB1A14  stw r7, 0x1a14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6676 as u32), ctx.r[7].u32 ) };
	// 821E175C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821E1760: 994B1A24  stb r10, 0x1a24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6692 as u32), ctx.r[10].u8 ) };
	// 821E1764: 386B1A10  addi r3, r11, 0x1a10
	ctx.r[3].s64 = ctx.r[11].s64 + 6672;
	// 821E1768: 992B1A1C  stb r9, 0x1a1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6684 as u32), ctx.r[9].u8 ) };
	// 821E176C: 4803CDE5  bl 0x8221e550
	ctx.lr = 0x821E1770;
	sub_8221E550(ctx, base);
	// 821E1770: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821E1774: 997C05A1  stb r11, 0x5a1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821E1778: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821E177C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1780: 409A0018  bne cr6, 0x821e1798
	if !ctx.cr[6].eq {
	pc = 0x821E1798; continue 'dispatch;
	}
	// 821E1784: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1788: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E178C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821E1790: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E1794: 419A0008  beq cr6, 0x821e179c
	if ctx.cr[6].eq {
	pc = 0x821E179C; continue 'dispatch;
	}
	// 821E1798: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E179C: 5567063E  clrlwi r7, r11, 0x18
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E17A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E17A4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E17A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E17AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E17B0: 4801D3C1  bl 0x821feb70
	ctx.lr = 0x821E17B4;
	sub_821FEB70(ctx, base);
	// 821E17B4: 894100C9  lbz r10, 0xc9(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(201 as u32) ) } as u64;
	// 821E17B8: 931E06F8  stw r24, 0x6f8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1784 as u32), ctx.r[24].u32 ) };
	// 821E17BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E17C0: 419A0010  beq cr6, 0x821e17d0
	if ctx.cr[6].eq {
	pc = 0x821E17D0; continue 'dispatch;
	}
	// 821E17C4: 9AE100C9  stb r23, 0xc9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(201 as u32), ctx.r[23].u8 ) };
	// 821E17C8: 387F2008  addi r3, r31, 0x2008
	ctx.r[3].s64 = ctx.r[31].s64 + 8200;
	// 821E17CC: 4803DB7D  bl 0x8221f348
	ctx.lr = 0x821E17D0;
	sub_8221F348(ctx, base);
	// 821E17D0: 894100C8  lbz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 821E17D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E17D8: 419A0010  beq cr6, 0x821e17e8
	if ctx.cr[6].eq {
	pc = 0x821E17E8; continue 'dispatch;
	}
	// 821E17DC: 9AE100C8  stb r23, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[23].u8 ) };
	// 821E17E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E17E4: 4803DB65  bl 0x8221f348
	ctx.lr = 0x821E17E8;
	sub_8221F348(ctx, base);
	// 821E17E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E17EC: 4803DAF5  bl 0x8221f2e0
	ctx.lr = 0x821E17F0;
	sub_8221F2E0(ctx, base);
	// 821E17F0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821E17F4: 48AC7C50  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E17F8 size=80
    let mut pc: u32 = 0x821E17F8;
    'dispatch: loop {
        match pc {
            0x821E17F8 => {
    //   block [0x821E17F8..0x821E1848)
	// 821E17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E17FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1804: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E1808: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821E180C: 390A2A2C  addi r8, r10, 0x2a2c
	ctx.r[8].s64 = ctx.r[10].s64 + 10796;
	// 821E1810: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1814: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E181C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821E1820: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821E1824: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821E1828: 419A0008  beq cr6, 0x821e1830
	if ctx.cr[6].eq {
	pc = 0x821E1830; continue 'dispatch;
	}
	// 821E182C: 4801A94D  bl 0x821fc178
	ctx.lr = 0x821E1830;
	sub_821FC178(ctx, base);
	// 821E1830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E1834: 4801AB6D  bl 0x821fc3a0
	ctx.lr = 0x821E1838;
	sub_821FC3A0(ctx, base);
	// 821E1838: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E183C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E1840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E1844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1848 size=144
    let mut pc: u32 = 0x821E1848;
    'dispatch: loop {
        match pc {
            0x821E1848 => {
    //   block [0x821E1848..0x821E18D8)
	// 821E1848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E184C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E1854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E1858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E185C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1860: 489EA339  bl 0x82bcbb98
	ctx.lr = 0x821E1864;
	sub_82BCBB98(ctx, base);
	// 821E1864: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E1868: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821E186C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E1874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E1878: 409AFFF4  bne cr6, 0x821e186c
	if !ctx.cr[6].eq {
	pc = 0x821E186C; continue 'dispatch;
	}
	// 821E187C: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 821E1880: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821E1884: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E1888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E188C: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E1890: 4809A329  bl 0x8227bbb8
	ctx.lr = 0x821E1894;
	sub_8227BBB8(ctx, base);
	// 821E1894: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821E1898: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821E189C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E18A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E18A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E18A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E18AC: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E18B0: 4BFEDE29  bl 0x821cf6d8
	ctx.lr = 0x821E18B4;
	sub_821CF6D8(ctx, base);
	// 821E18B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E18B8: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E18BC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E18C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E18C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E18C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E18CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E18D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E18D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E18D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E18D8 size=36
    let mut pc: u32 = 0x821E18D8;
    'dispatch: loop {
        match pc {
            0x821E18D8 => {
    //   block [0x821E18D8..0x821E18FC)
	// 821E18D8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E18DC: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821E18E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E18E4: 40980018  bge cr6, 0x821e18fc
	if !ctx.cr[6].lt {
		sub_821E18FC(ctx, base);
		return;
	}
	// 821E18E8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E18EC: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E18F0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E18F4: 386BFFF8  addi r3, r11, -8
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	// 821E18F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E18FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E18FC size=116
    let mut pc: u32 = 0x821E18FC;
    'dispatch: loop {
        match pc {
            0x821E18FC => {
    //   block [0x821E18FC..0x821E1970)
	// 821E18FC: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821E1900: 89230007  lbz r9, 7(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821E1904: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E1908: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E190C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821E1910: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821E1914: 7D0B4830  slw r11, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821E1918: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 821E191C: C1A79490  lfs f13, -0x6b70(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1920: 60C50001  ori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 | 1;
	// 821E1924: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E1928: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 821E192C: FC006018  frsp f0, f12
	ctx.f[0].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821E1930: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821E1934: D161FFF0  stfs f11, -0x10(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821E1938: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821E193C: 7C8B2B96  divwu r4, r11, r5
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[5].u32;
	// 821E1940: 7C6429D6  mullw r3, r4, r5
	ctx.r[3].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 821E1944: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 821E1948: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E194C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E1950: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1954: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E1958: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E195C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E1960: 409A0010  bne cr6, 0x821e1970
	if !ctx.cr[6].eq {
		sub_821E1970(ctx, base);
		return;
	}
	// 821E1964: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1968: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E196C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1970 size=24
    let mut pc: u32 = 0x821E1970;
    'dispatch: loop {
        match pc {
            0x821E1970 => {
    //   block [0x821E1970..0x821E1988)
	// 821E1970: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E1978: 409AFFE0  bne cr6, 0x821e1958
	if !ctx.cr[6].eq {
		sub_821E18FC(ctx, base);
		return;
	}
	// 821E197C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821E1980: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821E1984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1988 size=88
    let mut pc: u32 = 0x821E1988;
    'dispatch: loop {
        match pc {
            0x821E1988 => {
    //   block [0x821E1988..0x821E19E0)
	// 821E1988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E198C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E1994: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E199C: 489EA1FD  bl 0x82bcbb98
	ctx.lr = 0x821E19A0;
	sub_82BCBB98(ctx, base);
	// 821E19A0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821E19A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E19A8: 4BFFFF31  bl 0x821e18d8
	ctx.lr = 0x821E19AC;
	sub_821E18D8(ctx, base);
	// 821E19AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E19B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E19B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E19B8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E19BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E19C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E19C4: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E19C8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E19CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E19D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E19D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E19D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E19DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E19E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E19E0 size=452
    let mut pc: u32 = 0x821E19E0;
    'dispatch: loop {
        match pc {
            0x821E19E0 => {
    //   block [0x821E19E0..0x821E1BA4)
	// 821E19E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E19E4: 48AC7A21  bl 0x82ca9404
	ctx.lr = 0x821E19E8;
	sub_82CA93D0(ctx, base);
	// 821E19E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E19EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E19F0: 3D6082BC  lis r11, -0x7d44
	ctx.r[11].s64 = -2101608448;
	// 821E19F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E19F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E19FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E1A00: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A04: 388B9118  addi r4, r11, -0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + -28392;
	// 821E1A08: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A0C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1A10: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821E1A14: 7D1D1E70  srawi r29, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E1A18: 48099F51  bl 0x8227b968
	ctx.lr = 0x821E1A1C;
	sub_8227B968(ctx, base);
	// 821E1A1C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821E1A20: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A24: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1A28: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E1A2C: 4BFFFEAD  bl 0x821e18d8
	ctx.lr = 0x821E1A30;
	sub_821E18D8(ctx, base);
	// 821E1A30: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1A34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1A38: 80FB0008  lwz r7, 8(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A3C: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821E1A40: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A44: 90A70004  stw r5, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821E1A48: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A4C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 821E1A50: 907B0008  stw r3, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821E1A54: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A58: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A5C: 806BFFF8  lwz r3, -8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E1A60: 4BFFFE79  bl 0x821e18d8
	ctx.lr = 0x821E1A64;
	sub_821E18D8(ctx, base);
	// 821E1A64: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A68: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1A6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E1A70: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E1A74: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E1A78: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A7C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1A80: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A84: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E1A88: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E1A8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A90: 4BFFFDB9  bl 0x821e1848
	ctx.lr = 0x821E1A94;
	sub_821E1848(ctx, base);
	// 821E1A94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A98: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A9C: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 821E1AA0: 38C706F4  addi r6, r7, 0x6f4
	ctx.r[6].s64 = ctx.r[7].s64 + 1780;
	// 821E1AA4: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821E1AA8: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E1AAC: 409A000C  bne cr6, 0x821e1ab8
	if !ctx.cr[6].eq {
	pc = 0x821E1AB8; continue 'dispatch;
	}
	// 821E1AB0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821E1AB4: 48000008  b 0x821e1abc
	pc = 0x821E1ABC; continue 'dispatch;
	// 821E1AB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1ABC: 396BFFFA  addi r11, r11, -6
	ctx.r[11].s64 = ctx.r[11].s64 + -6;
	// 821E1AC0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821E1AC4: 555CDFFE  rlwinm r28, r10, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821E1AC8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E1ACC: 419A00C0  beq cr6, 0x821e1b8c
	if ctx.cr[6].eq {
	pc = 0x821E1B8C; continue 'dispatch;
	}
	// 821E1AD0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E1AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E1AD8: 388A0DA8  addi r4, r10, 0xda8
	ctx.r[4].s64 = ctx.r[10].s64 + 3496;
	// 821E1ADC: 80ABD9FC  lwz r5, -0x2604(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9732 as u32) ) } as u64;
	// 821E1AE0: 4BFBB221  bl 0x8219cd00
	ctx.lr = 0x821E1AE4;
	sub_8219CD00(ctx, base);
	// 821E1AE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1AE8: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 821E1AEC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1AF0: 80E8FFE8  lwz r7, -0x18(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24 as u32) ) } as u64;
	// 821E1AF4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821E1AF8: 80C8FFEC  lwz r6, -0x14(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20 as u32) ) } as u64;
	// 821E1AFC: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821E1B00: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B04: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 821E1B08: 90A90008  stw r5, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821E1B0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B10: 480C45C9  bl 0x822a60d8
	ctx.lr = 0x821E1B14;
	sub_822A60D8(ctx, base);
	// 821E1B14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B18: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B1C: 349D0001  addic. r4, r29, 1
	ctx.xer.ca = (ctx.r[29].u32 > (!(1 as u32)));
	ctx.r[4].s64 = ctx.r[29].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E1B20: 814BFFF0  lwz r10, -0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821E1B24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E1B28: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821E1B2C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1B30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B34: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E1B38: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E1B3C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B40: 4082000C  bne 0x821e1b4c
	if !ctx.cr[0].eq {
	pc = 0x821E1B4C; continue 'dispatch;
	}
	// 821E1B44: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E1B48: 48000014  b 0x821e1b5c
	pc = 0x821E1B5C; continue 'dispatch;
	// 821E1B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E1B50: 489EA049  bl 0x82bcbb98
	ctx.lr = 0x821E1B54;
	sub_82BCBB98(ctx, base);
	// 821E1B54: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1B58: 7CEB1850  subf r7, r11, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E1B5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E1B64: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1B68: 3D0082BD  lis r8, -0x7d43
	ctx.r[8].s64 = -2101542912;
	// 821E1B6C: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821E1B70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E1B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E1B78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E1B7C: 3888C870  addi r4, r8, -0x3790
	ctx.r[4].s64 = ctx.r[8].s64 + -14224;
	// 821E1B80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E1B84: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E1B88: 480DE9E9  bl 0x822c0570
	ctx.lr = 0x821E1B8C;
	sub_822C0570(ctx, base);
	// 821E1B8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E1B90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B94: 489EA175  bl 0x82bcbd08
	ctx.lr = 0x821E1B98;
	sub_82BCBD08(ctx, base);
	// 821E1B98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E1B9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E1BA0: 48AC78B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1BA8 size=100
    let mut pc: u32 = 0x821E1BA8;
    'dispatch: loop {
        match pc {
            0x821E1BA8 => {
    //   block [0x821E1BA8..0x821E1C0C)
	// 821E1BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1BAC: 48AC7861  bl 0x82ca940c
	ctx.lr = 0x821E1BB0;
	sub_82CA93D0(ctx, base);
	// 821E1BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E1BBC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E1BC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1BC4: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E1BC8: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E1BCC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E1BD0: 41980008  blt cr6, 0x821e1bd8
	if ctx.cr[6].lt {
	pc = 0x821E1BD8; continue 'dispatch;
	}
	// 821E1BD4: 4BF979AD  bl 0x82179580
	ctx.lr = 0x821E1BD8;
	sub_82179580(ctx, base);
	// 821E1BD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E1BDC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1BE8: 48045AB9  bl 0x822276a0
	ctx.lr = 0x821E1BEC;
	sub_822276A0(ctx, base);
	// 821E1BEC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821E1BF0: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821E1BF4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E1BF8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1BFC: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 821E1C00: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821E1C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1C08: 48AC7854  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1C10 size=76
    let mut pc: u32 = 0x821E1C10;
    'dispatch: loop {
        match pc {
            0x821E1C10 => {
    //   block [0x821E1C10..0x821E1C5C)
	// 821E1C10: 39200820  li r9, 0x820
	ctx.r[9].s64 = 2080;
	// 821E1C14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1C18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1C5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1C5C size=92
    let mut pc: u32 = 0x821E1C5C;
    'dispatch: loop {
        match pc {
            0x821E1C5C => {
    //   block [0x821E1C5C..0x821E1CB8)
	// 821E1C5C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E1C60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E1C64: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E1C68: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 821E1C6C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E1C70: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821E1C74: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E1C78: 40810054  ble 0x821e1ccc
	if !ctx.cr[0].gt {
		sub_821E1CB8(ctx, base);
		return;
	}
	// 821E1C7C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E1C80: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E1C84: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E1C88: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1C8C: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 821E1C90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E1C94: 41980008  blt cr6, 0x821e1c9c
	if ctx.cr[6].lt {
	pc = 0x821E1C9C; continue 'dispatch;
	}
	// 821E1C98: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E1C9C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E1CA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E1CA4: 419A0014  beq cr6, 0x821e1cb8
	if ctx.cr[6].eq {
		sub_821E1CB8(ctx, base);
		return;
	}
	// 821E1CA8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E1CAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E1CB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E1CB4: 4800000C  b 0x821e1cc0
	sub_821E1CB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1CB8 size=88
    let mut pc: u32 = 0x821E1CB8;
    'dispatch: loop {
        match pc {
            0x821E1CB8 => {
    //   block [0x821E1CB8..0x821E1D10)
	// 821E1CB8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E1CBC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E1CC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E1CC4: 4199FFB8  bgt cr6, 0x821e1c7c
	if ctx.cr[6].gt {
		sub_821E1C5C(ctx, base);
		return;
	}
	// 821E1CC8: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821E1CCC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E1CD0: 419A0040  beq cr6, 0x821e1d10
	if ctx.cr[6].eq {
		sub_821E1D10(ctx, base);
		return;
	}
	// 821E1CD4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1CD8: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 821E1CDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E1CE0: 41990008  bgt cr6, 0x821e1ce8
	if ctx.cr[6].gt {
	pc = 0x821E1CE8; continue 'dispatch;
	}
	// 821E1CE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E1CE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E1CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1CF0: 409A0020  bne cr6, 0x821e1d10
	if !ctx.cr[6].eq {
		sub_821E1D10(ctx, base);
		return;
	}
	// 821E1CF4: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E1CF8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821E1CFC: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821E1D00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E1D08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E1D0C: 4800001C  b 0x821e1d28
	sub_821E1D24(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1D10 size=20
    let mut pc: u32 = 0x821E1D10;
    'dispatch: loop {
        match pc {
            0x821E1D10 => {
    //   block [0x821E1D10..0x821E1D24)
	// 821E1D10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E1D14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E1D1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E1D20: 48000008  b 0x821e1d28
	sub_821E1D24(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1D24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1D24 size=16
    let mut pc: u32 = 0x821E1D24;
    'dispatch: loop {
        match pc {
            0x821E1D24 => {
    //   block [0x821E1D24..0x821E1D34)
	// 821E1D24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E1D28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E1D2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1D30: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1D34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1D34 size=20
    let mut pc: u32 = 0x821E1D34;
    'dispatch: loop {
        match pc {
            0x821E1D34 => {
    //   block [0x821E1D34..0x821E1D48)
	// 821E1D34: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 821E1D38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E1D3C: 992A0070  stb r9, 0x70(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(112 as u32), ctx.r[9].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E1D48 size=288
    let mut pc: u32 = 0x821E1D48;
    'dispatch: loop {
        match pc {
            0x821E1D48 => {
    //   block [0x821E1D48..0x821E1E68)
	// 821E1D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1D4C: 48AC76BD  bl 0x82ca9408
	ctx.lr = 0x821E1D50;
	sub_82CA93D0(ctx, base);
	// 821E1D50: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E1D54: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E1D58: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E1D5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1D64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E1D68: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1D70: 419A00E4  beq cr6, 0x821e1e54
	if ctx.cr[6].eq {
	pc = 0x821E1E54; continue 'dispatch;
	}
	// 821E1D74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1D7C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1D84: 4E800421  bctrl
	ctx.lr = 0x821E1D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1D88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D8C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E1D90: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1D94: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E1D98: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E1D9C: 4E800421  bctrl
	ctx.lr = 0x821E1DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1DA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E1DA4: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821E1DA8: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 821E1DAC: C1BE9A80  lfs f13, -0x6580(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1DB0: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821E1DB4: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821E1DB8: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821E1DBC: 40990008  ble cr6, 0x821e1dc4
	if !ctx.cr[6].gt {
	pc = 0x821E1DC4; continue 'dispatch;
	}
	// 821E1DC0: EC01F824  fdivs f0, f1, f31
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[31].f64) as f32) as f64;
	// 821E1DC4: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E1DC8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821E1DCC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E1DD0: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E1DD4: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821E1DD8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1DDC: 5547F77A  rlwinm r7, r10, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E1DE0: 3B8B0E68  addi r28, r11, 0xe68
	ctx.r[28].s64 = ctx.r[11].s64 + 3688;
	// 821E1DE4: 7D263B78  or r6, r9, r7
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 821E1DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1DEC: 80A80024  lwz r5, 0x24(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1DF0: 7DBC342E  lfsx f13, r28, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1DF4: FFADF82E  fsel f29, f13, f0, f31
	ctx.f[29].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 821E1DF8: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821E1DFC: 4E800421  bctrl
	ctx.lr = 0x821E1E00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1E00: ED9DF028  fsubs f12, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 - ctx.f[30].f64) as f32) as f64);
	// 821E1E04: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821E1E08: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821E1E0C: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E1E10: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821E1E14: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821E1E18: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821E1E1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1E20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1E24: 7D7C542E  lfsx f11, r28, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E1E28: FD4BEFAE  fsel f10, f11, f30, f29
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[29].f64 };
	// 821E1E2C: EC2A0032  fmuls f1, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821E1E30: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821E1E34: 4098000C  bge cr6, 0x821e1e40
	if !ctx.cr[6].lt {
	pc = 0x821E1E40; continue 'dispatch;
	}
	// 821E1E38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1E3C: 48000010  b 0x821e1e4c
	pc = 0x821E1E4C; continue 'dispatch;
	// 821E1E40: C1BE9A80  lfs f13, -0x6580(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1E44: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E1E48: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E1E4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1E50: 4E800421  bctrl
	ctx.lr = 0x821E1E54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1E54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E1E58: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821E1E5C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821E1E60: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E1E64: 48AC75F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1E68 size=88
    let mut pc: u32 = 0x821E1E68;
    'dispatch: loop {
        match pc {
            0x821E1E68 => {
    //   block [0x821E1E68..0x821E1EC0)
	// 821E1E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1E6C: 48AC75A1  bl 0x82ca940c
	ctx.lr = 0x821E1E70;
	sub_82CA93D0(ctx, base);
	// 821E1E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1E78: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E1E7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E1E80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1E84: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E1E88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1E8C: 4E800421  bctrl
	ctx.lr = 0x821E1E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1E90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E1E94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E1E98: 419A001C  beq cr6, 0x821e1eb4
	if ctx.cr[6].eq {
	pc = 0x821E1EB4; continue 'dispatch;
	}
	// 821E1E9C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E1EA0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 821E1EA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1EA8: 48673579  bl 0x82855420
	ctx.lr = 0x821E1EAC;
	sub_82855420(ctx, base);
	// 821E1EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1EB0: 48AC75AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E1EB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E1EB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1EBC: 48AC75A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1EC0 size=28
    let mut pc: u32 = 0x821E1EC0;
    'dispatch: loop {
        match pc {
            0x821E1EC0 => {
    //   block [0x821E1EC0..0x821E1EDC)
	// 821E1EC0: 89640706  lbz r11, 0x706(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1798 as u32) ) } as u64;
	// 821E1EC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1EC8: 409A0014  bne cr6, 0x821e1edc
	if !ctx.cr[6].eq {
		sub_821E1EDC(ctx, base);
		return;
	}
	// 821E1ECC: 89640707  lbz r11, 0x707(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1799 as u32) ) } as u64;
	// 821E1ED0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E1ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1ED8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1EDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1EDC size=8
    let mut pc: u32 = 0x821E1EDC;
    'dispatch: loop {
        match pc {
            0x821E1EDC => {
    //   block [0x821E1EDC..0x821E1EE4)
	// 821E1EDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E1EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1EE8 size=60
    let mut pc: u32 = 0x821E1EE8;
    'dispatch: loop {
        match pc {
            0x821E1EE8 => {
    //   block [0x821E1EE8..0x821E1F24)
	// 821E1EE8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1EEC: 394B5034  addi r10, r11, 0x5034
	ctx.r[10].s64 = ctx.r[11].s64 + 20532;
	// 821E1EF0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1EF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1EF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1EFC: 419A003C  beq cr6, 0x821e1f38
	if ctx.cr[6].eq {
		sub_821E1F38(ctx, base);
		return;
	}
	// 821E1F00: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F04: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F08: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E1F0C: 419A0018  beq cr6, 0x821e1f24
	if ctx.cr[6].eq {
		sub_821E1F24(ctx, base);
		return;
	}
	// 821E1F10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1F14: 409A0008  bne cr6, 0x821e1f1c
	if !ctx.cr[6].eq {
	pc = 0x821E1F1C; continue 'dispatch;
	}
	// 821E1F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E1F1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F20: 4BFFFFD8  b 0x821e1ef8
	pc = 0x821E1EF8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1F24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1F24 size=20
    let mut pc: u32 = 0x821E1F24;
    'dispatch: loop {
        match pc {
            0x821E1F24 => {
    //   block [0x821E1F24..0x821E1F38)
	// 821E1F24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1F28: 409A0008  bne cr6, 0x821e1f30
	if !ctx.cr[6].eq {
	pc = 0x821E1F30; continue 'dispatch;
	}
	// 821E1F2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E1F30: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1F38 size=8
    let mut pc: u32 = 0x821E1F38;
    'dispatch: loop {
        match pc {
            0x821E1F38 => {
    //   block [0x821E1F38..0x821E1F40)
	// 821E1F38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E1F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1F40 size=404
    let mut pc: u32 = 0x821E1F40;
    'dispatch: loop {
        match pc {
            0x821E1F40 => {
    //   block [0x821E1F40..0x821E20D4)
	// 821E1F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1F44: 48AC74BD  bl 0x82ca9400
	ctx.lr = 0x821E1F48;
	sub_82CA93D0(ctx, base);
	// 821E1F48: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821E1F4C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1F50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E1F54: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E1F58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821E1F5C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821E1F60: 93C100CC  stw r30, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 821E1F64: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821E1F68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1F74: 4E800421  bctrl
	ctx.lr = 0x821E1F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1F78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E1F7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E1F80: 419A0144  beq cr6, 0x821e20c4
	if ctx.cr[6].eq {
	pc = 0x821E20C4; continue 'dispatch;
	}
	// 821E1F84: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 821E1F88: 409A0064  bne cr6, 0x821e1fec
	if !ctx.cr[6].eq {
	pc = 0x821E1FEC; continue 'dispatch;
	}
	// 821E1F8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1F90: 3BEBF850  addi r31, r11, -0x7b0
	ctx.r[31].s64 = ctx.r[11].s64 + -1968;
	// 821E1F94: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1F98: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1F9C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FA0: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821E1FA4: 40820020  bne 0x821e1fc4
	if !ctx.cr[0].eq {
	pc = 0x821E1FC4; continue 'dispatch;
	}
	// 821E1FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1FAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E1FB0: 488AD739  bl 0x82a8f6e8
	ctx.lr = 0x821E1FB4;
	sub_82A8F6E8(ctx, base);
	// 821E1FB4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1FB8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1FBC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FC0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821E1FC4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E1FC8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FCC: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821E1FD0: 5506003A  rlwinm r6, r8, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821E1FD4: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821E1FD8: 83C7FFFC  lwz r30, -4(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E1FDC: 419A000C  beq cr6, 0x821e1fe8
	if ctx.cr[6].eq {
	pc = 0x821E1FE8; continue 'dispatch;
	}
	// 821E1FE0: 396AFFFC  addi r11, r10, -4
	ctx.r[11].s64 = ctx.r[10].s64 + -4;
	// 821E1FE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821E1FE8: 93C100CC  stw r30, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 821E1FEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1FF0: 3BEBF7A8  addi r31, r11, -0x858
	ctx.r[31].s64 = ctx.r[11].s64 + -2136;
	// 821E1FF4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1FF8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1FFC: 7D694050  subf r11, r9, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821E2000: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821E2004: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E2008: 41980054  blt cr6, 0x821e205c
	if ctx.cr[6].lt {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E200C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E2010: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 821E2014: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821E2018: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E201C: 40990028  ble cr6, 0x821e2044
	if !ctx.cr[6].gt {
	pc = 0x821E2044; continue 'dispatch;
	}
	// 821E2020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2024: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821E2028: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E202C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 821E2030: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E2034: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E2038: 4886D8A1  bl 0x82a4f8d8
	ctx.lr = 0x821E203C;
	sub_82A4F8D8(ctx, base);
	// 821E203C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2040: 4800001C  b 0x821e205c
	pc = 0x821E205C; continue 'dispatch;
	// 821E2044: 40980018  bge cr6, 0x821e205c
	if !ctx.cr[6].lt {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E2048: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E204C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E2050: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E2054: 419A0008  beq cr6, 0x821e205c
	if ctx.cr[6].eq {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E2058: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E205C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E2060: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E2064: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E2068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E206C: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	// 821E2070: 93DD0010  stw r30, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821E2074: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2078: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E207C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E2080: 4E800421  bctrl
	ctx.lr = 0x821E2084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E2084: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2088: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E208C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E2090: 80E80038  lwz r7, 0x38(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2094: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821E2098: 4E800421  bctrl
	ctx.lr = 0x821E209C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E209C: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E20A0: 54C5077A  rlwinm r5, r6, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821E20A4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E20A8: 419A001C  beq cr6, 0x821e20c4
	if ctx.cr[6].eq {
	pc = 0x821E20C4; continue 'dispatch;
	}
	// 821E20AC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821E20B0: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E20B4: 394AF970  addi r10, r10, -0x690
	ctx.r[10].s64 = ctx.r[10].s64 + -1680;
	// 821E20B8: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 821E20BC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E20C0: 4817FAA9  bl 0x82361b68
	ctx.lr = 0x821E20C4;
	sub_82361B68(ctx, base);
	// 821E20C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E20C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E20CC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821E20D0: 48AC7380  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E20D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E20D8 size=100
    let mut pc: u32 = 0x821E20D8;
    'dispatch: loop {
        match pc {
            0x821E20D8 => {
    //   block [0x821E20D8..0x821E213C)
	// 821E20D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E20DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E20E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E20E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E20E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E20EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E20F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E20F4: 807E00B0  lwz r3, 0xb0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821E20F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E20FC: 419A0018  beq cr6, 0x821e2114
	if ctx.cr[6].eq {
	pc = 0x821E2114; continue 'dispatch;
	}
	// 821E2100: 4801D0C9  bl 0x821ff1c8
	ctx.lr = 0x821E2104;
	sub_821FF1C8(ctx, base);
	// 821E2104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2108: 809E00B0  lwz r4, 0xb0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821E210C: 4805126D  bl 0x82233378
	ctx.lr = 0x821E2110;
	sub_82233378(ctx, base);
	// 821E2110: 48000010  b 0x821e2120
	pc = 0x821E2120; continue 'dispatch;
	// 821E2114: 389E0150  addi r4, r30, 0x150
	ctx.r[4].s64 = ctx.r[30].s64 + 336;
	// 821E2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E211C: 48029375  bl 0x8220b490
	ctx.lr = 0x821E2120;
	sub_8220B490(ctx, base);
	// 821E2120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E2128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E212C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E2130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E2134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E2138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E2140 size=1548
    let mut pc: u32 = 0x821E2140;
    'dispatch: loop {
        match pc {
            0x821E2140 => {
    //   block [0x821E2140..0x821E274C)
	// 821E2140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2144: 48AC72B9  bl 0x82ca93fc
	ctx.lr = 0x821E2148;
	sub_82CA93D0(ctx, base);
	// 821E2148: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821E214C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821E2150: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2154: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E2158: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E215C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E2160: 419A05DC  beq cr6, 0x821e273c
	if ctx.cr[6].eq {
	pc = 0x821E273C; continue 'dispatch;
	}
	// 821E2164: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2168: 48025689  bl 0x822077f0
	ctx.lr = 0x821E216C;
	sub_822077F0(ctx, base);
	// 821E216C: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2170: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E2174: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E2178: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 821E217C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 821E2180: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E2184: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E2188: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821E218C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2190: 419A00E8  beq cr6, 0x821e2278
	if ctx.cr[6].eq {
	pc = 0x821E2278; continue 'dispatch;
	}
	// 821E2194: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E2198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E219C: 419A0020  beq cr6, 0x821e21bc
	if ctx.cr[6].eq {
	pc = 0x821E21BC; continue 'dispatch;
	}
	// 821E21A0: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821E21A4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E21A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E21AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E21B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E21B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E21B8: 480000C4  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
	// 821E21BC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E21C0: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E21C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E21C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E21CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E21D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E21D4: 40810054  ble 0x821e2228
	if !ctx.cr[0].gt {
	pc = 0x821E2228; continue 'dispatch;
	}
	// 821E21D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E21DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E21E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E21E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E21E8: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821E21EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E21F0: 41980008  blt cr6, 0x821e21f8
	if ctx.cr[6].lt {
	pc = 0x821E21F8; continue 'dispatch;
	}
	// 821E21F4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821E21F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E21FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2200: 419A0014  beq cr6, 0x821e2214
	if ctx.cr[6].eq {
	pc = 0x821E2214; continue 'dispatch;
	}
	// 821E2204: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2208: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E220C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2210: 4800000C  b 0x821e221c
	pc = 0x821E221C; continue 'dispatch;
	// 821E2214: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2218: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E221C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2220: 4199FFB8  bgt cr6, 0x821e21d8
	if ctx.cr[6].gt {
	pc = 0x821E21D8; continue 'dispatch;
	}
	// 821E2224: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E2228: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E222C: 419A003C  beq cr6, 0x821e2268
	if ctx.cr[6].eq {
	pc = 0x821E2268; continue 'dispatch;
	}
	// 821E2230: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2234: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821E2238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E223C: 41990008  bgt cr6, 0x821e2244
	if ctx.cr[6].gt {
	pc = 0x821E2244; continue 'dispatch;
	}
	// 821E2240: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E2244: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E224C: 409A001C  bne cr6, 0x821e2268
	if !ctx.cr[6].eq {
	pc = 0x821E2268; continue 'dispatch;
	}
	// 821E2250: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E2254: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2258: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E225C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2264: 48000018  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
	// 821E2268: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E226C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2270: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2274: 48000008  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
	// 821E2278: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821E227C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E2280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E2284: 419A0014  beq cr6, 0x821e2298
	if ctx.cr[6].eq {
	pc = 0x821E2298; continue 'dispatch;
	}
	// 821E2288: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 821E228C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E2290: 409A0120  bne cr6, 0x821e23b0
	if !ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	// 821E2294: 48000118  b 0x821e23ac
	pc = 0x821E23AC; continue 'dispatch;
	// 821E2298: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E229C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E22A0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821E22A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E22A8: 419A00E8  beq cr6, 0x821e2390
	if ctx.cr[6].eq {
	pc = 0x821E2390; continue 'dispatch;
	}
	// 821E22AC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E22B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E22B4: 419A0020  beq cr6, 0x821e22d4
	if ctx.cr[6].eq {
	pc = 0x821E22D4; continue 'dispatch;
	}
	// 821E22B8: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E22BC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E22C0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E22C4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E22C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E22CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E22D0: 480000C4  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
	// 821E22D4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E22D8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E22DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E22E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E22E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E22E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E22EC: 40810054  ble 0x821e2340
	if !ctx.cr[0].gt {
	pc = 0x821E2340; continue 'dispatch;
	}
	// 821E22F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E22F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E22F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E22FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2300: 2F070020  cmpwi cr6, r7, 0x20
	ctx.cr[6].compare_i32(ctx.r[7].s32, 32, &mut ctx.xer);
	// 821E2304: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2308: 41980008  blt cr6, 0x821e2310
	if ctx.cr[6].lt {
	pc = 0x821E2310; continue 'dispatch;
	}
	// 821E230C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821E2310: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E2314: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2318: 419A0014  beq cr6, 0x821e232c
	if ctx.cr[6].eq {
	pc = 0x821E232C; continue 'dispatch;
	}
	// 821E231C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2320: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E2324: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2328: 4800000C  b 0x821e2334
	pc = 0x821E2334; continue 'dispatch;
	// 821E232C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2330: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E2334: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2338: 4199FFB8  bgt cr6, 0x821e22f0
	if ctx.cr[6].gt {
	pc = 0x821E22F0; continue 'dispatch;
	}
	// 821E233C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E2340: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E2344: 419A003C  beq cr6, 0x821e2380
	if ctx.cr[6].eq {
	pc = 0x821E2380; continue 'dispatch;
	}
	// 821E2348: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E234C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821E2350: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2354: 41990008  bgt cr6, 0x821e235c
	if ctx.cr[6].gt {
	pc = 0x821E235C; continue 'dispatch;
	}
	// 821E2358: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E235C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2364: 409A001C  bne cr6, 0x821e2380
	if !ctx.cr[6].eq {
	pc = 0x821E2380; continue 'dispatch;
	}
	// 821E2368: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E236C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2370: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E2374: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E237C: 48000018  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
	// 821E2380: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E2384: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E238C: 48000008  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
	// 821E2390: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821E2394: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E2398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E239C: 419A0014  beq cr6, 0x821e23b0
	if ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	// 821E23A0: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E23A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E23A8: 419A0008  beq cr6, 0x821e23b0
	if ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	// 821E23AC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821E23B0: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E23B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E23B8: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 821E23BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E23C0: 419A00E8  beq cr6, 0x821e24a8
	if ctx.cr[6].eq {
	pc = 0x821E24A8; continue 'dispatch;
	}
	// 821E23C4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E23C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E23CC: 419A0020  beq cr6, 0x821e23ec
	if ctx.cr[6].eq {
	pc = 0x821E23EC; continue 'dispatch;
	}
	// 821E23D0: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 821E23D4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E23D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E23DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E23E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E23E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E23E8: 480000C4  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
	// 821E23EC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E23F0: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E23F4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E23F8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E23FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E2400: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2404: 40810054  ble 0x821e2458
	if !ctx.cr[0].gt {
	pc = 0x821E2458; continue 'dispatch;
	}
	// 821E2408: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E240C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2410: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821E2414: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2418: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 821E241C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2420: 41980008  blt cr6, 0x821e2428
	if ctx.cr[6].lt {
	pc = 0x821E2428; continue 'dispatch;
	}
	// 821E2424: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821E2428: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E242C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2430: 419A0014  beq cr6, 0x821e2444
	if ctx.cr[6].eq {
	pc = 0x821E2444; continue 'dispatch;
	}
	// 821E2434: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2438: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E243C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2440: 4800000C  b 0x821e244c
	pc = 0x821E244C; continue 'dispatch;
	// 821E2444: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2448: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E244C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2450: 4199FFB8  bgt cr6, 0x821e2408
	if ctx.cr[6].gt {
	pc = 0x821E2408; continue 'dispatch;
	}
	// 821E2454: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E2458: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E245C: 419A003C  beq cr6, 0x821e2498
	if ctx.cr[6].eq {
	pc = 0x821E2498; continue 'dispatch;
	}
	// 821E2460: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2464: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821E2468: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E246C: 41990008  bgt cr6, 0x821e2474
	if ctx.cr[6].gt {
	pc = 0x821E2474; continue 'dispatch;
	}
	// 821E2470: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E2474: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E247C: 409A001C  bne cr6, 0x821e2498
	if !ctx.cr[6].eq {
	pc = 0x821E2498; continue 'dispatch;
	}
	// 821E2480: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E2484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2488: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E248C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2490: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2494: 48000018  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
	// 821E2498: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E249C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E24A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E24A4: 48000008  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
	// 821E24A8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821E24AC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E24B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E24B4: 419A0028  beq cr6, 0x821e24dc
	if ctx.cr[6].eq {
	pc = 0x821E24DC; continue 'dispatch;
	}
	// 821E24B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E24BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E24C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E24C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E24C8: 4E800421  bctrl
	ctx.lr = 0x821E24CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E24CC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E24D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E24D4: 419A0008  beq cr6, 0x821e24dc
	if ctx.cr[6].eq {
	pc = 0x821E24DC; continue 'dispatch;
	}
	// 821E24D8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821E24DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E24E0: 573E063E  clrlwi r30, r25, 0x18
	ctx.r[30].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821E24E4: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 821E24E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E24EC: C3FDFFF4  lfs f31, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E24F0: 409A0058  bne cr6, 0x821e2548
	if !ctx.cr[6].eq {
	pc = 0x821E2548; continue 'dispatch;
	}
	// 821E24F4: 897B0030  lbz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E24F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E24FC: 419A0044  beq cr6, 0x821e2540
	if ctx.cr[6].eq {
	pc = 0x821E2540; continue 'dispatch;
	}
	// 821E2500: D3FB0018  stfs f31, 0x18(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821E2504: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2508: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821E250C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E2510: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2514: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E2518: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E251C: 4E800421  bctrl
	ctx.lr = 0x821E2520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E2520: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 821E2524: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821E2528: C01B000C  lfs f0, 0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E2750 size=36
    let mut pc: u32 = 0x821E2750;
    'dispatch: loop {
        match pc {
            0x821E2750 => {
    //   block [0x821E2750..0x821E2774)
	// 821E2750: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E2754: C1A30334  lfs f13, 0x334(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(820 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E2758: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E275C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2760: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E2764: 41990008  bgt cr6, 0x821e276c
	if ctx.cr[6].gt {
	pc = 0x821E276C; continue 'dispatch;
	}
	// 821E2768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E276C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2778 size=332
    let mut pc: u32 = 0x821E2778;
    'dispatch: loop {
        match pc {
            0x821E2778 => {
    //   block [0x821E2778..0x821E28C4)
	// 821E2778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E277C: 48AC6C89  bl 0x82ca9404
	ctx.lr = 0x821E2780;
	sub_82CA93D0(ctx, base);
	// 821E2780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2784: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E2788: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E278C: 83BC0038  lwz r29, 0x38(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2790: 897D0112  lbz r11, 0x112(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(274 as u32) ) } as u64;
	// 821E2794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2798: 409A0124  bne cr6, 0x821e28bc
	if !ctx.cr[6].eq {
	pc = 0x821E28BC; continue 'dispatch;
	}
	// 821E279C: 817B06FC  lwz r11, 0x6fc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E27A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E27A4: 419A005C  beq cr6, 0x821e2800
	if ctx.cr[6].eq {
	pc = 0x821E2800; continue 'dispatch;
	}
	// 821E27A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E27AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E27B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E27B4: 808B5030  lwz r4, 0x5030(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20528 as u32) ) } as u64;
	// 821E27B8: 4801DFB9  bl 0x82200770
	ctx.lr = 0x821E27BC;
	sub_82200770(ctx, base);
	// 821E27BC: 8BE10054  lbz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E27C0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E27C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E27C8: 419A0010  beq cr6, 0x821e27d8
	if ctx.cr[6].eq {
	pc = 0x821E27D8; continue 'dispatch;
	}
	// 821E27CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E27D0: 490D7185  bl 0x832b9954
	ctx.lr = 0x821E27D4;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821E27D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821E27D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E27DC: 4BFFF70D  bl 0x821e1ee8
	ctx.lr = 0x821E27E0;
	sub_821E1EE8(ctx, base);
	// 821E27E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E27E4: 419A0008  beq cr6, 0x821e27ec
	if ctx.cr[6].eq {
	pc = 0x821E27EC; continue 'dispatch;
	}
	// 821E27E8: 480BC8D1  bl 0x8229f0b8
	ctx.lr = 0x821E27EC;
	sub_8229F0B8(ctx, base);
	// 821E27EC: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E27F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E27F4: 419A000C  beq cr6, 0x821e2800
	if ctx.cr[6].eq {
	pc = 0x821E2800; continue 'dispatch;
	}
	// 821E27F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E27FC: 490D7159  bl 0x832b9954
	ctx.lr = 0x821E2800;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821E2800: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E2804: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E2808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E280C: 41980018  blt cr6, 0x821e2824
	if ctx.cr[6].lt {
	pc = 0x821E2824; continue 'dispatch;
	}
	// 821E2810: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E2814: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E2818: 810A0058  lwz r8, 0x58(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E281C: 7C88482E  lwzx r4, r8, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E2820: 4800000C  b 0x821e282c
	pc = 0x821E282C; continue 'dispatch;
	// 821E2824: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E2828: 808B5760  lwz r4, 0x5760(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22368 as u32) ) } as u64;
	// 821E282C: 817B06FC  lwz r11, 0x6fc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E2830: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2834: 419A002C  beq cr6, 0x821e2860
	if ctx.cr[6].eq {
	pc = 0x821E2860; continue 'dispatch;
	}
	// 821E2838: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E283C: 419A0010  beq cr6, 0x821e284c
	if ctx.cr[6].eq {
	pc = 0x821E284C; continue 'dispatch;
	}
	// 821E2840: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821E2844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E2848: 409A0008  bne cr6, 0x821e2850
	if !ctx.cr[6].eq {
	pc = 0x821E2850; continue 'dispatch;
	}
	// 821E284C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2850: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E285C: 419A0008  beq cr6, 0x821e2864
	if ctx.cr[6].eq {
	pc = 0x821E2864; continue 'dispatch;
	}
	// 821E2860: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E286C: 419A0018  beq cr6, 0x821e2884
	if ctx.cr[6].eq {
	pc = 0x821E2884; continue 'dispatch;
	}
	// 821E2870: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E2874: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E2878: 48097FE1  bl 0x8227a858
	ctx.lr = 0x821E287C;
	sub_8227A858(ctx, base);
	// 821E287C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E2880: 48AC6BD4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821E2884: 897B0701  lbz r11, 0x701(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1793 as u32) ) } as u64;
	// 821E2888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E288C: 419A0010  beq cr6, 0x821e289c
	if ctx.cr[6].eq {
	pc = 0x821E289C; continue 'dispatch;
	}
	// 821E2890: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E2894: 556BE7FE  rlwinm r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821E2898: 48000008  b 0x821e28a0
	pc = 0x821E28A0; continue 'dispatch;
	// 821E289C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E28A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E28A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E28A8: 419A0014  beq cr6, 0x821e28bc
	if ctx.cr[6].eq {
	pc = 0x821E28BC; continue 'dispatch;
	}
	// 821E28AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E28B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E28B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E28B8: 4BFFEC39  bl 0x821e14f0
	ctx.lr = 0x821E28BC;
	sub_821E14F0(ctx, base);
	// 821E28BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E28C0: 48AC6B94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E28C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E28C8 size=636
    let mut pc: u32 = 0x821E28C8;
    'dispatch: loop {
        match pc {
            0x821E28C8 => {
    //   block [0x821E28C8..0x821E2B44)
	// 821E28C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E28CC: 48AC6B41  bl 0x82ca940c
	ctx.lr = 0x821E28D0;
	sub_82CA93D0(ctx, base);
	// 821E28D0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E28D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E28D8: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821E28DC: 389E0200  addi r4, r30, 0x200
	ctx.r[4].s64 = ctx.r[30].s64 + 512;
	// 821E28E0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821E28E4: 480382AD  bl 0x8221ab90
	ctx.lr = 0x821E28E8;
	sub_8221AB90(ctx, base);
	// 821E28E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E28EC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821E28F0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E28F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E28F8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E28FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E2900: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E2904: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E2908: 4200FFF0  bdnz 0x821e28f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E28F8; continue 'dispatch;
	}
	// 821E290C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E2910: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 821E2914: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E2918: 409A016C  bne cr6, 0x821e2a84
	if !ctx.cr[6].eq {
	pc = 0x821E2A84; continue 'dispatch;
	}
	// 821E291C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E2920: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E2924: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821E2928: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E292C: EBAB1758  ld r29, 0x1758(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5976 as u32) ) };
	// 821E2930: 409A00AC  bne cr6, 0x821e29dc
	if !ctx.cr[6].eq {
	pc = 0x821E29DC; continue 'dispatch;
	}
	// 821E2934: 798CB7E6  rldicr r12, r12, 0x36, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 821E2938: 7FAA6038  and r10, r29, r12
	ctx.r[10].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	// 821E293C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821E2940: 419A0020  beq cr6, 0x821e2960
	if ctx.cr[6].eq {
	pc = 0x821E2960; continue 'dispatch;
	}
	// 821E2944: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2948: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E294C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821E2950: 78E7B7E6  rldicr r7, r7, 0x36, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 821E2954: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E2958: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 821E295C: 480324D5  bl 0x82214e30
	ctx.lr = 0x821E2960;
	sub_82214E30(ctx, base);
	// 821E2960: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E2964: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 821E2968: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E296C: 798CE7E6  rldicr r12, r12, 0x3c, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(60) & 0xFFFFFFFFFFFFFFFF;
	// 821E2970: 7FA96038  and r9, r29, r12
	ctx.r[9].u64 = ctx.r[29].u64 & ctx.r[12].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2B48 size=188
    let mut pc: u32 = 0x821E2B48;
    'dispatch: loop {
        match pc {
            0x821E2B48 => {
    //   block [0x821E2B48..0x821E2C04)
	// 821E2B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2B4C: 48AC68B9  bl 0x82ca9404
	ctx.lr = 0x821E2B50;
	sub_82CA93D0(ctx, base);
	// 821E2B50: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821E2B54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2B58: 396100D4  addi r11, r1, 0xd4
	ctx.r[11].s64 = ctx.r[1].s64 + 212;
	// 821E2B5C: 90E100D4  stw r7, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[7].u32 ) };
	// 821E2B60: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821E2B64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E2B68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E2B6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E2B70: 394A1390  addi r10, r10, 0x1390
	ctx.r[10].s64 = ctx.r[10].s64 + 5008;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2C08 size=984
    let mut pc: u32 = 0x821E2C08;
    'dispatch: loop {
        match pc {
            0x821E2C08 => {
    //   block [0x821E2C08..0x821E2FE0)
	// 821E2C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2C0C: 48AC6801  bl 0x82ca940c
	ctx.lr = 0x821E2C10;
	sub_82CA93D0(ctx, base);
	// 821E2C10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2C14: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E2C18: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821E2C1C: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821E2C20: 38C97E70  addi r6, r9, 0x7e70
	ctx.r[6].s64 = ctx.r[9].s64 + 32368;
	// 821E2C24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2C28: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E2C2C: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821E2C30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E2C34: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2C38: 386A2008  addi r3, r10, 0x2008
	ctx.r[3].s64 = ctx.r[10].s64 + 8200;
	// 821E2C3C: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821E2C40: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2C44: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821E2C48: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821E2C4C: 38890DB8  addi r4, r9, 0xdb8
	ctx.r[4].s64 = ctx.r[9].s64 + 3512;
	// 821E2C50: 7CC7512E  stwx r6, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821E2C54: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2C58: 80EA2000  lwz r7, 0x2000(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2C5C: 812A400C  lwz r9, 0x400c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E2C60: 553F1838  slwi r31, r9, 3
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821E2C64: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821E2C68: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2C6C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821E2C70: 910A2000  stw r8, 0x2000(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8192 as u32), ctx.r[8].u32 ) };
	// 821E2C74: 7CDF192E  stwx r6, r31, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	// 821E2C78: 886B1A6D  lbz r3, 0x1a6d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821E2C7C: 80EA4008  lwz r7, 0x4008(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821E2C80: 80CB1A5C  lwz r6, 0x1a5c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821E2C84: 810A400C  lwz r8, 0x400c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E2C88: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821E2C8C: 1D032008  mulli r8, r3, 0x2008
	ctx.r[8].s64 = ctx.r[3].s64 * 8200;
	// 821E2C90: 912A400C  stw r9, 0x400c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 821E2C94: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E2C98: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2C9C: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2CA0: 910A4008  stw r8, 0x4008(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 821E2CA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E2CA8: 419A0088  beq cr6, 0x821e2d30
	if ctx.cr[6].eq {
	pc = 0x821E2D30; continue 'dispatch;
	}
	// 821E2CAC: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2CB0: 80EB1A60  lwz r7, 0x1a60(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821E2CB4: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2CB8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E2CBC: 409A003C  bne cr6, 0x821e2cf8
	if !ctx.cr[6].eq {
	pc = 0x821E2CF8; continue 'dispatch;
	}
	// 821E2CC0: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CC4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2CC8: 386B1A58  addi r3, r11, 0x1a58
	ctx.r[3].s64 = ctx.r[11].s64 + 6744;
	// 821E2CCC: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2CD0: 910B1A60  stw r8, 0x1a60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6752 as u32), ctx.r[8].u32 ) };
	// 821E2CD4: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 821E2CD8: 810B1A5C  lwz r8, 0x1a5c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821E2CDC: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CE0: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2CE4: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2CE8: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2CEC: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CF0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821E2CF4: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821E2CF8: 892B1A6C  lbz r9, 0x1a6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821E2CFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E2D00: 910B1A5C  stw r8, 0x1a5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6748 as u32), ctx.r[8].u32 ) };
	// 821E2D04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2D08: 409A0028  bne cr6, 0x821e2d30
	if !ctx.cr[6].eq {
	pc = 0x821E2D30; continue 'dispatch;
	}
	// 821E2D0C: 81250DB0  lwz r9, 0xdb0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821E2D10: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2D14: 38EB1A58  addi r7, r11, 0x1a58
	ctx.r[7].s64 = ctx.r[11].s64 + 6744;
	// 821E2D18: 5523103A  slwi r3, r9, 2
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2D1C: 990B1A6C  stb r8, 0x1a6c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6764 as u32), ctx.r[8].u8 ) };
	// 821E2D20: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E2D24: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2D28: 7CE3212E  stwx r7, r3, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821E2D2C: 48000008  b 0x821e2d34
	pc = 0x821E2D34; continue 'dispatch;
	// 821E2D30: 80C50DB0  lwz r6, 0xdb0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821E2D34: 892B1A85  lbz r9, 0x1a85(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821E2D38: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821E2D3C: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s64 = ctx.r[9].s64 * 8200;
	// 821E2D40: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2D44: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821E2D48: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2D4C: 419A0080  beq cr6, 0x821e2dcc
	if ctx.cr[6].eq {
	pc = 0x821E2DCC; continue 'dispatch;
	}
	// 821E2D50: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2D54: 80EB1A78  lwz r7, 0x1a78(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821E2D58: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2D60: 409A003C  bne cr6, 0x821e2d9c
	if !ctx.cr[6].eq {
	pc = 0x821E2D9C; continue 'dispatch;
	}
	// 821E2D64: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D68: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2D6C: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821E2D70: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2D74: 910B1A78  stw r8, 0x1a78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6776 as u32), ctx.r[8].u32 ) };
	// 821E2D78: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E2D7C: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821E2D80: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D84: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2D88: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2D8C: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2D90: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D94: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821E2D98: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821E2D9C: 892B1A84  lbz r9, 0x1a84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821E2DA0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2DA4: 910B1A74  stw r8, 0x1a74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6772 as u32), ctx.r[8].u32 ) };
	// 821E2DA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2DAC: 409A0020  bne cr6, 0x821e2dcc
	if !ctx.cr[6].eq {
	pc = 0x821E2DCC; continue 'dispatch;
	}
	// 821E2DB0: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2DB4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E2DB8: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821E2DBC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821E2DC0: 992B1A84  stb r9, 0x1a84(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6788 as u32), ctx.r[9].u8 ) };
	// 821E2DC4: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2DC8: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821E2DCC: 892B1AB5  lbz r9, 0x1ab5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821E2DD0: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821E2DD4: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s64 = ctx.r[9].s64 * 8200;
	// 821E2DD8: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2DDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E2DE0: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2DE4: 419A0080  beq cr6, 0x821e2e64
	if ctx.cr[6].eq {
	pc = 0x821E2E64; continue 'dispatch;
	}
	// 821E2DE8: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2DEC: 80EB1AA8  lwz r7, 0x1aa8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821E2DF0: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2DF8: 409A003C  bne cr6, 0x821e2e34
	if !ctx.cr[6].eq {
	pc = 0x821E2E34; continue 'dispatch;
	}
	// 821E2DFC: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E00: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2E04: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821E2E08: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2E0C: 910B1AA8  stw r8, 0x1aa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6824 as u32), ctx.r[8].u32 ) };
	// 821E2E10: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E2E14: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E18: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2E1C: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2E20: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821E2E24: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2E28: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E2C: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 821E2E30: 90692004  stw r3, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821E2E34: 892B1AB4  lbz r9, 0x1ab4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821E2E38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E2E3C: 910B1AA4  stw r8, 0x1aa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6820 as u32), ctx.r[8].u32 ) };
	// 821E2E40: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2E44: 409A0020  bne cr6, 0x821e2e64
	if !ctx.cr[6].eq {
	pc = 0x821E2E64; continue 'dispatch;
	}
	// 821E2E48: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2E4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E2E50: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821E2E54: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821E2E58: 992B1AB4  stb r9, 0x1ab4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6836 as u32), ctx.r[9].u8 ) };
	// 821E2E5C: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2E60: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821E2E64: 3CE08331  lis r7, -0x7ccf
	ctx.r[7].s64 = -2093940736;
	// 821E2E68: 886B1A9D  lbz r3, 0x1a9d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821E2E6C: 810B1A8C  lwz r8, 0x1a8c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821E2E70: 38E76FB8  addi r7, r7, 0x6fb8
	ctx.r[7].s64 = ctx.r[7].s64 + 28600;
	// 821E2E74: 1D232008  mulli r9, r3, 0x2008
	ctx.r[9].s64 = ctx.r[3].s64 * 8200;
	// 821E2E78: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2E7C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2E80: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E2E84: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821E2E88: 419A007C  beq cr6, 0x821e2f04
	if ctx.cr[6].eq {
	pc = 0x821E2F04; continue 'dispatch;
	}
	// 821E2E8C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2E90: 810B1A90  lwz r8, 0x1a90(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821E2E94: 7D234038  and r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821E2E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2E9C: 409A003C  bne cr6, 0x821e2ed8
	if !ctx.cr[6].eq {
	pc = 0x821E2ED8; continue 'dispatch;
	}
	// 821E2EA0: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2EA4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821E2EA8: 390B1A88  addi r8, r11, 0x1a88
	ctx.r[8].s64 = ctx.r[11].s64 + 6792;
	// 821E2EAC: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2EB0: 912B1A90  stw r9, 0x1a90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821E2EB4: 7D03512E  stwx r8, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821E2EB8: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2EBC: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2EC0: 812B1A8C  lwz r9, 0x1a8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821E2EC4: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E2EC8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E2ECC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2ED0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E2ED4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821E2ED8: 894B1A9C  lbz r10, 0x1a9c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821E2EDC: 90EB1A8C  stw r7, 0x1a8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821E2EE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E2EE4: 409A0020  bne cr6, 0x821e2f04
	if !ctx.cr[6].eq {
	pc = 0x821E2F04; continue 'dispatch;
	}
	// 821E2EE8: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2EEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2EF0: 38EB1A88  addi r7, r11, 0x1a88
	ctx.r[7].s64 = ctx.r[11].s64 + 6792;
	// 821E2EF4: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821E2EF8: 994B1A9C  stb r10, 0x1a9c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6812 as u32), ctx.r[10].u8 ) };
	// 821E2EFC: 91250DB0  stw r9, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821E2F00: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821E2F04: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821E2F08: 83FE0364  lwz r31, 0x364(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E2F0C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2F10: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E2F14: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E2F18: 4099000C  ble cr6, 0x821e2f24
	if !ctx.cr[6].gt {
	pc = 0x821E2F24; continue 'dispatch;
	}
	// 821E2F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2F20: 48005FA1  bl 0x821e8ec0
	ctx.lr = 0x821E2F24;
	sub_821E8EC0(ctx, base);
	// 821E2F24: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821E2F28: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821E2F2C: 61694600  ori r9, r11, 0x4600
	ctx.r[9].u64 = ctx.r[11].u64 | 17920;
	// 821E2F30: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821E2F34: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821E2F38: 891F2ABD  lbz r8, 0x2abd(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E2F3C: 5507063E  clrlwi r7, r8, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 821E2F40: 54E707B8  rlwinm r7, r7, 0, 0x1e, 0x1c
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E2F44: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821E2F48: 98FF2ABD  stb r7, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[7].u8 ) };
	// 821E2F4C: 4803B555  bl 0x8221e4a0
	ctx.lr = 0x821E2F50;
	sub_8221E4A0(ctx, base);
	// 821E2F50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E2F54: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E2F58: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E2F5C: 38EA1390  addi r7, r10, 0x1390
	ctx.r[7].s64 = ctx.r[10].s64 + 5008;
	// 821E2F60: 38A91350  addi r5, r9, 0x1350
	ctx.r[5].s64 = ctx.r[9].s64 + 4944;
	// 821E2F64: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E2F68: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 821E2F6C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2FE0 size=296
    let mut pc: u32 = 0x821E2FE0;
    'dispatch: loop {
        match pc {
            0x821E2FE0 => {
    //   block [0x821E2FE0..0x821E3108)
	// 821E2FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E2FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E2FEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2FF0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E2FF4: 409A00FC  bne cr6, 0x821e30f0
	if !ctx.cr[6].eq {
	pc = 0x821E30F0; continue 'dispatch;
	}
	// 821E2FF8: 80E33098  lwz r7, 0x3098(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12440 as u32) ) } as u64;
	// 821E2FFC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821E3000: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E3004: 40820008  bne 0x821e300c
	if !ctx.cr[0].eq {
	pc = 0x821E300C; continue 'dispatch;
	}
	// 821E3008: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	// 821E300C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E3010: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E3014: 89632ABC  lbz r11, 0x2abc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E3018: 552A74BE  srwi r10, r9, 0x12
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(18);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E301C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821E3020: 5529EC7E  rlwinm r9, r9, 0x1d, 0x11, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821E3024: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821E3028: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E302C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E3030: 557F06F7  rlwinm. r31, r11, 0, 0x1b, 0x1b
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821E3034: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821E3038: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821E303C: 4182000C  beq 0x821e3048
	if ctx.cr[0].eq {
	pc = 0x821E3048; continue 'dispatch;
	}
	// 821E3040: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3044: 48000090  b 0x821e30d4
	pc = 0x821E30D4; continue 'dispatch;
	// 821E3048: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E304C: 41820080  beq 0x821e30cc
	if ctx.cr[0].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E3050: 816331B8  lwz r11, 0x31b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12728 as u32) ) } as u64;
	// 821E3054: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E3058: 419A000C  beq cr6, 0x821e3064
	if ctx.cr[6].eq {
	pc = 0x821E3064; continue 'dispatch;
	}
	// 821E305C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3060: 409A006C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E3064: 8163309C  lwz r11, 0x309c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12444 as u32) ) } as u64;
	// 821E3068: 814331BC  lwz r10, 0x31bc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12732 as u32) ) } as u64;
	// 821E306C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E3070: 419A000C  beq cr6, 0x821e307c
	if ctx.cr[6].eq {
	pc = 0x821E307C; continue 'dispatch;
	}
	// 821E3074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3078: 409A0054  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E307C: 816330A0  lwz r11, 0x30a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12448 as u32) ) } as u64;
	// 821E3080: 814331C0  lwz r10, 0x31c0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12736 as u32) ) } as u64;
	// 821E3084: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E3088: 419A000C  beq cr6, 0x821e3094
	if ctx.cr[6].eq {
	pc = 0x821E3094; continue 'dispatch;
	}
	// 821E308C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3090: 409A003C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E3094: 816330A4  lwz r11, 0x30a4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12452 as u32) ) } as u64;
	// 821E3098: 814331C4  lwz r10, 0x31c4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12740 as u32) ) } as u64;
	// 821E309C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E30A0: 419A000C  beq cr6, 0x821e30ac
	if ctx.cr[6].eq {
	pc = 0x821E30AC; continue 'dispatch;
	}
	// 821E30A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E30A8: 409A0024  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E30AC: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	// 821E30B0: 814331C8  lwz r10, 0x31c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12744 as u32) ) } as u64;
	// 821E30B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E30B8: 419A000C  beq cr6, 0x821e30c4
	if ctx.cr[6].eq {
	pc = 0x821E30C4; continue 'dispatch;
	}
	// 821E30BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E30C0: 409A000C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E30C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E30C8: 48000008  b 0x821e30d0
	pc = 0x821E30D0; continue 'dispatch;
	// 821E30CC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821E30D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E30D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E30D8: 41820014  beq 0x821e30ec
	if ctx.cr[0].eq {
	pc = 0x821E30EC; continue 'dispatch;
	}
	// 821E30DC: 8163337C  lwz r11, 0x337c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(13180 as u32) ) } as u64;
	// 821E30E0: 81433380  lwz r10, 0x3380(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(13184 as u32) ) } as u64;
	// 821E30E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821E30E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E30EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E30F0: 48048801  bl 0x8222b8f0
	ctx.lr = 0x821E30F4;
	sub_8222B8F0(ctx, base);
	// 821E30F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E30F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E30FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3108 size=120
    let mut pc: u32 = 0x821E3108;
    'dispatch: loop {
        match pc {
            0x821E3108 => {
    //   block [0x821E3108..0x821E3180)
	// 821E3108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E310C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E3110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E3114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E3118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E311C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3120: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E3124: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E3128: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E312C: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821E3130: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821E3134: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E3138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E313C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E3140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E3144: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3148: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E314C: 4082FFE8  bne 0x821e3134
	if !ctx.cr[0].eq {
	pc = 0x821E3134; continue 'dispatch;
	}
	// 821E3150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3154: 4808204D  bl 0x822651a0
	ctx.lr = 0x821E3158;
	sub_822651A0(ctx, base);
	// 821E3158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E315C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3160: 48009699  bl 0x821ec7f8
	ctx.lr = 0x821E3164;
	sub_821EC7F8(ctx, base);
	// 821E3164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3168: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E316C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3174: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E3178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E317C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3180 size=812
    let mut pc: u32 = 0x821E3180;
    'dispatch: loop {
        match pc {
            0x821E3180 => {
    //   block [0x821E3180..0x821E34AC)
	// 821E3180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3184: 48AC6261  bl 0x82ca93e4
	ctx.lr = 0x821E3188;
	sub_82CA93D0(ctx, base);
	// 821E3188: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 821E318C: 48ACAB4D  bl 0x82cadcd8
	ctx.lr = 0x821E3190;
	sub_82CADCA0(ctx, base);
	// 821E3190: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3194: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3198: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E319C: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 821E31A0: 396BF1C8  addi r11, r11, -0xe38
	ctx.r[11].s64 = ctx.r[11].s64 + -3640;
	// 821E31A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821E31A8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E31AC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821E31B0: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 821E31B4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821E31B8: C8166F08  lfd f0, 0x6f08(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(28424 as u32) ) };
	// 821E31BC: C3EBA2BC  lfs f31, -0x5d44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E31C0: C9A80D38  lfd f13, 0xd38(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3384 as u32) ) };
	// 821E31C4: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 821E31C8: 828A0008  lwz r20, 8(r10)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E31CC: CB876E18  lfd f28, 0x6e18(r7)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(28184 as u32) ) };
	// 821E31D0: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 821E31D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821E31D8: 3BA9AC70  addi r29, r9, -0x5390
	ctx.r[29].s64 = ctx.r[9].s64 + -21392;
	// 821E31DC: 419A00A4  beq cr6, 0x821e3280
	if ctx.cr[6].eq {
	pc = 0x821E3280; continue 'dispatch;
	}
	// 821E31E0: FD7C0028  fsub f11, f28, f0
	ctx.f[11].f64 = ctx.f[28].f64 - ctx.f[0].f64;
	// 821E31E4: C1BD0024  lfs f13, 0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E31E8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821E31EC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E31F0: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 821E31F4: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 821E31F8: C0097E84  lfs f0, 0x7e84(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E31FC: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E3200: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821E3204: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 821E3208: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E320C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821E3210: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821E3214: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821E3218: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821E321C: FCE8FA6E  fsel f7, f8, f9, f31
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[31].f64 };
	// 821E3220: ECC70028  fsubs f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E3224: FF06F800  fcmpu cr6, f6, f31
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[31].f64);
	// 821E3228: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E322C: 546BDF7A  rlwinm r11, r3, 0x1b, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821E3230: 546AF77A  rlwinm r10, r3, 0x1e, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821E3234: 7D695378  or r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 821E3238: 7CA84C2E  lfsx f5, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821E323C: FFC5382E  fsel f30, f5, f0, f7
	ctx.f[30].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 821E3240: EC3E0332  fmuls f1, f30, f12
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 821E3244: 480B27C5  bl 0x82295a08
	ctx.lr = 0x821E3248;
	sub_82295A08(ctx, base);
	// 821E3248: FC800818  frsp f4, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E324C: FC60201E  fctiwz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 821E3250: D8610050  stfd f3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[3].u64 ) };
	// 821E3254: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E3258: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 821E325C: 7D68FE70  srawi r8, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821E3260: 7D075838  and r7, r8, r11
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[11].u64;
	// 821E3264: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 821E3268: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 821E326C: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821E3270: C8410050  lfd f2, 0x50(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E3274: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 821E3278: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E327C: EFBE0024  fdivs f29, f30, f0
	ctx.f[29].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 821E3280: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821E3284: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E3288: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 821E328C: 40990180  ble cr6, 0x821e340c
	if !ctx.cr[6].gt {
	pc = 0x821E340C; continue 'dispatch;
	}
	// 821E3290: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E3294: 3AEB5058  addi r23, r11, 0x5058
	ctx.r[23].s64 = ctx.r[11].s64 + 20568;
	// 821E3298: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E329C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 821E32A0: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E32A4: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821E32A8: 419A0164  beq cr6, 0x821e340c
	if ctx.cr[6].eq {
	pc = 0x821E340C; continue 'dispatch;
	}
	// 821E32AC: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E32B0: 409A0008  bne cr6, 0x821e32b8
	if !ctx.cr[6].eq {
	pc = 0x821E32B8; continue 'dispatch;
	}
	// 821E32B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E32B8: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E32BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E32C0: 9B3F0112  stb r25, 0x112(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(274 as u32), ctx.r[25].u8 ) };
	// 821E32C4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E32C8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E32CC: 7F09A000  cmpw cr6, r9, r20
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[20].s32, &mut ctx.xer);
	// 821E32D0: 409A0124  bne cr6, 0x821e33f4
	if !ctx.cr[6].eq {
	pc = 0x821E33F4; continue 'dispatch;
	}
	// 821E32D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E32D8: 4BFFEC11  bl 0x821e1ee8
	ctx.lr = 0x821E32DC;
	sub_821E1EE8(ctx, base);
	// 821E32DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E32E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E32E4: 419A0110  beq cr6, 0x821e33f4
	if ctx.cr[6].eq {
	pc = 0x821E33F4; continue 'dispatch;
	}
	// 821E32E8: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E32EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E32F0: 409A0010  bne cr6, 0x821e3300
	if !ctx.cr[6].eq {
	pc = 0x821E3300; continue 'dispatch;
	}
	// 821E32F4: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 821E32F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E32FC: 419A001C  beq cr6, 0x821e3318
	if ctx.cr[6].eq {
	pc = 0x821E3318; continue 'dispatch;
	}
	// 821E3300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3304: 4BFFEBE5  bl 0x821e1ee8
	ctx.lr = 0x821E3308;
	sub_821E1EE8(ctx, base);
	// 821E3308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E330C: 419A0008  beq cr6, 0x821e3314
	if ctx.cr[6].eq {
	pc = 0x821E3314; continue 'dispatch;
	}
	// 821E3310: 488B0F99  bl 0x82a942a8
	ctx.lr = 0x821E3314;
	sub_82A942A8(ctx, base);
	// 821E3314: 9B3F0110  stb r25, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[25].u8 ) };
	// 821E3318: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 821E331C: C81B02E8  lfd f0, 0x2e8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(744 as u32) ) };
	// 821E3320: 395F0090  addi r10, r31, 0x90
	ctx.r[10].s64 = ctx.r[31].s64 + 144;
	// 821E3324: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E3328: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E332C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3330: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E3334: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E3338: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E333C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3340: 4200FFF0  bdnz 0x821e3330
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E3330; continue 'dispatch;
	}
	// 821E3344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3348: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E334C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821E3350: 4BFFED89  bl 0x821e20d8
	ctx.lr = 0x821E3354;
	sub_821E20D8(ctx, base);
	// 821E3354: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E3358: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821E335C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E3360: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3364: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E3368: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E336C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E3370: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3374: 4200FFF0  bdnz 0x821e3364
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E3364; continue 'dispatch;
	}
	// 821E3378: E97C0190  ld r11, 0x190(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(400 as u32) ) };
	// 821E337C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E3380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3384: 395C0190  addi r10, r28, 0x190
	ctx.r[10].s64 = ctx.r[28].s64 + 400;
	// 821E3388: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
	// 821E338C: F97F0060  std r11, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E3390: E91C0198  ld r8, 0x198(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(408 as u32) ) };
	// 821E3394: F91F0068  std r8, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821E3398: E8FC01A0  ld r7, 0x1a0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(416 as u32) ) };
	// 821E339C: F8FF0070  std r7, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[7].u64 ) };
	// 821E33A0: E8DC01A8  ld r6, 0x1a8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(424 as u32) ) };
	// 821E33A4: F8DF0078  std r6, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[6].u64 ) };
	// 821E33A8: E8BC01B0  ld r5, 0x1b0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) };
	// 821E33AC: F8BF0080  std r5, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 821E33B0: E97C01B8  ld r11, 0x1b8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) };
	// 821E33B4: F97F0088  std r11, 0x88(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 821E33B8: 480000F9  bl 0x821e34b0
	ctx.lr = 0x821E33BC;
	sub_821E34B0(ctx, base);
	// 821E33BC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E33C0: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821E33C4: 4099002C  ble cr6, 0x821e33f0
	if !ctx.cr[6].gt {
	pc = 0x821E33F0; continue 'dispatch;
	}
	// 821E33C8: 9A7F0111  stb r19, 0x111(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(273 as u32), ctx.r[19].u8 ) };
	// 821E33CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E33D0: 4BFEEC09  bl 0x821d1fd8
	ctx.lr = 0x821E33D4;
	sub_821D1FD8(ctx, base);
	// 821E33D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E33D8: C87B02E8  lfd f3, 0x2e8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(744 as u32) ) };
	// 821E33DC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 821E33E0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E33E4: 4BFC8B0D  bl 0x821abef0
	ctx.lr = 0x821E33E8;
	sub_821ABEF0(ctx, base);
	// 821E33E8: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 821E33EC: 48000008  b 0x821e33f4
	pc = 0x821E33F4; continue 'dispatch;
	// 821E33F0: 9B3F0111  stb r25, 0x111(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(273 as u32), ctx.r[25].u8 ) };
	// 821E33F4: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E33F8: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E33FC: 409A0008  bne cr6, 0x821e3404
	if !ctx.cr[6].eq {
	pc = 0x821E3404; continue 'dispatch;
	}
	// 821E3400: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E3404: 835A0000  lwz r26, 0(r26)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3408: 4BFFFE9C  b 0x821e32a4
	pc = 0x821E32A4; continue 'dispatch;
	// 821E340C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821E3410: DB966F08  stfd f28, 0x6f08(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(28424 as u32), ctx.f[28].u64 ) };
	// 821E3414: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821E3418: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821E341C: 997D0001  stb r11, 1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 821E3420: 5708063E  clrlwi r8, r24, 0x18
	ctx.r[8].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 821E3424: 995D0003  stb r10, 3(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 821E3428: 993D0002  stb r9, 2(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 821E342C: 997D0005  stb r11, 5(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 821E3430: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3434: 995D0006  stb r10, 6(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u8 ) };
	// 821E3438: 993D0007  stb r9, 7(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(7 as u32), ctx.r[9].u8 ) };
	// 821E343C: 997D0008  stb r11, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 821E3440: 995D0000  stb r10, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821E3444: 419A0058  beq cr6, 0x821e349c
	if ctx.cr[6].eq {
	pc = 0x821E349C; continue 'dispatch;
	}
	// 821E3448: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E344C: 83CB5030  lwz r30, 0x5030(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20528 as u32) ) } as u64;
	// 821E3450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3454: 490D6511  bl 0x832b9964
	ctx.lr = 0x821E3458;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821E3458: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821E345C: 895F6F04  lbz r10, 0x6f04(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28420 as u32) ) } as u64;
	// 821E3460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E3464: 409A0030  bne cr6, 0x821e3494
	if !ctx.cr[6].eq {
	pc = 0x821E3494; continue 'dispatch;
	}
	// 821E3468: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E346C: 806B6F14  lwz r3, 0x6f14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28436 as u32) ) } as u64;
	// 821E3470: 4BFAA7A9  bl 0x8218dc18
	ctx.lr = 0x821E3474;
	sub_8218DC18(ctx, base);
	// 821E3474: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E3478: 806A6F10  lwz r3, 0x6f10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28432 as u32) ) } as u64;
	// 821E347C: 480E5F0D  bl 0x822c9388
	ctx.lr = 0x821E3480;
	sub_822C9388(ctx, base);
	// 821E3480: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821E3484: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821E3488: 997F6F04  stb r11, 0x6f04(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28420 as u32), ctx.r[11].u8 ) };
	// 821E348C: 38695040  addi r3, r9, 0x5040
	ctx.r[3].s64 = ctx.r[9].s64 + 20544;
	// 821E3490: 48831901  bl 0x82a14d90
	ctx.lr = 0x821E3494;
	sub_82A14D90(ctx, base);
	// 821E3494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3498: 490D64BD  bl 0x832b9954
	ctx.lr = 0x821E349C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821E349C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821E34A0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 821E34A4: 48ACA881  bl 0x82cadd24
	ctx.lr = 0x821E34A8;
	sub_82CADCEC(ctx, base);
	// 821E34A8: 48AC5F8C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E34B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E34B0 size=296
    let mut pc: u32 = 0x821E34B0;
    'dispatch: loop {
        match pc {
            0x821E34B0 => {
    //   block [0x821E34B0..0x821E35D8)
	// 821E34B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E34B4: 48AC5F55  bl 0x82ca9408
	ctx.lr = 0x821E34B8;
	sub_82CA93D0(ctx, base);
	// 821E34B8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E34BC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E34C0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E34C4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E35D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E35D8 size=348
    let mut pc: u32 = 0x821E35D8;
    'dispatch: loop {
        match pc {
            0x821E35D8 => {
    //   block [0x821E35D8..0x821E3734)
	// 821E35D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E35DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E35E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E35E4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821E35E8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E35EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E35F0: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E35F4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821E35F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E35FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E3600: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E3604: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821E3608: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E360C: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E3610: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E3614: 7D092850  subf r8, r9, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 821E3618: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821E361C: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3620: 4081005C  ble 0x821e367c
	if !ctx.cr[0].gt {
	pc = 0x821E367C; continue 'dispatch;
	}
	// 821E3624: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E3628: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E362C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821E3630: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E3634: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E3638: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E363C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821E3640: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E3644: 41980008  blt cr6, 0x821e364c
	if ctx.cr[6].lt {
	pc = 0x821E364C; continue 'dispatch;
	}
	// 821E3648: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E364C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E3650: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3654: 419A0014  beq cr6, 0x821e3668
	if ctx.cr[6].eq {
	pc = 0x821E3668; continue 'dispatch;
	}
	// 821E3658: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E365C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821E3660: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3664: 4800000C  b 0x821e3670
	pc = 0x821E3670; continue 'dispatch;
	// 821E3668: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821E366C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E3670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3674: 4199FFB0  bgt cr6, 0x821e3624
	if ctx.cr[6].gt {
	pc = 0x821E3624; continue 'dispatch;
	}
	// 821E3678: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821E367C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821E3680: 419A0034  beq cr6, 0x821e36b4
	if ctx.cr[6].eq {
	pc = 0x821E36B4; continue 'dispatch;
	}
	// 821E3684: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3688: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E368C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3690: 41990008  bgt cr6, 0x821e3698
	if ctx.cr[6].gt {
	pc = 0x821E3698; continue 'dispatch;
	}
	// 821E3694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E3698: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E369C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E36A0: 409A0014  bne cr6, 0x821e36b4
	if !ctx.cr[6].eq {
	pc = 0x821E36B4; continue 'dispatch;
	}
	// 821E36A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E36A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E36AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E36B0: 48000008  b 0x821e36b8
	pc = 0x821E36B8; continue 'dispatch;
	// 821E36B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821E36B8: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E36BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E36C0: 419A0010  beq cr6, 0x821e36d0
	if ctx.cr[6].eq {
	pc = 0x821E36D0; continue 'dispatch;
	}
	// 821E36C4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E36C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E36CC: 4800000C  b 0x821e36d8
	pc = 0x821E36D8; continue 'dispatch;
	// 821E36D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E36D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E36D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E36DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E36E0: 419A0034  beq cr6, 0x821e3714
	if ctx.cr[6].eq {
	pc = 0x821E3714; continue 'dispatch;
	}
	// 821E36E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E36E8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E36EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E36F0: 4E800421  bctrl
	ctx.lr = 0x821E36F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E36F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E36F8: 419A001C  beq cr6, 0x821e3714
	if ctx.cr[6].eq {
	pc = 0x821E3714; continue 'dispatch;
	}
	// 821E36FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E3700: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821E3704: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E3708: 48011691  bl 0x821f4d98
	ctx.lr = 0x821E370C;
	sub_821F4D98(ctx, base);
	// 821E370C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E3710: 48000008  b 0x821e3718
	pc = 0x821E3718; continue 'dispatch;
	// 821E3714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E3718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E371C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3724: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821E3728: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E372C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3738 size=1620
    let mut pc: u32 = 0x821E3738;
    'dispatch: loop {
        match pc {
            0x821E3738 => {
    //   block [0x821E3738..0x821E3D8C)
	// 821E3738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E373C: 48AC5CC1  bl 0x82ca93fc
	ctx.lr = 0x821E3740;
	sub_82CA93D0(ctx, base);
	// 821E3740: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821E3744: 48ACA595  bl 0x82cadcd8
	ctx.lr = 0x821E3748;
	sub_82CADCA0(ctx, base);
	// 821E3748: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E374C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E3750: 4BFB6341  bl 0x82199a90
	ctx.lr = 0x821E3754;
	sub_82199A90(ctx, base);
	// 821E3754: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E3758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E375C: 4BFD727D  bl 0x821ba9d8
	ctx.lr = 0x821E3760;
	sub_821BA9D8(ctx, base);
	// 821E3760: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E3764: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E3768: C39D006C  lfs f28, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821E376C: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 821E3770: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3774: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821E3778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E377C: 419A0020  beq cr6, 0x821e379c
	if ctx.cr[6].eq {
	pc = 0x821E379C; continue 'dispatch;
	}
	// 821E3780: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3784: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E3788: 419A000C  beq cr6, 0x821e3794
	if ctx.cr[6].eq {
	pc = 0x821E3794; continue 'dispatch;
	}
	// 821E378C: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E3790: 48000010  b 0x821e37a0
	pc = 0x821E37A0; continue 'dispatch;
	// 821E3794: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821E3798: 4BFB06A1  bl 0x82193e38
	ctx.lr = 0x821E379C;
	sub_82193E38(ctx, base);
	// 821E379C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E37A0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E37A4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821E37A8: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E37AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E37B0: 419A00F4  beq cr6, 0x821e38a4
	if ctx.cr[6].eq {
	pc = 0x821E38A4; continue 'dispatch;
	}
	// 821E37B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E37B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E37BC: 419A0024  beq cr6, 0x821e37e0
	if ctx.cr[6].eq {
	pc = 0x821E37E0; continue 'dispatch;
	}
	// 821E37C0: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 821E37C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E37C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E37CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E37D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E37D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E37D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E37DC: 480000CC  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
	// 821E37E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E37E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E37E8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821E37EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E37F0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E37F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E37F8: 40810054  ble 0x821e384c
	if !ctx.cr[0].gt {
	pc = 0x821E384C; continue 'dispatch;
	}
	// 821E37FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E3800: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E3804: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E3808: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E380C: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821E3810: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821E3814: 41980008  blt cr6, 0x821e381c
	if ctx.cr[6].lt {
	pc = 0x821E381C; continue 'dispatch;
	}
	// 821E3818: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821E381C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E3820: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3824: 419A0014  beq cr6, 0x821e3838
	if ctx.cr[6].eq {
	pc = 0x821E3838; continue 'dispatch;
	}
	// 821E3828: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E382C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3830: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3834: 4800000C  b 0x821e3840
	pc = 0x821E3840; continue 'dispatch;
	// 821E3838: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E383C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E3840: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3844: 4199FFB8  bgt cr6, 0x821e37fc
	if ctx.cr[6].gt {
	pc = 0x821E37FC; continue 'dispatch;
	}
	// 821E3848: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E384C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E3850: 419A0040  beq cr6, 0x821e3890
	if ctx.cr[6].eq {
	pc = 0x821E3890; continue 'dispatch;
	}
	// 821E3854: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3858: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821E385C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E3860: 41990008  bgt cr6, 0x821e3868
	if ctx.cr[6].gt {
	pc = 0x821E3868; continue 'dispatch;
	}
	// 821E3864: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E3868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E386C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3870: 409A0020  bne cr6, 0x821e3890
	if !ctx.cr[6].eq {
	pc = 0x821E3890; continue 'dispatch;
	}
	// 821E3874: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E3878: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821E387C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E3880: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3884: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E3888: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E388C: 4800001C  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
	// 821E3890: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E3894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3898: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E389C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E38A0: 48000008  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
	// 821E38A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E38A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E38AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E38B0: 419A000C  beq cr6, 0x821e38bc
	if ctx.cr[6].eq {
	pc = 0x821E38BC; continue 'dispatch;
	}
	// 821E38B4: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E38B8: EF800732  fmuls f28, f0, f28
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 821E38BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E38C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E38C4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E38C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E38CC: 4E800421  bctrl
	ctx.lr = 0x821E38D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E38D0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E38D4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E38D8: 4803B981  bl 0x8221f258
	ctx.lr = 0x821E38DC;
	sub_8221F258(ctx, base);
	// 821E38DC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E38E4: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 821E38E8: C3A99490  lfs f29, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821E38EC: C3E8FFF4  lfs f31, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E38F0: 419A0040  beq cr6, 0x821e3930
	if ctx.cr[6].eq {
	pc = 0x821E3930; continue 'dispatch;
	}
	// 821E38F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E38F8: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E38FC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821E3900: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E3904: 392B21E0  addi r9, r11, 0x21e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8672;
	// 821E3908: D3C30010  stfs f30, 0x10(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E390C: D3A30014  stfs f29, 0x14(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821E3910: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3914: D3830020  stfs f28, 0x20(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E3918: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E391C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821E3920: 9B83001C  stb r28, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821E3924: 9B83001D  stb r28, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[28].u8 ) };
	// 821E3928: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E392C: 48000008  b 0x821e3934
	pc = 0x821E3934; continue 'dispatch;
	// 821E3930: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821E3934: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3938: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821E393C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3940: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3944: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3948: 4E800421  bctrl
	ctx.lr = 0x821E394C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E394C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3950: 419A0304  beq cr6, 0x821e3c54
	if ctx.cr[6].eq {
	pc = 0x821E3C54; continue 'dispatch;
	}
	// 821E3954: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3958: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E395C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3960: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3964: 4E800421  bctrl
	ctx.lr = 0x821E3968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3968: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E396C: 889D0076  lbz r4, 0x76(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(118 as u32) ) } as u64;
	// 821E3970: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E3974: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E3978: 4E800421  bctrl
	ctx.lr = 0x821E397C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E397C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821E3980: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3984: 38871808  addi r4, r7, 0x1808
	ctx.r[4].s64 = ctx.r[7].s64 + 6152;
	// 821E3988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E398C: 48049545  bl 0x8222ced0
	ctx.lr = 0x821E3990;
	sub_8222CED0(ctx, base);
	// 821E3990: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3994: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E399C: 80A60020  lwz r5, 0x20(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E39A0: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821E39A4: 4E800421  bctrl
	ctx.lr = 0x821E39A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E39A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E39AC: 48089C15  bl 0x8226d5c0
	ctx.lr = 0x821E39B0;
	sub_8226D5C0(ctx, base);
	// 821E39B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E39B4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E39B8: 48031421  bl 0x82214dd8
	ctx.lr = 0x821E39BC;
	sub_82214DD8(ctx, base);
	// 821E39BC: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821E39C0: 40990008  ble cr6, 0x821e39c8
	if !ctx.cr[6].gt {
	pc = 0x821E39C8; continue 'dispatch;
	}
	// 821E39C4: D3DE0008  stfs f30, 8(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E39C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E39CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E39D0: 388B1100  addi r4, r11, 0x1100
	ctx.r[4].s64 = ctx.r[11].s64 + 4352;
	// 821E39D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E39D8: 480494F9  bl 0x8222ced0
	ctx.lr = 0x821E39DC;
	sub_8222CED0(ctx, base);
	// 821E39DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E39E0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E39E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E39E8: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E39EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E39F0: 4E800421  bctrl
	ctx.lr = 0x821E39F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E39F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E39F8: 4BFF7419  bl 0x821dae10
	ctx.lr = 0x821E39FC;
	sub_821DAE10(ctx, base);
	// 821E39FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E3A00: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E3A04: 480313D5  bl 0x82214dd8
	ctx.lr = 0x821E3A08;
	sub_82214DD8(ctx, base);
	// 821E3A08: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821E3A0C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E3A10: 38A87088  addi r5, r8, 0x7088
	ctx.r[5].s64 = ctx.r[8].s64 + 28808;
	// 821E3A14: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 821E3A18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3A1C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 821E3A20: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821E3A24: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3A28: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3A2C: 4082FFE8  bne 0x821e3a14
	if !ctx.cr[0].eq {
	pc = 0x821E3A14; continue 'dispatch;
	}
	// 821E3A30: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821E3A34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3A38: 38840F10  addi r4, r4, 0xf10
	ctx.r[4].s64 = ctx.r[4].s64 + 3856;
	// 821E3A3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3A40: 48049491  bl 0x8222ced0
	ctx.lr = 0x821E3A44;
	sub_8222CED0(ctx, base);
	// 821E3A44: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3A48: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3A4C: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3A50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3A54: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3A58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3A5C: 4E800421  bctrl
	ctx.lr = 0x821E3A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3A60: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3A64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3A68: 48058F01  bl 0x8223c968
	ctx.lr = 0x821E3A6C;
	sub_8223C968(ctx, base);
	// 821E3A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3A70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3A74: 48031365  bl 0x82214dd8
	ctx.lr = 0x821E3A78;
	sub_82214DD8(ctx, base);
	// 821E3A78: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3A7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E3A80: 419A0064  beq cr6, 0x821e3ae4
	if ctx.cr[6].eq {
	pc = 0x821E3AE4; continue 'dispatch;
	}
	// 821E3A84: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E3A88: 4803B7D1  bl 0x8221f258
	ctx.lr = 0x821E3A8C;
	sub_8221F258(ctx, base);
	// 821E3A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3A90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3A94: 419A0030  beq cr6, 0x821e3ac4
	if ctx.cr[6].eq {
	pc = 0x821E3AC4; continue 'dispatch;
	}
	// 821E3A98: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3A9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3AA0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3AA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3AA8: 4E800421  bctrl
	ctx.lr = 0x821E3AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3AAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3AB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3AB8: 4849DF49  bl 0x82681a00
	ctx.lr = 0x821E3ABC;
	sub_82681A00(ctx, base);
	// 821E3ABC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3AC0: 48000008  b 0x821e3ac8
	pc = 0x821E3AC8; continue 'dispatch;
	// 821E3AC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E3AC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3ACC: 4BFD7FE5  bl 0x821bbab0
	ctx.lr = 0x821E3AD0;
	sub_821BBAB0(ctx, base);
	// 821E3AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3AD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3AD8: 48088391  bl 0x8226be68
	ctx.lr = 0x821E3ADC;
	sub_8226BE68(ctx, base);
	// 821E3ADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3AE0: 4BFD4039  bl 0x821b7b18
	ctx.lr = 0x821E3AE4;
	sub_821B7B18(ctx, base);
	// 821E3AE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E3AE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3AEC: 388B12E0  addi r4, r11, 0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + 4832;
	// 821E3AF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3AF4: 480493DD  bl 0x8222ced0
	ctx.lr = 0x821E3AF8;
	sub_8222CED0(ctx, base);
	// 821E3AF8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3AFC: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3B00: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3B04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3B08: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3B0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3B10: 4E800421  bctrl
	ctx.lr = 0x821E3B14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3B14: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3B18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3B1C: 48058E4D  bl 0x8223c968
	ctx.lr = 0x821E3B20;
	sub_8223C968(ctx, base);
	// 821E3B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3B24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3B28: 480312B1  bl 0x82214dd8
	ctx.lr = 0x821E3B2C;
	sub_82214DD8(ctx, base);
	// 821E3B2C: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3B30: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3B34: 419A0064  beq cr6, 0x821e3b98
	if ctx.cr[6].eq {
	pc = 0x821E3B98; continue 'dispatch;
	}
	// 821E3B38: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 821E3B3C: 4803B71D  bl 0x8221f258
	ctx.lr = 0x821E3B40;
	sub_8221F258(ctx, base);
	// 821E3B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3B44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3B48: 419A0030  beq cr6, 0x821e3b78
	if ctx.cr[6].eq {
	pc = 0x821E3B78; continue 'dispatch;
	}
	// 821E3B4C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3B50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3B54: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3B58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3B5C: 4E800421  bctrl
	ctx.lr = 0x821E3B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3B60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3B6C: 4849EC25  bl 0x82682790
	ctx.lr = 0x821E3B70;
	sub_82682790(ctx, base);
	// 821E3B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3B74: 48000008  b 0x821e3b7c
	pc = 0x821E3B7C; continue 'dispatch;
	// 821E3B78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E3B7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821E3B80: 4BFD7F31  bl 0x821bbab0
	ctx.lr = 0x821E3B84;
	sub_821BBAB0(ctx, base);
	// 821E3B84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3B88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3B8C: 480882DD  bl 0x8226be68
	ctx.lr = 0x821E3B90;
	sub_8226BE68(ctx, base);
	// 821E3B90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821E3B94: 4BFD3F85  bl 0x821b7b18
	ctx.lr = 0x821E3B98;
	sub_821B7B18(ctx, base);
	// 821E3B98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E3B9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3BA0: 388B11C8  addi r4, r11, 0x11c8
	ctx.r[4].s64 = ctx.r[11].s64 + 4552;
	// 821E3BA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3BA8: 48049329  bl 0x8222ced0
	ctx.lr = 0x821E3BAC;
	sub_8222CED0(ctx, base);
	// 821E3BAC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3BB0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3BB4: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3BB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3BBC: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3BC0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3BC4: 4E800421  bctrl
	ctx.lr = 0x821E3BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3BC8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3BCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3BD0: 48058D99  bl 0x8223c968
	ctx.lr = 0x821E3BD4;
	sub_8223C968(ctx, base);
	// 821E3BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3BDC: 480311FD  bl 0x82214dd8
	ctx.lr = 0x821E3BE0;
	sub_82214DD8(ctx, base);
	// 821E3BE0: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3BE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3BE8: 419A0064  beq cr6, 0x821e3c4c
	if ctx.cr[6].eq {
	pc = 0x821E3C4C; continue 'dispatch;
	}
	// 821E3BEC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E3BF0: 4803B669  bl 0x8221f258
	ctx.lr = 0x821E3BF4;
	sub_8221F258(ctx, base);
	// 821E3BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3BF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3BFC: 419A0030  beq cr6, 0x821e3c2c
	if ctx.cr[6].eq {
	pc = 0x821E3C2C; continue 'dispatch;
	}
	// 821E3C00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3C04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3C08: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3C0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3C10: 4E800421  bctrl
	ctx.lr = 0x821E3C14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3C14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3C18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3C20: 4849F101  bl 0x82682d20
	ctx.lr = 0x821E3C24;
	sub_82682D20(ctx, base);
	// 821E3C24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C28: 48000008  b 0x821e3c30
	pc = 0x821E3C30; continue 'dispatch;
	// 821E3C2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E3C30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E3C34: 4BFD7E7D  bl 0x821bbab0
	ctx.lr = 0x821E3C38;
	sub_821BBAB0(ctx, base);
	// 821E3C38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3C40: 48088229  bl 0x8226be68
	ctx.lr = 0x821E3C44;
	sub_8226BE68(ctx, base);
	// 821E3C44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E3C48: 4BFD3ED1  bl 0x821b7b18
	ctx.lr = 0x821E3C4C;
	sub_821B7B18(ctx, base);
	// 821E3C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E3C50: 48031189  bl 0x82214dd8
	ctx.lr = 0x821E3C54;
	sub_82214DD8(ctx, base);
	// 821E3C54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3C58: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E3C5C: 4BFD7E55  bl 0x821bbab0
	ctx.lr = 0x821E3C60;
	sub_821BBAB0(ctx, base);
	// 821E3C60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3C68: 48088201  bl 0x8226be68
	ctx.lr = 0x821E3C6C;
	sub_8226BE68(ctx, base);
	// 821E3C6C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E3C70: 4BFD3EA9  bl 0x821b7b18
	ctx.lr = 0x821E3C74;
	sub_821B7B18(ctx, base);
	// 821E3C74: 897D0074  lbz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 821E3C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3C7C: 419A009C  beq cr6, 0x821e3d18
	if ctx.cr[6].eq {
	pc = 0x821E3D18; continue 'dispatch;
	}
	// 821E3C80: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 821E3C84: 4803B5D5  bl 0x8221f258
	ctx.lr = 0x821E3C88;
	sub_8221F258(ctx, base);
	// 821E3C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3C8C: 419A006C  beq cr6, 0x821e3cf8
	if ctx.cr[6].eq {
	pc = 0x821E3CF8; continue 'dispatch;
	}
	// 821E3C90: 897D0075  lbz r11, 0x75(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(117 as u32) ) } as u64;
	// 821E3C94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E3C98: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E3C9C: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3CA0: 392A1DEC  addi r9, r10, 0x1dec
	ctx.r[9].s64 = ctx.r[10].s64 + 7660;
	// 821E3CA4: D3A30024  stfs f29, 0x24(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821E3CA8: D3A30028  stfs f29, 0x28(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821E3CAC: 9B43000C  stb r26, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	// 821E3CB0: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821E3CB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E3CB8: D3E30030  stfs f31, 0x30(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821E3CBC: 9B83000D  stb r28, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[28].u8 ) };
	// 821E3CC0: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821E3CC4: 9B83000E  stb r28, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[28].u8 ) };
	// 821E3CC8: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821E3CCC: 9B830020  stb r28, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821E3CD0: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821E3CD4: 9B830040  stb r28, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[28].u8 ) };
	// 821E3CD8: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 821E3CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3CE0: 9B830042  stb r28, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[28].u8 ) };
	// 821E3CE4: 9B830043  stb r28, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[28].u8 ) };
	// 821E3CE8: 93830048  stw r28, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821E3CEC: 9383004C  stw r28, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 821E3CF0: 9B430054  stb r26, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[26].u8 ) };
	// 821E3CF4: 48000008  b 0x821e3cfc
	pc = 0x821E3CFC; continue 'dispatch;
	// 821E3CF8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E3CFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821E3D00: 4BFD7DB1  bl 0x821bbab0
	ctx.lr = 0x821E3D04;
	sub_821BBAB0(ctx, base);
	// 821E3D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3D0C: 4808815D  bl 0x8226be68
	ctx.lr = 0x821E3D10;
	sub_8226BE68(ctx, base);
	// 821E3D10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821E3D14: 4BFD3E05  bl 0x821b7b18
	ctx.lr = 0x821E3D18;
	sub_821B7B18(ctx, base);
	// 821E3D18: C01D0070  lfs f0, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3D1C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E3D20: 419A005C  beq cr6, 0x821e3d7c
	if ctx.cr[6].eq {
	pc = 0x821E3D7C; continue 'dispatch;
	}
	// 821E3D24: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821E3D28: 4803B531  bl 0x8221f258
	ctx.lr = 0x821E3D2C;
	sub_8221F258(ctx, base);
	// 821E3D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3D30: 419A002C  beq cr6, 0x821e3d5c
	if ctx.cr[6].eq {
	pc = 0x821E3D5C; continue 'dispatch;
	}
	// 821E3D34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E3D38: C01D0070  lfs f0, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3D3C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E3D40: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3D44: 394BB714  addi r10, r11, -0x48ec
	ctx.r[10].s64 = ctx.r[11].s64 + -18668;
	// 821E3D48: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E3D4C: D3C30010  stfs f30, 0x10(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E3D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E3D58: 48000008  b 0x821e3d60
	pc = 0x821E3D60; continue 'dispatch;
	// 821E3D5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E3D60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821E3D64: 4BFD7D4D  bl 0x821bbab0
	ctx.lr = 0x821E3D68;
	sub_821BBAB0(ctx, base);
	// 821E3D68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3D70: 480880F9  bl 0x8226be68
	ctx.lr = 0x821E3D74;
	sub_8226BE68(ctx, base);
	// 821E3D74: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821E3D78: 4BFD3DA1  bl 0x821b7b18
	ctx.lr = 0x821E3D7C;
	sub_821B7B18(ctx, base);
	// 821E3D7C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821E3D80: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821E3D84: 48AC9FA1  bl 0x82cadd24
	ctx.lr = 0x821E3D88;
	sub_82CADCEC(ctx, base);
	// 821E3D88: 48AC56C4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3D90 size=192
    let mut pc: u32 = 0x821E3D90;
    'dispatch: loop {
        match pc {
            0x821E3D90 => {
    //   block [0x821E3D90..0x821E3E50)
	// 821E3D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E3D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E3D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E3DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3DA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821E3DAC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821E3DB0: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	// 821E3DB4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821E3DB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E3DBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3DC0: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E3DC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E3DC8: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3DCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3DD0: 4082FFE8  bne 0x821e3db8
	if !ctx.cr[0].eq {
	pc = 0x821E3DB8; continue 'dispatch;
	}
	// 821E3DD4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3DDC: 409A0010  bne cr6, 0x821e3dec
	if !ctx.cr[6].eq {
	pc = 0x821E3DEC; continue 'dispatch;
	}
	// 821E3DE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821E3DE4: 396BFFDF  addi r11, r11, -0x21
	ctx.r[11].s64 = ctx.r[11].s64 + -33;
	// 821E3DE8: 48000008  b 0x821e3df0
	pc = 0x821E3DF0; continue 'dispatch;
	// 821E3DEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3DF0: 7C8B2A15  add. r4, r11, r5
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E3DF4: 41820020  beq 0x821e3e14
	if ctx.cr[0].eq {
	pc = 0x821E3E14; continue 'dispatch;
	}
	// 821E3DF8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3E00: 419A0014  beq cr6, 0x821e3e14
	if ctx.cr[6].eq {
	pc = 0x821E3E14; continue 'dispatch;
	}
	// 821E3E04: 7CA53050  subf r5, r5, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 821E3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E0C: 48023A95  bl 0x822078a0
	ctx.lr = 0x821E3E10;
	sub_822078A0(ctx, base);
	// 821E3E10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E3E14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3E1C: 419A000C  beq cr6, 0x821e3e28
	if ctx.cr[6].eq {
	pc = 0x821E3E28; continue 'dispatch;
	}
	// 821E3E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E24: 4BFE2945  bl 0x821c6768
	ctx.lr = 0x821E3E28;
	sub_821C6768(ctx, base);
	// 821E3E28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3E2C: 419A0008  beq cr6, 0x821e3e34
	if ctx.cr[6].eq {
	pc = 0x821E3E34; continue 'dispatch;
	}
	// 821E3E30: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821E3E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E3E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E3E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3E50 size=292
    let mut pc: u32 = 0x821E3E50;
    'dispatch: loop {
        match pc {
            0x821E3E50 => {
    //   block [0x821E3E50..0x821E3F74)
	// 821E3E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3E54: 48AC55B1  bl 0x82ca9404
	ctx.lr = 0x821E3E58;
	sub_82CA93D0(ctx, base);
	// 821E3E58: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821E3E5C: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 821E3E60: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 821E3E64: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 821E3E68: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821E3E6C: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 821E3E70: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 821E3E74: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3E78: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3E7C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821E3E80: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3E84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E3E88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E3E8C: 409AFFF4  bne cr6, 0x821e3e80
	if !ctx.cr[6].eq {
	pc = 0x821E3E80; continue 'dispatch;
	}
	// 821E3E90: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821E3E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3E98: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E3E9C: 3BAB0400  addi r29, r11, 0x400
	ctx.r[29].s64 = ctx.r[11].s64 + 1024;
	// 821E3EA0: 7D5D00D0  neg r10, r29
	ctx.r[10].s64 = -ctx.r[29].s64;
	// 821E3EA4: 554C0036  rlwinm r12, r10, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821E3EA8: 48ACC7AD  bl 0x82cb0654
	ctx.lr = 0x821E3EAC;
	sub_82CB0654(ctx, base);
	// 821E3EAC: 81210000  lwz r9, 0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3EB0: 391F0050  addi r8, r31, 0x50
	ctx.r[8].s64 = ctx.r[31].s64 + 80;
	// 821E3EB4: 38FF00B0  addi r7, r31, 0xb0
	ctx.r[7].s64 = ctx.r[31].s64 + 176;
	// 821E3EB8: 7D21616E  stwux r9, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[1].u32 = ea;
	// 821E3EBC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821E3EC0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 821E3EC4: 80BF0050  lwz r5, 0x50(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E3EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3ECC: 4BFE2985  bl 0x821c6850
	ctx.lr = 0x821E3ED0;
	sub_821C6850(ctx, base);
	// 821E3ED0: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821E3ED4: 41990094  bgt cr6, 0x821e3f68
	if ctx.cr[6].gt {
	pc = 0x821E3F68; continue 'dispatch;
	}
	// 821E3ED8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E3EDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3EE0: 419A0068  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3EE4: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3EEC: 419A005C  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3EF0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821E3EF4: 4803B365  bl 0x8221f258
	ctx.lr = 0x821E3EF8;
	sub_8221F258(ctx, base);
	// 821E3EF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E3EFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E3F00: 419A0048  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3F04: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821E3F08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E3F0C: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 821E3F10: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821E3F14: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F1C: 419A0014  beq cr6, 0x821e3f30
	if ctx.cr[6].eq {
	pc = 0x821E3F30; continue 'dispatch;
	}
	// 821E3F20: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821E3F24: 7D65F0AE  lbzx r11, r5, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821E3F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F2C: 409AFFF4  bne cr6, 0x821e3f20
	if !ctx.cr[6].eq {
	pc = 0x821E3F20; continue 'dispatch;
	}
	// 821E3F30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3F34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3F38: 48024841  bl 0x82208778
	ctx.lr = 0x821E3F3C;
	sub_82208778(ctx, base);
	// 821E3F3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3F40: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 821E3F44: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821E3F48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F50: 419A000C  beq cr6, 0x821e3f5c
	if ctx.cr[6].eq {
	pc = 0x821E3F5C; continue 'dispatch;
	}
	// 821E3F54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3F58: 4BFE2811  bl 0x821c6768
	ctx.lr = 0x821E3F5C;
	sub_821C6768(ctx, base);
	// 821E3F5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E3F60: 419A0008  beq cr6, 0x821e3f68
	if ctx.cr[6].eq {
	pc = 0x821E3F68; continue 'dispatch;
	}
	// 821E3F64: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821E3F68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3F6C: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 821E3F70: 48AC54E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3F78 size=548
    let mut pc: u32 = 0x821E3F78;
    'dispatch: loop {
        match pc {
            0x821E3F78 => {
    //   block [0x821E3F78..0x821E419C)
	// 821E3F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3F7C: 48AC5485  bl 0x82ca9400
	ctx.lr = 0x821E3F80;
	sub_82CA93D0(ctx, base);
	// 821E3F80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3F84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821E3F88: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821E3F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3F90: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 821E3F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E3F98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E3F9C: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3FA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E3FA4: 4800C29D  bl 0x821f0240
	ctx.lr = 0x821E3FA8;
	sub_821F0240(ctx, base);
	// 821E3FA8: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 821E3FAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3FB0: 4800C291  bl 0x821f0240
	ctx.lr = 0x821E3FB4;
	sub_821F0240(ctx, base);
	// 821E3FB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3FB8: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 821E3FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3FC0: 409A000C  bne cr6, 0x821e3fcc
	if !ctx.cr[6].eq {
	pc = 0x821E3FCC; continue 'dispatch;
	}
	// 821E3FC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E3FC8: 48000010  b 0x821e3fd8
	pc = 0x821E3FD8; continue 'dispatch;
	// 821E3FCC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E3FD0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E3FD4: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821E3FD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3FDC: 419A01A8  beq cr6, 0x821e4184
	if ctx.cr[6].eq {
	pc = 0x821E4184; continue 'dispatch;
	}
	// 821E3FE0: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E3FE4: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 821E3FE8: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821E3FEC: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 821E3FF0: 7D68D3D6  divw r11, r8, r26
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 821E3FF4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E3FF8: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E3FFC: 4098000C  bge cr6, 0x821e4008
	if !ctx.cr[6].lt {
	pc = 0x821E4008; continue 'dispatch;
	}
	// 821E4000: 488634C9  bl 0x82a474c8
	ctx.lr = 0x821E4004;
	sub_82A474C8(ctx, base);
	// 821E4004: 48000180  b 0x821e4184
	pc = 0x821E4184; continue 'dispatch;
	// 821E4008: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E400C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4010: 409800D8  bge cr6, 0x821e40e8
	if !ctx.cr[6].lt {
	pc = 0x821E40E8; continue 'dispatch;
	}
	// 821E4014: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E4018: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E401C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E4020: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E4024: 41980008  blt cr6, 0x821e402c
	if ctx.cr[6].lt {
	pc = 0x821E402C; continue 'dispatch;
	}
	// 821E4028: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E402C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4030: 40980008  bge cr6, 0x821e4038
	if !ctx.cr[6].lt {
	pc = 0x821E4038; continue 'dispatch;
	}
	// 821E4034: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 821E4038: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E403C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E4040: 4813F371  bl 0x823233b0
	ctx.lr = 0x821E4044;
	sub_823233B0(ctx, base);
	// 821E4044: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4048: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821E404C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E4050: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E4054: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E4058: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E405C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E4060: 48383BA9  bl 0x82567c08
	ctx.lr = 0x821E4064;
	sub_82567C08(ctx, base);
	// 821E4064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E4068: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E406C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E4070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E4074: 4880B825  bl 0x829ef898
	ctx.lr = 0x821E4078;
	sub_829EF898(ctx, base);
	// 821E4078: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E407C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E4080: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4084: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E4088: 48383B81  bl 0x82567c08
	ctx.lr = 0x821E408C;
	sub_82567C08(ctx, base);
	// 821E408C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4090: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E4098: 7D432050  subf r10, r3, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 821E409C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821E40A0: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E40A4: 419A0014  beq cr6, 0x821e40b8
	if ctx.cr[6].eq {
	pc = 0x821E40B8; continue 'dispatch;
	}
	// 821E40A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E40AC: 48382965  bl 0x82566a10
	ctx.lr = 0x821E40B0;
	sub_82566A10(ctx, base);
	// 821E40B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E40B4: 48037C85  bl 0x8221bd38
	ctx.lr = 0x821E40B8;
	sub_8221BD38(ctx, base);
	// 821E40B8: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E40BC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E40C0: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E40C4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821E40C8: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 821E40CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E40D0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E40D4: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E40D8: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 821E40DC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821E40E0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E40E4: 480000A0  b 0x821e4184
	pc = 0x821E4184; continue 'dispatch;
	// 821E40E8: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821E40EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E40F0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E40F4: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 821E40F8: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821E40FC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E4100: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E4104: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821E4108: 40980044  bge cr6, 0x821e414c
	if !ctx.cr[6].lt {
	pc = 0x821E414C; continue 'dispatch;
	}
	// 821E410C: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821E4110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4114: 7CBCEA14  add r5, r28, r29
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 821E4118: 48383AF1  bl 0x82567c08
	ctx.lr = 0x821E411C;
	sub_82567C08(ctx, base);
	// 821E411C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4120: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E4124: 7D5D2050  subf r10, r29, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 821E4128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E412C: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821E4130: 7CA9F050  subf r5, r9, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 821E4134: 4880B765  bl 0x829ef898
	ctx.lr = 0x821E4138;
	sub_829EF898(ctx, base);
	// 821E4138: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E413C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E4140: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E4144: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 821E4148: 48000030  b 0x821e4178
	pc = 0x821E4178; continue 'dispatch;
	// 821E414C: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821E4150: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E4154: 7F7EE050  subf r27, r30, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E4158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E415C: 48383AAD  bl 0x82567c08
	ctx.lr = 0x821E4160;
	sub_82567C08(ctx, base);
	// 821E4160: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821E4164: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E4168: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E416C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4170: 48382999  bl 0x82566b08
	ctx.lr = 0x821E4174;
	sub_82566B08(ctx, base);
	// 821E4174: 7C9EEA14  add r4, r30, r29
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 821E4178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E417C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4180: 48382929  bl 0x82566aa8
	ctx.lr = 0x821E4184;
	sub_82566AA8(ctx, base);
	// 821E4184: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E4188: 48030C51  bl 0x82214dd8
	ctx.lr = 0x821E418C;
	sub_82214DD8(ctx, base);
	// 821E418C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E4190: 48030C49  bl 0x82214dd8
	ctx.lr = 0x821E4194;
	sub_82214DD8(ctx, base);
	// 821E4194: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E4198: 48AC52B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E41A0 size=176
    let mut pc: u32 = 0x821E41A0;
    'dispatch: loop {
        match pc {
            0x821E41A0 => {
    //   block [0x821E41A0..0x821E4250)
	// 821E41A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E41A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E41A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E41AC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E4250 size=92
    let mut pc: u32 = 0x821E4250;
    'dispatch: loop {
        match pc {
            0x821E4250 => {
    //   block [0x821E4250..0x821E42AC)
	// 821E4250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4254: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E4258: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E425C: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 821E4260: 7D6B2038  and r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 821E4264: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E4268: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E426C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E4270: 419A002C  beq cr6, 0x821e429c
	if ctx.cr[6].eq {
	pc = 0x821E429C; continue 'dispatch;
	}
	// 821E4274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E4278: 419A0034  beq cr6, 0x821e42ac
	if ctx.cr[6].eq {
		sub_821E42AC(ctx, base);
		return;
	}
	// 821E427C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E4280: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4284: 409A0008  bne cr6, 0x821e428c
	if !ctx.cr[6].eq {
	pc = 0x821E428C; continue 'dispatch;
	}
	// 821E4288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E428C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E4290: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E4294: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E4298: 409AFFDC  bne cr6, 0x821e4274
	if !ctx.cr[6].eq {
	pc = 0x821E4274; continue 'dispatch;
	}
	// 821E429C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E42A0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E42A4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E42A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E42AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E42AC size=8
    let mut pc: u32 = 0x821E42AC;
    'dispatch: loop {
        match pc {
            0x821E42AC => {
    //   block [0x821E42AC..0x821E42B4)
	// 821E42AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E42B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E42B8 size=172
    let mut pc: u32 = 0x821E42B8;
    'dispatch: loop {
        match pc {
            0x821E42B8 => {
    //   block [0x821E42B8..0x821E4364)
	// 821E42B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E42BC: 48AC5151  bl 0x82ca940c
	ctx.lr = 0x821E42C0;
	sub_82CA93D0(ctx, base);
	// 821E42C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E42C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E42C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E42CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E42D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E42D4: 419A0084  beq cr6, 0x821e4358
	if ctx.cr[6].eq {
	pc = 0x821E4358; continue 'dispatch;
	}
	// 821E42D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E42DC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821E42E0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E42E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E42E8: 48044E21  bl 0x82229108
	ctx.lr = 0x821E42EC;
	sub_82229108(ctx, base);
	// 821E42EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E42F0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E42F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E42F8: 48044091  bl 0x82228388
	ctx.lr = 0x821E42FC;
	sub_82228388(ctx, base);
	// 821E42FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4300: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E4304: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821E4308: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 821E430C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4310: 419A0040  beq cr6, 0x821e4350
	if ctx.cr[6].eq {
	pc = 0x821E4350; continue 'dispatch;
	}
	// 821E4314: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4318: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821E431C: 409A0034  bne cr6, 0x821e4350
	if !ctx.cr[6].eq {
	pc = 0x821E4350; continue 'dispatch;
	}
	// 821E4320: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E4324: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E4328: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E432C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E4330: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821E4334: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E4338: 4811DB61  bl 0x82301e98
	ctx.lr = 0x821E433C;
	sub_82301E98(ctx, base);
	// 821E433C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4340: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821E4344: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E4348: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E434C: 48AC5110  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E4350: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821E4354: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E4358: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E435C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E4360: 48AC50FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E4368 size=388
    let mut pc: u32 = 0x821E4368;
    'dispatch: loop {
        match pc {
            0x821E4368 => {
    //   block [0x821E4368..0x821E44EC)
	// 821E4368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E436C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E4370: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E4374: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E4378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E437C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E4380: 419A0018  beq cr6, 0x821e4398
	if ctx.cr[6].eq {
	pc = 0x821E4398; continue 'dispatch;
	}
	// 821E4384: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E4388: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E438C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E4390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E4394: 409A0008  bne cr6, 0x821e439c
	if !ctx.cr[6].eq {
	pc = 0x821E439C; continue 'dispatch;
	}
	// 821E4398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E439C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E43A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E43A4: 419A0130  beq cr6, 0x821e44d4
	if ctx.cr[6].eq {
	pc = 0x821E44D4; continue 'dispatch;
	}
	// 821E43A8: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E43AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E43B0: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E43B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E43B8: 419A00EC  beq cr6, 0x821e44a4
	if ctx.cr[6].eq {
	pc = 0x821E44A4; continue 'dispatch;
	}
	// 821E43BC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E43C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E43C4: 419A0020  beq cr6, 0x821e43e4
	if ctx.cr[6].eq {
	pc = 0x821E43E4; continue 'dispatch;
	}
	// 821E43C8: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821E43CC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E43D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E43D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E43D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E43DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E43E0: 480000C8  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
	// 821E43E4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E43E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E43EC: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E43F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E43F4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E43F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E43FC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E4400: 40810054  ble 0x821e4454
	if !ctx.cr[0].gt {
	pc = 0x821E4454; continue 'dispatch;
	}
	// 821E4404: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E4408: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E440C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E4410: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4414: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821E4418: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E441C: 41980008  blt cr6, 0x821e4424
	if ctx.cr[6].lt {
	pc = 0x821E4424; continue 'dispatch;
	}
	// 821E4420: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E4424: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E4428: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E442C: 419A0014  beq cr6, 0x821e4440
	if ctx.cr[6].eq {
	pc = 0x821E4440; continue 'dispatch;
	}
	// 821E4430: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E4434: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E4438: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E443C: 4800000C  b 0x821e4448
	pc = 0x821E4448; continue 'dispatch;
	// 821E4440: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E4444: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E4448: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E444C: 4199FFB8  bgt cr6, 0x821e4404
	if ctx.cr[6].gt {
	pc = 0x821E4404; continue 'dispatch;
	}
	// 821E4450: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E4454: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E4458: 419A003C  beq cr6, 0x821e4494
	if ctx.cr[6].eq {
	pc = 0x821E4494; continue 'dispatch;
	}
	// 821E445C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4460: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E4464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E4468: 41990008  bgt cr6, 0x821e4470
	if ctx.cr[6].gt {
	pc = 0x821E4470; continue 'dispatch;
	}
	// 821E446C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E4470: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E4474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E4478: 409A001C  bne cr6, 0x821e4494
	if !ctx.cr[6].eq {
	pc = 0x821E4494; continue 'dispatch;
	}
	// 821E447C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E4480: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E4484: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E4488: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E448C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4490: 48000018  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
	// 821E4494: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E4498: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E449C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E44A0: 48000008  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
	// 821E44A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E44A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E44AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E44B0: 419A0024  beq cr6, 0x821e44d4
	if ctx.cr[6].eq {
	pc = 0x821E44D4; continue 'dispatch;
	}
	// 821E44B4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E44B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821E44BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E44C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E44C4: 4E800421  bctrl
	ctx.lr = 0x821E44C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E44C8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E44F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E44F0 size=1940
    let mut pc: u32 = 0x821E44F0;
    'dispatch: loop {
        match pc {
            0x821E44F0 => {
    //   block [0x821E44F0..0x821E4C84)
	// 821E44F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E44F4: 48AC4EE9  bl 0x82ca93dc
	ctx.lr = 0x821E44F8;
	sub_82CA93D0(ctx, base);
	// 821E44F8: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821E44FC: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E4C88 size=1204
    let mut pc: u32 = 0x821E4C88;
    'dispatch: loop {
        match pc {
            0x821E4C88 => {
    //   block [0x821E4C88..0x821E513C)
	// 821E4C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E4C8C: 48AC4745  bl 0x82ca93d0
	ctx.lr = 0x821E4C90;
	sub_82CA93D0(ctx, base);
	// 821E4C90: 39600680  li r11, 0x680
	ctx.r[11].s64 = 1664;
	// 821E4C94: 9061FF00  stw r3, -0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-256 as u32), ctx.r[3].u32 ) };
	// 821E4C98: 3941FF40  addi r10, r1, -0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + -192;
	// 821E4C9C: 39200670  li r9, 0x670
	ctx.r[9].s64 = 1648;
	// 821E4CA0: 3901FF40  addi r8, r1, -0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + -192;
	// 821E4CA4: 38C1FF40  addi r6, r1, -0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5140 size=336
    let mut pc: u32 = 0x821E5140;
    'dispatch: loop {
        match pc {
            0x821E5140 => {
    //   block [0x821E5140..0x821E5290)
	// 821E5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5144: 48AC42C1  bl 0x82ca9404
	ctx.lr = 0x821E5148;
	sub_82CA93D0(ctx, base);
	// 821E5148: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E514C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E5150: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 821E5154: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E5158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E515C: 419A007C  beq cr6, 0x821e51d8
	if ctx.cr[6].eq {
	pc = 0x821E51D8; continue 'dispatch;
	}
	// 821E5160: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E5164: 419A0074  beq cr6, 0x821e51d8
	if ctx.cr[6].eq {
	pc = 0x821E51D8; continue 'dispatch;
	}
	// 821E5168: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E516C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 821E5170: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E5174: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5178: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E517C: 40990008  ble cr6, 0x821e5184
	if !ctx.cr[6].gt {
	pc = 0x821E5184; continue 'dispatch;
	}
	// 821E5180: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E5184: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5188: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821E518C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E5190: 41980008  blt cr6, 0x821e5198
	if ctx.cr[6].lt {
	pc = 0x821E5198; continue 'dispatch;
	}
	// 821E5194: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E5198: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E519C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E51A0: 41990008  bgt cr6, 0x821e51a8
	if ctx.cr[6].gt {
	pc = 0x821E51A8; continue 'dispatch;
	}
	// 821E51A4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E51A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E51AC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E51B0: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E51B4: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E51B8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E51BC: 484991F5  bl 0x8267e3b0
	ctx.lr = 0x821E51C0;
	sub_8267E3B0(ctx, base);
	// 821E51C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E51C4: 48499425  bl 0x8267e5e8
	ctx.lr = 0x821E51C8;
	sub_8267E5E8(ctx, base);
	// 821E51C8: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E51CC: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821E51D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E51D4: 409AFF8C  bne cr6, 0x821e5160
	if !ctx.cr[6].eq {
	pc = 0x821E5160; continue 'dispatch;
	}
	// 821E51D8: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 821E51DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E51E0: 484991D1  bl 0x8267e3b0
	ctx.lr = 0x821E51E4;
	sub_8267E3B0(ctx, base);
	// 821E51E4: 3BBE0020  addi r29, r30, 0x20
	ctx.r[29].s64 = ctx.r[30].s64 + 32;
	// 821E51E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E51EC: 484991C5  bl 0x8267e3b0
	ctx.lr = 0x821E51F0;
	sub_8267E3B0(ctx, base);
	// 821E51F0: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 821E51F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E51F8: 484991B9  bl 0x8267e3b0
	ctx.lr = 0x821E51FC;
	sub_8267E3B0(ctx, base);
	// 821E51FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5200: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E5204: 3B6B0B7C  addi r27, r11, 0xb7c
	ctx.r[27].s64 = ctx.r[11].s64 + 2940;
	// 821E5208: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E520C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5210: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E5214: 4BFAEC25  bl 0x82193e38
	ctx.lr = 0x821E5218;
	sub_82193E38(ctx, base);
	// 821E5218: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E521C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5220: 482ECCA9  bl 0x824d1ec8
	ctx.lr = 0x821E5224;
	sub_824D1EC8(ctx, base);
	// 821E5224: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E5228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E522C: 3BEA0B7C  addi r31, r10, 0xb7c
	ctx.r[31].s64 = ctx.r[10].s64 + 2940;
	// 821E5230: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5234: 4BFAEC05  bl 0x82193e38
	ctx.lr = 0x821E5238;
	sub_82193E38(ctx, base);
	// 821E5238: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E523C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E5240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5244: 4BFAEBF5  bl 0x82193e38
	ctx.lr = 0x821E5248;
	sub_82193E38(ctx, base);
	// 821E5248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E524C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E5250: 482ECC79  bl 0x824d1ec8
	ctx.lr = 0x821E5254;
	sub_824D1EC8(ctx, base);
	// 821E5254: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E525C: 4BFAEBDD  bl 0x82193e38
	ctx.lr = 0x821E5260;
	sub_82193E38(ctx, base);
	// 821E5260: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E5264: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E5268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E526C: 4BFAEBCD  bl 0x82193e38
	ctx.lr = 0x821E5270;
	sub_82193E38(ctx, base);
	// 821E5270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E5274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E5278: 482ECC51  bl 0x824d1ec8
	ctx.lr = 0x821E527C;
	sub_824D1EC8(ctx, base);
	// 821E527C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5284: 4BFAEBB5  bl 0x82193e38
	ctx.lr = 0x821E5288;
	sub_82193E38(ctx, base);
	// 821E5288: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E528C: 48AC41C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5290 size=104
    let mut pc: u32 = 0x821E5290;
    'dispatch: loop {
        match pc {
            0x821E5290 => {
    //   block [0x821E5290..0x821E52F8)
	// 821E5290: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821E5294: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 821E5298: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821E529C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E52A0: 55490529  rlwinm. r9, r10, 0, 0x14, 0x14
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821E52A4: 4082000C  bne 0x821e52b0
	if !ctx.cr[0].eq {
	pc = 0x821E52B0; continue 'dispatch;
	}
	// 821E52A8: 554A056B  rlwinm. r10, r10, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E52AC: 41820040  beq 0x821e52ec
	if ctx.cr[0].eq {
	pc = 0x821E52EC; continue 'dispatch;
	}
	// 821E52B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E52B4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E52B8: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E52BC: 394A5110  addi r10, r10, 0x5110
	ctx.r[10].s64 = ctx.r[10].s64 + 20752;
	// 821E52C0: 38E40020  addi r7, r4, 0x20
	ctx.r[7].s64 = ctx.r[4].s64 + 32;
	// 821E52C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821E52C8: 78E70020  clrldi r7, r7, 0x20
	ctx.r[7].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821E52CC: 78C6FFE6  rldicr r6, r6, 0x3f, 0x3f
	ctx.r[6].u64 = (ctx.r[6].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821E52D0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821E52D4: 7CC83C36  srd r8, r6, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[6].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821E52D8: 5149C90C  rlwimi r9, r10, 0x19, 4, 6
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(25) as u64) & 0x000000000E000000) | (ctx.r[9].u64 & 0xFFFFFFFFF1FFFFFF);
	// 821E52DC: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821E52E0: E9630018  ld r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 821E52E4: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 821E52E8: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 821E52EC: 7D632214  add r11, r3, r4
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 821E52F0: 98AB2E94  stb r5, 0x2e94(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11924 as u32), ctx.r[5].u8 ) };
	// 821E52F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E52F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E52F8 size=688
    let mut pc: u32 = 0x821E52F8;
    'dispatch: loop {
        match pc {
            0x821E52F8 => {
    //   block [0x821E52F8..0x821E55A8)
	// 821E52F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E52FC: 48AC4109  bl 0x82ca9404
	ctx.lr = 0x821E5300;
	sub_82CA93D0(ctx, base);
	// 821E5300: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821E5304: 48AC89C9  bl 0x82cadccc
	ctx.lr = 0x821E5308;
	sub_82CADCA0(ctx, base);
	// 821E5308: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E530C: F88100E0  std r4, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[4].u64 ) };
	// 821E5310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5314: F8A100E8  std r5, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[5].u64 ) };
	// 821E5318: C00100EC  lfs f0, 0xec(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E531C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821E5320: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821E5324: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E5328: 5528F87E  srwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E532C: 5507F87E  srwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E5330: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821E5334: 38CB0CF0  addi r6, r11, 0xcf0
	ctx.r[6].s64 = ctx.r[11].s64 + 3312;
	// 821E5338: 54E5FFBE  rlwinm r5, r7, 0x1f, 0x1e, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821E533C: 552307FE  clrlwi r3, r9, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821E5340: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821E5344: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821E5348: 39440CD0  addi r10, r4, 0xcd0
	ctx.r[10].s64 = ctx.r[4].s64 + 3280;
	// 821E534C: 7D2530AE  lbzx r9, r5, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821E5350: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821E5354: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821E5358: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 821E535C: 551B07FE  clrlwi r27, r8, 0x1f
	ctx.r[27].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 821E5360: 7CDE5A14  add r6, r30, r11
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821E5364: 7CABF050  subf r5, r11, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 821E5368: 7C8650AE  lbzx r4, r6, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821E536C: 7C6538AE  lbzx r3, r5, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821E5370: 7C9D0774  extsb r29, r4
	ctx.r[29].s64 = ctx.r[4].s8 as i64;
	// 821E5374: 7C7C0774  extsb r28, r3
	ctx.r[28].s64 = ctx.r[3].s8 as i64;
	// 821E5378: 409A0010  bne cr6, 0x821e5388
	if !ctx.cr[6].eq {
	pc = 0x821E5388; continue 'dispatch;
	}
	// 821E537C: C1A100E0  lfs f13, 0xe0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E5380: C00100E8  lfs f0, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5384: 4800000C  b 0x821e5390
	pc = 0x821E5390; continue 'dispatch;
	// 821E5388: C1A100E8  lfs f13, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E538C: C00100E0  lfs f0, 0xe0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5390: C18100E4  lfs f12, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E5394: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E5398: 409A0010  bne cr6, 0x821e53a8
	if !ctx.cr[6].eq {
	pc = 0x821E53A8; continue 'dispatch;
	}
	// 821E539C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E53A0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E53A4: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E53A8: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 821E53AC: FF406090  fmr f26, f12
	ctx.f[26].f64 = ctx.f[12].f64;
	// 821E53B0: FF206890  fmr f25, f13
	ctx.f[25].f64 = ctx.f[13].f64;
	// 821E53B4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E53B8: 48054AF9  bl 0x82239eb0
	ctx.lr = 0x821E53BC;
	sub_82239EB0(ctx, base);
	// 821E53BC: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821E53C0: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821E53C4: 48054AED  bl 0x82239eb0
	ctx.lr = 0x821E53C8;
	sub_82239EB0(ctx, base);
	// 821E53C8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E53CC: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821E53D0: 48054AE1  bl 0x82239eb0
	ctx.lr = 0x821E53D4;
	sub_82239EB0(ctx, base);
	// 821E53D4: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 821E53D8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E53DC: 48054BB5  bl 0x82239f90
	ctx.lr = 0x821E53E0;
	sub_82239F90(ctx, base);
	// 821E53E0: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 821E53E4: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821E53E8: 48054BA9  bl 0x82239f90
	ctx.lr = 0x821E53EC;
	sub_82239F90(ctx, base);
	// 821E53EC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E53F0: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821E53F4: 48054B9D  bl 0x82239f90
	ctx.lr = 0x821E53F8;
	sub_82239F90(ctx, base);
	// 821E53F8: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E53FC: FC1C0772  fmul f0, f28, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[28].f64 * ctx.f[29].f64;
	// 821E5400: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5404: FDBB0732  fmul f13, f27, f28
	ctx.f[13].f64 = ctx.f[27].f64 * ctx.f[28].f64;
	// 821E5408: 7D1E4A14  add r8, r30, r9
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 821E540C: FD810772  fmul f12, f1, f29
	ctx.f[12].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 821E5410: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E5414: FD6106F2  fmul f11, f1, f27
	ctx.f[11].f64 = ctx.f[1].f64 * ctx.f[27].f64;
	// 821E5418: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E541C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5420: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E5424: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5428: 7CFD4A14  add r7, r29, r9
	ctx.r[7].u64 = ctx.r[29].u64 + ctx.r[9].u64;
	// 821E542C: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E5430: 7CAAF214  add r5, r10, r30
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821E5434: 7C6AE214  add r3, r10, r28
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821E5438: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E543C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 821E5440: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5444: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821E5448: 54A5103A  slwi r5, r5, 2
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E544C: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5450: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E5454: 409A0094  bne cr6, 0x821e54e8
	if !ctx.cr[6].eq {
	pc = 0x821E54E8; continue 'dispatch;
	}
	// 821E5458: FD4C07F2  fmul f10, f12, f31
	ctx.f[10].f64 = ctx.f[12].f64 * ctx.f[31].f64;
	// 821E545C: FCC107B2  fmul f6, f1, f30
	ctx.f[6].f64 = ctx.f[1].f64 * ctx.f[30].f64;
	// 821E5460: FCFE0772  fmul f7, f30, f29
	ctx.f[7].f64 = ctx.f[30].f64 * ctx.f[29].f64;
	// 821E5464: FD3E0732  fmul f9, f30, f28
	ctx.f[9].f64 = ctx.f[30].f64 * ctx.f[28].f64;
	// 821E5468: FD1E06F2  fmul f8, f30, f27
	ctx.f[8].f64 = ctx.f[30].f64 * ctx.f[27].f64;
	// 821E546C: FCAB07FC  fnmsub f5, f11, f31, f0
	ctx.f[5].f64 = -(ctx.f[11].f64 * ctx.f[31].f64 - ctx.f[0].f64);
	// 821E5470: FC605FF8  fmsub f3, f0, f31, f11
	ctx.f[3].f64 = ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64;
	// 821E5474: FC8D67FA  fmadd f4, f13, f31, f12
	ctx.f[4].f64 = ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[12].f64;
	// 821E5478: FC40F818  frsp f2, f31
	ctx.f[2].f64 = (ctx.f[31].f64 as f32) as f64;
	// 821E547C: 7C44FD2E  stfsx f2, r4, r31
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5480: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E5484: FC205050  fneg f1, f10
	ctx.f[1].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5488: 5484103A  slwi r4, r4, 2
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E548C: FD403018  frsp f10, f6
	ctx.f[10].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821E5490: FD603818  frsp f11, f7
	ctx.f[11].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E5494: FC004850  fneg f0, f9
	ctx.f[0].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5498: FD804018  frsp f12, f8
	ctx.f[12].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E549C: 7D88FD2E  stfsx f12, r8, r31
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54A0: 7D66FD2E  stfsx f11, r6, r31
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54A4: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E54A8: 7CDC5214  add r6, r28, r10
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E54AC: 7D45FD2E  stfsx f10, r5, r31
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54B0: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E54B4: FD202818  frsp f9, f5
	ctx.f[9].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821E54B8: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E54BC: FD002018  frsp f8, f4
	ctx.f[8].f64 = (ctx.f[4].f64 as f32) as f64;
	// 821E54C0: 7D29FD2E  stfsx f9, r9, r31
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54C4: FCA01818  frsp f5, f3
	ctx.f[5].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821E54C8: FCE16828  fsub f7, f1, f13
	ctx.f[7].f64 = ctx.f[1].f64 - ctx.f[13].f64;
	// 821E54CC: FCC00018  frsp f6, f0
	ctx.f[6].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821E54D0: FC803818  frsp f4, f7
	ctx.f[4].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E54D4: 7C87FD2E  stfsx f4, r7, r31
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54D8: 7CC4FD2E  stfsx f6, r4, r31
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54DC: 7D03FD2E  stfsx f8, r3, r31
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54E0: 7CABFD2E  stfsx f5, r11, r31
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54E4: 48000088  b 0x821e556c
	pc = 0x821E556C; continue 'dispatch;
	// 821E54E8: FD5C07F2  fmul f10, f28, f31
	ctx.f[10].f64 = ctx.f[28].f64 * ctx.f[31].f64;
	// 821E54EC: FD2D67B8  fmsub f9, f13, f30, f12
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[12].f64;
	// 821E54F0: FD005FBA  fmadd f8, f0, f30, f11
	ctx.f[8].f64 = ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[11].f64;
	// 821E54F4: FCE107F2  fmul f7, f1, f31
	ctx.f[7].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 821E54F8: FCCB07BA  fmadd f6, f11, f30, f0
	ctx.f[6].f64 = ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[0].f64;
	// 821E54FC: FCAC6FB8  fmsub f5, f12, f30, f13
	ctx.f[5].f64 = ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64;
	// 821E5500: FC80F050  fneg f4, f30
	ctx.f[4].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5504: FC7B07F2  fmul f3, f27, f31
	ctx.f[3].f64 = ctx.f[27].f64 * ctx.f[31].f64;
	// 821E5508: FC5F0772  fmul f2, f31, f29
	ctx.f[2].f64 = ctx.f[31].f64 * ctx.f[29].f64;
	// 821E550C: FC205018  frsp f1, f10
	ctx.f[1].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821E5510: 7C24FD2E  stfsx f1, r4, r31
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5514: FC004818  frsp f0, f9
	ctx.f[0].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821E5518: 7C08FD2E  stfsx f0, r8, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E551C: FDA04018  frsp f13, f8
	ctx.f[13].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E5520: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E5524: 7DA6FD2E  stfsx f13, r6, r31
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5528: FD803818  frsp f12, f7
	ctx.f[12].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E552C: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E5530: 7D85FD2E  stfsx f12, r5, r31
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5534: 7CDC5214  add r6, r28, r10
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E5538: FD603018  frsp f11, f6
	ctx.f[11].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821E553C: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E5540: 7D69FD2E  stfsx f11, r9, r31
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5544: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E5548: FD402818  frsp f10, f5
	ctx.f[10].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821E554C: 54C3103A  slwi r3, r6, 2
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E5550: 7D47FD2E  stfsx f10, r7, r31
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5554: FD202018  frsp f9, f4
	ctx.f[9].f64 = (ctx.f[4].f64 as f32) as f64;
	// 821E5558: FD001818  frsp f8, f3
	ctx.f[8].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821E555C: 7D25FD2E  stfsx f9, r5, r31
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5560: FCE01018  frsp f7, f2
	ctx.f[7].f64 = (ctx.f[2].f64 as f32) as f64;
	// 821E5564: 7D04FD2E  stfsx f8, r4, r31
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5568: 7CE3FD2E  stfsx f7, r3, r31
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E556C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E5570: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 821E5574: C00B9490  lfs f0, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5578: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821E557C: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5580: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821E5584: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821E5588: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821E558C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E5590: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821E5594: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821E5598: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E559C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821E55A0: 48AC8779  bl 0x82cadd18
	ctx.lr = 0x821E55A4;
	sub_82CADCEC(ctx, base);
	// 821E55A4: 48AC3EB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E55A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E55A8 size=100
    let mut pc: u32 = 0x821E55A8;
    'dispatch: loop {
        match pc {
            0x821E55A8 => {
    //   block [0x821E55A8..0x821E560C)
	// 821E55A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E55AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E55B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E55B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E55B8: 4883EB29  bl 0x82a240e0
	ctx.lr = 0x821E55BC;
	sub_82A240E0(ctx, base);
	// 821E55BC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E55C0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E55C4: 40990024  ble cr6, 0x821e55e8
	if !ctx.cr[6].gt {
	pc = 0x821E55E8; continue 'dispatch;
	}
	// 821E55C8: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E55CC: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821E55D0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E55D4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E55D8: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E55DC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E55E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E55E4: 4199FFE4  bgt cr6, 0x821e55c8
	if ctx.cr[6].gt {
	pc = 0x821E55C8; continue 'dispatch;
	}
	// 821E55E8: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E55EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E55F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E55F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E55F8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E55FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E5600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5610 size=232
    let mut pc: u32 = 0x821E5610;
    'dispatch: loop {
        match pc {
            0x821E5610 => {
    //   block [0x821E5610..0x821E56F8)
	// 821E5610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E561C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E562C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E5630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5634: 419A0018  beq cr6, 0x821e564c
	if ctx.cr[6].eq {
	pc = 0x821E564C; continue 'dispatch;
	}
	// 821E5638: 93CB0550  stw r30, 0x550(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1360 as u32), ctx.r[30].u32 ) };
	// 821E563C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821E5640: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E5644: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821E5648: 48ACA3E9  bl 0x82cafa30
	ctx.lr = 0x821E564C;
	sub_82CAFA30(ctx, base);
	// 821E564C: 9BDF0006  stb r30, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[30].u8 ) };
	// 821E5650: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E5654: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E5658: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E565C: 419A0094  beq cr6, 0x821e56f0
	if ctx.cr[6].eq {
	pc = 0x821E56F0; continue 'dispatch;
	}
	// 821E5660: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E5664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5668: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821E566C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5670: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 821E5674: 48045DF5  bl 0x8222b468
	ctx.lr = 0x821E5678;
	sub_8222B468(ctx, base);
	// 821E5678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E567C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5680: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E5684: 4884E315  bl 0x82a33998
	ctx.lr = 0x821E5688;
	sub_82A33998(ctx, base);
	// 821E5688: A13F0036  lhz r9, 0x36(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(54 as u32) ) } as u64;
	// 821E568C: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E5690: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E5694: 995F0039  stb r10, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[10].u8 ) };
	// 821E5698: 2F084E20  cmpwi cr6, r8, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[8].s32, 20000, &mut ctx.xer);
	// 821E569C: B13F0034  sth r9, 0x34(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u16 ) };
	// 821E56A0: 40990030  ble cr6, 0x821e56d0
	if !ctx.cr[6].gt {
	pc = 0x821E56D0; continue 'dispatch;
	}
	// 821E56A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E56A8: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 821E56AC: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E56B0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E56B4: 7D6853D6  divw r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 821E56B8: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 821E56BC: 2F074E20  cmpwi cr6, r7, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20000, &mut ctx.xer);
	// 821E56C0: 40980010  bge cr6, 0x821e56d0
	if !ctx.cr[6].lt {
	pc = 0x821E56D0; continue 'dispatch;
	}
	// 821E56C4: 38804E20  li r4, 0x4e20
	ctx.r[4].s64 = 20000;
	// 821E56C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E56CC: 4884E50D  bl 0x82a33bd8
	ctx.lr = 0x821E56D0;
	sub_82A33BD8(ctx, base);
	// 821E56D0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E56D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E56D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E56DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821E56E0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821E56E4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E56E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E56EC: 4E800421  bctrl
	ctx.lr = 0x821E56F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E56F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E56F4: 48ACA875  bl 0x82caff68
	ctx.lr = 0x821E56F8;
	sub_82CAFF68(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E56F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E56F8 size=56
    let mut pc: u32 = 0x821E56F8;
    'dispatch: loop {
        match pc {
            0x821E56F8 => {
    //   block [0x821E56F8..0x821E5730)
	// 821E56F8: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	// 821E56FC: 90832E68  stw r4, 0x2e68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11880 as u32), ctx.r[4].u32 ) };
	// 821E5700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5704: 409A0008  bne cr6, 0x821e570c
	if !ctx.cr[6].eq {
	pc = 0x821E570C; continue 'dispatch;
	}
	// 821E5708: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E570C: 81632934  lwz r11, 0x2934(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821E5710: 508B07FE  rlwimi r11, r4, 0, 0x1f, 0x1f
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFFE);
	// 821E5714: 91632934  stw r11, 0x2934(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10548 as u32), ctx.r[11].u32 ) };
	// 821E5718: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821E571C: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 821E5720: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E5724: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 821E5728: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E572C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5730 size=224
    let mut pc: u32 = 0x821E5730;
    'dispatch: loop {
        match pc {
            0x821E5730 => {
    //   block [0x821E5730..0x821E5810)
	// 821E5730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E573C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5740: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5810 size=104
    let mut pc: u32 = 0x821E5810;
    'dispatch: loop {
        match pc {
            0x821E5810 => {
    //   block [0x821E5810..0x821E5878)
	// 821E5810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5814: 48AC3BF9  bl 0x82ca940c
	ctx.lr = 0x821E5818;
	sub_82CA93D0(ctx, base);
	// 821E5818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E581C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5820: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E5824: 392B0F94  addi r9, r11, 0xf94
	ctx.r[9].s64 = ctx.r[11].s64 + 3988;
	// 821E5828: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 821E582C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5830: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E5834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E5838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E583C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E5840: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5844: 4801D515  bl 0x82202d58
	ctx.lr = 0x821E5848;
	sub_82202D58(ctx, base);
	// 821E5848: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821E584C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E5850: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E5854: 38E82B90  addi r7, r8, 0x2b90
	ctx.r[7].s64 = ctx.r[8].s64 + 11152;
	// 821E5858: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E585C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821E5860: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5864: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E5868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821E586C: 4E800421  bctrl
	ctx.lr = 0x821E5870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E5870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5874: 48AC3BE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E5878 size=92
    let mut pc: u32 = 0x821E5878;
    'dispatch: loop {
        match pc {
            0x821E5878 => {
    //   block [0x821E5878..0x821E58D4)
	// 821E5878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E587C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5888: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E588C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821E5890: 4881AE39  bl 0x82a006c8
	ctx.lr = 0x821E5894;
	sub_82A006C8(ctx, base);
	// 821E5894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E5898: 419A0024  beq cr6, 0x821e58bc
	if ctx.cr[6].eq {
	pc = 0x821E58BC; continue 'dispatch;
	}
	// 821E589C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E58A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E58A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E58A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E58AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E58B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E58B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E58B8: 4E800020  blr
	return;
	// 821E58BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E58C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E58C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E58C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E58CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E58D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E58D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E58D8 size=152
    let mut pc: u32 = 0x821E58D8;
    'dispatch: loop {
        match pc {
            0x821E58D8 => {
    //   block [0x821E58D8..0x821E5970)
	// 821E58D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E58DC: 48AC3B31  bl 0x82ca940c
	ctx.lr = 0x821E58E0;
	sub_82CA93D0(ctx, base);
	// 821E58E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E58E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E58E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E58EC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 821E58F0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821E58F4: 386B0E48  addi r3, r11, 0xe48
	ctx.r[3].s64 = ctx.r[11].s64 + 3656;
	// 821E58F8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 821E58FC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5900: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E5904: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 821E5908: 4800E451  bl 0x821f3d58
	ctx.lr = 0x821E590C;
	sub_821F3D58(ctx, base);
	// 821E590C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E5910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E5914: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E5918: 48000059  bl 0x821e5970
	ctx.lr = 0x821E591C;
	sub_821E5970(ctx, base);
	// 821E591C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E5924: 419A0040  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5928: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E592C: 556A002E  rlwinm r10, r11, 0, 0, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E5930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E5934: 419A0030  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5938: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821E593C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5940: 419A0024  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5944: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E5948: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E594C: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5950: 806A6DA0  lwz r3, 0x6da0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821E5954: 7C88582E  lwzx r4, r8, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E5958: 4BFFE8F9  bl 0x821e4250
	ctx.lr = 0x821E595C;
	sub_821E4250(ctx, base);
	// 821E595C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5960: 48AC3AFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E5964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5968: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E596C: 48AC3AF0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5970 size=60
    let mut pc: u32 = 0x821E5970;
    'dispatch: loop {
        match pc {
            0x821E5970 => {
    //   block [0x821E5970..0x821E59AC)
	// 821E5970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5974: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 821E5978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E597C: 5569C23E  srwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E5980: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821E5984: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5988: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E598C: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821E5990: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E5994: 419A0034  beq cr6, 0x821e59c8
	if ctx.cr[6].eq {
		sub_821E59C8(ctx, base);
		return;
	}
	// 821E5998: 40980014  bge cr6, 0x821e59ac
	if !ctx.cr[6].lt {
		sub_821E59AC(ctx, base);
		return;
	}
	// 821E599C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E59A0: 419A0020  beq cr6, 0x821e59c0
	if ctx.cr[6].eq {
		sub_821E59AC(ctx, base);
		return;
	}
	// 821E59A4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821E59A8: 48000010  b 0x821e59b8
	sub_821E59AC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E59AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E59AC size=28
    let mut pc: u32 = 0x821E59AC;
    'dispatch: loop {
        match pc {
            0x821E59AC => {
    //   block [0x821E59AC..0x821E59C8)
	// 821E59AC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E59B0: 419A0010  beq cr6, 0x821e59c0
	if ctx.cr[6].eq {
	pc = 0x821E59C0; continue 'dispatch;
	}
	// 821E59B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821E59B8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E59BC: 4099FFC4  ble cr6, 0x821e5980
	if !ctx.cr[6].gt {
		sub_821E5970(ctx, base);
		return;
	}
	// 821E59C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E59C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E59C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E59C8 size=64
    let mut pc: u32 = 0x821E59C8;
    'dispatch: loop {
        match pc {
            0x821E59C8 => {
    //   block [0x821E59C8..0x821E5A08)
	// 821E59C8: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E59CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E59D0: 419A0030  beq cr6, 0x821e5a00
	if ctx.cr[6].eq {
	pc = 0x821E5A00; continue 'dispatch;
	}
	// 821E59D4: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E59D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E59DC: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821E59E0: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E59E4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E59E8: 409A0018  bne cr6, 0x821e5a00
	if !ctx.cr[6].eq {
	pc = 0x821E5A00; continue 'dispatch;
	}
	// 821E59EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E59F0: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E59F4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E59F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E59FC: 4199FFD8  bgt cr6, 0x821e59d4
	if ctx.cr[6].gt {
	pc = 0x821E59D4; continue 'dispatch;
	}
	// 821E5A00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E5A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5A08 size=184
    let mut pc: u32 = 0x821E5A08;
    'dispatch: loop {
        match pc {
            0x821E5A08 => {
    //   block [0x821E5A08..0x821E5AC0)
	// 821E5A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5A0C: 48AC39FD  bl 0x82ca9408
	ctx.lr = 0x821E5A10;
	sub_82CA93D0(ctx, base);
	// 821E5A10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5A14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E5A18: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E5A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E5A24: 419A0040  beq cr6, 0x821e5a64
	if ctx.cr[6].eq {
	pc = 0x821E5A64; continue 'dispatch;
	}
	// 821E5A28: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821E5A2C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821E5A30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E5A34: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E5A3C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 821E5A40: 4BFFFF31  bl 0x821e5970
	ctx.lr = 0x821E5A44;
	sub_821E5970(ctx, base);
	// 821E5A44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5A4C: 409A0024  bne cr6, 0x821e5a70
	if !ctx.cr[6].eq {
	pc = 0x821E5A70; continue 'dispatch;
	}
	// 821E5A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5A54: 4BFFFE85  bl 0x821e58d8
	ctx.lr = 0x821E5A58;
	sub_821E58D8(ctx, base);
	// 821E5A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E5A60: 409AFFCC  bne cr6, 0x821e5a2c
	if !ctx.cr[6].eq {
	pc = 0x821E5A2C; continue 'dispatch;
	}
	// 821E5A64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5A68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5A6C: 48AC39EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821E5A70: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A74: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E5A78: 556BC23E  srwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5A7C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E5A84: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821E5A88: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A8C: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E5A90: 54E4002E  rlwinm r4, r7, 0, 0, 0x17
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E5A94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E5A98: 7C6530AE  lbzx r3, r5, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821E5A9C: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 821E5AA0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E5AA4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821E5AA8: 409A0008  bne cr6, 0x821e5ab0
	if !ctx.cr[6].eq {
	pc = 0x821E5AB0; continue 'dispatch;
	}
	// 821E5AAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E5AB0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5AB4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5AB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5ABC: 48AC399C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5AC0 size=20
    let mut pc: u32 = 0x821E5AC0;
    'dispatch: loop {
        match pc {
            0x821E5AC0 => {
    //   block [0x821E5AC0..0x821E5AD4)
	// 821E5AC0: 39650006  addi r11, r5, 6
	ctx.r[11].s64 = ctx.r[5].s64 + 6;
	// 821E5AC4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5AC8: 7D6A202E  lwzx r11, r10, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 821E5ACC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5AD0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5AD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5AD4 size=84
    let mut pc: u32 = 0x821E5AD4;
    'dispatch: loop {
        match pc {
            0x821E5AD4 => {
    //   block [0x821E5AD4..0x821E5B28)
	// 821E5AD4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E5AD8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821E5ADC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821E5AE0: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821E5AE4: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E5AE8: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821E5AEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821E5AF0: 419A0024  beq cr6, 0x821e5b14
	if ctx.cr[6].eq {
	pc = 0x821E5B14; continue 'dispatch;
	}
	// 821E5AF4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5B28 size=396
    let mut pc: u32 = 0x821E5B28;
    'dispatch: loop {
        match pc {
            0x821E5B28 => {
    //   block [0x821E5B28..0x821E5CB4)
	// 821E5B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5B2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5B30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5B34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5B38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5B3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821E5B40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E5B44: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821E5B48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E5B4C: 419A00F4  beq cr6, 0x821e5c40
	if ctx.cr[6].eq {
	pc = 0x821E5C40; continue 'dispatch;
	}
	// 821E5B50: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E5B54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E5B58: 419A0024  beq cr6, 0x821e5b7c
	if ctx.cr[6].eq {
	pc = 0x821E5B7C; continue 'dispatch;
	}
	// 821E5B5C: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821E5B60: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E5B64: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E5B68: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5B6C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5B70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5B78: 480000CC  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
	// 821E5B7C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E5B80: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E5B84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5B88: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E5B8C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E5B90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5B94: 40810054  ble 0x821e5be8
	if !ctx.cr[0].gt {
	pc = 0x821E5BE8; continue 'dispatch;
	}
	// 821E5B98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E5B9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5BA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E5BA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5BA8: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821E5BAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E5BB0: 41980008  blt cr6, 0x821e5bb8
	if ctx.cr[6].lt {
	pc = 0x821E5BB8; continue 'dispatch;
	}
	// 821E5BB4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821E5BB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E5BBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E5BC0: 419A0014  beq cr6, 0x821e5bd4
	if ctx.cr[6].eq {
	pc = 0x821E5BD4; continue 'dispatch;
	}
	// 821E5BC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E5BC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E5BCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E5BD0: 4800000C  b 0x821e5bdc
	pc = 0x821E5BDC; continue 'dispatch;
	// 821E5BD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E5BD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E5BDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5BE0: 4199FFB8  bgt cr6, 0x821e5b98
	if ctx.cr[6].gt {
	pc = 0x821E5B98; continue 'dispatch;
	}
	// 821E5BE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E5BE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E5BEC: 419A0040  beq cr6, 0x821e5c2c
	if ctx.cr[6].eq {
	pc = 0x821E5C2C; continue 'dispatch;
	}
	// 821E5BF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5BF4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821E5BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5BFC: 41990008  bgt cr6, 0x821e5c04
	if ctx.cr[6].gt {
	pc = 0x821E5C04; continue 'dispatch;
	}
	// 821E5C00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E5C04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C0C: 409A0020  bne cr6, 0x821e5c2c
	if !ctx.cr[6].eq {
	pc = 0x821E5C2C; continue 'dispatch;
	}
	// 821E5C10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E5C14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E5C18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E5C1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5C20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5C28: 4800001C  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
	// 821E5C2C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E5C30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5C34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5C38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5C3C: 48000008  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
	// 821E5C40: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E5C44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C4C: 419A0050  beq cr6, 0x821e5c9c
	if ctx.cr[6].eq {
	pc = 0x821E5C9C; continue 'dispatch;
	}
	// 821E5C50: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 821E5C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5C58: 48019971  bl 0x821ff5c8
	ctx.lr = 0x821E5C5C;
	sub_821FF5C8(ctx, base);
	// 821E5C5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C64: 419A001C  beq cr6, 0x821e5c80
	if ctx.cr[6].eq {
	pc = 0x821E5C80; continue 'dispatch;
	}
	// 821E5C68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5C6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E5C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E5C7C: 4E800020  blr
	return;
	// 821E5C80: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 821E5C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5C88: 48019941  bl 0x821ff5c8
	ctx.lr = 0x821E5C8C;
	sub_821FF5C8(ctx, base);
	// 821E5C8C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5C90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C98: 409A0008  bne cr6, 0x821e5ca0
	if !ctx.cr[6].eq {
	pc = 0x821E5CA0; continue 'dispatch;
	}
	// 821E5C9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E5CA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E5CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E5CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E5CB8 size=156
    let mut pc: u32 = 0x821E5CB8;
    'dispatch: loop {
        match pc {
            0x821E5CB8 => {
    //   block [0x821E5CB8..0x821E5D54)
	// 821E5CB8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821E5CBC: C80300F0  lfd f0, 0xf0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) };
	// 821E5CC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E5CC4: 394A9484  addi r10, r10, -0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + -27516;
	// 821E5CC8: 396300F0  addi r11, r3, 0xf0
	ctx.r[11].s64 = ctx.r[3].s64 + 240;
	// 821E5CCC: C9890D38  lfd f12, 0xd38(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821E5CD0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E5CD4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821E5CD8: 419A0068  beq cr6, 0x821e5d40
	if ctx.cr[6].eq {
	pc = 0x821E5D40; continue 'dispatch;
	}
	// 821E5CDC: C96B0008  lfd f11, 8(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821E5CE0: FD6B0028  fsub f11, f11, f0
	ctx.f[11].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821E5CE4: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821E5CE8: 40990058  ble cr6, 0x821e5d40
	if !ctx.cr[6].gt {
	pc = 0x821E5D40; continue 'dispatch;
	}
	// 821E5CEC: FD810028  fsub f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 - ctx.f[0].f64;
	// 821E5CF0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5CF4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821E5CF8: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 821E5CFC: FD6C5824  fdiv f11, f12, f11
	ctx.f[11].f64 = ctx.f[12].f64 / ctx.f[11].f64;
	// 821E5D00: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E5D04: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 821E5D08: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E5D0C: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821E5D10: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821E5D14: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 821E5D18: 7D292C2E  lfsx f9, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821E5D1C: FD0902AE  fsel f8, f9, f10, f0
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[0].f64 };
	// 821E5D20: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E5D24: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 821E5D28: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E5D2C: 548ADF7A  rlwinm r10, r4, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821E5D30: 5488F77A  rlwinm r8, r4, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821E5D34: 7D474378  or r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 821E5D38: 7CC93C2E  lfsx f6, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821E5D3C: FDA6436E  fsel f13, f6, f13, f8
	ctx.f[13].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[8].f64 };
	// 821E5D40: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5D44: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E5D48: 409A000C  bne cr6, 0x821e5d54
	if !ctx.cr[6].eq {
		sub_821E5D54(ctx, base);
		return;
	}
	// 821E5D4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E5D50: 4800000C  b 0x821e5d5c
	sub_821E5D54(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5D54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E5D54 size=20
    let mut pc: u32 = 0x821E5D54;
    'dispatch: loop {
        match pc {
            0x821E5D54 => {
    //   block [0x821E5D54..0x821E5D68)
	// 821E5D54: D1AB0010  stfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E5D58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5D5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5D64: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E5D68 size=76
    let mut pc: u32 = 0x821E5D68;
    'dispatch: loop {
        match pc {
            0x821E5D68 => {
    //   block [0x821E5D68..0x821E5DB4)
	// 821E5D68: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 821E5D6C: C0030100  lfs f0, 0x100(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5D70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821E5D74: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821E5D78: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 821E5D7C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5DB8 size=2136
    let mut pc: u32 = 0x821E5DB8;
    'dispatch: loop {
        match pc {
            0x821E5DB8 => {
    //   block [0x821E5DB8..0x821E6610)
	// 821E5DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5DBC: 48AC3619  bl 0x82ca93d4
	ctx.lr = 0x821E5DC0;
	sub_82CA93D0(ctx, base);
	// 821E5DC0: DBA1FF58  stfd f29, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[29].u64 ) };
	// 821E5DC4: DBC1FF60  stfd f30, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 821E5DC8: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 821E5DCC: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6610 size=212
    let mut pc: u32 = 0x821E6610;
    'dispatch: loop {
        match pc {
            0x821E6610 => {
    //   block [0x821E6610..0x821E66E4)
	// 821E6610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6614: 48AC2DE9  bl 0x82ca93fc
	ctx.lr = 0x821E6618;
	sub_82CA93D0(ctx, base);
	// 821E6618: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E661C: E8630028  ld r3, 0x28(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	// 821E6620: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E6624: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E6628: 486E1F51  bl 0x828c8578
	ctx.lr = 0x821E662C;
	sub_828C8578(ctx, base);
	// 821E662C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E6630: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E6634: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6638: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 821E663C: 39091220  addi r8, r9, 0x1220
	ctx.r[8].s64 = ctx.r[9].s64 + 4640;
	// 821E6640: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E6644: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E6648: 7CC7E3D7  divw. r6, r7, r28
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E66E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E66E8 size=8
    let mut pc: u32 = 0x821E66E8;
    'dispatch: loop {
        match pc {
            0x821E66E8 => {
    //   block [0x821E66E8..0x821E66F0)
	// 821E66E8: C0230100  lfs f1, 0x100(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E66EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E66F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E66F0 size=88
    let mut pc: u32 = 0x821E66F0;
    'dispatch: loop {
        match pc {
            0x821E66F0 => {
    //   block [0x821E66F0..0x821E6748)
	// 821E66F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E66F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E66F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E66FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6700: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 821E6704: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E6708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E670C: 419A0028  beq cr6, 0x821e6734
	if ctx.cr[6].eq {
	pc = 0x821E6734; continue 'dispatch;
	}
	// 821E6710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6714: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6718: 419A0018  beq cr6, 0x821e6730
	if ctx.cr[6].eq {
	pc = 0x821E6730; continue 'dispatch;
	}
	// 821E671C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E6720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E672C: 4E800020  blr
	return;
	// 821E6730: 4BFAD709  bl 0x82193e38
	ctx.lr = 0x821E6734;
	sub_82193E38(ctx, base);
	// 821E6734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6738: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E673C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6748 size=128
    let mut pc: u32 = 0x821E6748;
    'dispatch: loop {
        match pc {
            0x821E6748 => {
    //   block [0x821E6748..0x821E67C8)
	// 821E6748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E674C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E6754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E675C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6760: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821E6764: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821E6768: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E676C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E6770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6774: 419A0008  beq cr6, 0x821e677c
	if ctx.cr[6].eq {
	pc = 0x821E677C; continue 'dispatch;
	}
	// 821E6778: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E677C: 4800004D  bl 0x821e67c8
	ctx.lr = 0x821E6780;
	sub_821E67C8(ctx, base);
	// 821E6780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E6784: 419A0028  beq cr6, 0x821e67ac
	if ctx.cr[6].eq {
	pc = 0x821E67AC; continue 'dispatch;
	}
	// 821E6788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E678C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6790: 409A0010  bne cr6, 0x821e67a0
	if !ctx.cr[6].eq {
	pc = 0x821E67A0; continue 'dispatch;
	}
	// 821E6794: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E6798: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E679C: 48000014  b 0x821e67b0
	pc = 0x821E67B0; continue 'dispatch;
	// 821E67A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67A4: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E67A8: 48000008  b 0x821e67b0
	pc = 0x821E67B0; continue 'dispatch;
	// 821E67AC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821E67B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E67B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E67B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E67BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E67C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E67C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E67C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E67C8 size=12
    let mut pc: u32 = 0x821E67C8;
    'dispatch: loop {
        match pc {
            0x821E67C8 => {
    //   block [0x821E67C8..0x821E67D4)
	// 821E67C8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E67D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E67D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E67D4 size=84
    let mut pc: u32 = 0x821E67D4;
    'dispatch: loop {
        match pc {
            0x821E67D4 => {
    //   block [0x821E67D4..0x821E6828)
	// 821E67D4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67D8: 7D6A0775  extsb. r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67DC: 41820060  beq 0x821e683c
	if ctx.cr[0].eq {
		sub_821E6828(ctx, base);
		return;
	}
	// 821E67E0: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 821E67E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821E67E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67EC: 419A0030  beq cr6, 0x821e681c
	if ctx.cr[6].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	// 821E67F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67F4: 7D4A0775  extsb. r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67F8: 41820024  beq 0x821e681c
	if ctx.cr[0].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	// 821E67FC: 7D0958AE  lbzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E6800: 7D080774  extsb r8, r8
	ctx.r[8].s64 = ctx.r[8].s8 as i64;
	// 821E6804: 7D4A4051  subf. r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6808: 40820014  bne 0x821e681c
	if !ctx.cr[0].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	// 821E680C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E6810: 7D4958AE  lbzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E6814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6818: 409AFFD8  bne cr6, 0x821e67f0
	if !ctx.cr[6].eq {
	pc = 0x821E67F0; continue 'dispatch;
	}
	// 821E681C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6824: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E6828 size=28
    let mut pc: u32 = 0x821E6828;
    'dispatch: loop {
        match pc {
            0x821E6828 => {
    //   block [0x821E6828..0x821E6844)
	// 821E6828: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821E682C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6830: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6834: 7D6A0775  extsb. r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6838: 4082FFAC  bne 0x821e67e4
	if !ctx.cr[0].eq {
		sub_821E67D4(ctx, base);
		return;
	}
	// 821E683C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6848 size=356
    let mut pc: u32 = 0x821E6848;
    'dispatch: loop {
        match pc {
            0x821E6848 => {
    //   block [0x821E6848..0x821E69AC)
	// 821E6848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E684C: 48AC2BAD  bl 0x82ca93f8
	ctx.lr = 0x821E6850;
	sub_82CA93D0(ctx, base);
	// 821E6850: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6854: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E6858: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821E685C: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 821E6860: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E6864: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821E6868: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821E686C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821E6870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E6874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6878: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E687C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E6880: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E6884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6888: 4082FFE8  bne 0x821e6870
	if !ctx.cr[0].eq {
	pc = 0x821E6870; continue 'dispatch;
	}
	// 821E688C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821E6890: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6894: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821E6898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E689C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 821E68A0: 419A0008  beq cr6, 0x821e68a8
	if ctx.cr[6].eq {
	pc = 0x821E68A8; continue 'dispatch;
	}
	// 821E68A4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E68A8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E68AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E68B0: 419A0008  beq cr6, 0x821e68b8
	if ctx.cr[6].eq {
	pc = 0x821E68B8; continue 'dispatch;
	}
	// 821E68B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E68B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E68BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E68C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821E68C4: 4BFFFF05  bl 0x821e67c8
	ctx.lr = 0x821E68C8;
	sub_821E67C8(ctx, base);
	// 821E68C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E68CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E68D0: 419A009C  beq cr6, 0x821e696c
	if ctx.cr[6].eq {
	pc = 0x821E696C; continue 'dispatch;
	}
	// 821E68D4: 7CDCF850  subf r6, r28, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 821E68D8: 7CBCE850  subf r5, r28, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 821E68DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E68E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E68E4: 4BFFD4AD  bl 0x821e3d90
	ctx.lr = 0x821E68E8;
	sub_821E3D90(ctx, base);
	// 821E68E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E68EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E68F0: 48005F09  bl 0x821ec7f8
	ctx.lr = 0x821E68F4;
	sub_821EC7F8(ctx, base);
	// 821E68F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E68F8: 4BFDFE71  bl 0x821c6768
	ctx.lr = 0x821E68FC;
	sub_821C6768(ctx, base);
	// 821E68FC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821E6900: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E6904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6908: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E690C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6910: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E6914: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6918: 4082FFE8  bne 0x821e6900
	if !ctx.cr[0].eq {
	pc = 0x821E6900; continue 'dispatch;
	}
	// 821E691C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E6920: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 821E6924: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6928: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E692C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6930: 409AFFF4  bne cr6, 0x821e6924
	if !ctx.cr[6].eq {
	pc = 0x821E6924; continue 'dispatch;
	}
	// 821E6934: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821E6938: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E693C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6944: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E6948: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E694C: 48005EAD  bl 0x821ec7f8
	ctx.lr = 0x821E6950;
	sub_821EC7F8(ctx, base);
	// 821E6950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E6954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E6958: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821E695C: 4BFFFE6D  bl 0x821e67c8
	ctx.lr = 0x821E6960;
	sub_821E67C8(ctx, base);
	// 821E6960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6964: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E6968: 409AFF6C  bne cr6, 0x821e68d4
	if !ctx.cr[6].eq {
	pc = 0x821E68D4; continue 'dispatch;
	}
	// 821E696C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E6970: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E6974: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E6978: 48046559  bl 0x8222ced0
	ctx.lr = 0x821E697C;
	sub_8222CED0(ctx, base);
	// 821E697C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E6980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6984: 48005E75  bl 0x821ec7f8
	ctx.lr = 0x821E6988;
	sub_821EC7F8(ctx, base);
	// 821E6988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E698C: 4802E44D  bl 0x82214dd8
	ctx.lr = 0x821E6990;
	sub_82214DD8(ctx, base);
	// 821E6990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6994: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E6998: 4807E809  bl 0x822651a0
	ctx.lr = 0x821E699C;
	sub_822651A0(ctx, base);
	// 821E699C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E69A0: 4802E439  bl 0x82214dd8
	ctx.lr = 0x821E69A4;
	sub_82214DD8(ctx, base);
	// 821E69A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E69A8: 48AC2AA0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E69B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E69B0 size=8
    let mut pc: u32 = 0x821E69B0;
    'dispatch: loop {
        match pc {
            0x821E69B0 => {
    //   block [0x821E69B0..0x821E69B8)
	// 821E69B0: 88630045  lbz r3, 0x45(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(69 as u32) ) } as u64;
	// 821E69B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E69B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E69B8 size=372
    let mut pc: u32 = 0x821E69B8;
    'dispatch: loop {
        match pc {
            0x821E69B8 => {
    //   block [0x821E69B8..0x821E6B2C)
	// 821E69B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E69BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E69C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E69C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E69C8: 419A0018  beq cr6, 0x821e69e0
	if ctx.cr[6].eq {
	pc = 0x821E69E0; continue 'dispatch;
	}
	// 821E69CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E69D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E69D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E69D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E69DC: 409A0008  bne cr6, 0x821e69e4
	if !ctx.cr[6].eq {
	pc = 0x821E69E4; continue 'dispatch;
	}
	// 821E69E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E69E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E69E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E69EC: 419A012C  beq cr6, 0x821e6b18
	if ctx.cr[6].eq {
	pc = 0x821E6B18; continue 'dispatch;
	}
	// 821E69F0: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E69F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E69F8: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821E69FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E6A00: 419A00E8  beq cr6, 0x821e6ae8
	if ctx.cr[6].eq {
	pc = 0x821E6AE8; continue 'dispatch;
	}
	// 821E6A04: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E6A08: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E6A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6A10: 419A001C  beq cr6, 0x821e6a2c
	if ctx.cr[6].eq {
	pc = 0x821E6A2C; continue 'dispatch;
	}
	// 821E6A14: 896B0047  lbz r11, 0x47(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 821E6A18: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821E6A1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E6A20: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6A24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6A28: 480000C4  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
	// 821E6A2C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E6A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E6A34: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E6A38: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E6A3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E6A40: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6A44: 40810054  ble 0x821e6a98
	if !ctx.cr[0].gt {
	pc = 0x821E6A98; continue 'dispatch;
	}
	// 821E6A48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E6A4C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E6A50: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E6A54: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6A58: 2F070047  cmpwi cr6, r7, 0x47
	ctx.cr[6].compare_i32(ctx.r[7].s32, 71, &mut ctx.xer);
	// 821E6A5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E6A60: 41980008  blt cr6, 0x821e6a68
	if ctx.cr[6].lt {
	pc = 0x821E6A68; continue 'dispatch;
	}
	// 821E6A64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E6A68: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E6A6C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E6A70: 419A0014  beq cr6, 0x821e6a84
	if ctx.cr[6].eq {
	pc = 0x821E6A84; continue 'dispatch;
	}
	// 821E6A74: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E6A78: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E6A7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6A80: 4800000C  b 0x821e6a8c
	pc = 0x821E6A8C; continue 'dispatch;
	// 821E6A84: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E6A88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E6A8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6A90: 4199FFB8  bgt cr6, 0x821e6a48
	if ctx.cr[6].gt {
	pc = 0x821E6A48; continue 'dispatch;
	}
	// 821E6A94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E6A98: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E6A9C: 419A003C  beq cr6, 0x821e6ad8
	if ctx.cr[6].eq {
	pc = 0x821E6AD8; continue 'dispatch;
	}
	// 821E6AA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6AA4: 2F0B0047  cmpwi cr6, r11, 0x47
	ctx.cr[6].compare_i32(ctx.r[11].s32, 71, &mut ctx.xer);
	// 821E6AA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E6AAC: 41990008  bgt cr6, 0x821e6ab4
	if ctx.cr[6].gt {
	pc = 0x821E6AB4; continue 'dispatch;
	}
	// 821E6AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E6AB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E6AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6ABC: 409A001C  bne cr6, 0x821e6ad8
	if !ctx.cr[6].eq {
	pc = 0x821E6AD8; continue 'dispatch;
	}
	// 821E6AC0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E6AC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6AC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E6ACC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6AD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6AD4: 48000018  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
	// 821E6AD8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E6ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6AE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6AE4: 48000008  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
	// 821E6AE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E6AEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E6AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6AF4: 419A0024  beq cr6, 0x821e6b18
	if ctx.cr[6].eq {
	pc = 0x821E6B18; continue 'dispatch;
	}
	// 821E6AF8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E6AFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E6B00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E6B04: 4E800421  bctrl
	ctx.lr = 0x821E6B08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E6B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6B14: 4E800020  blr
	return;
	// 821E6B18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6B1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E6B30 size=400
    let mut pc: u32 = 0x821E6B30;
    'dispatch: loop {
        match pc {
            0x821E6B30 => {
    //   block [0x821E6B30..0x821E6CC0)
	// 821E6B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6B38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6B3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6B44: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6B4C: 40990160  ble cr6, 0x821e6cac
	if !ctx.cr[6].gt {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6B50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6B54: 48020C9D  bl 0x822077f0
	ctx.lr = 0x821E6B58;
	sub_822077F0(ctx, base);
	// 821E6B58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E6B5C: 815F01A0  lwz r10, 0x1a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6B60: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E6B64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E6B68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6B6C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821E6B70: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821E6B74: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821E6B78: FDA10024  fdiv f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 821E6B7C: C0069484  lfs f0, -0x6b7c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6B80: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821E6B84: 40990054  ble cr6, 0x821e6bd8
	if !ctx.cr[6].gt {
	pc = 0x821E6BD8; continue 'dispatch;
	}
	// 821E6B88: 397F0238  addi r11, r31, 0x238
	ctx.r[11].s64 = ctx.r[31].s64 + 568;
	// 821E6B8C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6B90: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821E6B94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6B98: 4099001C  ble cr6, 0x821e6bb4
	if !ctx.cr[6].gt {
	pc = 0x821E6BB4; continue 'dispatch;
	}
	// 821E6B9C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821E6BA0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6BA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6BA8: 4199000C  bgt cr6, 0x821e6bb4
	if ctx.cr[6].gt {
	pc = 0x821E6BB4; continue 'dispatch;
	}
	// 821E6BAC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6BB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6BB4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E6BB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6BBC: 419A0008  beq cr6, 0x821e6bc4
	if ctx.cr[6].eq {
	pc = 0x821E6BC4; continue 'dispatch;
	}
	// 821E6BC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E6BC4: 815F01A0  lwz r10, 0x1a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6BC8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6BCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6BD0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E6BD4: 4198FFB8  blt cr6, 0x821e6b8c
	if ctx.cr[6].lt {
	pc = 0x821E6B8C; continue 'dispatch;
	}
	// 821E6BD8: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E6BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6BE0: 419A00CC  beq cr6, 0x821e6cac
	if ctx.cr[6].eq {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6BE4: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6BE8: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821E6BEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6BF0: 40990034  ble cr6, 0x821e6c24
	if !ctx.cr[6].gt {
	pc = 0x821E6C24; continue 'dispatch;
	}
	// 821E6BF4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E6BF8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821E6BFC: 395F0238  addi r10, r31, 0x238
	ctx.r[10].s64 = ctx.r[31].s64 + 568;
	// 821E6C00: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6C04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6C08: 40990010  ble cr6, 0x821e6c18
	if !ctx.cr[6].gt {
	pc = 0x821E6C18; continue 'dispatch;
	}
	// 821E6C0C: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6C10: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821E6C14: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821E6C18: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6C1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821E6C20: 4082FFE0  bne 0x821e6c00
	if !ctx.cr[0].eq {
	pc = 0x821E6C00; continue 'dispatch;
	}
	// 821E6C24: 395F0238  addi r10, r31, 0x238
	ctx.r[10].s64 = ctx.r[31].s64 + 568;
	// 821E6C28: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821E6C2C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E6C30: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E6C34: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821E6C38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6C3C: 4200FFF8  bdnz 0x821e6c34
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E6C34; continue 'dispatch;
	}
	// 821E6C40: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 821E6C44: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821E6C48: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821E6C4C: 40990028  ble cr6, 0x821e6c74
	if !ctx.cr[6].gt {
	pc = 0x821E6C74; continue 'dispatch;
	}
	// 821E6C50: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821E6C54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6C58: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6C5C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6C60: 80FF01A0  lwz r7, 0x1a0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6C64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6C68: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821E6C6C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821E6C70: 4198FFE4  blt cr6, 0x821e6c54
	if ctx.cr[6].lt {
	pc = 0x821E6C54; continue 'dispatch;
	}
	// 821E6C74: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821E6C78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E6C7C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 821E6C80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6C84: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821E6C88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6C8C: 48563E3D  bl 0x8274aac8
	ctx.lr = 0x821E6C90;
	sub_8274AAC8(ctx, base);
	// 821E6C90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6C94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6C98: 48563B09  bl 0x8274a7a0
	ctx.lr = 0x821E6C9C;
	sub_8274A7A0(ctx, base);
	// 821E6C9C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E6CA4: 419A0008  beq cr6, 0x821e6cac
	if ctx.cr[6].eq {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6CA8: 48035091  bl 0x8221bd38
	ctx.lr = 0x821E6CAC;
	sub_8221BD38(ctx, base);
	// 821E6CAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E6CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E6CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E6CC0 size=172
    let mut pc: u32 = 0x821E6CC0;
    'dispatch: loop {
        match pc {
            0x821E6CC0 => {
    //   block [0x821E6CC0..0x821E6D6C)
	// 821E6CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6CCC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E6D70 size=412
    let mut pc: u32 = 0x821E6D70;
    'dispatch: loop {
        match pc {
            0x821E6D70 => {
    //   block [0x821E6D70..0x821E6F0C)
	// 821E6D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6D74: 48AC2699  bl 0x82ca940c
	ctx.lr = 0x821E6D78;
	sub_82CA93D0(ctx, base);
	// 821E6D78: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821E6D7C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821E6D80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6D88: 897F026D  lbz r11, 0x26d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821E6D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6D90: 419A016C  beq cr6, 0x821e6efc
	if ctx.cr[6].eq {
	pc = 0x821E6EFC; continue 'dispatch;
	}
	// 821E6D94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6D98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E6D9C: 48020A55  bl 0x822077f0
	ctx.lr = 0x821E6DA0;
	sub_822077F0(ctx, base);
	// 821E6DA0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E6DA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6DA8: C1BF020C  lfs f13, 0x20c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6DAC: C19F0210  lfs f12, 0x210(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6DB0: 3BCBBE04  addi r30, r11, -0x41fc
	ctx.r[30].s64 = ctx.r[11].s64 + -16892;
	// 821E6DB4: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 821E6DB8: FD610024  fdiv f11, f1, f0
	ctx.f[11].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 821E6DBC: C3DED680  lfs f30, -0x2980(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10624 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821E6DC0: C3FED68C  lfs f31, -0x2974(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10612 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E6DC4: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 821E6DC8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E6DCC: EC0C6ABA  fmadds f0, f12, f10, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E6DD0: D01F020C  stfs f0, 0x20c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 821E6DD4: 40990020  ble cr6, 0x821e6df4
	if !ctx.cr[6].gt {
	pc = 0x821E6DF4; continue 'dispatch;
	}
	// 821E6DD8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E6DDC: 41980024  blt cr6, 0x821e6e00
	if ctx.cr[6].lt {
	pc = 0x821E6E00; continue 'dispatch;
	}
	// 821E6DE0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821E6DE4: D3FF020C  stfs f31, 0x20c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 821E6DE8: C00B1474  lfs f0, 0x1474(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6DEC: D01F0210  stfs f0, 0x210(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 821E6DF0: 48000010  b 0x821e6e00
	pc = 0x821E6E00; continue 'dispatch;
	// 821E6DF4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821E6DF8: 41990008  bgt cr6, 0x821e6e00
	if ctx.cr[6].gt {
	pc = 0x821E6E00; continue 'dispatch;
	}
	// 821E6DFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E6E00: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821E6E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6E08: 409A00C4  bne cr6, 0x821e6ecc
	if !ctx.cr[6].eq {
	pc = 0x821E6ECC; continue 'dispatch;
	}
	// 821E6E0C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E6E10: C01F0214  lfs f0, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E14: C1BF0218  lfs f13, 0x218(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E18: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E6E1C: C17F020C  lfs f11, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E6E20: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E6E24: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6E28: EC2C02FA  fmadds f1, f12, f11, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 821E6E2C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E6E30: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6E34: 83A80054  lwz r29, 0x54(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6E38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E6E3C: 48426F0D  bl 0x8260dd48
	ctx.lr = 0x821E6E40;
	sub_8260DD48(ctx, base);
	// 821E6E40: C1BED4C8  lfs f13, -0x2b38(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-11064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E44: C19F0220  lfs f12, 0x220(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6E48: C01F020C  lfs f0, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E4C: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 821E6E50: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821E6E54: 4098005C  bge cr6, 0x821e6eb0
	if !ctx.cr[6].lt {
	pc = 0x821E6EB0; continue 'dispatch;
	}
	// 821E6E58: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E6E5C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E60: ED4DF83C  fnmsubs f10, f13, f0, f31
	ctx.f[10].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 821E6E64: FF0AF800  fcmpu cr6, f10, f31
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[31].f64);
	// 821E6E68: 40980048  bge cr6, 0x821e6eb0
	if !ctx.cr[6].lt {
	pc = 0x821E6EB0; continue 'dispatch;
	}
	// 821E6E6C: C17F021C  lfs f11, 0x21c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E6E70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6E74: EC0C5828  fsubs f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821E6E78: C1AB9044  lfs f13, -0x6fbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E7C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821E6E80: 40980008  bge cr6, 0x821e6e88
	if !ctx.cr[6].lt {
	pc = 0x821E6E88; continue 'dispatch;
	}
	// 821E6E84: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821E6E88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6E8C: C18B9040  lfs f12, -0x6fc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6E90: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821E6E94: 40990008  ble cr6, 0x821e6e9c
	if !ctx.cr[6].gt {
	pc = 0x821E6E9C; continue 'dispatch;
	}
	// 821E6E98: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E6E9C: EC005ABA  fmadds f0, f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 821E6EA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E6EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6EA8: 4840F719  bl 0x825f65c0
	ctx.lr = 0x821E6EAC;
	sub_825F65C0(ctx, base);
	// 821E6EAC: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E6EB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E6EB4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821E6EB8: 48426F01  bl 0x8260ddb8
	ctx.lr = 0x821E6EBC;
	sub_8260DDB8(ctx, base);
	// 821E6EBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E6EC0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E6EC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821E6EC8: 48AC2594  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E6ECC: 897F026D  lbz r11, 0x26d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821E6ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6ED4: 419A0028  beq cr6, 0x821e6efc
	if ctx.cr[6].eq {
	pc = 0x821E6EFC; continue 'dispatch;
	}
	// 821E6ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E6EDC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E6EE0: 997F026D  stb r11, 0x26d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(621 as u32), ctx.r[11].u8 ) };
	// 821E6EE4: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E6EE8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6EEC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E6EF0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6EF4: 80670054  lwz r3, 0x54(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6EF8: 48426F29  bl 0x8260de20
	ctx.lr = 0x821E6EFC;
	sub_8260DE20(ctx, base);
	// 821E6EFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E6F00: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E6F04: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821E6F08: 48AC2554  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E6F10 size=1228
    let mut pc: u32 = 0x821E6F10;
    'dispatch: loop {
        match pc {
            0x821E6F10 => {
    //   block [0x821E6F10..0x821E73DC)
	// 821E6F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6F14: 48AC24F5  bl 0x82ca9408
	ctx.lr = 0x821E6F18;
	sub_82CA93D0(ctx, base);
	// 821E6F18: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E6F1C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E6F20: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E6F24: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E73E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E73E0 size=296
    let mut pc: u32 = 0x821E73E0;
    'dispatch: loop {
        match pc {
            0x821E73E0 => {
    //   block [0x821E73E0..0x821E7508)
	// 821E73E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E73E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E73E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E73EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E73F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E73F4: 897F026A  lbz r11, 0x26a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(618 as u32) ) } as u64;
	// 821E73F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E73FC: 419A0058  beq cr6, 0x821e7454
	if ctx.cr[6].eq {
	pc = 0x821E7454; continue 'dispatch;
	}
	// 821E7400: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E7404: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7408: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E740C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821E7410: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E7414: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7418: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E741C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7420: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E7424: 4BF8CF05  bl 0x82174328
	ctx.lr = 0x821E7428;
	sub_82174328(ctx, base);
	// 821E7428: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E742C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E7430: 409A0020  bne cr6, 0x821e7450
	if !ctx.cr[6].eq {
	pc = 0x821E7450; continue 'dispatch;
	}
	// 821E7434: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 821E7438: 997F026A  stb r11, 0x26a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(618 as u32), ctx.r[11].u8 ) };
	// 821E743C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E7440: 409A0010  bne cr6, 0x821e7450
	if !ctx.cr[6].eq {
	pc = 0x821E7450; continue 'dispatch;
	}
	// 821E7444: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E7448: C00A9240  lfs f0, -0x6dc0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E744C: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 821E7450: 997F026B  stb r11, 0x26b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(619 as u32), ctx.r[11].u8 ) };
	// 821E7454: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 821E7458: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E745C: 419A002C  beq cr6, 0x821e7488
	if ctx.cr[6].eq {
	pc = 0x821E7488; continue 'dispatch;
	}
	// 821E7460: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 821E7464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7468: 419A000C  beq cr6, 0x821e7474
	if ctx.cr[6].eq {
	pc = 0x821E7474; continue 'dispatch;
	}
	// 821E746C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E7470: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 821E7474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7478: 483572B1  bl 0x8253e728
	ctx.lr = 0x821E747C;
	sub_8253E728(ctx, base);
	// 821E747C: 48357515  bl 0x8253e990
	ctx.lr = 0x821E7480;
	sub_8253E990(ctx, base);
	// 821E7480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7484: 4835B8ED  bl 0x82542d70
	ctx.lr = 0x821E7488;
	sub_82542D70(ctx, base);
	// 821E7488: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E748C: C01F0234  lfs f0, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7490: C16B9484  lfs f11, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E7494: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E7498: 4099003C  ble cr6, 0x821e74d4
	if !ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E749C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E74A0: 48020351  bl 0x822077f0
	ctx.lr = 0x821E74A4;
	sub_822077F0(ctx, base);
	// 821E74A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E74A8: C01F0234  lfs f0, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E74AC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E74B0: C9AB9660  lfd f13, -0x69a0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821E74B4: FDA16824  fdiv f13, f1, f13
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[13].f64;
	// 821E74B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821E74BC: 40990018  ble cr6, 0x821e74d4
	if !ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E74C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E74C4: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 821E74C8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E74CC: 41990008  bgt cr6, 0x821e74d4
	if ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E74D0: D17F0234  stfs f11, 0x234(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 821E74D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74D8: 4BFFFA39  bl 0x821e6f10
	ctx.lr = 0x821E74DC;
	sub_821E6F10(ctx, base);
	// 821E74DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74E0: 4BFFF651  bl 0x821e6b30
	ctx.lr = 0x821E74E4;
	sub_821E6B30(ctx, base);
	// 821E74E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74E8: 4BFFF889  bl 0x821e6d70
	ctx.lr = 0x821E74EC;
	sub_821E6D70(ctx, base);
	// 821E74EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74F0: 4BFFF7D1  bl 0x821e6cc0
	ctx.lr = 0x821E74F4;
	sub_821E6CC0(ctx, base);
	// 821E74F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E74F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E74FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E7500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7508 size=88
    let mut pc: u32 = 0x821E7508;
    'dispatch: loop {
        match pc {
            0x821E7508 => {
    //   block [0x821E7508..0x821E7560)
	// 821E7508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E750C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7514: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7518: 8084007C  lwz r4, 0x7c(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E751C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E7520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7524: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E7528: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E752C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E7530: 4E800421  bctrl
	ctx.lr = 0x821E7534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E7534: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821E7538: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821E753C: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821E7540: 4800E619  bl 0x821f5b58
	ctx.lr = 0x821E7544;
	sub_821F5B58(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7560 size=196
    let mut pc: u32 = 0x821E7560;
    'dispatch: loop {
        match pc {
            0x821E7560 => {
    //   block [0x821E7560..0x821E7624)
	// 821E7560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E756C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E7574: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E7578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E757C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821E7580: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E7584: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E7588: 409A0018  bne cr6, 0x821e75a0
	if !ctx.cr[6].eq {
	pc = 0x821E75A0; continue 'dispatch;
	}
	// 821E758C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E7590: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E7594: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E7598: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E759C: 48000028  b 0x821e75c4
	pc = 0x821E75C4; continue 'dispatch;
	// 821E75A0: 81040010  lwz r8, 0x10(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E75A4: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 821E75A8: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E75AC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E75B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E75B4: 409A000C  bne cr6, 0x821e75c0
	if !ctx.cr[6].eq {
	pc = 0x821E75C0; continue 'dispatch;
	}
	// 821E75B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E75BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E75C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E75C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E75C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E75CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E75D0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E75D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E75D8: 419A0020  beq cr6, 0x821e75f8
	if ctx.cr[6].eq {
	pc = 0x821E75F8; continue 'dispatch;
	}
	// 821E75DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821E75E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E75E4: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E75E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E75EC: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E75F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E75F4: 4082FFE8  bne 0x821e75dc
	if !ctx.cr[0].eq {
	pc = 0x821E75DC; continue 'dispatch;
	}
	// 821E75F8: 552B07FE  clrlwi r11, r9, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821E75FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7600: 419A000C  beq cr6, 0x821e760c
	if ctx.cr[6].eq {
	pc = 0x821E760C; continue 'dispatch;
	}
	// 821E7604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7608: 4BFD0511  bl 0x821b7b18
	ctx.lr = 0x821E760C;
	sub_821B7B18(ctx, base);
	// 821E760C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7610: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E7614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E7618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E761C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7628 size=220
    let mut pc: u32 = 0x821E7628;
    'dispatch: loop {
        match pc {
            0x821E7628 => {
    //   block [0x821E7628..0x821E7704)
	// 821E7628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E762C: 48AC1DD5  bl 0x82ca9400
	ctx.lr = 0x821E7630;
	sub_82CA93D0(ctx, base);
	// 821E7630: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7634: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E7638: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821E763C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E7640: 392B6978  addi r9, r11, 0x6978
	ctx.r[9].s64 = ctx.r[11].s64 + 27000;
	// 821E7644: 3BDB0F38  addi r30, r27, 0xf38
	ctx.r[30].s64 = ctx.r[27].s64 + 3896;
	// 821E7648: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E764C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821E7650: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E7654: 3940000E  li r10, 0xe
	ctx.r[10].s64 = 14;
	// 821E7658: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 821E765C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E7660: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 821E7664: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E7668: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E766C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E7670: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821E7674: 4080FFEC  bge 0x821e7660
	if !ctx.cr[0].lt {
	pc = 0x821E7660; continue 'dispatch;
	}
	// 821E7678: 3BBB1028  addi r29, r27, 0x1028
	ctx.r[29].s64 = ctx.r[27].s64 + 4136;
	// 821E767C: 7FFBD050  subf r31, r27, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[27].s64;
	// 821E7680: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	// 821E7684: 7C9FF214  add r4, r31, r30
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 821E7688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E768C: 4800007D  bl 0x821e7708
	ctx.lr = 0x821E7690;
	sub_821E7708(ctx, base);
	// 821E7690: 7C1FEC2E  lfsx f0, r31, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7694: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7698: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821E769C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821E76A0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821E76A4: 4082FFE0  bne 0x821e7684
	if !ctx.cr[0].eq {
	pc = 0x821E7684; continue 'dispatch;
	}
	// 821E76A8: 38FA0C34  addi r7, r26, 0xc34
	ctx.r[7].s64 = ctx.r[26].s64 + 3124;
	// 821E76AC: 391A0020  addi r8, r26, 0x20
	ctx.r[8].s64 = ctx.r[26].s64 + 32;
	// 821E76B0: 395B0C30  addi r10, r27, 0xc30
	ctx.r[10].s64 = ctx.r[27].s64 + 3120;
	// 821E76B4: 397B0010  addi r11, r27, 0x10
	ctx.r[11].s64 = ctx.r[27].s64 + 16;
	// 821E76B8: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821E76BC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7708 size=568
    let mut pc: u32 = 0x821E7708;
    'dispatch: loop {
        match pc {
            0x821E7708 => {
    //   block [0x821E7708..0x821E7940)
	// 821E7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E770C: 48AC1D01  bl 0x82ca940c
	ctx.lr = 0x821E7710;
	sub_82CA93D0(ctx, base);
	// 821E7710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E7718: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E771C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E7720: 419A0214  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E7724: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7728: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E772C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7730: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821E7734: 7D471E71  srawi. r7, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821E7738: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E773C: 4082005C  bne 0x821e7798
	if !ctx.cr[0].eq {
	pc = 0x821E7798; continue 'dispatch;
	}
	// 821E7740: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7744: 419A01F0  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E7748: 7D0A5050  subf r8, r10, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 821E774C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E7750: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E7754: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7758: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E775C: 7CE84A14  add r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E7760: 419A0028  beq cr6, 0x821e7788
	if ctx.cr[6].eq {
	pc = 0x821E7788; continue 'dispatch;
	}
	// 821E7764: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821E7768: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E776C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821E7770: 7C095D2E  stfsx f0, r9, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821E7774: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7778: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E777C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7780: 7CC9412E  stwx r6, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 821E7784: 409AFFE4  bne cr6, 0x821e7768
	if !ctx.cr[6].eq {
	pc = 0x821E7768; continue 'dispatch;
	}
	// 821E7788: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821E778C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E7790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E7794: 48AC1CC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E7798: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821E779C: 7CCA1E70  srawi r10, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 821E77A0: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E77A4: 4199005C  bgt cr6, 0x821e7800
	if ctx.cr[6].gt {
	pc = 0x821E7800; continue 'dispatch;
	}
	// 821E77A8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E77AC: 419A0028  beq cr6, 0x821e77d4
	if ctx.cr[6].eq {
	pc = 0x821E77D4; continue 'dispatch;
	}
	// 821E77B0: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821E77B4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E77B8: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821E77BC: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821E77C0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E77C8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E77CC: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E77D0: 409AFFE4  bne cr6, 0x821e77b4
	if !ctx.cr[6].eq {
	pc = 0x821E77B4; continue 'dispatch;
	}
	// 821E77D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E77D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E77DC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77E0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77E4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E77E8: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E77EC: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E77F0: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E77F4: 90DD0008  stw r6, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821E77F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E77FC: 48AC1C60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E7800: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821E7804: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E7808: 409A000C  bne cr6, 0x821e7814
	if !ctx.cr[6].eq {
	pc = 0x821E7814; continue 'dispatch;
	}
	// 821E780C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E7810: 48000010  b 0x821e7820
	pc = 0x821E7820; continue 'dispatch;
	// 821E7814: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7818: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E781C: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E7820: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E7824: 41990084  bgt cr6, 0x821e78a8
	if ctx.cr[6].gt {
	pc = 0x821E78A8; continue 'dispatch;
	}
	// 821E7828: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E782C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E7830: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E7834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7838: 419A0024  beq cr6, 0x821e785c
	if ctx.cr[6].eq {
	pc = 0x821E785C; continue 'dispatch;
	}
	// 821E783C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7840: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7844: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7848: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E784C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E7850: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7854: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E7858: 409AFFE4  bne cr6, 0x821e783c
	if !ctx.cr[6].eq {
	pc = 0x821E783C; continue 'dispatch;
	}
	// 821E785C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7860: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E7864: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7868: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E786C: 419A002C  beq cr6, 0x821e7898
	if ctx.cr[6].eq {
	pc = 0x821E7898; continue 'dispatch;
	}
	// 821E7870: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E7874: 419A0014  beq cr6, 0x821e7888
	if ctx.cr[6].eq {
	pc = 0x821E7888; continue 'dispatch;
	}
	// 821E7878: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E787C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7880: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7884: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E7888: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E788C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E7890: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E7894: 409AFFDC  bne cr6, 0x821e7870
	if !ctx.cr[6].eq {
	pc = 0x821E7870; continue 'dispatch;
	}
	// 821E7898: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E789C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E78A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E78A4: 48AC1BB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E78A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E78AC: 419A000C  beq cr6, 0x821e78b8
	if ctx.cr[6].eq {
	pc = 0x821E78B8; continue 'dispatch;
	}
	// 821E78B0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821E78B4: 48034485  bl 0x8221bd38
	ctx.lr = 0x821E78B8;
	sub_8221BD38(ctx, base);
	// 821E78B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E78BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E78C0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821E78C4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E78C8: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821E78CC: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821E78D0: 7D241E71  srawi. r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E78D4: 4082000C  bne 0x821e78e0
	if !ctx.cr[0].eq {
	pc = 0x821E78E0; continue 'dispatch;
	}
	// 821E78D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E78DC: 4800000C  b 0x821e78e8
	pc = 0x821E78E8; continue 'dispatch;
	// 821E78E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E78E4: 48370535  bl 0x82557e18
	ctx.lr = 0x821E78E8;
	sub_82557E18(ctx, base);
	// 821E78E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E78EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E78F0: 419A0044  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E78F4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E78F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E78FC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7900: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E7904: 419A002C  beq cr6, 0x821e7930
	if ctx.cr[6].eq {
	pc = 0x821E7930; continue 'dispatch;
	}
	// 821E7908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E790C: 419A0014  beq cr6, 0x821e7920
	if ctx.cr[6].eq {
	pc = 0x821E7920; continue 'dispatch;
	}
	// 821E7910: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7914: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7918: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E791C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E7920: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E7924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E7928: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E792C: 409AFFDC  bne cr6, 0x821e7908
	if !ctx.cr[6].eq {
	pc = 0x821E7908; continue 'dispatch;
	}
	// 821E7930: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821E7934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E7938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E793C: 48AC1B20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7940 size=324
    let mut pc: u32 = 0x821E7940;
    'dispatch: loop {
        match pc {
            0x821E7940 => {
    //   block [0x821E7940..0x821E7A84)
	// 821E7940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E794C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7950: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E7958: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 821E795C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E7960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7964: 419A005C  beq cr6, 0x821e79c0
	if ctx.cr[6].eq {
	pc = 0x821E79C0; continue 'dispatch;
	}
	// 821E7968: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E796C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7970: 419A0050  beq cr6, 0x821e79c0
	if ctx.cr[6].eq {
	pc = 0x821E79C0; continue 'dispatch;
	}
	// 821E7974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E7978: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E797C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821E7980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7984: 4804554D  bl 0x8222ced0
	ctx.lr = 0x821E7988;
	sub_8222CED0(ctx, base);
	// 821E7988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E798C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E7990: 4807F819  bl 0x822671a8
	ctx.lr = 0x821E7994;
	sub_822671A8(ctx, base);
	// 821E7994: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E7998: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E799C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E79A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E79A4: 4BFF1C65  bl 0x821d9608
	ctx.lr = 0x821E79A8;
	sub_821D9608(ctx, base);
	// 821E79A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E79AC: 48A1E54D  bl 0x82c05ef8
	ctx.lr = 0x821E79B0;
	sub_82C05EF8(ctx, base);
	// 821E79B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E79B4: 480A2095  bl 0x82289a48
	ctx.lr = 0x821E79B8;
	sub_82289A48(ctx, base);
	// 821E79B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E79BC: 4802D41D  bl 0x82214dd8
	ctx.lr = 0x821E79C0;
	sub_82214DD8(ctx, base);
	// 821E79C0: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E79C4: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 821E79C8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E79CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E79D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E79D4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821E79D8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E79DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E79E0: 419A000C  beq cr6, 0x821e79ec
	if ctx.cr[6].eq {
	pc = 0x821E79EC; continue 'dispatch;
	}
	// 821E79E4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E79E8: 419A0008  beq cr6, 0x821e79f0
	if ctx.cr[6].eq {
	pc = 0x821E79F0; continue 'dispatch;
	}
	// 821E79EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E79F0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E79F4: 419A0078  beq cr6, 0x821e7a6c
	if ctx.cr[6].eq {
	pc = 0x821E7A6C; continue 'dispatch;
	}
	// 821E79F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E79FC: 409A0008  bne cr6, 0x821e7a04
	if !ctx.cr[6].eq {
	pc = 0x821E7A04; continue 'dispatch;
	}
	// 821E7A00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E7A04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7A08: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E7A0C: 409A0008  bne cr6, 0x821e7a14
	if !ctx.cr[6].eq {
	pc = 0x821E7A14; continue 'dispatch;
	}
	// 821E7A10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E7A14: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E7A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E7A1C: 419A002C  beq cr6, 0x821e7a48
	if ctx.cr[6].eq {
	pc = 0x821E7A48; continue 'dispatch;
	}
	// 821E7A20: 3889000C  addi r4, r9, 0xc
	ctx.r[4].s64 = ctx.r[9].s64 + 12;
	// 821E7A24: 488163A5  bl 0x829fddc8
	ctx.lr = 0x821E7A28;
	sub_829FDDC8(ctx, base);
	// 821E7A28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E7A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7A30: 419A0018  beq cr6, 0x821e7a48
	if ctx.cr[6].eq {
	pc = 0x821E7A48; continue 'dispatch;
	}
	// 821E7A34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7A38: 4836EE21  bl 0x82556858
	ctx.lr = 0x821E7A3C;
	sub_82556858(ctx, base);
	// 821E7A3C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7A40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E7A44: 4BFFFF94  b 0x821e79d8
	pc = 0x821E79D8; continue 'dispatch;
	// 821E7A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E7A4C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E7A50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E7A54: 48133DC5  bl 0x8231b818
	ctx.lr = 0x821E7A58;
	sub_8231B818(ctx, base);
	// 821E7A58: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821E7A5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E7A60: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7A64: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E7A68: 4BFFFF70  b 0x821e79d8
	pc = 0x821E79D8; continue 'dispatch;
	// 821E7A6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E7A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E7A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E7A78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E7A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7A88 size=904
    let mut pc: u32 = 0x821E7A88;
    'dispatch: loop {
        match pc {
            0x821E7A88 => {
    //   block [0x821E7A88..0x821E7E10)
	// 821E7A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7A8C: 48AC1955  bl 0x82ca93e0
	ctx.lr = 0x821E7A90;
	sub_82CA93D0(ctx, base);
	// 821E7A90: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7A94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E7A98: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821E7A9C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821E7AA0: 897E0052  lbz r11, 0x52(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(82 as u32) ) } as u64;
	// 821E7AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7AA8: 419A0360  beq cr6, 0x821e7e08
	if ctx.cr[6].eq {
	pc = 0x821E7E08; continue 'dispatch;
	}
	// 821E7AAC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E7AB0: 839A003C  lwz r28, 0x3c(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821E7AB4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821E7AB8: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821E7ABC: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
	// 821E7AC0: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821E7AC4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821E7AC8: 833C0004  lwz r25, 4(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7ACC: 831C0034  lwz r24, 0x34(r28)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E7AD0: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821E7AD4: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E7AD8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E7ADC: C0039490  lfs f0, -0x6b70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7AE0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821E7AE4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E7AE8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7E10 size=292
    let mut pc: u32 = 0x821E7E10;
    'dispatch: loop {
        match pc {
            0x821E7E10 => {
    //   block [0x821E7E10..0x821E7F34)
	// 821E7E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7E14: 48AC15E9  bl 0x82ca93fc
	ctx.lr = 0x821E7E18;
	sub_82CA93D0(ctx, base);
	// 821E7E18: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7E1C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E7E20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E7E24: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821E7E28: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E7E2C: 409A00AC  bne cr6, 0x821e7ed8
	if !ctx.cr[6].eq {
	pc = 0x821E7ED8; continue 'dispatch;
	}
	// 821E7E30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E7E38: 8343000C  lwz r26, 0xc(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7E3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E7E40: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821E7E44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E7E48: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E7E4C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E7E50: 419A00DC  beq cr6, 0x821e7f2c
	if ctx.cr[6].eq {
	pc = 0x821E7F2C; continue 'dispatch;
	}
	// 821E7E54: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821E7E58: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7E5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E7E60: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 821E7E64: 3BEB44B0  addi r31, r11, 0x44b0
	ctx.r[31].s64 = ctx.r[11].s64 + 17584;
	// 821E7E68: 3BCA1148  addi r30, r10, 0x1148
	ctx.r[30].s64 = ctx.r[10].s64 + 4424;
	// 821E7E6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7E70: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7E74: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821E7E78: 419A004C  beq cr6, 0x821e7ec4
	if ctx.cr[6].eq {
	pc = 0x821E7EC4; continue 'dispatch;
	}
	// 821E7E7C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E7F38 size=32
    let mut pc: u32 = 0x821E7F38;
    'dispatch: loop {
        match pc {
            0x821E7F38 => {
    //   block [0x821E7F38..0x821E7F58)
	// 821E7F38: 39610024  addi r11, r1, 0x24
	ctx.r[11].s64 = ctx.r[1].s64 + 36;
	// 821E7F3C: D0210024  stfs f1, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7F58 size=284
    let mut pc: u32 = 0x821E7F58;
    'dispatch: loop {
        match pc {
            0x821E7F58 => {
    //   block [0x821E7F58..0x821E8074)
	// 821E7F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7F64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7F68: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821E7F6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E7F70: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 821E7F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E7F78: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821E7F7C: 552B077C  rlwinm r11, r9, 0, 0x1d, 0x1e
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821E7F80: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821E7F84: 480000F5  bl 0x821e8078
	ctx.lr = 0x821E7F88;
	sub_821E8078(ctx, base);
	// 821E7F88: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E7F8C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E7F90: 419A00CC  beq cr6, 0x821e805c
	if ctx.cr[6].eq {
	pc = 0x821E805C; continue 'dispatch;
	}
	// 821E7F94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7F98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E7F9C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E7FA0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E7FA4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E7FA8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E7FAC: 4E800421  bctrl
	ctx.lr = 0x821E7FB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E7FB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E7FB4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821E7FB8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821E7FBC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E7FC0: 396B92D8  addi r11, r11, -0x6d28
	ctx.r[11].s64 = ctx.r[11].s64 + -27944;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8078 size=184
    let mut pc: u32 = 0x821E8078;
    'dispatch: loop {
        match pc {
            0x821E8078 => {
    //   block [0x821E8078..0x821E8130)
	// 821E8078: 54AB07BC  rlwinm r11, r5, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E807C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821E8080: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8084: 419A0018  beq cr6, 0x821e809c
	if ctx.cr[6].eq {
	pc = 0x821E809C; continue 'dispatch;
	}
	// 821E8088: 816A00B4  lwz r11, 0xb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821E808C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E8090: 419A0034  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E8094: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E8098: 419A002C  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E809C: 54AB077A  rlwinm r11, r5, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E80A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E80A4: 419A0050  beq cr6, 0x821e80f4
	if ctx.cr[6].eq {
	pc = 0x821E80F4; continue 'dispatch;
	}
	// 821E80A8: 816A00B4  lwz r11, 0xb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821E80AC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E80B0: 419A0014  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E80B4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E80B8: 419A000C  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E80BC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821E80C0: 409A0034  bne cr6, 0x821e80f4
	if !ctx.cr[6].eq {
	pc = 0x821E80F4; continue 'dispatch;
	}
	// 821E80C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E80C8: 39200210  li r9, 0x210
	ctx.r[9].s64 = 528;
	// 821E80CC: 390BA950  addi r8, r11, -0x56b0
	ctx.r[8].s64 = ctx.r[11].s64 + -22192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8130 size=32
    let mut pc: u32 = 0x821E8130;
    'dispatch: loop {
        match pc {
            0x821E8130 => {
    //   block [0x821E8130..0x821E8150)
	// 821E8130: 54AB0738  rlwinm r11, r5, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8134: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8138: 419A0010  beq cr6, 0x821e8148
	if ctx.cr[6].eq {
	pc = 0x821E8148; continue 'dispatch;
	}
	// 821E813C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8150 size=60
    let mut pc: u32 = 0x821E8150;
    'dispatch: loop {
        match pc {
            0x821E8150 => {
    //   block [0x821E8150..0x821E818C)
	// 821E8150: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821E8154: 419A0024  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8158: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821E815C: 419A001C  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8160: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E8164: 419A0014  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8168: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E816C: 419A000C  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8170: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E8174: 409A0018  bne cr6, 0x821e818c
	if !ctx.cr[6].eq {
		sub_821E818C(ctx, base);
		return;
	}
	// 821E8178: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 821E817C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E818C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E818C size=8
    let mut pc: u32 = 0x821E818C;
    'dispatch: loop {
        match pc {
            0x821E818C => {
    //   block [0x821E818C..0x821E8194)
	// 821E818C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8198 size=432
    let mut pc: u32 = 0x821E8198;
    'dispatch: loop {
        match pc {
            0x821E8198 => {
    //   block [0x821E8198..0x821E8348)
	// 821E8198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E819C: 48AC1271  bl 0x82ca940c
	ctx.lr = 0x821E81A0;
	sub_82CA93D0(ctx, base);
	// 821E81A0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821E81A4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821E81A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E81AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E81B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E81B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E81B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821E81BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E81C0: 4BFFFEB9  bl 0x821e8078
	ctx.lr = 0x821E81C4;
	sub_821E8078(ctx, base);
	// 821E81C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E81C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E81CC: 419A0164  beq cr6, 0x821e8330
	if ctx.cr[6].eq {
	pc = 0x821E8330; continue 'dispatch;
	}
	// 821E81D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E81D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E81D8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E81DC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E81E0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E81E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E81E8: 4E800421  bctrl
	ctx.lr = 0x821E81EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E81EC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821E81F0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821E81F4: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E81F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E81FC: 388690F0  addi r4, r6, -0x6f10
	ctx.r[4].s64 = ctx.r[6].s64 + -28432;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8348 size=300
    let mut pc: u32 = 0x821E8348;
    'dispatch: loop {
        match pc {
            0x821E8348 => {
    //   block [0x821E8348..0x821E8474)
	// 821E8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E834C: 48AC10C1  bl 0x82ca940c
	ctx.lr = 0x821E8350;
	sub_82CA93D0(ctx, base);
	// 821E8350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8354: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E8358: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E835C: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 821E8360: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 821E8364: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821E8368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E836C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E8370: 48825589  bl 0x82a0d8f8
	ctx.lr = 0x821E8374;
	sub_82A0D8F8(ctx, base);
	// 821E8374: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8378: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E837C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8380: 419A000C  beq cr6, 0x821e838c
	if ctx.cr[6].eq {
	pc = 0x821E838C; continue 'dispatch;
	}
	// 821E8384: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E8388: 419A0008  beq cr6, 0x821e8390
	if ctx.cr[6].eq {
	pc = 0x821E8390; continue 'dispatch;
	}
	// 821E838C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E8390: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8394: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8398: 419A0014  beq cr6, 0x821e83ac
	if ctx.cr[6].eq {
	pc = 0x821E83AC; continue 'dispatch;
	}
	// 821E839C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E83A0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E83A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E83A8: 48362B79  bl 0x8254af20
	ctx.lr = 0x821E83AC;
	sub_8254AF20(ctx, base);
	// 821E83AC: 815E0248  lwz r10, 0x248(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(584 as u32) ) } as u64;
	// 821E83B0: 3BFE0244  addi r31, r30, 0x244
	ctx.r[31].s64 = ctx.r[30].s64 + 580;
	// 821E83B4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E83B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E83BC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E83C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E83C4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E83C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E83CC: 419A000C  beq cr6, 0x821e83d8
	if ctx.cr[6].eq {
	pc = 0x821E83D8; continue 'dispatch;
	}
	// 821E83D0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E83D4: 419A0008  beq cr6, 0x821e83dc
	if ctx.cr[6].eq {
	pc = 0x821E83DC; continue 'dispatch;
	}
	// 821E83D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E83DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E83E0: 419A008C  beq cr6, 0x821e846c
	if ctx.cr[6].eq {
	pc = 0x821E846C; continue 'dispatch;
	}
	// 821E83E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E83E8: 409A0008  bne cr6, 0x821e83f0
	if !ctx.cr[6].eq {
	pc = 0x821E83F0; continue 'dispatch;
	}
	// 821E83EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E83F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E83F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E83F8: 409A0008  bne cr6, 0x821e8400
	if !ctx.cr[6].eq {
	pc = 0x821E8400; continue 'dispatch;
	}
	// 821E83FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E8400: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8404: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 821E8408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E840C: 419A0034  beq cr6, 0x821e8440
	if ctx.cr[6].eq {
	pc = 0x821E8440; continue 'dispatch;
	}
	// 821E8410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E8418: 419A003C  beq cr6, 0x821e8454
	if ctx.cr[6].eq {
	pc = 0x821E8454; continue 'dispatch;
	}
	// 821E841C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8424: 419A001C  beq cr6, 0x821e8440
	if ctx.cr[6].eq {
	pc = 0x821E8440; continue 'dispatch;
	}
	// 821E8428: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E842C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E8430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8434: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8438: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E843C: 4E800421  bctrl
	ctx.lr = 0x821E8440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E8440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E8444: 488B40D5  bl 0x82a9c518
	ctx.lr = 0x821E8448;
	sub_82A9C518(ctx, base);
	// 821E8448: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E844C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8450: 4BFFFF74  b 0x821e83c4
	pc = 0x821E83C4; continue 'dispatch;
	// 821E8454: 4BFAB9E5  bl 0x82193e38
	ctx.lr = 0x821E8458;
	sub_82193E38(ctx, base);
	// 821E8458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E845C: 488B40BD  bl 0x82a9c518
	ctx.lr = 0x821E8460;
	sub_82A9C518(ctx, base);
	// 821E8460: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8464: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8468: 4BFFFF5C  b 0x821e83c4
	pc = 0x821E83C4; continue 'dispatch;
	// 821E846C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8470: 48AC0FEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8478 size=124
    let mut pc: u32 = 0x821E8478;
    'dispatch: loop {
        match pc {
            0x821E8478 => {
    //   block [0x821E8478..0x821E84F4)
	// 821E8478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E847C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8484: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E848C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8490: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8498: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E849C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E84A0: 4099003C  ble cr6, 0x821e84dc
	if !ctx.cr[6].gt {
	pc = 0x821E84DC; continue 'dispatch;
	}
	// 821E84A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E84A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E84AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E84B0: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E84B4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E84B8: 480001C1  bl 0x821e8678
	ctx.lr = 0x821E84BC;
	sub_821E8678(ctx, base);
	// 821E84BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E84C0: 41820018  beq 0x821e84d8
	if ctx.cr[0].eq {
	pc = 0x821E84D8; continue 'dispatch;
	}
	// 821E84C4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E84C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E84CC: 4099000C  ble cr6, 0x821e84d8
	if !ctx.cr[6].gt {
	pc = 0x821E84D8; continue 'dispatch;
	}
	// 821E84D0: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 821E84D4: 48000008  b 0x821e84dc
	pc = 0x821E84DC; continue 'dispatch;
	// 821E84D8: D3FF01E8  stfs f31, 0x1e8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 821E84DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E84E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E84E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E84E8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E84EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E84F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E84F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E84F8 size=124
    let mut pc: u32 = 0x821E84F8;
    'dispatch: loop {
        match pc {
            0x821E84F8 => {
    //   block [0x821E84F8..0x821E8574)
	// 821E84F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E84FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8504: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E850C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8518: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E851C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8520: 4099003C  ble cr6, 0x821e855c
	if !ctx.cr[6].gt {
	pc = 0x821E855C; continue 'dispatch;
	}
	// 821E8524: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E852C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8530: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8534: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8538: 48000141  bl 0x821e8678
	ctx.lr = 0x821E853C;
	sub_821E8678(ctx, base);
	// 821E853C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8540: 41820018  beq 0x821e8558
	if ctx.cr[0].eq {
	pc = 0x821E8558; continue 'dispatch;
	}
	// 821E8544: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8548: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E854C: 4099000C  ble cr6, 0x821e8558
	if !ctx.cr[6].gt {
	pc = 0x821E8558; continue 'dispatch;
	}
	// 821E8550: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821E8554: 48000008  b 0x821e855c
	pc = 0x821E855C; continue 'dispatch;
	// 821E8558: D3FF00AC  stfs f31, 0xac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821E855C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8568: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E856C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8578 size=124
    let mut pc: u32 = 0x821E8578;
    'dispatch: loop {
        match pc {
            0x821E8578 => {
    //   block [0x821E8578..0x821E85F4)
	// 821E8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E857C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8584: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E858C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8598: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E859C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E85A0: 4099003C  ble cr6, 0x821e85dc
	if !ctx.cr[6].gt {
	pc = 0x821E85DC; continue 'dispatch;
	}
	// 821E85A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E85A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E85AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E85B0: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E85B4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E85B8: 480000C1  bl 0x821e8678
	ctx.lr = 0x821E85BC;
	sub_821E8678(ctx, base);
	// 821E85BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E85C0: 41820018  beq 0x821e85d8
	if ctx.cr[0].eq {
	pc = 0x821E85D8; continue 'dispatch;
	}
	// 821E85C4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E85C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E85CC: 4099000C  ble cr6, 0x821e85d8
	if !ctx.cr[6].gt {
	pc = 0x821E85D8; continue 'dispatch;
	}
	// 821E85D0: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E85D4: 48000008  b 0x821e85dc
	pc = 0x821E85DC; continue 'dispatch;
	// 821E85D8: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E85DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E85E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E85E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E85E8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E85EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E85F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E85F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E85F8 size=124
    let mut pc: u32 = 0x821E85F8;
    'dispatch: loop {
        match pc {
            0x821E85F8 => {
    //   block [0x821E85F8..0x821E8674)
	// 821E85F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E85FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8604: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E860C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8618: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E861C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8620: 4099003C  ble cr6, 0x821e865c
	if !ctx.cr[6].gt {
	pc = 0x821E865C; continue 'dispatch;
	}
	// 821E8624: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8628: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E862C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8630: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8634: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8638: 48000041  bl 0x821e8678
	ctx.lr = 0x821E863C;
	sub_821E8678(ctx, base);
	// 821E863C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8640: 41820018  beq 0x821e8658
	if ctx.cr[0].eq {
	pc = 0x821E8658; continue 'dispatch;
	}
	// 821E8644: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8648: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E864C: 4099000C  ble cr6, 0x821e8658
	if !ctx.cr[6].gt {
	pc = 0x821E8658; continue 'dispatch;
	}
	// 821E8650: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821E8654: 48000008  b 0x821e865c
	pc = 0x821E865C; continue 'dispatch;
	// 821E8658: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821E865C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8668: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E866C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8678 size=204
    let mut pc: u32 = 0x821E8678;
    'dispatch: loop {
        match pc {
            0x821E8678 => {
    //   block [0x821E8678..0x821E8744)
	// 821E8678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E867C: 48AC0D89  bl 0x82ca9404
	ctx.lr = 0x821E8680;
	sub_82CA93D0(ctx, base);
	// 821E8680: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8684: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E8688: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E868C: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8690: 4182002C  beq 0x821e86bc
	if ctx.cr[0].eq {
	pc = 0x821E86BC; continue 'dispatch;
	}
	// 821E8694: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8698: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821E869C: 4180008C  blt 0x821e8728
	if ctx.cr[0].lt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86A0: 815E005C  lwz r10, 0x5c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E86A4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E86A8: 40980080  bge cr6, 0x821e8728
	if !ctx.cr[6].lt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86AC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E86B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E86B4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E86B8: 48000074  b 0x821e872c
	pc = 0x821E872C; continue 'dispatch;
	// 821E86BC: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E86C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E86C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E86C8: 40990060  ble cr6, 0x821e8728
	if !ctx.cr[6].gt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821E86D0: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E86D4: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821E86D8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E86DC: 41820038  beq 0x821e8714
	if ctx.cr[0].eq {
	pc = 0x821E8714; continue 'dispatch;
	}
	// 821E86E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E86E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E86E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E86EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821E86F0: 4E800421  bctrl
	ctx.lr = 0x821E86F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E86F4: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E86F8: 419A003C  beq cr6, 0x821e8734
	if ctx.cr[6].eq {
	pc = 0x821E8734; continue 'dispatch;
	}
	// 821E86FC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 821E8700: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8704: 4082FFF0  bne 0x821e86f4
	if !ctx.cr[0].eq {
	pc = 0x821E86F4; continue 'dispatch;
	}
	// 821E8708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E870C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8710: 4082002C  bne 0x821e873c
	if !ctx.cr[0].eq {
	pc = 0x821E873C; continue 'dispatch;
	}
	// 821E8714: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E8718: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821E871C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821E8720: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821E8724: 4198FFAC  blt cr6, 0x821e86d0
	if ctx.cr[6].lt {
	pc = 0x821E86D0; continue 'dispatch;
	}
	// 821E8728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E872C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8730: 48AC0D24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821E8734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8738: 4BFFFFD4  b 0x821e870c
	pc = 0x821E870C; continue 'dispatch;
	// 821E873C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8740: 4BFFFFEC  b 0x821e872c
	pc = 0x821E872C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8748 size=124
    let mut pc: u32 = 0x821E8748;
    'dispatch: loop {
        match pc {
            0x821E8748 => {
    //   block [0x821E8748..0x821E87C4)
	// 821E8748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E874C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8754: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E875C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8760: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8768: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E876C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8770: 4099003C  ble cr6, 0x821e87ac
	if !ctx.cr[6].gt {
	pc = 0x821E87AC; continue 'dispatch;
	}
	// 821E8774: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8778: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E877C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8780: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8784: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8788: 4BFFFEF1  bl 0x821e8678
	ctx.lr = 0x821E878C;
	sub_821E8678(ctx, base);
	// 821E878C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8790: 41820018  beq 0x821e87a8
	if ctx.cr[0].eq {
	pc = 0x821E87A8; continue 'dispatch;
	}
	// 821E8794: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8798: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E879C: 4099000C  ble cr6, 0x821e87a8
	if !ctx.cr[6].gt {
	pc = 0x821E87A8; continue 'dispatch;
	}
	// 821E87A0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821E87A4: 48000008  b 0x821e87ac
	pc = 0x821E87AC; continue 'dispatch;
	// 821E87A8: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821E87AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E87B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E87B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E87B8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E87BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E87C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E87C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E87C8 size=348
    let mut pc: u32 = 0x821E87C8;
    'dispatch: loop {
        match pc {
            0x821E87C8 => {
    //   block [0x821E87C8..0x821E8924)
	// 821E87C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E87CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E87D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E87D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E87D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E87DC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E87E0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E87E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E87E8: 419A0040  beq cr6, 0x821e8828
	if ctx.cr[6].eq {
	pc = 0x821E8828; continue 'dispatch;
	}
	// 821E87EC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E87F0: 4BFFFF59  bl 0x821e8748
	ctx.lr = 0x821E87F4;
	sub_821E8748(ctx, base);
	// 821E87F4: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E87F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E87FC: 4BFFFCFD  bl 0x821e84f8
	ctx.lr = 0x821E8800;
	sub_821E84F8(ctx, base);
	// 821E8800: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E8804: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8808: 4BFFFDF1  bl 0x821e85f8
	ctx.lr = 0x821E880C;
	sub_821E85F8(ctx, base);
	// 821E880C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8810: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8814: 4BFFFD65  bl 0x821e8578
	ctx.lr = 0x821E8818;
	sub_821E8578(ctx, base);
	// 821E8818: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E881C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8820: 4BFFFC59  bl 0x821e8478
	ctx.lr = 0x821E8824;
	sub_821E8478(ctx, base);
	// 821E8824: 480000E8  b 0x821e890c
	pc = 0x821E890C; continue 'dispatch;
	// 821E8828: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E882C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E8830: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821E8834: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821E8838: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E883C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E8840: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E8844: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E8848: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E884C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E8850: 4082FFE8  bne 0x821e8838
	if !ctx.cr[0].eq {
	pc = 0x821E8838; continue 'dispatch;
	}
	// 821E8854: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 821E8858: 3BE30074  addi r31, r3, 0x74
	ctx.r[31].s64 = ctx.r[3].s64 + 116;
	// 821E885C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8860: 419A0038  beq cr6, 0x821e8898
	if ctx.cr[6].eq {
	pc = 0x821E8898; continue 'dispatch;
	}
	// 821E8864: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8868: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E886C: 419A007C  beq cr6, 0x821e88e8
	if ctx.cr[6].eq {
	pc = 0x821E88E8; continue 'dispatch;
	}
	// 821E8870: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8878: 419A0020  beq cr6, 0x821e8898
	if ctx.cr[6].eq {
	pc = 0x821E8898; continue 'dispatch;
	}
	// 821E887C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8880: 4BF8B5B9  bl 0x82173e38
	ctx.lr = 0x821E8884;
	sub_82173E38(ctx, base);
	// 821E8884: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E8888: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E888C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8890: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E8894: 409A0008  bne cr6, 0x821e889c
	if !ctx.cr[6].eq {
	pc = 0x821E889C; continue 'dispatch;
	}
	// 821E8898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E889C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E88A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E88A4: 419A0050  beq cr6, 0x821e88f4
	if ctx.cr[6].eq {
	pc = 0x821E88F4; continue 'dispatch;
	}
	// 821E88A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E88AC: 4BF8B58D  bl 0x82173e38
	ctx.lr = 0x821E88B0;
	sub_82173E38(ctx, base);
	// 821E88B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E88B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88B8: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 821E88BC: 48007985  bl 0x821f0240
	ctx.lr = 0x821E88C0;
	sub_821F0240(ctx, base);
	// 821E88C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E88C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88C8: 388B8544  addi r4, r11, -0x7abc
	ctx.r[4].s64 = ctx.r[11].s64 + -31420;
	// 821E88CC: 4BFF20F5  bl 0x821da9c0
	ctx.lr = 0x821E88D0;
	sub_821DA9C0(ctx, base);
	// 821E88D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E88D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E88D8: 4807C8C9  bl 0x822651a0
	ctx.lr = 0x821E88DC;
	sub_822651A0(ctx, base);
	// 821E88DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88E0: 4802C4F9  bl 0x82214dd8
	ctx.lr = 0x821E88E4;
	sub_82214DD8(ctx, base);
	// 821E88E4: 48000020  b 0x821e8904
	pc = 0x821E8904; continue 'dispatch;
	// 821E88E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E88EC: 4BFAB54D  bl 0x82193e38
	ctx.lr = 0x821E88F0;
	sub_82193E38(ctx, base);
	// 821E88F0: 4BFFFFA8  b 0x821e8898
	pc = 0x821E8898; continue 'dispatch;
	// 821E88F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E88F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E88FC: 388B8554  addi r4, r11, -0x7aac
	ctx.r[4].s64 = ctx.r[11].s64 + -31404;
	// 821E8900: 4808CB39  bl 0x82275438
	ctx.lr = 0x821E8904;
	sub_82275438(ctx, base);
	// 821E8904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E8908: 4802C4D1  bl 0x82214dd8
	ctx.lr = 0x821E890C;
	sub_82214DD8(ctx, base);
	// 821E890C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8918: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E891C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8928 size=88
    let mut pc: u32 = 0x821E8928;
    'dispatch: loop {
        match pc {
            0x821E8928 => {
    //   block [0x821E8928..0x821E8980)
	// 821E8928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E892C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E893C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8940: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8944: 40820020  bne 0x821e8964
	if !ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8948: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E894C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8950: 41820014  beq 0x821e8964
	if ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8954: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8958: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E895C: 41820008  beq 0x821e8964
	if ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8960: 48CA4C51  bl 0x82e8d5b0
	ctx.lr = 0x821E8964;
	sub_82E8D5B0(ctx, base);
	// 821E8964: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8968: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821E896C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E897C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8980 size=524
    let mut pc: u32 = 0x821E8980;
    'dispatch: loop {
        match pc {
            0x821E8980 => {
    //   block [0x821E8980..0x821E8B8C)
	// 821E8980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E898C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8994: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E8998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E899C: 419A01D4  beq cr6, 0x821e8b70
	if ctx.cr[6].eq {
	pc = 0x821E8B70; continue 'dispatch;
	}
	// 821E89A0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E89A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E89A8: 40990020  ble cr6, 0x821e89c8
	if !ctx.cr[6].gt {
	pc = 0x821E89C8; continue 'dispatch;
	}
	// 821E89AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E89B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E89B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E89B8: 4E800421  bctrl
	ctx.lr = 0x821E89BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E89BC: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E89C0: 7D034850  subf r8, r3, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 821E89C4: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 821E89C8: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E89CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E89D0: 419A016C  beq cr6, 0x821e8b3c
	if ctx.cr[6].eq {
	pc = 0x821E8B3C; continue 'dispatch;
	}
	// 821E89D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E89D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E89DC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E89E0: 5528CFFE  rlwinm r8, r9, 0x19, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 821E89E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E89E8: 419A00F8  beq cr6, 0x821e8ae0
	if ctx.cr[6].eq {
	pc = 0x821E8AE0; continue 'dispatch;
	}
	// 821E89EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E89F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E89F4: 419A0024  beq cr6, 0x821e8a18
	if ctx.cr[6].eq {
	pc = 0x821E8A18; continue 'dispatch;
	}
	// 821E89F8: 894A0087  lbz r10, 0x87(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(135 as u32) ) } as u64;
	// 821E89FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E8A00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E8A04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E8A08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8A0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8A10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8A14: 480000D0  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
	// 821E8A18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E8A1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E8A20: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E8A24: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E8A28: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E8A2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E8A30: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8A34: 40810054  ble 0x821e8a88
	if !ctx.cr[0].gt {
	pc = 0x821E8A88; continue 'dispatch;
	}
	// 821E8A38: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E8A3C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E8A40: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E8A44: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8A48: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 821E8A4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E8A50: 41980008  blt cr6, 0x821e8a58
	if ctx.cr[6].lt {
	pc = 0x821E8A58; continue 'dispatch;
	}
	// 821E8A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E8A58: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E8A5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E8A60: 419A0014  beq cr6, 0x821e8a74
	if ctx.cr[6].eq {
	pc = 0x821E8A74; continue 'dispatch;
	}
	// 821E8A64: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E8A68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E8A6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E8A70: 4800000C  b 0x821e8a7c
	pc = 0x821E8A7C; continue 'dispatch;
	// 821E8A74: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E8A78: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E8A7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8A80: 4199FFB8  bgt cr6, 0x821e8a38
	if ctx.cr[6].gt {
	pc = 0x821E8A38; continue 'dispatch;
	}
	// 821E8A84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E8A88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E8A8C: 419A0040  beq cr6, 0x821e8acc
	if ctx.cr[6].eq {
	pc = 0x821E8ACC; continue 'dispatch;
	}
	// 821E8A90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8A94: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 821E8A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8A9C: 41990008  bgt cr6, 0x821e8aa4
	if ctx.cr[6].gt {
	pc = 0x821E8AA4; continue 'dispatch;
	}
	// 821E8AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8AA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E8AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8AAC: 409A0020  bne cr6, 0x821e8acc
	if !ctx.cr[6].eq {
	pc = 0x821E8ACC; continue 'dispatch;
	}
	// 821E8AB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E8AB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E8AB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8ABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8AC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8AC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8AC8: 4800001C  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
	// 821E8ACC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E8AD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8AD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8AD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8ADC: 48000008  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
	// 821E8AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E8AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8AEC: 419A008C  beq cr6, 0x821e8b78
	if ctx.cr[6].eq {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8AF0: 806A002C  lwz r3, 0x2c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8AF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E8AF8: 419A0014  beq cr6, 0x821e8b0c
	if ctx.cr[6].eq {
	pc = 0x821E8B0C; continue 'dispatch;
	}
	// 821E8AFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E8B00: 388B8A34  addi r4, r11, -0x75cc
	ctx.r[4].s64 = ctx.r[11].s64 + -30156;
	// 821E8B04: 488152C5  bl 0x829fddc8
	ctx.lr = 0x821E8B08;
	sub_829FDDC8(ctx, base);
	// 821E8B08: 48000008  b 0x821e8b10
	pc = 0x821E8B10; continue 'dispatch;
	// 821E8B0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8B10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E8B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8B18: 409A0060  bne cr6, 0x821e8b78
	if !ctx.cr[6].eq {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8B1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8B24: 483F071D  bl 0x825d9240
	ctx.lr = 0x821E8B28;
	sub_825D9240(ctx, base);
	// 821E8B28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B38: 4E800020  blr
	return;
	// 821E8B3C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E8B40: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8B44: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821E8B48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E8B4C: 4099002C  ble cr6, 0x821e8b78
	if !ctx.cr[6].gt {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8B50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8B58: 483F06E9  bl 0x825d9240
	ctx.lr = 0x821E8B5C;
	sub_825D9240(ctx, base);
	// 821E8B5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B6C: 4E800020  blr
	return;
	// 821E8B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8B74: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821E8B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8B90 size=116
    let mut pc: u32 = 0x821E8B90;
    'dispatch: loop {
        match pc {
            0x821E8B90 => {
    //   block [0x821E8B90..0x821E8C04)
	// 821E8B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8B94: 48AC0879  bl 0x82ca940c
	ctx.lr = 0x821E8B98;
	sub_82CA93D0(ctx, base);
	// 821E8B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8B9C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E8BA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E8BA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E8BA8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E8BAC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E8BB0: 806A0080  lwz r3, 0x80(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821E8BB4: 4808C32D  bl 0x82274ee0
	ctx.lr = 0x821E8BB8;
	sub_82274EE0(ctx, base);
	// 821E8BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8BBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E8BC0: 419A0038  beq cr6, 0x821e8bf8
	if ctx.cr[6].eq {
	pc = 0x821E8BF8; continue 'dispatch;
	}
	// 821E8BC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8BC8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8BCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E8BD0: 4E800421  bctrl
	ctx.lr = 0x821E8BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E8BD4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E8BD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E8BDC: 419A001C  beq cr6, 0x821e8bf8
	if ctx.cr[6].eq {
	pc = 0x821E8BF8; continue 'dispatch;
	}
	// 821E8BE0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E8BE4: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E8BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8BEC: 4BFF48E5  bl 0x821dd4d0
	ctx.lr = 0x821E8BF0;
	sub_821DD4D0(ctx, base);
	// 821E8BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8BF4: 48AC0868  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821E8BF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8C00: 48AC085C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8C08 size=112
    let mut pc: u32 = 0x821E8C08;
    'dispatch: loop {
        match pc {
            0x821E8C08 => {
    //   block [0x821E8C08..0x821E8C78)
	// 821E8C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8C10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8C14: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821E8C18: 488929D1  bl 0x82a7b5e8
	ctx.lr = 0x821E8C1C;
	sub_82A7B5E8(ctx, base);
	// 821E8C1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E8C20: 409A0018  bne cr6, 0x821e8c38
	if !ctx.cr[6].eq {
	pc = 0x821E8C38; continue 'dispatch;
	}
	// 821E8C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8C28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8C34: 4E800020  blr
	return;
	// 821E8C38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8C3C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E8C40: 409AFFE4  bne cr6, 0x821e8c24
	if !ctx.cr[6].eq {
	pc = 0x821E8C24; continue 'dispatch;
	}
	// 821E8C44: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8C4C: 419A0018  beq cr6, 0x821e8c64
	if ctx.cr[6].eq {
	pc = 0x821E8C64; continue 'dispatch;
	}
	// 821E8C50: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8C54: 91680010  stw r11, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821E8C58: 4082000C  bne 0x821e8c64
	if !ctx.cr[0].eq {
	pc = 0x821E8C64; continue 'dispatch;
	}
	// 821E8C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8C60: 9168000C  stw r11, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821E8C64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E8C68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8C6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8C70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E8C78 size=56
    let mut pc: u32 = 0x821E8C78;
    'dispatch: loop {
        match pc {
            0x821E8C78 => {
    //   block [0x821E8C78..0x821E8CB0)
	// 821E8C78: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821E8C7C: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8C80: 390ADED4  addi r8, r10, -0x212c
	ctx.r[8].s64 = ctx.r[10].s64 + -8492;
	// 821E8C84: 7CE35A14  add r7, r3, r11
	ctx.r[7].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821E8C88: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821E8C8C: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E8C90: 396BED14  addi r11, r11, -0x12ec
	ctx.r[11].s64 = ctx.r[11].s64 + -4844;
	// 821E8C94: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8C98: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E8C9C: D02B0000  stfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E8CA0: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8CA4: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821E8CA8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8CAC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E8CB0 size=44
    let mut pc: u32 = 0x821E8CB0;
    'dispatch: loop {
        match pc {
            0x821E8CB0 => {
    //   block [0x821E8CB0..0x821E8CDC)
	// 821E8CB0: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821E8CB4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E8CB8: 7CC90194  addze r6, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821E8CBC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821E8CC0: 7909FFE6  rldicr r9, r8, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821E8CC4: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 821E8CC8: 7D242C36  srd r4, r9, r5
	if (ctx.r[5].u8 & 0x40) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = (ctx.r[9].u64) >> ((ctx.r[5].u8 & 0x3F) as u32);
	}
	// 821E8CCC: E9071758  ld r8, 0x1758(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(5976 as u32) ) };
	// 821E8CD0: 7C834038  and r3, r4, r8
	ctx.r[3].u64 = ctx.r[4].u64 & ctx.r[8].u64;
	// 821E8CD4: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 821E8CD8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8CDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E8CDC size=92
    let mut pc: u32 = 0x821E8CDC;
    'dispatch: loop {
        match pc {
            0x821E8CDC => {
    //   block [0x821E8CDC..0x821E8D38)
	// 821E8CDC: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 821E8CE0: 38CA0178  addi r6, r10, 0x178
	ctx.r[6].s64 = ctx.r[10].s64 + 376;
	// 821E8CE4: 5545F0BE  srwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E8CE8: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E8CEC: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E8CF0: 81470364  lwz r10, 0x364(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E8CF4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821E8CF8: 7CE52850  subf r7, r5, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821E8CFC: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E8D00: 78E60020  clrldi r6, r7, 0x20
	ctx.r[6].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821E8D04: 7C24552E  stfsx f1, r4, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821E8D08: 7C643634  srad r4, r3, r6
	tmp.u64 = (ctx.r[6].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[3].s64 < 0) && ((ctx.r[3].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[4].s64 = ctx.r[3].s64 >> tmp.u64;
	// 821E8D0C: 7C832C36  srd r3, r4, r5
	if (ctx.r[5].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[4].u64) >> ((ctx.r[5].u8 & 0x3F) as u32);
	}
	// 821E8D10: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D14: D0091784  stfs f0, 0x1784(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 821E8D18: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D1C: D0091788  stfs f0, 0x1788(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 821E8D20: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D24: D009178C  stfs f0, 0x178c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 821E8D28: E96A0008  ld r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821E8D2C: 7C695B78  or r9, r3, r11
	ctx.r[9].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821E8D30: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821E8D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8D38 size=388
    let mut pc: u32 = 0x821E8D38;
    'dispatch: loop {
        match pc {
            0x821E8D38 => {
    //   block [0x821E8D38..0x821E8EBC)
	// 821E8D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8D3C: 48AC06CD  bl 0x82ca9408
	ctx.lr = 0x821E8D40;
	sub_82CA93D0(ctx, base);
	// 821E8D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8D48: 895F2ABD  lbz r10, 0x2abd(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8D4C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8D50: 83DF3A50  lwz r30, 0x3a50(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14928 as u32) ) } as u64;
	// 821E8D54: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E8D58: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 821E8D5C: 4082011C  bne 0x821e8e78
	if !ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D60: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8D64: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8D68: 4182006C  beq 0x821e8dd4
	if ctx.cr[0].eq {
	pc = 0x821E8DD4; continue 'dispatch;
	}
	// 821E8D6C: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821E8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8D74: 419A0104  beq cr6, 0x821e8e78
	if ctx.cr[6].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D78: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 821E8D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8D80: 409A00F8  bne cr6, 0x821e8e78
	if !ctx.cr[6].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D84: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E8D88: 7D7D1671  srawi. r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821E8D8C: 418200EC  beq 0x821e8e78
	if ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D90: 817F34E4  lwz r11, 0x34e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13540 as u32) ) } as u64;
	// 821E8D94: 807F34E0  lwz r3, 0x34e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13536 as u32) ) } as u64;
	// 821E8D98: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E8D9C: 4198000C  blt cr6, 0x821e8da8
	if ctx.cr[6].lt {
	pc = 0x821E8DA8; continue 'dispatch;
	}
	// 821E8DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8DA4: 489B8DD5  bl 0x82ba1b78
	ctx.lr = 0x821E8DA8;
	sub_82BA1B78(ctx, base);
	// 821E8DA8: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8DAC: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8DB0: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8DB4: 67A98100  oris r9, r29, 0x8100
	ctx.r[9].u64 = ctx.r[29].u64 | 2164260864;
	// 821E8DB8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8DBC: 39030008  addi r8, r3, 8
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	// 821E8DC0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E8DC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8DC8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E8DCC: 911F34E0  stw r8, 0x34e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13536 as u32), ctx.r[8].u32 ) };
	// 821E8DD0: 480000A8  b 0x821e8e78
	pc = 0x821E8E78; continue 'dispatch;
	// 821E8DD4: 817F33B0  lwz r11, 0x33b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13232 as u32) ) } as u64;
	// 821E8DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8DDC: 419A005C  beq cr6, 0x821e8e38
	if ctx.cr[6].eq {
	pc = 0x821E8E38; continue 'dispatch;
	}
	// 821E8DE0: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8DE4: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8DE8: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8DEC: 7D3EE050  subf r9, r30, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E8DF0: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8DF4: 7D3E1671  srawi. r30, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821E8DF8: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8DFC: 4182007C  beq 0x821e8e78
	if ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8E00: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821E8E04: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821E8E08: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821E8E0C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E8E10: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8E14: 4099000C  ble cr6, 0x821e8e20
	if !ctx.cr[6].gt {
	pc = 0x821E8E20; continue 'dispatch;
	}
	// 821E8E18: 4BFE8799  bl 0x821d15b0
	ctx.lr = 0x821E8E1C;
	sub_821D15B0(ctx, base);
	// 821E8E1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E8E20: 67CA8100  oris r10, r30, 0x8100
	ctx.r[10].u64 = ctx.r[30].u64 | 2164260864;
	// 821E8E24: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E8E28: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E8E2C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E8E30: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821E8E34: 48000044  b 0x821e8e78
	pc = 0x821E8E78; continue 'dispatch;
	// 821E8E38: 389CFFFC  addi r4, r28, -4
	ctx.r[4].s64 = ctx.r[28].s64 + -4;
	// 821E8E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E40: 480AF7F1  bl 0x82298630
	ctx.lr = 0x821E8E44;
	sub_82298630(ctx, base);
	// 821E8E44: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8E48: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 821E8E4C: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8E50: 7D3E2050  subf r9, r30, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 821E8E54: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8E58: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8E5C: 391F3438  addi r8, r31, 0x3438
	ctx.r[8].s64 = ctx.r[31].s64 + 13368;
	// 821E8E60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E8E64: 7D261670  srawi r6, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821E8E68: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E70: 4809DA59  bl 0x822868c8
	ctx.lr = 0x821E8E74;
	sub_822868C8(ctx, base);
	// 821E8E74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E8E78: 397C001F  addi r11, r28, 0x1f
	ctx.r[11].s64 = ctx.r[28].s64 + 31;
	// 821E8E7C: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E8E80: 55690034  rlwinm r9, r11, 0, 0, 0x1a
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8E84: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8E88: 4099001C  ble cr6, 0x821e8ea4
	if !ctx.cr[6].gt {
	pc = 0x821E8EA4; continue 'dispatch;
	}
	// 821E8E8C: 397CFFFC  addi r11, r28, -4
	ctx.r[11].s64 = ctx.r[28].s64 + -4;
	// 821E8E90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8E94: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821E8E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E9C: 4BFE8C5D  bl 0x821d1af8
	ctx.lr = 0x821E8EA0;
	sub_821D1AF8(ctx, base);
	// 821E8EA0: 48000014  b 0x821e8eb4
	pc = 0x821E8EB4; continue 'dispatch;
	// 821E8EA4: 556B0034  rlwinm r11, r11, 0, 0, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8EA8: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 821E8EAC: 917F3A50  stw r11, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[11].u32 ) };
	// 821E8EB0: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 821E8EB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8EB8: 48AC05A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8EC0 size=256
    let mut pc: u32 = 0x821E8EC0;
    'dispatch: loop {
        match pc {
            0x821E8EC0 => {
    //   block [0x821E8EC0..0x821E8FC0)
	// 821E8EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E8ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8ED8: 817F2A90  lwz r11, 0x2a90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10896 as u32) ) } as u64;
	// 821E8EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8EE0: 419A0008  beq cr6, 0x821e8ee8
	if ctx.cr[6].eq {
	pc = 0x821E8EE8; continue 'dispatch;
	}
	// 821E8EE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8EE8: 817F33B0  lwz r11, 0x33b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13232 as u32) ) } as u64;
	// 821E8EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8EF0: 409A005C  bne cr6, 0x821e8f4c
	if !ctx.cr[6].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8EF4: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8EF8: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8EFC: 40820050  bne 0x821e8f4c
	if !ctx.cr[0].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E8F04: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821E8F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F0C: 4809A925  bl 0x82283830
	ctx.lr = 0x821E8F10;
	sub_82283830(ctx, base);
	// 821E8F10: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8F14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E8F18: 419A0034  beq cr6, 0x821e8f4c
	if ctx.cr[6].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F1C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821E8F20: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821E8F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F28: 4801D7C1  bl 0x822066e8
	ctx.lr = 0x821E8F2C;
	sub_822066E8(ctx, base);
	// 821E8F2C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E8F30: 4182001C  beq 0x821e8f4c
	if ctx.cr[0].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F34: 391F3438  addi r8, r31, 0x3438
	ctx.r[8].s64 = ctx.r[31].s64 + 13368;
	// 821E8F38: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8F3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E8F40: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E8F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F48: 4809D981  bl 0x822868c8
	ctx.lr = 0x821E8F4C;
	sub_822868C8(ctx, base);
	// 821E8F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F50: 4BFFFDE9  bl 0x821e8d38
	ctx.lr = 0x821E8F54;
	sub_821E8D38(ctx, base);
	// 821E8F54: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8F58: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F5C: 40820048  bne 0x821e8fa4
	if !ctx.cr[0].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F60: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E8F64: 816B7144  lwz r11, 0x7144(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28996 as u32) ) } as u64;
	// 821E8F68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F6C: 419A0038  beq cr6, 0x821e8fa4
	if ctx.cr[6].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F70: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8F74: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F78: 4082002C  bne 0x821e8fa4
	if !ctx.cr[0].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F7C: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821E8F80: 348BFFFE  addic. r4, r11, -2
	ctx.xer.ca = (ctx.r[11].u32 > (!(-2 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E8F84: 41820014  beq 0x821e8f98
	if ctx.cr[0].eq {
	pc = 0x821E8F98; continue 'dispatch;
	}
	// 821E8F88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E8F8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E8F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F94: 480596D5  bl 0x82242668
	ctx.lr = 0x821E8F98;
	sub_82242668(ctx, base);
	// 821E8F98: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8F9C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821E8FA0: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	// 821E8FA4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E8FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8FC0 size=8
    let mut pc: u32 = 0x821E8FC0;
    'dispatch: loop {
        match pc {
            0x821E8FC0 => {
    //   block [0x821E8FC0..0x821E8FC8)
	// 821E8FC0: 886300BA  lbz r3, 0xba(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(186 as u32) ) } as u64;
	// 821E8FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8FC8 size=140
    let mut pc: u32 = 0x821E8FC8;
    'dispatch: loop {
        match pc {
            0x821E8FC8 => {
    //   block [0x821E8FC8..0x821E9054)
	// 821E8FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8FCC: 48AC0441  bl 0x82ca940c
	ctx.lr = 0x821E8FD0;
	sub_82CA93D0(ctx, base);
	// 821E8FD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8FD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E8FD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E8FDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E8FE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E8FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E8FE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8FEC: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E8FF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E8FF4: 4E800421  bctrl
	ctx.lr = 0x821E8FF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E8FF8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821E8FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E9000: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E9004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E9008: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821E900C: F91D00E0  std r8, 0xe0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(224 as u32), ctx.r[8].u64 ) };
	// 821E9010: E8E90008  ld r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821E9014: F8FD00E8  std r7, 0xe8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[7].u64 ) };
	// 821E9018: 4BFFC7F9  bl 0x821e5810
	ctx.lr = 0x821E901C;
	sub_821E5810(ctx, base);
	// 821E901C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E9020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9024: 419A000C  beq cr6, 0x821e9030
	if ctx.cr[6].eq {
	pc = 0x821E9030; continue 'dispatch;
	}
	// 821E9028: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E902C: 48000008  b 0x821e9034
	pc = 0x821E9034; continue 'dispatch;
	// 821E9030: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E9034: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E903C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E9040: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E9048: 4E800421  bctrl
	ctx.lr = 0x821E904C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E904C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E9050: 48AC040C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E9058 size=664
    let mut pc: u32 = 0x821E9058;
    'dispatch: loop {
        match pc {
            0x821E9058 => {
    //   block [0x821E9058..0x821E92F0)
	// 821E9058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E905C: 48AC0399  bl 0x82ca93f4
	ctx.lr = 0x821E9060;
	sub_82CA93D0(ctx, base);
	// 821E9060: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821E9064: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9068: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821E906C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821E9070: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 821E9074: 817900EC  lwz r11, 0xec(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(236 as u32) ) } as u64;
	// 821E9078: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 821E907C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9080: 40990240  ble cr6, 0x821e92c0
	if !ctx.cr[6].gt {
	pc = 0x821E92C0; continue 'dispatch;
	}
	// 821E9084: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E9088: 3B5900E4  addi r26, r25, 0xe4
	ctx.r[26].s64 = ctx.r[25].s64 + 228;
	// 821E908C: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821E9090: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E9094: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E9098: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E909C: 48000255  bl 0x821e92f0
	ctx.lr = 0x821E90A0;
	sub_821E92F0(ctx, base);
	// 821E90A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E90A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90A8: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E90AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E90B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E90B4: 4800023D  bl 0x821e92f0
	ctx.lr = 0x821E90B8;
	sub_821E92F0(ctx, base);
	// 821E90B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90BC: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E90C0: 419A0008  beq cr6, 0x821e90c8
	if ctx.cr[6].eq {
	pc = 0x821E90C8; continue 'dispatch;
	}
	// 821E90C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E90C8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E90CC: 419A01E0  beq cr6, 0x821e92ac
	if ctx.cr[6].eq {
	pc = 0x821E92AC; continue 'dispatch;
	}
	// 821E90D0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90D4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E90D8: 409A0008  bne cr6, 0x821e90e0
	if !ctx.cr[6].eq {
	pc = 0x821E90E0; continue 'dispatch;
	}
	// 821E90DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E90E0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E90E4: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 821E90E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E90EC: 419A0084  beq cr6, 0x821e9170
	if ctx.cr[6].eq {
	pc = 0x821E9170; continue 'dispatch;
	}
	// 821E90F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E90F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E90F8: 419A0074  beq cr6, 0x821e916c
	if ctx.cr[6].eq {
	pc = 0x821E916C; continue 'dispatch;
	}
	// 821E90FC: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821E9100: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E9104: 419A0018  beq cr6, 0x821e911c
	if ctx.cr[6].eq {
	pc = 0x821E911C; continue 'dispatch;
	}
	// 821E9108: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E910C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E9110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9118: 409A0008  bne cr6, 0x821e9120
	if !ctx.cr[6].eq {
	pc = 0x821E9120; continue 'dispatch;
	}
	// 821E911C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821E9120: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9128: 419A016C  beq cr6, 0x821e9294
	if ctx.cr[6].eq {
	pc = 0x821E9294; continue 'dispatch;
	}
	// 821E912C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E9130: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821E9134: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821E9138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E913C: 419A0100  beq cr6, 0x821e923c
	if ctx.cr[6].eq {
	pc = 0x821E923C; continue 'dispatch;
	}
	// 821E9140: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E9144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9148: 419A0030  beq cr6, 0x821e9178
	if ctx.cr[6].eq {
	pc = 0x821E9178; continue 'dispatch;
	}
	// 821E914C: 894B0055  lbz r10, 0x55(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(85 as u32) ) } as u64;
	// 821E9150: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E9154: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E9158: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E915C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9160: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9168: 480000D8  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
	// 821E916C: 4BFAACCD  bl 0x82193e38
	ctx.lr = 0x821E9170;
	sub_82193E38(ctx, base);
	// 821E9170: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821E9174: 4BFFFFA8  b 0x821e911c
	pc = 0x821E911C; continue 'dispatch;
	// 821E9178: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E917C: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E9180: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821E9184: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E9188: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E918C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E9190: 40810054  ble 0x821e91e4
	if !ctx.cr[0].gt {
	pc = 0x821E91E4; continue 'dispatch;
	}
	// 821E9194: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E9198: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E919C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E91A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E91A4: 2F070055  cmpwi cr6, r7, 0x55
	ctx.cr[6].compare_i32(ctx.r[7].s32, 85, &mut ctx.xer);
	// 821E91A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E91AC: 41980008  blt cr6, 0x821e91b4
	if ctx.cr[6].lt {
	pc = 0x821E91B4; continue 'dispatch;
	}
	// 821E91B0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821E91B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E91B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E91BC: 419A0014  beq cr6, 0x821e91d0
	if ctx.cr[6].eq {
	pc = 0x821E91D0; continue 'dispatch;
	}
	// 821E91C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E91C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E91C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E91CC: 4800000C  b 0x821e91d8
	pc = 0x821E91D8; continue 'dispatch;
	// 821E91D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E91D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821E91D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E91DC: 4199FFB8  bgt cr6, 0x821e9194
	if ctx.cr[6].gt {
	pc = 0x821E9194; continue 'dispatch;
	}
	// 821E91E0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E91E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E91E8: 419A0040  beq cr6, 0x821e9228
	if ctx.cr[6].eq {
	pc = 0x821E9228; continue 'dispatch;
	}
	// 821E91EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E91F0: 2F0B0055  cmpwi cr6, r11, 0x55
	ctx.cr[6].compare_i32(ctx.r[11].s32, 85, &mut ctx.xer);
	// 821E91F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E91F8: 41990008  bgt cr6, 0x821e9200
	if ctx.cr[6].gt {
	pc = 0x821E9200; continue 'dispatch;
	}
	// 821E91FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821E9200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9208: 409A0020  bne cr6, 0x821e9228
	if !ctx.cr[6].eq {
	pc = 0x821E9228; continue 'dispatch;
	}
	// 821E920C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E9210: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E9214: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E921C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9224: 4800001C  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
	// 821E9228: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E922C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9230: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9238: 48000008  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
	// 821E923C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821E9240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9248: 419A0044  beq cr6, 0x821e928c
	if ctx.cr[6].eq {
	pc = 0x821E928C; continue 'dispatch;
	}
	// 821E924C: 89786C21  lbz r11, 0x6c21(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27681 as u32) ) } as u64;
	// 821E9250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9254: 419A002C  beq cr6, 0x821e9280
	if ctx.cr[6].eq {
	pc = 0x821E9280; continue 'dispatch;
	}
	// 821E9258: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E925C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E9260: 419A000C  beq cr6, 0x821e926c
	if ctx.cr[6].eq {
	pc = 0x821E926C; continue 'dispatch;
	}
	// 821E9264: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9268: 49049179  bl 0x832323e0
	ctx.lr = 0x821E926C;
	sub_832323E0(ctx, base);
	// 821E926C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E9270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E9274: 419A0018  beq cr6, 0x821e928c
	if ctx.cr[6].eq {
	pc = 0x821E928C; continue 'dispatch;
	}
	// 821E9278: 49048D89  bl 0x83232000
	ctx.lr = 0x821E927C;
	sub_83232000(ctx, base);
	// 821E927C: 48000010  b 0x821e928c
	pc = 0x821E928C; continue 'dispatch;
	// 821E9280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E9284: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9288: 48380C99  bl 0x82569f20
	ctx.lr = 0x821E928C;
	sub_82569F20(ctx, base);
	// 821E928C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E9290: 481A4599  bl 0x8238d828
	ctx.lr = 0x821E9294;
	sub_8238D828(ctx, base);
	// 821E9294: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9298: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E929C: 409A0008  bne cr6, 0x821e92a4
	if !ctx.cr[6].eq {
	pc = 0x821E92A4; continue 'dispatch;
	}
	// 821E92A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E92A4: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E92A8: 4BFFFE04  b 0x821e90ac
	pc = 0x821E90AC; continue 'dispatch;
	// 821E92AC: 817900EC  lwz r11, 0xec(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(236 as u32) ) } as u64;
	// 821E92B0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821E92B4: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 821E92B8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E92BC: 4198FDD8  blt cr6, 0x821e9094
	if ctx.cr[6].lt {
	pc = 0x821E9094; continue 'dispatch;
	}
	// 821E92C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821E92C4: 480E0BC5  bl 0x822c9e88
	ctx.lr = 0x821E92C8;
	sub_822C9E88(ctx, base);
	// 821E92C8: 93B90158  stw r29, 0x158(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(344 as u32), ctx.r[29].u32 ) };
	// 821E92CC: 387900F0  addi r3, r25, 0xf0
	ctx.r[3].s64 = ctx.r[25].s64 + 240;
	// 821E92D0: 4882BAC1  bl 0x82a14d90
	ctx.lr = 0x821E92D4;
	sub_82A14D90(ctx, base);
	// 821E92D4: 387900FC  addi r3, r25, 0xfc
	ctx.r[3].s64 = ctx.r[25].s64 + 252;
	// 821E92D8: 4882BAB9  bl 0x82a14d90
	ctx.lr = 0x821E92DC;
	sub_82A14D90(ctx, base);
	// 821E92DC: 93B901AC  stw r29, 0x1ac(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(428 as u32), ctx.r[29].u32 ) };
	// 821E92E0: 93B901B0  stw r29, 0x1b0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(432 as u32), ctx.r[29].u32 ) };
	// 821E92E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E92E8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821E92EC: 48AC0158  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E92F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E92F0 size=320
    let mut pc: u32 = 0x821E92F0;
    'dispatch: loop {
        match pc {
            0x821E92F0 => {
    //   block [0x821E92F0..0x821E9430)
	// 821E92F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E92F4: 48AC0119  bl 0x82ca940c
	ctx.lr = 0x821E92F8;
	sub_82CA93D0(ctx, base);
	// 821E92F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E92FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E9300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E9304: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821E9308: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E930C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9310: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 821E9314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9318: 409A0044  bne cr6, 0x821e935c
	if !ctx.cr[6].eq {
	pc = 0x821E935C; continue 'dispatch;
	}
	// 821E931C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9320: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9324: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821E9328: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E932C: 41980008  blt cr6, 0x821e9334
	if ctx.cr[6].lt {
	pc = 0x821E9334; continue 'dispatch;
	}
	// 821E9330: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821E9334: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E9338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E933C: 419A000C  beq cr6, 0x821e9348
	if ctx.cr[6].eq {
	pc = 0x821E9348; continue 'dispatch;
	}
	// 821E9340: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E9344: 4800000C  b 0x821e9350
	pc = 0x821E9350; continue 'dispatch;
	// 821E9348: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821E934C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9350: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 821E9354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9358: 419AFFC8  beq cr6, 0x821e9320
	if ctx.cr[6].eq {
	pc = 0x821E9320; continue 'dispatch;
	}
	// 821E935C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9360: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821E9364: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821E9368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E936C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E9370: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821E9374: 419A0028  beq cr6, 0x821e939c
	if ctx.cr[6].eq {
	pc = 0x821E939C; continue 'dispatch;
	}
	// 821E9378: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E937C: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9380: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821E9384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9388: 41980008  blt cr6, 0x821e9390
	if ctx.cr[6].lt {
	pc = 0x821E9390; continue 'dispatch;
	}
	// 821E938C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821E9390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9398: 419A0070  beq cr6, 0x821e9408
	if ctx.cr[6].eq {
	pc = 0x821E9408; continue 'dispatch;
	}
	// 821E939C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E93A0: 4865EC11  bl 0x82847fb0
	ctx.lr = 0x821E93A4;
	sub_82847FB0(ctx, base);
	// 821E93A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E93A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E93AC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821E93B0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821E93B4: 4836E8D5  bl 0x82557c88
	ctx.lr = 0x821E93B8;
	sub_82557C88(ctx, base);
	// 821E93B8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821E93BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E93C0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E93C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E93C8: 4836D591  bl 0x82556958
	ctx.lr = 0x821E93CC;
	sub_82556958(ctx, base);
	// 821E93CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821E93D0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821E93D4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821E93D8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E93DC: 48543F5D  bl 0x8272d338
	ctx.lr = 0x821E93E0;
	sub_8272D338(ctx, base);
	// 821E93E0: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821E93E4: 48032955  bl 0x8221bd38
	ctx.lr = 0x821E93E8;
	sub_8221BD38(ctx, base);
	// 821E93E8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 821E93EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E93F0: 48543F49  bl 0x8272d338
	ctx.lr = 0x821E93F4;
	sub_8272D338(ctx, base);
	// 821E93F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E93F8: 48032941  bl 0x8221bd38
	ctx.lr = 0x821E93FC;
	sub_8221BD38(ctx, base);
	// 821E93FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E9400: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E9404: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821E9408: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E940C: 409A0008  bne cr6, 0x821e9414
	if !ctx.cr[6].eq {
	pc = 0x821E9414; continue 'dispatch;
	}
	// 821E9410: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E9414: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9418: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E941C: 409A0008  bne cr6, 0x821e9424
	if !ctx.cr[6].eq {
	pc = 0x821E9424; continue 'dispatch;
	}
	// 821E9420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E9424: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 821E9428: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E942C: 48AC0030  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E9430 size=2504
    let mut pc: u32 = 0x821E9430;
    'dispatch: loop {
        match pc {
            0x821E9430 => {
    //   block [0x821E9430..0x821E9DF8)
	// 821E9430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9434: 48ABFFC1  bl 0x82ca93f4
	ctx.lr = 0x821E9438;
	sub_82CA93D0(ctx, base);
	// 821E9438: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821E943C: 48AC489D  bl 0x82cadcd8
	ctx.lr = 0x821E9440;
	sub_82CADCA0(ctx, base);
	// 821E9440: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E9DF8 size=192
    let mut pc: u32 = 0x821E9DF8;
    'dispatch: loop {
        match pc {
            0x821E9DF8 => {
    //   block [0x821E9DF8..0x821E9EB8)
	// 821E9DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E9E00: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821E9E04: 48AC3ED5  bl 0x82cadcd8
	ctx.lr = 0x821E9E08;
	sub_82CADCA0(ctx, base);
	// 821E9E08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9E0C: FFA01090  fmr f29, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[2].f64;
	// 821E9E10: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E9E14: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 821E9E18: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821E9E1C: 48050095  bl 0x82239eb0
	ctx.lr = 0x821E9E20;
	sub_82239EB0(ctx, base);
	// 821E9E20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E24: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821E9E28: EFA007B2  fmuls f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821E9E2C: 48050165  bl 0x82239f90
	ctx.lr = 0x821E9E30;
	sub_82239F90(ctx, base);
	// 821E9E30: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9E38: 48050079  bl 0x82239eb0
	ctx.lr = 0x821E9E3C;
	sub_82239EB0(ctx, base);
	// 821E9E3C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E9E44: ED9C07B2  fmuls f12, f28, f30
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[30].f64) as f32) as f64);
	// 821E9E48: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821E9E4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9E50: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E9E54: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821E9E58: ED6D0772  fmuls f11, f13, f29
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 821E9E5C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E9E60: 48050131  bl 0x82239f90
	ctx.lr = 0x821E9E64;
	sub_82239F90(ctx, base);
	// 821E9E64: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E68: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E9E6C: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 821E9E70: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821E9E74: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E9EB8 size=168
    let mut pc: u32 = 0x821E9EB8;
    'dispatch: loop {
        match pc {
            0x821E9EB8 => {
    //   block [0x821E9EB8..0x821E9F60)
	// 821E9EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E9EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E9EC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9EC8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821E9ECC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E9ED0: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 821E9ED4: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821E9ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E9EDC: 4800A5A5  bl 0x821f4480
	ctx.lr = 0x821E9EE0;
	sub_821F4480(ctx, base);
	// 821E9EE0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E9EE4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9EE8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E9EEC: 419A0060  beq cr6, 0x821e9f4c
	if ctx.cr[6].eq {
	pc = 0x821E9F4C; continue 'dispatch;
	}
	// 821E9EF0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9EF4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E9EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9EFC: 419A0018  beq cr6, 0x821e9f14
	if ctx.cr[6].eq {
	pc = 0x821E9F14; continue 'dispatch;
	}
	// 821E9F00: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E9F04: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E9F08: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821E9F0C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E9F10: 41980008  blt cr6, 0x821e9f18
	if ctx.cr[6].lt {
	pc = 0x821E9F18; continue 'dispatch;
	}
	// 821E9F14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821E9F18: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E9F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E9F20: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E9F24: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9F28: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E9F2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E9F30: 4E800421  bctrl
	ctx.lr = 0x821E9F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E9F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E9F38: 48015E41  bl 0x821ffd78
	ctx.lr = 0x821E9F3C;
	sub_821FFD78(ctx, base);
	// 821E9F3C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E9F40: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9F44: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E9F48: 409AFFA8  bne cr6, 0x821e9ef0
	if !ctx.cr[6].eq {
	pc = 0x821E9EF0; continue 'dispatch;
	}
	// 821E9F4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E9F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E9F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E9F58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E9F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E9F60 size=2044
    let mut pc: u32 = 0x821E9F60;
    'dispatch: loop {
        match pc {
            0x821E9F60 => {
    //   block [0x821E9F60..0x821EA75C)
	// 821E9F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9F64: 48ABF491  bl 0x82ca93f4
	ctx.lr = 0x821E9F68;
	sub_82CA93D0(ctx, base);
	// 821E9F68: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821E9F6C: 48AC3D6D  bl 0x82cadcd8
	ctx.lr = 0x821E9F70;
	sub_82CADCA0(ctx, base);
	// 821E9F70: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EA760 size=2512
    let mut pc: u32 = 0x821EA760;
    'dispatch: loop {
        match pc {
            0x821EA760 => {
    //   block [0x821EA760..0x821EB130)
	// 821EA760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EA764: 48ABEC79  bl 0x82ca93dc
	ctx.lr = 0x821EA768;
	sub_82CA93D0(ctx, base);
	// 821EA768: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 821EA76C: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821EA770: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EA774: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EA778: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821EA77C: 3B4B2390  addi r26, r11, 0x2390
	ctx.r[26].s64 = ctx.r[11].s64 + 9104;
	// 821EA780: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821EA784: 9A810050  stb r20, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u8 ) };
	// 821EA788: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821EA78C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821EA790: 397A2004  addi r11, r26, 0x2004
	ctx.r[11].s64 = ctx.r[26].s64 + 8196;
	// 821EA794: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	// 821EA798: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EA79C: 391A6014  addi r8, r26, 0x6014
	ctx.r[8].s64 = ctx.r[26].s64 + 24596;
	// 821EA7A0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EA7A4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821EA7A8: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 821EA7AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EA7B0: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821EA7B4: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EA7B8: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821EA7BC: 908BFFFC  stw r4, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 821EA7C0: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821EA7C4: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821EA7C8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821EA7CC: 4198FFCC  blt cr6, 0x821ea798
	if ctx.cr[6].lt {
	pc = 0x821EA798; continue 'dispatch;
	}
	// 821EA7D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EA7D4: 807305A4  lwz r3, 0x5a4(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1444 as u32) ) } as u64;
	// 821EA7D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EA7DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EA7E0: 3A530270  addi r18, r19, 0x270
	ctx.r[18].s64 = ctx.r[19].s64 + 624;
	// 821EA7E4: 4803430D  bl 0x8221eaf0
	ctx.lr = 0x821EA7E8;
	sub_8221EAF0(ctx, base);
	// 821EA7E8: 817305A4  lwz r11, 0x5a4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1444 as u32) ) } as u64;
	// 821EA7EC: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 821EA7F0: 81330270  lwz r9, 0x270(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(624 as u32) ) } as u64;
	// 821EA7F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821EA7F8: 615FFFFF  ori r31, r10, 0xffff
	ctx.r[31].u64 = ctx.r[10].u64 | 65535;
	// 821EA7FC: 5528077A  rlwinm r8, r9, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821EA800: 80EB0054  lwz r7, 0x54(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821EA804: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821EA808: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EA80C: 7CC7F850  subf r6, r7, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 821EA810: 7CC50034  cntlzw r5, r6
	ctx.r[5].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 821EA814: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 821EA818: 689E0001  xori r30, r4, 1
	ctx.r[30].u64 = ctx.r[4].u64 ^ 1;
	// 821EA81C: 419A0038  beq cr6, 0x821ea854
	if ctx.cr[6].eq {
	pc = 0x821EA854; continue 'dispatch;
	}
	// 821EA820: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EA824: 807305A8  lwz r3, 0x5a8(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1448 as u32) ) } as u64;
	// 821EA828: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EA82C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EA830: 480342C1  bl 0x8221eaf0
	ctx.lr = 0x821EA834;
	sub_8221EAF0(ctx, base);
	// 821EA834: 817305A8  lwz r11, 0x5a8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1448 as u32) ) } as u64;
	// 821EA838: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821EA83C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821EA840: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 821EA844: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821EA848: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821EA84C: 68E60001  xori r6, r7, 1
	ctx.r[6].u64 = ctx.r[7].u64 ^ 1;
	// 821EA850: 7CDEF038  and r30, r6, r30
	ctx.r[30].u64 = ctx.r[6].u64 & ctx.r[30].u64;
	// 821EA854: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821EA858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA85C: 419A08BC  beq cr6, 0x821eb118
	if ctx.cr[6].eq {
	pc = 0x821EB118; continue 'dispatch;
	}
	// 821EA860: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821EA864: C8130048  lfd f0, 0x48(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[19].u32.wrapping_add(72 as u32) ) };
	// 821EA868: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821EA86C: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 821EA870: 39730048  addi r11, r19, 0x48
	ctx.r[11].s64 = ctx.r[19].s64 + 72;
	// 821EA874: C3CA9484  lfs f30, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821EA878: C9A90D38  lfd f13, 0xd38(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821EA87C: C3E8000C  lfs f31, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EA880: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821EA884: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 821EA888: 419A006C  beq cr6, 0x821ea8f4
	if ctx.cr[6].eq {
	pc = 0x821EA8F4; continue 'dispatch;
	}
	// 821EA88C: C98B0008  lfd f12, 8(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821EA890: FD8C0028  fsub f12, f12, f0
	ctx.f[12].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821EA894: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821EA898: 4099005C  ble cr6, 0x821ea8f4
	if !ctx.cr[6].gt {
	pc = 0x821EA8F4; continue 'dispatch;
	}
	// 821EA89C: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EA8A0: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 821EA8A4: 39090E68  addi r8, r9, 0xe68
	ctx.r[8].s64 = ctx.r[9].s64 + 3688;
	// 821EA8A8: C9AA02E8  lfd f13, 0x2e8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(744 as u32) ) };
	// 821EA8AC: FD6D0028  fsub f11, f13, f0
	ctx.f[11].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 821EA8B0: FD4B6024  fdiv f10, f11, f12
	ctx.f[10].f64 = ctx.f[11].f64 / ctx.f[12].f64;
	// 821EA8B4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821EA8B8: FF09F000  fcmpu cr6, f9, f30
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[30].f64);
	// 821EA8BC: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821EA8C0: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821EA8C4: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821EA8C8: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821EA8CC: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821EA8D0: FCE8F26E  fsel f7, f8, f9, f30
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[30].f64 };
	// 821EA8D4: ECC7F828  fsubs f6, f7, f31
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EA8D8: FF06F000  fcmpu cr6, f6, f30
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[30].f64);
	// 821EA8DC: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821EA8E0: 546ADF7A  rlwinm r10, r3, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821EA8E4: 5469F77A  rlwinm r9, r3, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821EA8E8: 7D474B78  or r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EA8EC: 7CA83C2E  lfsx f5, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821EA8F0: FD653FEE  fsel f11, f5, f31, f7
	ctx.f[11].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[7].f64 };
	// 821EA8F4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EA8F8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821EA8FC: 409A000C  bne cr6, 0x821ea908
	if !ctx.cr[6].eq {
	pc = 0x821EA908; continue 'dispatch;
	}
	// 821EA900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EA904: 4800000C  b 0x821ea910
	pc = 0x821EA910; continue 'dispatch;
	// 821EA908: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821EA90C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821EA910: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EA914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA918: 419A0010  beq cr6, 0x821ea928
	if ctx.cr[6].eq {
	pc = 0x821EA928; continue 'dispatch;
	}
	// 821EA91C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821EA920: C0330058  lfs f1, 0x58(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EA924: 4887AF45  bl 0x82a65868
	ctx.lr = 0x821EA928;
	sub_82A65868(ctx, base);
	// 821EA928: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EA92C: 3EA08336  lis r21, -0x7cca
	ctx.r[21].s64 = -2093613056;
	// 821EA930: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 821EA934: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EA938: 38600076  li r3, 0x76
	ctx.r[3].s64 = 118;
	// 821EA93C: 81750364  lwz r11, 0x364(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EA940: 814A00B4  lwz r10, 0xb4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821EA944: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821EA948: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821EA94C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821EA950: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821EA954: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821EA958: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821EA95C: 480418B5  bl 0x8222c210
	ctx.lr = 0x821EA960;
	sub_8222C210(ctx, base);
	// 821EA960: 38600077  li r3, 0x77
	ctx.r[3].s64 = 119;
	// 821EA964: 4801E1AD  bl 0x82208b10
	ctx.lr = 0x821EA968;
	sub_82208B10(ctx, base);
	// 821EA968: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EA96C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 821EA970: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821EA974: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821EA978: 3ACB0DB8  addi r22, r11, 0xdb8
	ctx.r[22].s64 = ctx.r[11].s64 + 3512;
	// 821EA97C: 88BF00BD  lbz r5, 0xbd(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 821EA980: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821EA984: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821EA988: 1D652008  mulli r11, r5, 0x2008
	ctx.r[11].s64 = ctx.r[5].s64 * 8200;
	// 821EA98C: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821EA990: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821EA994: 419A0084  beq cr6, 0x821eaa18
	if ctx.cr[6].eq {
	pc = 0x821EAA18; continue 'dispatch;
	}
	// 821EA998: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EA99C: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821EA9A0: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821EA9A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EA9A8: 409A003C  bne cr6, 0x821ea9e4
	if !ctx.cr[6].eq {
	pc = 0x821EA9E4; continue 'dispatch;
	}
	// 821EA9AC: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9B0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EA9B4: 38FF00A8  addi r7, r31, 0xa8
	ctx.r[7].s64 = ctx.r[31].s64 + 168;
	// 821EA9B8: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EA9BC: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821EA9C0: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821EA9C4: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9C8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EA9CC: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821EA9D0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EA9D4: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EA9D8: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9DC: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821EA9E0: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821EA9E4: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821EA9E8: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 821EA9EC: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821EA9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA9F4: 409A0024  bne cr6, 0x821eaa18
	if !ctx.cr[6].eq {
	pc = 0x821EAA18; continue 'dispatch;
	}
	// 821EA9F8: 81790DB0  lwz r11, 0xdb0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EA9FC: 393F00A8  addi r9, r31, 0xa8
	ctx.r[9].s64 = ctx.r[31].s64 + 168;
	// 821EAA00: 995F00BC  stb r10, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821EAA04: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAA08: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821EAA0C: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAA10: 7D28B12E  stwx r9, r8, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	// 821EAA14: 48000008  b 0x821eaa1c
	pc = 0x821EAA1C; continue 'dispatch;
	// 821EAA18: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EAA1C: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821EAA20: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EAA24: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821EAA28: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821EAA2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAA30: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821EAA34: 419A0080  beq cr6, 0x821eaab4
	if ctx.cr[6].eq {
	pc = 0x821EAAB4; continue 'dispatch;
	}
	// 821EAA38: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAA3C: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EAA40: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821EAA44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EAA48: 409A003C  bne cr6, 0x821eaa84
	if !ctx.cr[6].eq {
	pc = 0x821EAA84; continue 'dispatch;
	}
	// 821EAA4C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA50: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EAA54: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 821EAA58: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EAA5C: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821EAA60: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821EAA64: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA68: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EAA6C: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAA70: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAA74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EAA78: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EAA80: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821EAA84: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821EAA88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EAA8C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 821EAA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EAA94: 409A0020  bne cr6, 0x821eaab4
	if !ctx.cr[6].eq {
	pc = 0x821EAAB4; continue 'dispatch;
	}
	// 821EAA98: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAA9C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821EAAA0: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821EAAA4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAAA8: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 821EAAAC: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAAB0: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	// 821EAAB4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EAAB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EAABC: 392BDED4  addi r9, r11, -0x212c
	ctx.r[9].s64 = ctx.r[11].s64 + -8492;
	// 821EAAC0: 7958FFE6  rldicr r24, r10, 0x3f, 0x3f
	ctx.r[24].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821EAAC4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAAC8: 83CB0300  lwz r30, 0x300(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(768 as u32) ) } as u64;
	// 821EAACC: 83AB02F4  lwz r29, 0x2f4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(756 as u32) ) } as u64;
	// 821EAAD0: 836B0660  lwz r27, 0x660(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1632 as u32) ) } as u64;
	// 821EAAD4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821EAAD8: 41980024  blt cr6, 0x821eaafc
	if ctx.cr[6].lt {
	pc = 0x821EAAFC; continue 'dispatch;
	}
	// 821EAADC: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821EAAE0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAAE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EAAE8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAAEC: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAAF0: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAAF4: 4BFCC3ED  bl 0x821b6ee0
	ctx.lr = 0x821EAAF8;
	sub_821B6EE0(ctx, base);
	// 821EAAF8: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EAAFC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EAB00: 395F0AB0  addi r10, r31, 0xab0
	ctx.r[10].s64 = ctx.r[31].s64 + 2736;
	// 821EAB04: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821EAB08: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821EAB0C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAB10: 3BCB6F38  addi r30, r11, 0x6f38
	ctx.r[30].s64 = ctx.r[11].s64 + 28472;
	// 821EAB14: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAB18: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAB1C: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAB20: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAB24: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 821EAB28: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s64 = ctx.r[7].s64 * 8200;
	// 821EAB2C: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAB30: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAB34: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAB38: 419A0070  beq cr6, 0x821eaba8
	if ctx.cr[6].eq {
	pc = 0x821EABA8; continue 'dispatch;
	}
	// 821EAB3C: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAB40: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAB44: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAB48: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EAB4C: 409A0038  bne cr6, 0x821eab84
	if !ctx.cr[6].eq {
	pc = 0x821EAB84; continue 'dispatch;
	}
	// 821EAB50: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB54: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAB58: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAB5C: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821EAB60: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAB64: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB68: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAB6C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAB70: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAB74: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAB78: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB7C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821EAB80: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821EAB84: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAB88: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821EAB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAB90: 409A0018  bne cr6, 0x821eaba8
	if !ctx.cr[6].eq {
	pc = 0x821EABA8; continue 'dispatch;
	}
	// 821EAB94: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAB98: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAB9C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EABA0: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EABA4: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EABA8: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EABAC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EABB0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EABB4: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821EABB8: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EABBC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EABC0: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821EABC4: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EABC8: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EABCC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EABD0: 419A0070  beq cr6, 0x821eac40
	if ctx.cr[6].eq {
	pc = 0x821EAC40; continue 'dispatch;
	}
	// 821EABD4: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EABD8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EABDC: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821EABE0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EABE4: 409A0038  bne cr6, 0x821eac1c
	if !ctx.cr[6].eq {
	pc = 0x821EAC1C; continue 'dispatch;
	}
	// 821EABE8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EABEC: 7D044B78  or r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821EABF0: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EABF4: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EABF8: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EABFC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAC00: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAC04: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAC08: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAC0C: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821EAC10: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAC14: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821EAC18: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	// 821EAC1C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAC20: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAC24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAC28: 409A0018  bne cr6, 0x821eac40
	if !ctx.cr[6].eq {
	pc = 0x821EAC40; continue 'dispatch;
	}
	// 821EAC2C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAC30: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAC34: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAC38: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAC3C: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EAC40: 81520000  lwz r10, 0(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAC44: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821EAC48: 5549077A  rlwinm r9, r10, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EAC4C: 3B8BB0BC  addi r28, r11, -0x4f44
	ctx.r[28].s64 = ctx.r[11].s64 + -20292;
	// 821EAC50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EAC54: 419A0168  beq cr6, 0x821eadbc
	if ctx.cr[6].eq {
	pc = 0x821EADBC; continue 'dispatch;
	}
	// 821EAC58: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EAC5C: 41980024  blt cr6, 0x821eac80
	if ctx.cr[6].lt {
	pc = 0x821EAC80; continue 'dispatch;
	}
	// 821EAC60: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 821EAC64: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAC68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EAC6C: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAC70: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAC74: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAC78: 4BFCC269  bl 0x821b6ee0
	ctx.lr = 0x821EAC7C;
	sub_821B6EE0(ctx, base);
	// 821EAC7C: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EAC80: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAC84: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAC88: 397F0AB0  addi r11, r31, 0xab0
	ctx.r[11].s64 = ctx.r[31].s64 + 2736;
	// 821EAC8C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 821EAC90: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821EAC94: 55461838  slwi r6, r10, 3
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EAC98: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821EAC9C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EACA0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EACA4: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s64 = ctx.r[8].s64 * 8200;
	// 821EACA8: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EACAC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EACB0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EACB4: 419A0074  beq cr6, 0x821ead28
	if ctx.cr[6].eq {
	pc = 0x821EAD28; continue 'dispatch;
	}
	// 821EACB8: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EACBC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EACC0: 7CE34038  and r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EACC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EACC8: 409A003C  bne cr6, 0x821ead04
	if !ctx.cr[6].eq {
	pc = 0x821EAD04; continue 'dispatch;
	}
	// 821EACCC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACD0: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EACD4: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821EACD8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821EACDC: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EACE0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EACE8: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EACEC: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EACF0: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821EACF4: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACF8: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 821EACFC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAD00: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821EAD04: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAD08: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821EAD0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAD10: 409A0018  bne cr6, 0x821ead28
	if !ctx.cr[6].eq {
	pc = 0x821EAD28; continue 'dispatch;
	}
	// 821EAD14: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAD18: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAD1C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAD20: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAD24: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EAD28: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EAD2C: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821EAD30: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAD34: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAD38: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821EAD3C: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAD40: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EAD44: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAD48: 419A009C  beq cr6, 0x821eade4
	if ctx.cr[6].eq {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EAD4C: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAD50: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAD54: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAD58: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EAD5C: 409A0038  bne cr6, 0x821ead94
	if !ctx.cr[6].eq {
	pc = 0x821EAD94; continue 'dispatch;
	}
	// 821EAD60: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD64: 7CE44378  or r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAD68: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EAD6C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EAD70: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAD74: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD78: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAD7C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAD80: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAD84: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAD88: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD8C: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 821EAD90: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	// 821EAD94: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAD98: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821EAD9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EADA0: 409A0044  bne cr6, 0x821eade4
	if !ctx.cr[6].eq {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EADA4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EADA8: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EADAC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EADB0: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EADB4: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EADB8: 4800002C  b 0x821eade4
	pc = 0x821EADE4; continue 'dispatch;
	// 821EADBC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EADC0: 41980024  blt cr6, 0x821eade4
	if ctx.cr[6].lt {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EADC4: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 821EADC8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EADCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EADD0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EADD4: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EADD8: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EADDC: 4BFCC105  bl 0x821b6ee0
	ctx.lr = 0x821EADE0;
	sub_821B6EE0(ctx, base);
	// 821EADE0: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EADE4: 81720204  lwz r11, 0x204(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(516 as u32) ) } as u64;
	// 821EADE8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821EADEC: 419A0180  beq cr6, 0x821eaf6c
	if ctx.cr[6].eq {
	pc = 0x821EAF6C; continue 'dispatch;
	}
	// 821EADF0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821EADF4: 41980038  blt cr6, 0x821eae2c
	if ctx.cr[6].lt {
	pc = 0x821EAE2C; continue 'dispatch;
	}
	// 821EADF8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821EADFC: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAE00: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAE04: 390AF7A8  addi r8, r10, -0x858
	ctx.r[8].s64 = ctx.r[10].s64 + -2136;
	// 821EAE08: 38FB0020  addi r7, r27, 0x20
	ctx.r[7].s64 = ctx.r[27].s64 + 32;
	// 821EAE0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EAE10: 78E60020  clrldi r6, r7, 0x20
	ctx.r[6].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821EAE14: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE18: 7F063436  srd r6, r24, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 821EAE1C: 7CA9582E  lwzx r5, r9, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821EAE20: 80A50078  lwz r5, 0x78(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(120 as u32) ) } as u64;
	// 821EAE24: 4BFCC0BD  bl 0x821b6ee0
	ctx.lr = 0x821EAE28;
	sub_821B6EE0(ctx, base);
	// 821EAE28: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EAE2C: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAE30: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAE34: 397F0AB0  addi r11, r31, 0xab0
	ctx.r[11].s64 = ctx.r[31].s64 + 2736;
	// 821EAE38: 7CFB5214  add r7, r27, r10
	ctx.r[7].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 821EAE3C: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 821EAE40: 54E91838  slwi r9, r7, 3
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAE44: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAE48: 888B0015  lbz r4, 0x15(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAE4C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE50: 1D442008  mulli r10, r4, 0x2008
	ctx.r[10].s64 = ctx.r[4].s64 * 8200;
	// 821EAE54: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAE58: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAE5C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAE60: 419A0070  beq cr6, 0x821eaed0
	if ctx.cr[6].eq {
	pc = 0x821EAED0; continue 'dispatch;
	}
	// 821EAE64: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAE68: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAE6C: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAE70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EAE74: 409A0038  bne cr6, 0x821eaeac
	if !ctx.cr[6].eq {
	pc = 0x821EAEAC; continue 'dispatch;
	}
	// 821EAE78: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAE7C: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAE80: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAE84: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821EAE88: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAE8C: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAE90: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE94: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAE98: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAE9C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821EAEA0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAEA4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821EAEA8: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821EAEAC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAEB0: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821EAEB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAEB8: 409A0018  bne cr6, 0x821eaed0
	if !ctx.cr[6].eq {
	pc = 0x821EAED0; continue 'dispatch;
	}
	// 821EAEBC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAEC0: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAEC4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAEC8: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAECC: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EAED0: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EAED4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAED8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAEDC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821EAEE0: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAEE4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAEE8: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821EAEEC: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAEF0: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAEF4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAEF8: 419A0098  beq cr6, 0x821eaf90
	if ctx.cr[6].eq {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAEFC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAF00: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAF04: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821EAF08: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EAF0C: 409A0038  bne cr6, 0x821eaf44
	if !ctx.cr[6].eq {
	pc = 0x821EAF44; continue 'dispatch;
	}
	// 821EAF10: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF14: 7D044B78  or r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821EAF18: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EAF1C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EAF20: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAF24: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAF28: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF2C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAF30: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAF34: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821EAF38: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF3C: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821EAF40: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	// 821EAF44: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAF48: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAF4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAF50: 409A0040  bne cr6, 0x821eaf90
	if !ctx.cr[6].eq {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAF54: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAF58: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAF5C: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821EAF60: 91590DB0  stw r10, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821EAF64: 7D69B12E  stwx r11, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EAF68: 48000028  b 0x821eaf90
	pc = 0x821EAF90; continue 'dispatch;
	// 821EAF6C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821EAF70: 41980020  blt cr6, 0x821eaf90
	if ctx.cr[6].lt {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAF74: 397B0020  addi r11, r27, 0x20
	ctx.r[11].s64 = ctx.r[27].s64 + 32;
	// 821EAF78: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAF7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EAF80: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAF84: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAF88: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAF8C: 4BFCBF55  bl 0x821b6ee0
	ctx.lr = 0x821EAF90;
	sub_821B6EE0(ctx, base);
	// 821EAF90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821EAF94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821EAF98: 394B60B8  addi r10, r11, 0x60b8
	ctx.r[10].s64 = ctx.r[11].s64 + 24760;
	// 821EAF9C: 83EB60B8  lwz r31, 0x60b8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821EAFA0: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAFA4: 83AA0008  lwz r29, 8(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAFA8: 838A000C  lwz r28, 0xc(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EAFAC: 48050E05  bl 0x8223bdb0
	ctx.lr = 0x821EAFB0;
	sub_8223BDB0(ctx, base);
	// 821EAFB0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821EAFB4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821EAFB8: 48085D19  bl 0x82270cd0
	ctx.lr = 0x821EAFBC;
	sub_82270CD0(ctx, base);
	// 821EAFBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EAFC0: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 821EAFC4: 4BFDD14D  bl 0x821c8110
	ctx.lr = 0x821EAFC8;
	sub_821C8110(ctx, base);
	// 821EAFC8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EAFCC: E9691760  ld r11, 0x1760(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 821EAFD0: 79680004  rldicr r8, r11, 0, 0
	ctx.r[8].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821EAFD4: 2B280000  cmpldi cr6, r8, 0
	ctx.cr[6].compare_u64(ctx.r[8].u64, 0, &mut ctx.xer);
	// 821EAFD8: 419A001C  beq cr6, 0x821eaff4
	if ctx.cr[6].eq {
	pc = 0x821EAFF4; continue 'dispatch;
	}
	// 821EAFDC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821EAFE0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAFE4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821EAFE8: 38B106B0  addi r5, r17, 0x6b0
	ctx.r[5].s64 = ctx.r[17].s64 + 1712;
	// 821EAFEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EAFF0: 4802F891  bl 0x8221a880
	ctx.lr = 0x821EAFF4;
	sub_8221A880(ctx, base);
	// 821EAFF4: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAFF8: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 821EAFFC: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB130 size=52
    let mut pc: u32 = 0x821EB130;
    'dispatch: loop {
        match pc {
            0x821EB130 => {
    //   block [0x821EB130..0x821EB164)
	// 821EB130: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821EB134: 39800020  li r12, 0x20
	ctx.r[12].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB164(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB164 size=44
    let mut pc: u32 = 0x821EB164;
    'dispatch: loop {
        match pc {
            0x821EB164 => {
    //   block [0x821EB164..0x821EB190)
	// 821EB164: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821EB168: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821EB16C: 7CEA0194  addze r7, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821EB170: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821EB174: 792AFFE6  rldicr r10, r9, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821EB178: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 821EB17C: 7D453436  srd r5, r10, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = (ctx.r[10].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 821EB180: E9281758  ld r9, 0x1758(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5976 as u32) ) };
	// 821EB184: 7CA44838  and r4, r5, r9
	ctx.r[4].u64 = ctx.r[5].u64 & ctx.r[9].u64;
	// 821EB188: 2B240000  cmpldi cr6, r4, 0
	ctx.cr[6].compare_u64(ctx.r[4].u64, 0, &mut ctx.xer);
	// 821EB18C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB190 size=96
    let mut pc: u32 = 0x821EB190;
    'dispatch: loop {
        match pc {
            0x821EB190 => {
    //   block [0x821EB190..0x821EB1F0)
	// 821EB190: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821EB194: C0010020  lfs f0, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EB198: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821EB19C: C1A10024  lfs f13, 0x24(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EB1A0: 38CB0178  addi r6, r11, 0x178
	ctx.r[6].s64 = ctx.r[11].s64 + 376;
	// 821EB1A4: C1810028  lfs f12, 0x28(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821EB1A8: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EB1AC: C161002C  lfs f11, 0x2c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821EB1B0: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821EB1B4: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EB1B8: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EB1BC: 7C673850  subf r3, r7, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 821EB1C0: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EB1C4: D16A178C  stfs f11, 0x178c(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 821EB1C8: D1AA1784  stfs f13, 0x1784(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 821EB1CC: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 821EB1D0: 7C045D2E  stfsx f0, r4, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821EB1D4: 7CA84E34  srad r8, r5, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[5].s64 < 0) && ((ctx.r[5].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[8].s64 = ctx.r[5].s64 >> tmp.u64;
	// 821EB1D8: D18A1788  stfs f12, 0x1788(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 821EB1DC: 7D073C36  srd r7, r8, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[8].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821EB1E0: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821EB1E4: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 821EB1E8: F8AB0008  std r5, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821EB1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB1F0 size=108
    let mut pc: u32 = 0x821EB1F0;
    'dispatch: loop {
        match pc {
            0x821EB1F0 => {
    //   block [0x821EB1F0..0x821EB25C)
	// 821EB1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB1FC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821EB200: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB260 size=76
    let mut pc: u32 = 0x821EB260;
    'dispatch: loop {
        match pc {
            0x821EB260 => {
    //   block [0x821EB260..0x821EB2AC)
	// 821EB260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB26C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB270: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB274: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821EB278: 8085001C  lwz r4, 0x1c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EB280: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB284: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821EB288: 386BFFF8  addi r3, r11, -8
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	// 821EB28C: 480001C5  bl 0x821eb450
	ctx.lr = 0x821EB290;
	sub_821EB450(ctx, base);
	// 821EB290: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EB298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB2B0 size=76
    let mut pc: u32 = 0x821EB2B0;
    'dispatch: loop {
        match pc {
            0x821EB2B0 => {
    //   block [0x821EB2B0..0x821EB2FC)
	// 821EB2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB2BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB2C0: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB2C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821EB2C8: 80850024  lwz r4, 0x24(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821EB2CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EB2D0: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB2D4: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821EB2D8: 386BFFEC  addi r3, r11, -0x14
	ctx.r[3].s64 = ctx.r[11].s64 + -20;
	// 821EB2DC: 48000175  bl 0x821eb450
	ctx.lr = 0x821EB2E0;
	sub_821EB450(ctx, base);
	// 821EB2E0: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EB2E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB2EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB2F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB2F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB2F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB300 size=332
    let mut pc: u32 = 0x821EB300;
    'dispatch: loop {
        match pc {
            0x821EB300 => {
    //   block [0x821EB300..0x821EB44C)
	// 821EB300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB308: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB30C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EB314: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB318: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821EB31C: 409A0024  bne cr6, 0x821eb340
	if !ctx.cr[6].eq {
	pc = 0x821EB340; continue 'dispatch;
	}
	// 821EB320: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB328: 419A0084  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	// 821EB32C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB330: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB338: 409AFFF4  bne cr6, 0x821eb32c
	if !ctx.cr[6].eq {
	pc = 0x821EB32C; continue 'dispatch;
	}
	// 821EB33C: 48000070  b 0x821eb3ac
	pc = 0x821EB3AC; continue 'dispatch;
	// 821EB340: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB344: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB348: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821EB34C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB350: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB354: 38EA0044  addi r7, r10, 0x44
	ctx.r[7].s64 = ctx.r[10].s64 + 68;
	// 821EB358: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EB35C: 7D46482E  lwzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821EB360: 5545077A  rlwinm r5, r10, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB364: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821EB368: 409A005C  bne cr6, 0x821eb3c4
	if !ctx.cr[6].eq {
	pc = 0x821EB3C4; continue 'dispatch;
	}
	// 821EB36C: 55470294  rlwinm r7, r10, 0, 0xa, 0xa
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB370: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821EB374: 409A007C  bne cr6, 0x821eb3f0
	if !ctx.cr[6].eq {
	pc = 0x821EB3F0; continue 'dispatch;
	}
	// 821EB378: 554A035A  rlwinm r10, r10, 0, 0xd, 0xd
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB37C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821EB380: 409A00AC  bne cr6, 0x821eb42c
	if !ctx.cr[6].eq {
	pc = 0x821EB42C; continue 'dispatch;
	}
	// 821EB384: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB38C: 409AFFC0  bne cr6, 0x821eb34c
	if !ctx.cr[6].eq {
	pc = 0x821EB34C; continue 'dispatch;
	}
	// 821EB390: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EB394: 419A0018  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	// 821EB398: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821EB39C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB3A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB3A8: 409AFFF4  bne cr6, 0x821eb39c
	if !ctx.cr[6].eq {
	pc = 0x821EB39C; continue 'dispatch;
	}
	// 821EB3AC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB3B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB3C0: 4E800020  blr
	return;
	// 821EB3C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3C8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821EB3CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB3D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB3D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB3D8: 4E800421  bctrl
	ctx.lr = 0x821EB3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB3DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB3E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB3E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB3E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB3EC: 4E800020  blr
	return;
	// 821EB3F0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3F8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EB3FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB400: 4E800421  bctrl
	ctx.lr = 0x821EB404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB404: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB408: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB40C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB410: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821EB414: 4E800421  bctrl
	ctx.lr = 0x821EB418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB41C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB428: 4E800020  blr
	return;
	// 821EB42C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EB430: 419AFF7C  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	// 821EB434: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821EB438: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB43C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB444: 409AFFF4  bne cr6, 0x821eb438
	if !ctx.cr[6].eq {
	pc = 0x821EB438; continue 'dispatch;
	}
	// 821EB448: 4BFFFF64  b 0x821eb3ac
	pc = 0x821EB3AC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB450 size=800
    let mut pc: u32 = 0x821EB450;
    'dispatch: loop {
        match pc {
            0x821EB450 => {
    //   block [0x821EB450..0x821EB770)
	// 821EB450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB454: 48ABDF99  bl 0x82ca93ec
	ctx.lr = 0x821EB458;
	sub_82CA93D0(ctx, base);
	// 821EB458: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB45C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EB460: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821EB464: 578B06FE  clrlwi r11, r28, 0x1b
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x0000001Fu64;
	// 821EB468: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821EB46C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821EB470: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821EB474: 3AC0001F  li r22, 0x1f
	ctx.r[22].s64 = 31;
	// 821EB478: 571506FE  clrlwi r21, r24, 0x1b
	ctx.r[21].u64 = ctx.r[24].u32 as u64 & 0x0000001Fu64;
	// 821EB47C: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 821EB480: 409A0224  bne cr6, 0x821eb6a4
	if !ctx.cr[6].eq {
	pc = 0x821EB6A4; continue 'dispatch;
	}
	// 821EB484: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821EB488: 3BF70034  addi r31, r23, 0x34
	ctx.r[31].s64 = ctx.r[23].s64 + 52;
	// 821EB48C: 52CB043E  rlwimi r11, r22, 0, 0x10, 0x1f
	ctx.r[11].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x000000000000FFFF) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF0000);
	// 821EB490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821EB494: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821EB498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821EB49C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB4A0: 48393769  bl 0x8257ec08
	ctx.lr = 0x821EB4A4;
	sub_8257EC08(ctx, base);
	// 821EB4A4: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EB4A8: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB4AC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB4B0: 419A000C  beq cr6, 0x821eb4bc
	if ctx.cr[6].eq {
	pc = 0x821EB4BC; continue 'dispatch;
	}
	// 821EB4B4: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EB4B8: 419A0008  beq cr6, 0x821eb4c0
	if ctx.cr[6].eq {
	pc = 0x821EB4C0; continue 'dispatch;
	}
	// 821EB4BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB4C0: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821EB4C4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB4C8: 419A01D8  beq cr6, 0x821eb6a0
	if ctx.cr[6].eq {
	pc = 0x821EB6A0; continue 'dispatch;
	}
	// 821EB4CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821EB4D0: 419A0188  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB4D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EB4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB4DC: 4BFD0935  bl 0x821bbe10
	ctx.lr = 0x821EB4E0;
	sub_821BBE10(ctx, base);
	// 821EB4E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EB4E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EB4E8: 419A0170  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB4EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EB4F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EB4F4: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 821EB4F8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821EB4FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB500: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821EB504: 48029395  bl 0x82214898
	ctx.lr = 0x821EB508;
	sub_82214898(ctx, base);
	// 821EB508: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB50C: 409A0008  bne cr6, 0x821eb514
	if !ctx.cr[6].eq {
	pc = 0x821EB514; continue 'dispatch;
	}
	// 821EB510: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB514: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB518: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB51C: 409A0008  bne cr6, 0x821eb524
	if !ctx.cr[6].eq {
	pc = 0x821EB524; continue 'dispatch;
	}
	// 821EB520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB524: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB528: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821EB52C: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB530: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB534: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB538: 40990008  ble cr6, 0x821eb540
	if !ctx.cr[6].gt {
	pc = 0x821EB540; continue 'dispatch;
	}
	// 821EB53C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB540: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB544: 409A0008  bne cr6, 0x821eb54c
	if !ctx.cr[6].eq {
	pc = 0x821EB54C; continue 'dispatch;
	}
	// 821EB548: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB54C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB550: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB554: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB558: 40990008  ble cr6, 0x821eb560
	if !ctx.cr[6].gt {
	pc = 0x821EB560; continue 'dispatch;
	}
	// 821EB55C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB560: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821EB564: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821EB568: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821EB56C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB570: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821EB574: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821EB578: 419A0074  beq cr6, 0x821eb5ec
	if ctx.cr[6].eq {
	pc = 0x821EB5EC; continue 'dispatch;
	}
	// 821EB57C: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821EB580: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB588: 419A0020  beq cr6, 0x821eb5a8
	if ctx.cr[6].eq {
	pc = 0x821EB5A8; continue 'dispatch;
	}
	// 821EB58C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EB594: 419A000C  beq cr6, 0x821eb5a0
	if ctx.cr[6].eq {
	pc = 0x821EB5A0; continue 'dispatch;
	}
	// 821EB598: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821EB59C: 48000010  b 0x821eb5ac
	pc = 0x821EB5AC; continue 'dispatch;
	// 821EB5A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB5A4: 4BFA8895  bl 0x82193e38
	ctx.lr = 0x821EB5A8;
	sub_82193E38(ctx, base);
	// 821EB5A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821EB5AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821EB5B0: 419A0024  beq cr6, 0x821eb5d4
	if ctx.cr[6].eq {
	pc = 0x821EB5D4; continue 'dispatch;
	}
	// 821EB5B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB5BC: 419A000C  beq cr6, 0x821eb5c8
	if ctx.cr[6].eq {
	pc = 0x821EB5C8; continue 'dispatch;
	}
	// 821EB5C0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EB5C4: 48000014  b 0x821eb5d8
	pc = 0x821EB5D8; continue 'dispatch;
	// 821EB5C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB5CC: 4BFA886D  bl 0x82193e38
	ctx.lr = 0x821EB5D0;
	sub_82193E38(ctx, base);
	// 821EB5D0: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821EB5D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EB5D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB5DC: 419A0010  beq cr6, 0x821eb5ec
	if ctx.cr[6].eq {
	pc = 0x821EB5EC; continue 'dispatch;
	}
	// 821EB5E0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821EB5E4: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB5E8: 409AFF98  bne cr6, 0x821eb580
	if !ctx.cr[6].eq {
	pc = 0x821EB580; continue 'dispatch;
	}
	// 821EB5EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EB5F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB5F4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821EB5F8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821EB5FC: 4BFA883D  bl 0x82193e38
	ctx.lr = 0x821EB600;
	sub_82193E38(ctx, base);
	// 821EB600: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB604: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB608: 409A0008  bne cr6, 0x821eb610
	if !ctx.cr[6].eq {
	pc = 0x821EB610; continue 'dispatch;
	}
	// 821EB60C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB610: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB614: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821EB618: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB61C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB620: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB624: 40990008  ble cr6, 0x821eb62c
	if !ctx.cr[6].gt {
	pc = 0x821EB62C; continue 'dispatch;
	}
	// 821EB628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB62C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB630: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EB634: 419A000C  beq cr6, 0x821eb640
	if ctx.cr[6].eq {
	pc = 0x821EB640; continue 'dispatch;
	}
	// 821EB638: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB63C: 419A0008  beq cr6, 0x821eb644
	if ctx.cr[6].eq {
	pc = 0x821EB644; continue 'dispatch;
	}
	// 821EB640: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB644: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB648: 419A0010  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB64C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EB650: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821EB654: 48ABDDE8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 821EB658: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB65C: 409A0008  bne cr6, 0x821eb664
	if !ctx.cr[6].eq {
	pc = 0x821EB664; continue 'dispatch;
	}
	// 821EB660: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB664: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB668: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB66C: 409A0008  bne cr6, 0x821eb674
	if !ctx.cr[6].eq {
	pc = 0x821EB674; continue 'dispatch;
	}
	// 821EB670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB674: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB678: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821EB67C: 578905B4  rlwinm r9, r28, 0, 0x16, 0x1a
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB680: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB684: 510A06FE  rlwimi r10, r8, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821EB688: 5507001E  rlwinm r7, r8, 0, 0, 0xf
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB68C: 5546047E  clrlwi r6, r10, 0x11
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 821EB690: 54C606EA  rlwinm r6, r6, 0, 0x1b, 0x15
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB694: 7CC53B78  or r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 821EB698: 7CBC4B78  or r28, r5, r9
	ctx.r[28].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821EB69C: 48000008  b 0x821eb6a4
	pc = 0x821EB6A4; continue 'dispatch;
	// 821EB6A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821EB6A4: 2B15001F  cmplwi cr6, r21, 0x1f
	ctx.cr[6].compare_u32(ctx.r[21].u32, 31 as u32, &mut ctx.xer);
	// 821EB6A8: 409A0098  bne cr6, 0x821eb740
	if !ctx.cr[6].eq {
	pc = 0x821EB740; continue 'dispatch;
	}
	// 821EB6AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821EB6B0: 3BF70034  addi r31, r23, 0x34
	ctx.r[31].s64 = ctx.r[23].s64 + 52;
	// 821EB6B4: 52CB043E  rlwimi r11, r22, 0, 0x10, 0x1f
	ctx.r[11].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x000000000000FFFF) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF0000);
	// 821EB6B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821EB6BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821EB6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821EB6C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB6C8: 48393541  bl 0x8257ec08
	ctx.lr = 0x821EB6CC;
	sub_8257EC08(ctx, base);
	// 821EB6CC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB6D0: 81370038  lwz r9, 0x38(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EB6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB6D8: 419A000C  beq cr6, 0x821eb6e4
	if ctx.cr[6].eq {
	pc = 0x821EB6E4; continue 'dispatch;
	}
	// 821EB6DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EB6E0: 419A0008  beq cr6, 0x821eb6e8
	if ctx.cr[6].eq {
	pc = 0x821EB6E8; continue 'dispatch;
	}
	// 821EB6E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB6E8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821EB6EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB6F0: 419A004C  beq cr6, 0x821eb73c
	if ctx.cr[6].eq {
	pc = 0x821EB73C; continue 'dispatch;
	}
	// 821EB6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB6F8: 409A0008  bne cr6, 0x821eb700
	if !ctx.cr[6].eq {
	pc = 0x821EB700; continue 'dispatch;
	}
	// 821EB6FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB704: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB708: 409A0008  bne cr6, 0x821eb710
	if !ctx.cr[6].eq {
	pc = 0x821EB710; continue 'dispatch;
	}
	// 821EB70C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EB710: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB714: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821EB718: 570905B4  rlwinm r9, r24, 0, 0x16, 0x1a
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB71C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB720: 510A06FE  rlwimi r10, r8, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821EB724: 5507001E  rlwinm r7, r8, 0, 0, 0xf
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB728: 5546047E  clrlwi r6, r10, 0x11
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 821EB72C: 54C606EA  rlwinm r6, r6, 0, 0x1b, 0x15
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB730: 7CC53B78  or r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 821EB734: 7CB84B78  or r24, r5, r9
	ctx.r[24].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821EB738: 48000008  b 0x821eb740
	pc = 0x821EB740; continue 'dispatch;
	// 821EB73C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821EB740: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821EB744: 80970030  lwz r4, 0x30(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(48 as u32) ) } as u64;
	// 821EB748: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821EB74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EB750: 48BCB641  bl 0x82db6d90
	ctx.lr = 0x821EB754;
	sub_82DB6D90(ctx, base);
	// 821EB754: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB758: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 821EB75C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821EB760: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821EB764: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821EB768: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821EB76C: 48ABDCD0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB770 size=88
    let mut pc: u32 = 0x821EB770;
    'dispatch: loop {
        match pc {
            0x821EB770 => {
    //   block [0x821EB770..0x821EB7C8)
	// 821EB770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB774: 48ABDC99  bl 0x82ca940c
	ctx.lr = 0x821EB778;
	sub_82CA93D0(ctx, base);
	// 821EB778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB77C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EB784: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EB788: 83A50020  lwz r29, 0x20(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 821EB78C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 821EB790: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821EB794: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB79C: 4E800421  bctrl
	ctx.lr = 0x821EB7A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB7A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EB7A4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB7A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EB7AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EB7B0: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 821EB7B4: 4BFFFC9D  bl 0x821eb450
	ctx.lr = 0x821EB7B8;
	sub_821EB450(ctx, base);
	// 821EB7B8: 987E0000  stb r3, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB7C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EB7C4: 48ABDC98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB7C8 size=140
    let mut pc: u32 = 0x821EB7C8;
    'dispatch: loop {
        match pc {
            0x821EB7C8 => {
    //   block [0x821EB7C8..0x821EB854)
	// 821EB7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB7CC: 48ABDC35  bl 0x82ca9400
	ctx.lr = 0x821EB7D0;
	sub_82CA93D0(ctx, base);
	// 821EB7D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB7D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821EB7D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EB7DC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821EB7E0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821EB7E4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821EB7E8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821EB7EC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 821EB7F0: 4BFFFB11  bl 0x821eb300
	ctx.lr = 0x821EB7F4;
	sub_821EB300(ctx, base);
	// 821EB7F4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB7F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EB7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EB800: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821EB804: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB808: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB80C: 4E800421  bctrl
	ctx.lr = 0x821EB810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB810: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB814: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EB818: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821EB81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB820: 419A0014  beq cr6, 0x821eb834
	if ctx.cr[6].eq {
	pc = 0x821EB834; continue 'dispatch;
	}
	// 821EB824: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821EB828: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB830: 409AFFF4  bne cr6, 0x821eb824
	if !ctx.cr[6].eq {
	pc = 0x821EB824; continue 'dispatch;
	}
	// 821EB834: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821EB838: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EB83C: 387CFFF4  addi r3, r28, -0xc
	ctx.r[3].s64 = ctx.r[28].s64 + -12;
	// 821EB840: 4BFFFC11  bl 0x821eb450
	ctx.lr = 0x821EB844;
	sub_821EB450(ctx, base);
	// 821EB844: 987D0000  stb r3, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EB84C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EB850: 48ABDC00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB858 size=112
    let mut pc: u32 = 0x821EB858;
    'dispatch: loop {
        match pc {
            0x821EB858 => {
    //   block [0x821EB858..0x821EB8C8)
	// 821EB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB860: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB864: 48BCD455  bl 0x82db8cb8
	ctx.lr = 0x821EB868;
	sub_82DB8CB8(ctx, base);
	// 821EB868: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821EB86C: 894B8FEF  lbz r10, -0x7011(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28689 as u32) ) } as u64;
	// 821EB870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EB874: 419A0044  beq cr6, 0x821eb8b8
	if ctx.cr[6].eq {
	pc = 0x821EB8B8; continue 'dispatch;
	}
	// 821EB878: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821EB87C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821EB880: 392B1210  addi r9, r11, 0x1210
	ctx.r[9].s64 = ctx.r[11].s64 + 4624;
	// 821EB884: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821EB888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB8C8 size=88
    let mut pc: u32 = 0x821EB8C8;
    'dispatch: loop {
        match pc {
            0x821EB8C8 => {
    //   block [0x821EB8C8..0x821EB920)
	// 821EB8C8: 81430060  lwz r10, 0x60(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB8CC: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 821EB8D0: 81230068  lwz r9, 0x68(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 821EB8D4: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821EB8D8: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 821EB8DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB8E0: 7D6859D6  mullw r11, r8, r11
	ctx.r[11].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821EB8E4: 7D6B4A15  add. r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EB8E8: 41800038  blt 0x821eb920
	if ctx.cr[0].lt {
		sub_821EB920(ctx, base);
		return;
	}
	// 821EB8EC: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EB8F0: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 821EB8F4: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB8F8: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821EB8FC: 7CA643D6  divw r5, r6, r8
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[8].s32;
	// 821EB900: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821EB904: 4098001C  bge cr6, 0x821eb920
	if !ctx.cr[6].lt {
		sub_821EB920(ctx, base);
		return;
	}
	// 821EB908: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EB90C: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EB910: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821EB914: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EB918: 7C28542E  lfsx f1, r8, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB920 size=12
    let mut pc: u32 = 0x821EB920;
    'dispatch: loop {
        match pc {
            0x821EB920 => {
    //   block [0x821EB920..0x821EB92C)
	// 821EB920: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EB924: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EB930 size=156
    let mut pc: u32 = 0x821EB930;
    'dispatch: loop {
        match pc {
            0x821EB930 => {
    //   block [0x821EB930..0x821EB9CC)
	// 821EB930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB934: 48ABDAD5  bl 0x82ca9408
	ctx.lr = 0x821EB938;
	sub_82CA93D0(ctx, base);
	// 821EB938: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB93C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EB940: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821EB944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB948: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821EB94C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821EB950: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB954: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB958: 48B6BA19  bl 0x82d57370
	ctx.lr = 0x821EB95C;
	sub_82D57370(ctx, base);
	// 821EB95C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB960: C03C0004  lfs f1, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB964: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821EB968: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821EB96C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB970: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821EB978: 4E800421  bctrl
	ctx.lr = 0x821EB97C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB97C: 38BC0050  addi r5, r28, 0x50
	ctx.r[5].s64 = ctx.r[28].s64 + 80;
	// 821EB980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EB984: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB988: 48B6AAF1  bl 0x82d56478
	ctx.lr = 0x821EB98C;
	sub_82D56478(ctx, base);
	// 821EB98C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821EB990: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB9D0 size=864
    let mut pc: u32 = 0x821EB9D0;
    'dispatch: loop {
        match pc {
            0x821EB9D0 => {
    //   block [0x821EB9D0..0x821EBD30)
	// 821EB9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB9D4: 48ABDA05  bl 0x82ca93d8
	ctx.lr = 0x821EB9D8;
	sub_82CA93D0(ctx, base);
	// 821EB9D8: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 821EB9DC: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 821EB9E0: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 821EB9E4: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EBD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EBD30 size=512
    let mut pc: u32 = 0x821EBD30;
    'dispatch: loop {
        match pc {
            0x821EBD30 => {
    //   block [0x821EBD30..0x821EBF30)
	// 821EBD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EBD34: 48ABD6D1  bl 0x82ca9404
	ctx.lr = 0x821EBD38;
	sub_82CA93D0(ctx, base);
	// 821EBD38: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821EBD3C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EBD40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EBD44: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821EBD48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EBD4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EBD50: 409901D4  ble cr6, 0x821ebf24
	if !ctx.cr[6].gt {
	pc = 0x821EBF24; continue 'dispatch;
	}
	// 821EBD54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EBD58: 3BFB0030  addi r31, r27, 0x30
	ctx.r[31].s64 = ctx.r[27].s64 + 48;
	// 821EBD5C: C3EB0AFC  lfs f31, 0xafc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EBD60: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EBF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EBF30 size=616
    let mut pc: u32 = 0x821EBF30;
    'dispatch: loop {
        match pc {
            0x821EBF30 => {
    //   block [0x821EBF30..0x821EC198)
	// 821EBF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EBF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EBF38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EBF3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EBF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EBF44: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EBF48: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821EBF4C: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821EBF50: 38EA7064  addi r7, r10, 0x7064
	ctx.r[7].s64 = ctx.r[10].s64 + 28772;
	// 821EBF54: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821EBF58: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 821EBF5C: 88CB008D  lbz r6, 0x8d(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821EBF60: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EBF64: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821EBF68: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EBF6C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821EBF70: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821EBF74: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EBF78: 419A008C  beq cr6, 0x821ec004
	if ctx.cr[6].eq {
	pc = 0x821EC004; continue 'dispatch;
	}
	// 821EBF7C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EBF80: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821EBF84: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821EBF88: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EBF8C: 409A003C  bne cr6, 0x821ebfc8
	if !ctx.cr[6].eq {
	pc = 0x821EBFC8; continue 'dispatch;
	}
	// 821EBF90: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBF94: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821EBF98: 38AB0078  addi r5, r11, 0x78
	ctx.r[5].s64 = ctx.r[11].s64 + 120;
	// 821EBF9C: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EBFA0: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821EBFA4: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821EBFA8: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EBFAC: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBFB0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EBFB4: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EBFB8: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821EBFBC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBFC0: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821EBFC4: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821EBFC8: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821EBFCC: 90EB007C  stw r7, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821EBFD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EBFD4: 409A0030  bne cr6, 0x821ec004
	if !ctx.cr[6].eq {
	pc = 0x821EC004; continue 'dispatch;
	}
	// 821EBFD8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EBFDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EBFE0: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821EBFE4: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821EBFE8: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821EBFEC: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EBFF0: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821EBFF4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821EBFF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821EBFFC: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821EC000: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	// 821EC004: 3CE0834F  lis r7, -0x7cb1
	ctx.r[7].s64 = -2091974656;
	// 821EC008: 8147D5CC  lwz r10, -0x2a34(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10804 as u32) ) } as u64;
	// 821EC00C: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821EC010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC014: 409A000C  bne cr6, 0x821ec020
	if !ctx.cr[6].eq {
	pc = 0x821EC020; continue 'dispatch;
	}
	// 821EC018: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821EC01C: 9147D5CC  stw r10, -0x2a34(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-10804 as u32), ctx.r[10].u32 ) };
	// 821EC020: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821EC024: C1630000  lfs f11, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821EC028: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821EC02C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EC030: 39099484  addi r8, r9, -0x6b7c
	ctx.r[8].s64 = ctx.r[9].s64 + -27516;
	// 821EC034: C1230004  lfs f9, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821EC038: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821EC03C: 3BCB3DB8  addi r30, r11, 0x3db8
	ctx.r[30].s64 = ctx.r[11].s64 + 15800;
	// 821EC040: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 821EC044: C1899484  lfs f12, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821EC048: 554607BC  rlwinm r6, r10, 0, 0x1e, 0x1e
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EC04C: 3BEBD5B8  addi r31, r11, -0x2a48
	ctx.r[31].s64 = ctx.r[11].s64 + -10824;
	// 821EC050: C0081FFC  lfs f0, 0x1ffc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC054: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EC058: C1A8000C  lfs f13, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC05C: ECEB6838  fmsubs f7, f11, f0, f13
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC060: ECCA6838  fmsubs f6, f10, f0, f13
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC064: ECA96838  fmsubs f5, f9, f0, f13
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC068: EC886838  fmsubs f4, f8, f0, f13
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC06C: EC663828  fsubs f3, f6, f7
	ctx.f[3].f64 = (((ctx.f[6].f64 - ctx.f[7].f64) as f32) as f64);
	// 821EC070: EC442828  fsubs f2, f4, f5
	ctx.f[2].f64 = (((ctx.f[4].f64 - ctx.f[5].f64) as f32) as f64);
	// 821EC074: EC230332  fmuls f1, f3, f12
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 821EC078: EC03382A  fadds f0, f3, f7
	ctx.f[0].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 821EC07C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821EC080: EDA2282A  fadds f13, f2, f5
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[5].f64) as f32) as f64;
	// 821EC084: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821EC088: ED81382A  fadds f12, f1, f7
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[7].f64) as f32) as f64;
	// 821EC08C: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821EC090: ED61282A  fadds f11, f1, f5
	ctx.f[11].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 821EC094: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821EC098: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821EC09C: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC0A0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821EC0A4: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821EC0A8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EC0AC: F93E0000  std r9, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821EC0B0: F97E0008  std r11, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821EC0B4: F91E0010  std r8, 0x10(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821EC0B8: 409A0034  bne cr6, 0x821ec0ec
	if !ctx.cr[6].eq {
	pc = 0x821EC0EC; continue 'dispatch;
	}
	// 821EC0BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EC0C0: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821EC0C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC0C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821EC0CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821EC0D0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821EC0D4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821EC0D8: 9147D5CC  stw r10, -0x2a34(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-10804 as u32), ctx.r[10].u32 ) };
	// 821EC0DC: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 821EC0E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821EC0E4: 386A61C8  addi r3, r10, 0x61c8
	ctx.r[3].s64 = ctx.r[10].s64 + 25032;
	// 821EC0E8: 48ABDE39  bl 0x82ca9f20
	ctx.lr = 0x821EC0EC;
	sub_82CA9F20(ctx, base);
	// 821EC0EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC0F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC0F4: 409A0030  bne cr6, 0x821ec124
	if !ctx.cr[6].eq {
	pc = 0x821EC124; continue 'dispatch;
	}
	// 821EC0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC0FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821EC100: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821EC104: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821EC108: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821EC10C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EC110: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EC114: 489A144D  bl 0x82b8d560
	ctx.lr = 0x821EC118;
	sub_82B8D560(ctx, base);
	// 821EC118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC11C: 489A1585  bl 0x82b8d6a0
	ctx.lr = 0x821EC120;
	sub_82B8D6A0(ctx, base);
	// 821EC120: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC124: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821EC128: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EC12C: 815F0364  lwz r10, 0x364(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EC130: 916970B8  stw r11, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[11].u32 ) };
	// 821EC134: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821EC138: 916A2E2C  stw r11, 0x2e2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(11820 as u32), ctx.r[11].u32 ) };
	// 821EC13C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821EC140: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821EC144: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821EC148: 48032359  bl 0x8221e4a0
	ctx.lr = 0x821EC14C;
	sub_8221E4A0(ctx, base);
	// 821EC14C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821EC150: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821EC154: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821EC158: 83FF0364  lwz r31, 0x364(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EC15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC160: 48019E09  bl 0x82205f68
	ctx.lr = 0x821EC164;
	sub_82205F68(ctx, base);
	// 821EC164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EC168: 419A0018  beq cr6, 0x821ec180
	if ctx.cr[6].eq {
	pc = 0x821EC180; continue 'dispatch;
	}
	// 821EC16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC170: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821EC174: 48ABD30D  bl 0x82ca9480
	ctx.lr = 0x821EC178;
	sub_82CA9480(ctx, base);
	// 821EC178: 817F3484  lwz r11, 0x3484(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13444 as u32) ) } as u64;
	// 821EC17C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821EC180: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821EC184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EC188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EC18C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EC190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EC194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EC198 size=1324
    let mut pc: u32 = 0x821EC198;
    'dispatch: loop {
        match pc {
            0x821EC198 => {
    //   block [0x821EC198..0x821EC6C4)
	// 821EC198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC19C: 48ABD235  bl 0x82ca93d0
	ctx.lr = 0x821EC1A0;
	sub_82CA93D0(ctx, base);
	// 821EC1A0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC1A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EC1A8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EC1AC: 3BFC0014  addi r31, r28, 0x14
	ctx.r[31].s64 = ctx.r[28].s64 + 20;
	// 821EC1B0: 83650004  lwz r27, 4(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC1B4: 807B0014  lwz r3, 0x14(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC1B8: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 821EC1BC: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 821EC1C0: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821EC1C4: 480A338D  bl 0x8228f550
	ctx.lr = 0x821EC1C8;
	sub_8228F550(ctx, base);
	// 821EC1C8: 897B00A0  lbz r11, 0xa0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(160 as u32) ) } as u64;
	// 821EC1CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EC1D0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821EC1D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EC1D8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821EC1DC: 3BABB46C  addi r29, r11, -0x4b94
	ctx.r[29].s64 = ctx.r[11].s64 + -19348;
	// 821EC1E0: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 821EC1E4: 991C0000  stb r8, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 821EC1E8: 419A0024  beq cr6, 0x821ec20c
	if ctx.cr[6].eq {
	pc = 0x821EC20C; continue 'dispatch;
	}
	// 821EC1EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EC1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EC1F4: 4BF93555  bl 0x8217f748
	ctx.lr = 0x821EC1F8;
	sub_8217F748(ctx, base);
	// 821EC1F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC1FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC200: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC204: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EC208: 48000018  b 0x821ec220
	pc = 0x821EC220; continue 'dispatch;
	// 821EC20C: C01DDE68  lfs f0, -0x2198(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC210: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC214: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821EC218: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EC21C: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821EC220: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 821EC224: C1BDDE5C  lfs f13, -0x21a4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC228: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821EC22C: 39200160  li r9, 0x160
	ctx.r[9].s64 = 352;
	// 821EC230: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821EC234: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC6C8 size=204
    let mut pc: u32 = 0x821EC6C8;
    'dispatch: loop {
        match pc {
            0x821EC6C8 => {
    //   block [0x821EC6C8..0x821EC794)
	// 821EC6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC6CC: 48ABCD41  bl 0x82ca940c
	ctx.lr = 0x821EC6D0;
	sub_82CA93D0(ctx, base);
	// 821EC6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC6D4: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EC6D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821EC6DC: 83A30010  lwz r29, 0x10(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EC6E0: 3BE30058  addi r31, r3, 0x58
	ctx.r[31].s64 = ctx.r[3].s64 + 88;
	// 821EC6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC6E8: 419A0028  beq cr6, 0x821ec710
	if ctx.cr[6].eq {
	pc = 0x821EC710; continue 'dispatch;
	}
	// 821EC6EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC6F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EC6F4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821EC6F8: 41980018  blt cr6, 0x821ec710
	if ctx.cr[6].lt {
	pc = 0x821EC710; continue 'dispatch;
	}
	// 821EC6FC: 419A0068  beq cr6, 0x821ec764
	if ctx.cr[6].eq {
	pc = 0x821EC764; continue 'dispatch;
	}
	// 821EC700: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC704: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EC708: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EC70C: 409AFFE0  bne cr6, 0x821ec6ec
	if !ctx.cr[6].eq {
	pc = 0x821EC6EC; continue 'dispatch;
	}
	// 821EC710: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 821EC714: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EC718: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EC71C: 4803B105  bl 0x82227820
	ctx.lr = 0x821EC720;
	sub_82227820(ctx, base);
	// 821EC720: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 821EC724: 395D0068  addi r10, r29, 0x68
	ctx.r[10].s64 = ctx.r[29].s64 + 104;
	// 821EC728: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 821EC72C: 893D0014  lbz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC730: 552807BE  clrlwi r8, r9, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 821EC734: 99030005  stb r8, 5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 821EC738: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821EC73C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC740: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821EC744: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821EC748: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821EC74C: 80DD0078  lwz r6, 0x78(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 821EC750: 90C30010  stw r6, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 821EC754: 9066000C  stw r3, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 821EC758: 907D0078  stw r3, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 821EC75C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC760: 48ABCCFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821EC764: 893D0014  lbz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC768: 894B0005  lbz r10, 5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 821EC76C: 7D484878  andc r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	// 821EC770: 550707BE  clrlwi r7, r8, 0x1e
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821EC774: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821EC778: 419A0010  beq cr6, 0x821ec788
	if ctx.cr[6].eq {
	pc = 0x821EC788; continue 'dispatch;
	}
	// 821EC77C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821EC780: 69490003  xori r9, r10, 3
	ctx.r[9].u64 = ctx.r[10].u64 ^ 3;
	// 821EC784: 992B0005  stb r9, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[9].u8 ) };
	// 821EC788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821EC78C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC790: 48ABCCCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EC798 size=92
    let mut pc: u32 = 0x821EC798;
    'dispatch: loop {
        match pc {
            0x821EC798 => {
    //   block [0x821EC798..0x821EC7F4)
	// 821EC798: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 821EC79C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821EC7A0: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821EC7A4: 39240020  addi r9, r4, 0x20
	ctx.r[9].s64 = ctx.r[4].s64 + 32;
	// 821EC7A8: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 821EC7AC: C00AABC8  lfs f0, -0x5438(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC7B0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821EC7B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EC7B8: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 821EC7BC: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821EC7C0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EC7C4: 7D4A4C36  srd r10, r10, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[10].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821EC7C8: C1A10024  lfs f13, 0x24(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC7CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821EC7D0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821EC7D4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 821EC7D8: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821EC7DC: 512862A6  rlwimi r8, r9, 0xc, 0xa, 0x13
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(12) as u64) & 0x00000000003FF000) | (ctx.r[8].u64 & 0xFFFFFFFFFFC00FFF);
	// 821EC7E0: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821EC7E4: E9630018  ld r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 821EC7E8: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821EC7EC: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 821EC7F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC7F8 size=176
    let mut pc: u32 = 0x821EC7F8;
    'dispatch: loop {
        match pc {
            0x821EC7F8 => {
    //   block [0x821EC7F8..0x821EC8A8)
	// 821EC7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EC810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821EC814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC81C: 419A0038  beq cr6, 0x821ec854
	if ctx.cr[6].eq {
	pc = 0x821EC854; continue 'dispatch;
	}
	// 821EC820: 48041FD9  bl 0x8222e7f8
	ctx.lr = 0x821EC824;
	sub_8222E7F8(ctx, base);
	// 821EC824: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC82C: 409A0018  bne cr6, 0x821ec844
	if !ctx.cr[6].eq {
	pc = 0x821EC844; continue 'dispatch;
	}
	// 821EC830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821EC834: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC838: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821EC83C: 489520C5  bl 0x82b3e900
	ctx.lr = 0x821EC840;
	sub_82B3E900(ctx, base);
	// 821EC840: 4800004C  b 0x821ec88c
	pc = 0x821EC88C; continue 'dispatch;
	// 821EC844: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC848: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC84C: 489520B5  bl 0x82b3e900
	ctx.lr = 0x821EC850;
	sub_82B3E900(ctx, base);
	// 821EC850: 4800003C  b 0x821ec88c
	pc = 0x821EC88C; continue 'dispatch;
	// 821EC854: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EC858: 419A0034  beq cr6, 0x821ec88c
	if ctx.cr[6].eq {
	pc = 0x821EC88C; continue 'dispatch;
	}
	// 821EC85C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC864: 419A0028  beq cr6, 0x821ec88c
	if ctx.cr[6].eq {
	pc = 0x821EC88C; continue 'dispatch;
	}
	// 821EC868: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC86C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821EC870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821EC874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EC878: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821EC87C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EC880: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821EC884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EC888: 4082FFE8  bne 0x821ec870
	if !ctx.cr[0].eq {
	pc = 0x821EC870; continue 'dispatch;
	}
	// 821EC88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EC898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EC89C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EC8A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EC8A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EC8A8 size=296
    let mut pc: u32 = 0x821EC8A8;
    'dispatch: loop {
        match pc {
            0x821EC8A8 => {
    //   block [0x821EC8A8..0x821EC9D0)
	// 821EC8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC8AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC8B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC8B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC8B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC8BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EC8C0: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EC8C4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821EC8C8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821EC8CC: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821EC8D0: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821EC8D4: 4099000C  ble cr6, 0x821ec8e0
	if !ctx.cr[6].gt {
	pc = 0x821EC8E0; continue 'dispatch;
	}
	// 821EC8D8: 4837DF51  bl 0x8256a828
	ctx.lr = 0x821EC8DC;
	sub_8256A828(ctx, base);
	// 821EC8DC: 480000DC  b 0x821ec9b8
	pc = 0x821EC9B8; continue 'dispatch;
	// 821EC8E0: 897F0043  lbz r11, 0x43(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(67 as u32) ) } as u64;
	// 821EC8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC8E8: 419A0054  beq cr6, 0x821ec93c
	if ctx.cr[6].eq {
	pc = 0x821EC93C; continue 'dispatch;
	}
	// 821EC8EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC8F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821EC8F4: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EC8F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC8FC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC900: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821EC904: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821EC908: 4E800421  bctrl
	ctx.lr = 0x821EC90C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EC90C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821EC910: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821EC914: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC918: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC91C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821EC920: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821EC924: E9680008  ld r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821EC928: 81460040  lwz r10, 0x40(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 821EC92C: F8A70000  std r5, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 821EC930: F9670008  std r11, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821EC934: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EC938: 4800004C  b 0x821ec984
	pc = 0x821EC984; continue 'dispatch;
	// 821EC93C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EC940: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC944: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821EC948: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821EC94C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821EC950: 38C89160  addi r6, r8, -0x6ea0
	ctx.r[6].s64 = ctx.r[8].s64 + -28320;
	// 821EC954: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC958: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EC95C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC960: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC9D0 size=92
    let mut pc: u32 = 0x821EC9D0;
    'dispatch: loop {
        match pc {
            0x821EC9D0 => {
    //   block [0x821EC9D0..0x821ECA2C)
	// 821EC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC9E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EC9E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EC9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC9F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC9F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC9F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EC9FC: 4E800421  bctrl
	ctx.lr = 0x821ECA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ECA00: 2F03000A  cmpwi cr6, r3, 0xa
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10, &mut ctx.xer);
	// 821ECA04: 409A0010  bne cr6, 0x821eca14
	if !ctx.cr[6].eq {
	pc = 0x821ECA14; continue 'dispatch;
	}
	// 821ECA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821ECA0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ECA10: 4BFFFE99  bl 0x821ec8a8
	ctx.lr = 0x821ECA14;
	sub_821EC8A8(ctx, base);
	// 821ECA14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ECA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECA20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ECA24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ECA28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ECA30 size=164
    let mut pc: u32 = 0x821ECA30;
    'dispatch: loop {
        match pc {
            0x821ECA30 => {
    //   block [0x821ECA30..0x821ECAD4)
	// 821ECA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ECA38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECA3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821ECA40: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ECA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ECA48: 419A0010  beq cr6, 0x821eca58
	if ctx.cr[6].eq {
	pc = 0x821ECA58; continue 'dispatch;
	}
	// 821ECA4C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821ECA50: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821ECA54: 48000008  b 0x821eca5c
	pc = 0x821ECA5C; continue 'dispatch;
	// 821ECA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821ECA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ECA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ECA64: 409A0018  bne cr6, 0x821eca7c
	if !ctx.cr[6].eq {
	pc = 0x821ECA7C; continue 'dispatch;
	}
	// 821ECA68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821ECA6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECA78: 4E800020  blr
	return;
	// 821ECA7C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ECA80: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ECA84: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA88: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA8C: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ECA90: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821ECA98: 409A000C  bne cr6, 0x821ecaa4
	if !ctx.cr[6].eq {
	pc = 0x821ECAA4; continue 'dispatch;
	}
	// 821ECA9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821ECAA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821ECAA4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821ECAA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ECAAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECAB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ECAB4: 4E800421  bctrl
	ctx.lr = 0x821ECAB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ECAB8: 3923FFFF  addi r9, r3, -1
	ctx.r[9].s64 = ctx.r[3].s64 + -1;
	// 821ECABC: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821ECAC0: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821ECAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ECAD8 size=416
    let mut pc: u32 = 0x821ECAD8;
    'dispatch: loop {
        match pc {
            0x821ECAD8 => {
    //   block [0x821ECAD8..0x821ECC78)
	// 821ECAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECADC: 48ABC931  bl 0x82ca940c
	ctx.lr = 0x821ECAE0;
	sub_82CA93D0(ctx, base);
	// 821ECAE0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821ECAE4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821ECAE8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ECC78 size=184
    let mut pc: u32 = 0x821ECC78;
    'dispatch: loop {
        match pc {
            0x821ECC78 => {
    //   block [0x821ECC78..0x821ECD30)
	// 821ECC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECC7C: 48ABC785  bl 0x82ca9400
	ctx.lr = 0x821ECC80;
	sub_82CA93D0(ctx, base);
	// 821ECC80: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ECD30 size=572
    let mut pc: u32 = 0x821ECD30;
    'dispatch: loop {
        match pc {
            0x821ECD30 => {
    //   block [0x821ECD30..0x821ECF6C)
	// 821ECD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECD34: 48ABC6D1  bl 0x82ca9404
	ctx.lr = 0x821ECD38;
	sub_82CA93D0(ctx, base);
	// 821ECD38: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821ECD3C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821ECD40: 9421F3F0  stwu r1, -0xc10(r1)
	ea = ctx.r[1].u32.wrapping_add(-3088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECD44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821ECD48: 80660014  lwz r3, 0x14(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ECD4C: 81460018  lwz r10, 0x18(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821ECD50: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821ECD54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821ECD58: 392B2A2C  addi r9, r11, 0x2a2c
	ctx.r[9].s64 = ctx.r[11].s64 + 10796;
	// 821ECD5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821ECD60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ECD64: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 821ECD68: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821ECD6C: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821ECD70: 419A0008  beq cr6, 0x821ecd78
	if ctx.cr[6].eq {
	pc = 0x821ECD78; continue 'dispatch;
	}
	// 821ECD74: 4800F405  bl 0x821fc178
	ctx.lr = 0x821ECD78;
	sub_821FC178(ctx, base);
	// 821ECD78: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821ECD7C: 4800F625  bl 0x821fc3a0
	ctx.lr = 0x821ECD80;
	sub_821FC3A0(ctx, base);
	// 821ECD80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821ECD84: 3F60820A  lis r27, -0x7df6
	ctx.r[27].s64 = -2113273856;
	// 821ECD88: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 821ECD8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821ECD90: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 821ECD94: 397B9484  addi r11, r27, -0x6b7c
	ctx.r[11].s64 = ctx.r[27].s64 + -27516;
	// 821ECD98: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 821ECD9C: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 821ECDA0: C3CB000C  lfs f30, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ECDA4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821ECDA8: 4BFF5E61  bl 0x821e2c08
	ctx.lr = 0x821ECDAC;
	sub_821E2C08(ctx, base);
	// 821ECDAC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821ECDB0: 4809EFA9  bl 0x8228bd58
	ctx.lr = 0x821ECDB4;
	sub_8228BD58(ctx, base);
	// 821ECDB4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821ECDB8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821ECDBC: C3FB9484  lfs f31, -0x6b7c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ECDC0: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 821ECDC4: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821ECDC8: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 821ECDCC: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821ECDD0: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 821ECDD4: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ECF70 size=96
    let mut pc: u32 = 0x821ECF70;
    'dispatch: loop {
        match pc {
            0x821ECF70 => {
    //   block [0x821ECF70..0x821ECFD0)
	// 821ECF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ECF78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ECF7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECF80: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821ECF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ECF88: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821ECF8C: 814A0364  lwz r10, 0x364(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821ECF90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ECF94: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821ECF98: 916A2E2C  stw r11, 0x2e2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(11820 as u32), ctx.r[11].u32 ) };
	// 821ECF9C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821ECFA0: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821ECFA4: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821ECFA8: 916970B8  stw r11, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[11].u32 ) };
	// 821ECFAC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ECFB0: 4803F261  bl 0x8222c210
	ctx.lr = 0x821ECFB4;
	sub_8222C210(ctx, base);
	// 821ECFB4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821ECFB8: 4801BB59  bl 0x82208b10
	ctx.lr = 0x821ECFBC;
	sub_82208B10(ctx, base);
	// 821ECFBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECFC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ECFCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ECFD0 size=856
    let mut pc: u32 = 0x821ECFD0;
    'dispatch: loop {
        match pc {
            0x821ECFD0 => {
    //   block [0x821ECFD0..0x821ED328)
	// 821ECFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECFD4: 48ABC431  bl 0x82ca9404
	ctx.lr = 0x821ECFD8;
	sub_82CA93D0(ctx, base);
	// 821ECFD8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821ECFDC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821ECFE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECFE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821ECFE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821ECFEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821ECFF0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821ECFF4: 4BFFFF7D  bl 0x821ecf70
	ctx.lr = 0x821ECFF8;
	sub_821ECF70(ctx, base);
	// 821ECFF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821ECFFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED000: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ED004: 4800DBCD  bl 0x821fabd0
	ctx.lr = 0x821ED008;
	sub_821FABD0(ctx, base);
	// 821ED008: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821ED00C: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 821ED010: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED014: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 821ED018: 397C9484  addi r11, r28, -0x6b7c
	ctx.r[11].s64 = ctx.r[28].s64 + -27516;
	// 821ED01C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821ED020: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821ED024: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821ED028: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821ED02C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ED030: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ED034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ED038: ED7E6024  fdivs f11, f30, f12
	ctx.f[11].f64 = ((ctx.f[30].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ED03C: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821ED040: 4800DB91  bl 0x821fabd0
	ctx.lr = 0x821ED044;
	sub_821FABD0(ctx, base);
	// 821ED044: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821ED048: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821ED04C: C3FC9484  lfs f31, -0x6b7c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ED050: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821ED054: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821ED058: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821ED05C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821ED060: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821ED064: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821ED068: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ED328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ED328 size=80
    let mut pc: u32 = 0x821ED328;
    'dispatch: loop {
        match pc {
            0x821ED328 => {
    //   block [0x821ED328..0x821ED378)
	// 821ED328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ED32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ED330: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ED334: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ED338: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821ED33C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ED340: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED344: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821ED348: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821ED34C: 4800D885  bl 0x821fabd0
	ctx.lr = 0x821ED350;
	sub_821FABD0(ctx, base);
	// 821ED350: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821ED354: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821ED358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ED35C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821ED360: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821ED364: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821ED368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ED36C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ED370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ED374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ED378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ED378 size=2844
    let mut pc: u32 = 0x821ED378;
    'dispatch: loop {
        match pc {
            0x821ED378 => {
    //   block [0x821ED378..0x821EDE94)
	// 821ED378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ED37C: 48ABC06D  bl 0x82ca93e8
	ctx.lr = 0x821ED380;
	sub_82CA93D0(ctx, base);
	// 821ED380: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ED384: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 821ED388: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821ED38C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821ED390: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 821ED394: 81746AB8  lwz r11, 0x6ab8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ED398: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ED39C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ED3A0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821ED3A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ED3A8: 419A0014  beq cr6, 0x821ed3bc
	if ctx.cr[6].eq {
	pc = 0x821ED3BC; continue 'dispatch;
	}
	// 821ED3AC: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821ED3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3B4: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821ED3B8: 409A0008  bne cr6, 0x821ed3c0
	if !ctx.cr[6].eq {
	pc = 0x821ED3C0; continue 'dispatch;
	}
	// 821ED3BC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821ED3C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ED3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3C8: 409A0AC4  bne cr6, 0x821ede8c
	if !ctx.cr[6].eq {
	pc = 0x821EDE8C; continue 'dispatch;
	}
	// 821ED3CC: 897A003E  lbz r11, 0x3e(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(62 as u32) ) } as u64;
	// 821ED3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3D4: 419A0018  beq cr6, 0x821ed3ec
	if ctx.cr[6].eq {
	pc = 0x821ED3EC; continue 'dispatch;
	}
	// 821ED3D8: 9AFA003E  stb r23, 0x3e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(62 as u32), ctx.r[23].u8 ) };
	// 821ED3DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821ED3E0: 4864F419  bl 0x8283c7f8
	ctx.lr = 0x821ED3E4;
	sub_8283C7F8(ctx, base);
	// 821ED3E4: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821ED3E8: 48ABC050  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 821ED3EC: 897A003D  lbz r11, 0x3d(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(61 as u32) ) } as u64;
	// 821ED3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3F4: 419A0018  beq cr6, 0x821ed40c
	if ctx.cr[6].eq {
	pc = 0x821ED40C; continue 'dispatch;
	}
	// 821ED3F8: 9AFA003D  stb r23, 0x3d(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(61 as u32), ctx.r[23].u8 ) };
	// 821ED3FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821ED400: 4864EAF9  bl 0x8283bef8
	ctx.lr = 0x821ED404;
	sub_8283BEF8(ctx, base);
	// 821ED404: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821ED408: 48ABC030  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 821ED40C: 897A0037  lbz r11, 0x37(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(55 as u32) ) } as u64;
	// 821ED410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED414: 419A0A70  beq cr6, 0x821ede84
	if ctx.cr[6].eq {
	pc = 0x821EDE84; continue 'dispatch;
	}
	// 821ED418: 816A0058  lwz r11, 0x58(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ED41C: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 821ED420: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED424: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED428: 4803ED91  bl 0x8222c1b8
	ctx.lr = 0x821ED42C;
	sub_8222C1B8(ctx, base);
	// 821ED42C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821ED430: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 821ED434: 419A0018  beq cr6, 0x821ed44c
	if ctx.cr[6].eq {
	pc = 0x821ED44C; continue 'dispatch;
	}
	// 821ED438: 89760090  lbz r11, 0x90(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ED43C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ED440: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821ED444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ED448: 409A0008  bne cr6, 0x821ed450
	if !ctx.cr[6].eq {
	pc = 0x821ED450; continue 'dispatch;
	}
	// 821ED44C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821ED450: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ED454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED458: 419A0A34  beq cr6, 0x821ede8c
	if ctx.cr[6].eq {
	pc = 0x821EDE8C; continue 'dispatch;
	}
	// 821ED45C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED460: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821ED464: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ED468: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED46C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ED470: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821ED474: 4E800421  bctrl
	ctx.lr = 0x821ED478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ED478: 8096007C  lwz r4, 0x7c(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ED47C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821ED480: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED484: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ED488: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821ED48C: 4E800421  bctrl
	ctx.lr = 0x821ED490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ED490: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821ED494: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821ED498: C01A0024  lfs f0, 0x24(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ED49C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ED4A0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821ED4A4: 393A0024  addi r9, r26, 0x24
	ctx.r[9].s64 = ctx.r[26].s64 + 36;
	// 821ED4A8: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EDE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EDE98 size=756
    let mut pc: u32 = 0x821EDE98;
    'dispatch: loop {
        match pc {
            0x821EDE98 => {
    //   block [0x821EDE98..0x821EE18C)
	// 821EDE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EDE9C: 48ABB551  bl 0x82ca93ec
	ctx.lr = 0x821EDEA0;
	sub_82CA93D0(ctx, base);
	// 821EDEA0: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 821EDEA4: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 821EDEA8: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 821EDEAC: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE190 size=116
    let mut pc: u32 = 0x821EE190;
    'dispatch: loop {
        match pc {
            0x821EE190 => {
    //   block [0x821EE190..0x821EE204)
	// 821EE190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE198: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 821EE19C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE1A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE1A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821EE1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EE1AC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EE1B0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE1B4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821EE1B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821EE1BC: 4E800421  bctrl
	ctx.lr = 0x821EE1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EE1C0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821EE1C4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821EE1C8: 81686AB8  lwz r11, 0x6ab8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27320 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EE208 size=172
    let mut pc: u32 = 0x821EE208;
    'dispatch: loop {
        match pc {
            0x821EE208 => {
    //   block [0x821EE208..0x821EE2B4)
	// 821EE208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EE214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE218: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE2B8 size=140
    let mut pc: u32 = 0x821EE2B8;
    'dispatch: loop {
        match pc {
            0x821EE2B8 => {
    //   block [0x821EE2B8..0x821EE344)
	// 821EE2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE2C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EE2CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE2D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821EE2D4: 419A0054  beq cr6, 0x821ee328
	if ctx.cr[6].eq {
	pc = 0x821EE328; continue 'dispatch;
	}
	// 821EE2D8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821EE2DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821EE2E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821EE2E4: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EE2E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE2EC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE2F0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE2F4: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 821EE2F8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821EE2FC: 80EB00C4  lwz r7, 0xc4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821EE300: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821EE304: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821EE308: 488A9061  bl 0x82a97368
	ctx.lr = 0x821EE30C;
	sub_82A97368(ctx, base);
	// 821EE30C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821EE310: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821EE314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE31C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE324: 4E800020  blr
	return;
	// 821EE328: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821EE32C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EE330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE33C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE348 size=552
    let mut pc: u32 = 0x821EE348;
    'dispatch: loop {
        match pc {
            0x821EE348 => {
    //   block [0x821EE348..0x821EE570)
	// 821EE348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE34C: 48ABB0BD  bl 0x82ca9408
	ctx.lr = 0x821EE350;
	sub_82CA93D0(ctx, base);
	// 821EE350: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE354: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821EE358: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821EE35C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821EE360: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EE364: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE368: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE36C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE370: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE374: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821EE378: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821EE37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE380: 419A0020  beq cr6, 0x821ee3a0
	if ctx.cr[6].eq {
	pc = 0x821EE3A0; continue 'dispatch;
	}
	// 821EE384: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE388: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE38C: 419A000C  beq cr6, 0x821ee398
	if ctx.cr[6].eq {
	pc = 0x821EE398; continue 'dispatch;
	}
	// 821EE390: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821EE394: 48000010  b 0x821ee3a4
	pc = 0x821EE3A4; continue 'dispatch;
	// 821EE398: 4BFA5AA1  bl 0x82193e38
	ctx.lr = 0x821EE39C;
	sub_82193E38(ctx, base);
	// 821EE39C: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EE3A0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821EE3A4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE3A8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE3AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE3B0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE3B4: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 821EE3B8: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821EE3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE3C0: 419A0020  beq cr6, 0x821ee3e0
	if ctx.cr[6].eq {
	pc = 0x821EE3E0; continue 'dispatch;
	}
	// 821EE3C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE3C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE3CC: 419A000C  beq cr6, 0x821ee3d8
	if ctx.cr[6].eq {
	pc = 0x821EE3D8; continue 'dispatch;
	}
	// 821EE3D0: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EE3D4: 48000010  b 0x821ee3e4
	pc = 0x821EE3E4; continue 'dispatch;
	// 821EE3D8: 4BFA5A61  bl 0x82193e38
	ctx.lr = 0x821EE3DC;
	sub_82193E38(ctx, base);
	// 821EE3DC: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EE3E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EE3E4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE3E8: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821EE3EC: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821EE3F0: 409A0128  bne cr6, 0x821ee518
	if !ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE3F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE3F8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE3FC: 409A011C  bne cr6, 0x821ee518
	if !ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE400: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821EE404: 419A0018  beq cr6, 0x821ee41c
	if ctx.cr[6].eq {
	pc = 0x821EE41C; continue 'dispatch;
	}
	// 821EE408: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821EE40C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE418: 409A0008  bne cr6, 0x821ee420
	if !ctx.cr[6].eq {
	pc = 0x821EE420; continue 'dispatch;
	}
	// 821EE41C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821EE420: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE428: 419A00F0  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE42C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821EE430: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821EE434: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE438: 419A00E0  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE43C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821EE440: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821EE444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE448: 419A0018  beq cr6, 0x821ee460
	if ctx.cr[6].eq {
	pc = 0x821EE460; continue 'dispatch;
	}
	// 821EE44C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821EE450: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821EE454: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821EE458: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE45C: 480000AC  b 0x821ee508
	pc = 0x821EE508; continue 'dispatch;
	// 821EE460: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821EE464: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821EE468: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821EE46C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821EE470: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EE474: 40810054  ble 0x821ee4c8
	if !ctx.cr[0].gt {
	pc = 0x821EE4C8; continue 'dispatch;
	}
	// 821EE478: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821EE47C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EE480: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EE484: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE488: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821EE48C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821EE490: 41980008  blt cr6, 0x821ee498
	if ctx.cr[6].lt {
	pc = 0x821EE498; continue 'dispatch;
	}
	// 821EE494: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821EE498: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821EE49C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821EE4A0: 419A0014  beq cr6, 0x821ee4b4
	if ctx.cr[6].eq {
	pc = 0x821EE4B4; continue 'dispatch;
	}
	// 821EE4A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821EE4A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821EE4AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821EE4B0: 4800000C  b 0x821ee4bc
	pc = 0x821EE4BC; continue 'dispatch;
	// 821EE4B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821EE4B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821EE4BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EE4C0: 4199FFB8  bgt cr6, 0x821ee478
	if ctx.cr[6].gt {
	pc = 0x821EE478; continue 'dispatch;
	}
	// 821EE4C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821EE4C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821EE4CC: 419A0034  beq cr6, 0x821ee500
	if ctx.cr[6].eq {
	pc = 0x821EE500; continue 'dispatch;
	}
	// 821EE4D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE4D4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821EE4D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE4DC: 41990008  bgt cr6, 0x821ee4e4
	if ctx.cr[6].gt {
	pc = 0x821EE4E4; continue 'dispatch;
	}
	// 821EE4E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821EE4E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE4E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE4EC: 409A0014  bne cr6, 0x821ee500
	if !ctx.cr[6].eq {
	pc = 0x821EE500; continue 'dispatch;
	}
	// 821EE4F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EE4F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821EE4F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821EE4FC: 48000008  b 0x821ee504
	pc = 0x821EE504; continue 'dispatch;
	// 821EE500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821EE504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE50C: 419A000C  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE510: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821EE514: 4BFFFE50  b 0x821ee364
	pc = 0x821EE364; continue 'dispatch;
	// 821EE518: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE51C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE520: 419A0018  beq cr6, 0x821ee538
	if ctx.cr[6].eq {
	pc = 0x821EE538; continue 'dispatch;
	}
	// 821EE524: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 821EE528: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE52C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE530: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE534: 409A0008  bne cr6, 0x821ee53c
	if !ctx.cr[6].eq {
	pc = 0x821EE53C; continue 'dispatch;
	}
	// 821EE538: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821EE53C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE544: 419A0020  beq cr6, 0x821ee564
	if ctx.cr[6].eq {
	pc = 0x821EE564; continue 'dispatch;
	}
	// 821EE548: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE54C: 419A000C  beq cr6, 0x821ee558
	if ctx.cr[6].eq {
	pc = 0x821EE558; continue 'dispatch;
	}
	// 821EE550: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE554: 409A0010  bne cr6, 0x821ee564
	if !ctx.cr[6].eq {
	pc = 0x821EE564; continue 'dispatch;
	}
	// 821EE558: 887C0019  lbz r3, 0x19(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 821EE55C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EE560: 48ABAEF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821EE564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE568: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EE56C: 48ABAEEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE570 size=584
    let mut pc: u32 = 0x821EE570;
    'dispatch: loop {
        match pc {
            0x821EE570 => {
    //   block [0x821EE570..0x821EE7B8)
	// 821EE570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE574: 48ABAE79  bl 0x82ca93ec
	ctx.lr = 0x821EE578;
	sub_82CA93D0(ctx, base);
	// 821EE578: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE57C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EE580: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 821EE584: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821EE588: 397AFFFE  addi r11, r26, -2
	ctx.r[11].s64 = ctx.r[26].s64 + -2;
	// 821EE58C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821EE590: 815B0034  lwz r10, 0x34(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EE594: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821EE598: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 821EE59C: 5535DFFE  rlwinm r21, r9, 0x1b, 0x1f, 0x1f
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821EE5A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE5A4: 409901FC  ble cr6, 0x821ee7a0
	if !ctx.cr[6].gt {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5A8: 3ADB0004  addi r22, r27, 4
	ctx.r[22].s64 = ctx.r[27].s64 + 4;
	// 821EE5AC: 83FB0014  lwz r31, 0x14(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EE5B0: 7F1FB040  cmplw cr6, r31, r22
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[22].u32, &mut ctx.xer);
	// 821EE5B4: 419A01EC  beq cr6, 0x821ee7a0
	if ctx.cr[6].eq {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821EE5BC: 419A01E4  beq cr6, 0x821ee7a0
	if ctx.cr[6].eq {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE5C8: 419A0068  beq cr6, 0x821ee630
	if ctx.cr[6].eq {
	pc = 0x821EE630; continue 'dispatch;
	}
	// 821EE5CC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE5D4: 419A0038  beq cr6, 0x821ee60c
	if ctx.cr[6].eq {
	pc = 0x821EE60C; continue 'dispatch;
	}
	// 821EE5D8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE5DC: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5E0: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE5E4: 409A0020  bne cr6, 0x821ee604
	if !ctx.cr[6].eq {
	pc = 0x821EE604; continue 'dispatch;
	}
	// 821EE5E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE5EC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE5F0: 409A0014  bne cr6, 0x821ee604
	if !ctx.cr[6].eq {
	pc = 0x821EE604; continue 'dispatch;
	}
	// 821EE5F4: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821EE5F8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE600: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821EE604: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 821EE608: 933F0010  stw r25, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 821EE60C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE610: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 821EE614: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE618: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821EE61C: 5528003E  slwi r8, r9, 0
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EE620: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821EE624: 93E80010  stw r31, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821EE628: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE62C: 93E7000C  stw r31, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 821EE630: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE638: 419A0018  beq cr6, 0x821ee650
	if ctx.cr[6].eq {
	pc = 0x821EE650; continue 'dispatch;
	}
	// 821EE63C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821EE640: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821EE644: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821EE648: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821EE64C: 419A0144  beq cr6, 0x821ee790
	if ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	// 821EE650: 56AB063E  clrlwi r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	// 821EE654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE658: 409A0048  bne cr6, 0x821ee6a0
	if !ctx.cr[6].eq {
	pc = 0x821EE6A0; continue 'dispatch;
	}
	// 821EE65C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 821EE660: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 821EE664: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 821EE668: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE66C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EE670: 419A0018  beq cr6, 0x821ee688
	if ctx.cr[6].eq {
	pc = 0x821EE688; continue 'dispatch;
	}
	// 821EE674: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EE678: 48000141  bl 0x821ee7b8
	ctx.lr = 0x821EE67C;
	sub_821EE7B8(ctx, base);
	// 821EE67C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821EE680: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821EE684: 7D7C5378  or r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 821EE688: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EE68C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821EE690: 4082FFD8  bne 0x821ee668
	if !ctx.cr[0].eq {
	pc = 0x821EE668; continue 'dispatch;
	}
	// 821EE694: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821EE698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE69C: 409A00F4  bne cr6, 0x821ee790
	if !ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	// 821EE6A0: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 821EE6A4: 556A06B4  rlwinm r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE6AC: 409A00E4  bne cr6, 0x821ee790
	if !ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	// 821EE6B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE6B4: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 821EE6B8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6BC: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 821EE6C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE6C4: 419A00B0  beq cr6, 0x821ee774
	if ctx.cr[6].eq {
	pc = 0x821EE774; continue 'dispatch;
	}
	// 821EE6C8: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821EE6CC: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE6D4: 419A00A0  beq cr6, 0x821ee774
	if ctx.cr[6].eq {
	pc = 0x821EE774; continue 'dispatch;
	}
	// 821EE6D8: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EE6DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EE6E0: 419A0020  beq cr6, 0x821ee700
	if ctx.cr[6].eq {
	pc = 0x821EE700; continue 'dispatch;
	}
	// 821EE6E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE6E8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821EE6EC: 809B003C  lwz r4, 0x3c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 821EE6F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE6F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EE6F8: 4E800421  bctrl
	ctx.lr = 0x821EE6FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EE6FC: 48000078  b 0x821ee774
	pc = 0x821EE774; continue 'dispatch;
	// 821EE700: 8177051C  lwz r11, 0x51c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1308 as u32) ) } as u64;
	// 821EE704: 38970518  addi r4, r23, 0x518
	ctx.r[4].s64 = ctx.r[23].s64 + 1304;
	// 821EE708: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821EE70C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821EE710: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE714: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EE718: 7F042040  cmplw cr6, r4, r4
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE71C: 419A0008  beq cr6, 0x821ee724
	if ctx.cr[6].eq {
	pc = 0x821EE724; continue 'dispatch;
	}
	// 821EE720: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EE724: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EE728: 419A0048  beq cr6, 0x821ee770
	if ctx.cr[6].eq {
	pc = 0x821EE770; continue 'dispatch;
	}
	// 821EE72C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE730: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE734: 409A0008  bne cr6, 0x821ee73c
	if !ctx.cr[6].eq {
	pc = 0x821EE73C; continue 'dispatch;
	}
	// 821EE738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EE73C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE740: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE744: 419A0018  beq cr6, 0x821ee75c
	if ctx.cr[6].eq {
	pc = 0x821EE75C; continue 'dispatch;
	}
	// 821EE748: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE74C: 409A0008  bne cr6, 0x821ee754
	if !ctx.cr[6].eq {
	pc = 0x821EE754; continue 'dispatch;
	}
	// 821EE750: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EE754: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE758: 4BFFFFC0  b 0x821ee718
	pc = 0x821EE718; continue 'dispatch;
	// 821EE75C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EE760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EE764: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EE768: 48972E89  bl 0x82b615f0
	ctx.lr = 0x821EE76C;
	sub_82B615F0(ctx, base);
	// 821EE76C: 48000008  b 0x821ee774
	pc = 0x821EE774; continue 'dispatch;
	// 821EE770: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EE774: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 821EE778: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE77C: 554A06F2  rlwinm r10, r10, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE780: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE784: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 821EE788: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE78C: 419A0020  beq cr6, 0x821ee7ac
	if ctx.cr[6].eq {
	pc = 0x821EE7AC; continue 'dispatch;
	}
	// 821EE790: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EE794: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821EE798: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EE79C: 4198FE10  blt cr6, 0x821ee5ac
	if ctx.cr[6].lt {
	pc = 0x821EE5AC; continue 'dispatch;
	}
	// 821EE7A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE7A4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821EE7A8: 48ABAC94  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 821EE7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EE7B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821EE7B4: 48ABAC88  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE7B8 size=136
    let mut pc: u32 = 0x821EE7B8;
    'dispatch: loop {
        match pc {
            0x821EE7B8 => {
    //   block [0x821EE7B8..0x821EE840)
	// 821EE7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE7C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE7C4: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE7C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821EE7CC: 409A0018  bne cr6, 0x821ee7e4
	if !ctx.cr[6].eq {
	pc = 0x821EE7E4; continue 'dispatch;
	}
	// 821EE7D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE7D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE7E0: 4E800020  blr
	return;
	// 821EE7E4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821EE7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE7EC: 419A0030  beq cr6, 0x821ee81c
	if ctx.cr[6].eq {
	pc = 0x821EE81C; continue 'dispatch;
	}
	// 821EE7F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821EE7F4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821EE7F8: 808B0364  lwz r4, 0x364(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EE7FC: 480B44F5  bl 0x822a2cf0
	ctx.lr = 0x821EE800;
	sub_822A2CF0(ctx, base);
	// 821EE800: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EE804: 419A0018  beq cr6, 0x821ee81c
	if ctx.cr[6].eq {
	pc = 0x821EE81C; continue 'dispatch;
	}
	// 821EE808: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821EE80C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE810: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE814: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE818: 4E800020  blr
	return;
	// 821EE81C: 80670008  lwz r3, 8(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE820: 48007A51  bl 0x821f6270
	ctx.lr = 0x821EE824;
	sub_821F6270(ctx, base);
	// 821EE824: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821EE828: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821EE82C: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 821EE830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EE840 size=8
    let mut pc: u32 = 0x821EE840;
    'dispatch: loop {
        match pc {
            0x821EE840 => {
    //   block [0x821EE840..0x821EE848)
	// 821EE840: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE844: 48007A2C  b 0x821f6270
	sub_821F6270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE848 size=180
    let mut pc: u32 = 0x821EE848;
    'dispatch: loop {
        match pc {
            0x821EE848 => {
    //   block [0x821EE848..0x821EE8FC)
	// 821EE848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EE854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE85C: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821EE860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE864: 409A0010  bne cr6, 0x821ee874
	if !ctx.cr[6].eq {
	pc = 0x821EE874; continue 'dispatch;
	}
	// 821EE868: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821EE86C: 480309ED  bl 0x8221f258
	ctx.lr = 0x821EE870;
	sub_8221F258(ctx, base);
	// 821EE870: 48000074  b 0x821ee8e4
	pc = 0x821EE8E4; continue 'dispatch;
	// 821EE874: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EE878: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 821EE87C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EE880: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE884: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE888: 409A0008  bne cr6, 0x821ee890
	if !ctx.cr[6].eq {
	pc = 0x821EE890; continue 'dispatch;
	}
	// 821EE88C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EE890: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE894: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE898: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EE89C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EE8A4: 409A0008  bne cr6, 0x821ee8ac
	if !ctx.cr[6].eq {
	pc = 0x821EE8AC; continue 'dispatch;
	}
	// 821EE8A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EE8AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE8B0: 419A0030  beq cr6, 0x821ee8e0
	if ctx.cr[6].eq {
	pc = 0x821EE8E0; continue 'dispatch;
	}
	// 821EE8B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE8B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821EE8BC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8C0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821EE8C4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8C8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE8CC: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EE8D0: 4802D469  bl 0x8221bd38
	ctx.lr = 0x821EE8D4;
	sub_8221BD38(ctx, base);
	// 821EE8D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE8D8: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 821EE8DC: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821EE8E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EE8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EE8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EE900 size=112
    let mut pc: u32 = 0x821EE900;
    'dispatch: loop {
        match pc {
            0x821EE900 => {
    //   block [0x821EE900..0x821EE970)
	// 821EE900: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EE970 size=32
    let mut pc: u32 = 0x821EE970;
    'dispatch: loop {
        match pc {
            0x821EE970 => {
    //   block [0x821EE970..0x821EE990)
	// 821EE970: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EE974: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821EE978: 392B9150  addi r9, r11, -0x6eb0
	ctx.r[9].s64 = ctx.r[11].s64 + -28336;
	// 821EE97C: C02A9484  lfs f1, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE990 size=396
    let mut pc: u32 = 0x821EE990;
    'dispatch: loop {
        match pc {
            0x821EE990 => {
    //   block [0x821EE990..0x821EEB1C)
	// 821EE990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE994: 48ABAA75  bl 0x82ca9408
	ctx.lr = 0x821EE998;
	sub_82CA93D0(ctx, base);
	// 821EE998: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE99C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EE9A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821EE9A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821EE9A8: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821EE9AC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821EE9B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821EE9B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EE9B8: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821EE9BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EE9C0: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821EE9C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EE9C8: 4082FFE8  bne 0x821ee9b0
	if !ctx.cr[0].eq {
	pc = 0x821EE9B0; continue 'dispatch;
	}
	// 821EE9CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821EE9D0: FF010800  fcmpu cr6, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[1].f64);
	// 821EE9D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EE9D8: 419A0024  beq cr6, 0x821ee9fc
	if ctx.cr[6].eq {
	pc = 0x821EE9FC; continue 'dispatch;
	}
	// 821EE9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EE9E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821EE9E4: 388A0E04  addi r4, r10, 0xe04
	ctx.r[4].s64 = ctx.r[10].s64 + 3588;
	// 821EE9E8: C82B0D38  lfd f1, 0xd38(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 821EE9EC: D8210028  stfd f1, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 821EE9F0: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 821EE9F4: 4BFF545D  bl 0x821e3e50
	ctx.lr = 0x821EE9F8;
	sub_821E3E50(ctx, base);
	// 821EE9F8: 48000018  b 0x821eea10
	pc = 0x821EEA10; continue 'dispatch;
	// 821EE9FC: D8210028  stfd f1, 0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 821EEA00: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 821EEA04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EEA08: 388B0E04  addi r4, r11, 0xe04
	ctx.r[4].s64 = ctx.r[11].s64 + 3588;
	// 821EEA0C: 4BFF5445  bl 0x821e3e50
	ctx.lr = 0x821EEA10;
	sub_821E3E50(ctx, base);
	// 821EEA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA14: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821EEA18: 48000199  bl 0x821eebb0
	ctx.lr = 0x821EEA1C;
	sub_821EEBB0(ctx, base);
	// 821EEA1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821EEA20: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EEA24: 4099002C  ble cr6, 0x821eea50
	if !ctx.cr[6].gt {
	pc = 0x821EEA50; continue 'dispatch;
	}
	// 821EEA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA2C: 4803933D  bl 0x82227d68
	ctx.lr = 0x821EEA30;
	sub_82227D68(ctx, base);
	// 821EEA30: 7D63F0AE  lbzx r11, r3, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821EEA34: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 821EEA38: 419A0014  beq cr6, 0x821eea4c
	if ctx.cr[6].eq {
	pc = 0x821EEA4C; continue 'dispatch;
	}
	// 821EEA3C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821EEA40: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821EEA44: 4198FFE4  blt cr6, 0x821eea28
	if ctx.cr[6].lt {
	pc = 0x821EEA28; continue 'dispatch;
	}
	// 821EEA48: 48000008  b 0x821eea50
	pc = 0x821EEA50; continue 'dispatch;
	// 821EEA4C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821EEA50: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821EEA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EEA5C: 419A00B8  beq cr6, 0x821eeb14
	if ctx.cr[6].eq {
	pc = 0x821EEB14; continue 'dispatch;
	}
	// 821EEA60: 48000151  bl 0x821eebb0
	ctx.lr = 0x821EEA64;
	sub_821EEBB0(ctx, base);
	// 821EEA64: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EEA68: 409900A8  ble cr6, 0x821eeb10
	if !ctx.cr[6].gt {
	pc = 0x821EEB10; continue 'dispatch;
	}
	// 821EEA6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EEA70: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 821EEA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA78: 480392F1  bl 0x82227d68
	ctx.lr = 0x821EEA7C;
	sub_82227D68(ctx, base);
	// 821EEA7C: 3BC3FFFF  addi r30, r3, -1
	ctx.r[30].s64 = ctx.r[3].s64 + -1;
	// 821EEA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA84: 4800012D  bl 0x821eebb0
	ctx.lr = 0x821EEA88;
	sub_821EEBB0(ctx, base);
	// 821EEA88: 7D7E18AE  lbzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 821EEA8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEA90: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821EEA94: 2F0B002E  cmpwi cr6, r11, 0x2e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 46, &mut ctx.xer);
	// 821EEA98: 419A0070  beq cr6, 0x821eeb08
	if ctx.cr[6].eq {
	pc = 0x821EEB08; continue 'dispatch;
	}
	// 821EEA9C: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 821EEAA0: 409A0074  bne cr6, 0x821eeb14
	if !ctx.cr[6].eq {
	pc = 0x821EEB14; continue 'dispatch;
	}
	// 821EEAA4: 4800010D  bl 0x821eebb0
	ctx.lr = 0x821EEAA8;
	sub_821EEBB0(ctx, base);
	// 821EEAA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEAAC: 3BC3FFFF  addi r30, r3, -1
	ctx.r[30].s64 = ctx.r[3].s64 + -1;
	// 821EEAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EEAB4: 419A0008  beq cr6, 0x821eeabc
	if ctx.cr[6].eq {
	pc = 0x821EEABC; continue 'dispatch;
	}
	// 821EEAB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EEABC: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821EEAC0: 4099002C  ble cr6, 0x821eeaec
	if !ctx.cr[6].gt {
	pc = 0x821EEAEC; continue 'dispatch;
	}
	// 821EEAC4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821EEAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEACC: 409A0010  bne cr6, 0x821eeadc
	if !ctx.cr[6].eq {
	pc = 0x821EEADC; continue 'dispatch;
	}
	// 821EEAD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EEAD4: 48086965  bl 0x82275438
	ctx.lr = 0x821EEAD8;
	sub_82275438(ctx, base);
	// 821EEAD8: 48000014  b 0x821eeaec
	pc = 0x821EEAEC; continue 'dispatch;
	// 821EEADC: 4803FD1D  bl 0x8222e7f8
	ctx.lr = 0x821EEAE0;
	sub_8222E7F8(ctx, base);
	// 821EEAE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EEAE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEAE8: 4BFC8709  bl 0x821b71f0
	ctx.lr = 0x821EEAEC;
	sub_821B71F0(ctx, base);
	// 821EEAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEAF0: 480000C1  bl 0x821eebb0
	ctx.lr = 0x821EEAF4;
	sub_821EEBB0(ctx, base);
	// 821EEAF4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EEAF8: 4199FF7C  bgt cr6, 0x821eea74
	if ctx.cr[6].gt {
	pc = 0x821EEA74; continue 'dispatch;
	}
	// 821EEAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEB00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821EEB04: 48ABA954  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821EEB08: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821EEB0C: 4BFA8765  bl 0x82197270
	ctx.lr = 0x821EEB10;
	sub_82197270(ctx, base);
	// 821EEB10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EEB14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821EEB18: 48ABA940  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEB20 size=8
    let mut pc: u32 = 0x821EEB20;
    'dispatch: loop {
        match pc {
            0x821EEB20 => {
    //   block [0x821EEB20..0x821EEB28)
	// 821EEB20: 2F030041  cmpwi cr6, r3, 0x41
	ctx.cr[6].compare_i32(ctx.r[3].s32, 65, &mut ctx.xer);
	// 821EEB24: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEB28 size=8
    let mut pc: u32 = 0x821EEB28;
    'dispatch: loop {
        match pc {
            0x821EEB28 => {
    //   block [0x821EEB28..0x821EEB30)
	// 821EEB28: 2F03005A  cmpwi cr6, r3, 0x5a
	ctx.cr[6].compare_i32(ctx.r[3].s32, 90, &mut ctx.xer);
	// 821EEB2C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEB30 size=8
    let mut pc: u32 = 0x821EEB30;
    'dispatch: loop {
        match pc {
            0x821EEB30 => {
    //   block [0x821EEB30..0x821EEB38)
	// 821EEB30: 38630020  addi r3, r3, 0x20
	ctx.r[3].s64 = ctx.r[3].s64 + 32;
	// 821EEB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EEB38 size=120
    let mut pc: u32 = 0x821EEB38;
    'dispatch: loop {
        match pc {
            0x821EEB38 => {
    //   block [0x821EEB38..0x821EEBB0)
	// 821EEB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EEB3C: 48ABA8D1  bl 0x82ca940c
	ctx.lr = 0x821EEB40;
	sub_82CA93D0(ctx, base);
	// 821EEB40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EEB44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EEB48: 480016F9  bl 0x821f0240
	ctx.lr = 0x821EEB4C;
	sub_821F0240(ctx, base);
	// 821EEB4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EEB50: 4803FCA9  bl 0x8222e7f8
	ctx.lr = 0x821EEB54;
	sub_8222E7F8(ctx, base);
	// 821EEB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EEB58: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEB5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821EEB60: 419A0048  beq cr6, 0x821eeba8
	if ctx.cr[6].eq {
	pc = 0x821EEBA8; continue 'dispatch;
	}
	// 821EEB64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821EEB68: 48000049  bl 0x821eebb0
	ctx.lr = 0x821EEB6C;
	sub_821EEBB0(ctx, base);
	// 821EEB6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EEB70: 40990034  ble cr6, 0x821eeba4
	if !ctx.cr[6].gt {
	pc = 0x821EEBA4; continue 'dispatch;
	}
	// 821EEB74: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEB78: 7D6BF8AE  lbzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821EEB7C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 821EEB80: 4BFFFFA1  bl 0x821eeb20
	ctx.lr = 0x821EEB84;
	sub_821EEB20(ctx, base);
	// 821EEB84: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEB88: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821EEB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EEB90: 7D2AF9AE  stbx r9, r10, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u8) };
	// 821EEB94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821EEB98: 48000019  bl 0x821eebb0
	ctx.lr = 0x821EEB9C;
	sub_821EEBB0(ctx, base);
	// 821EEB9C: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821EEBA0: 4198FFD4  blt cr6, 0x821eeb74
	if ctx.cr[6].lt {
	pc = 0x821EEB74; continue 'dispatch;
	}
	// 821EEBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EEBA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EEBAC: 48ABA8B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEBB0 size=16
    let mut pc: u32 = 0x821EEBB0;
    'dispatch: loop {
        match pc {
            0x821EEBB0 => {
    //   block [0x821EEBB0..0x821EEBC0)
	// 821EEBB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEBB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EEBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EEBBC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEBC0 size=8
    let mut pc: u32 = 0x821EEBC0;
    'dispatch: loop {
        match pc {
            0x821EEBC0 => {
    //   block [0x821EEBC0..0x821EEBC8)
	// 821EEBC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EEBC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EEBC8 size=124
    let mut pc: u32 = 0x821EEBC8;
    'dispatch: loop {
        match pc {
            0x821EEBC8 => {
    //   block [0x821EEBC8..0x821EEC44)
	// 821EEBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EEBCC: 48ABA841  bl 0x82ca940c
	ctx.lr = 0x821EEBD0;
	sub_82CA93D0(ctx, base);
	// 821EEBD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EEBD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821EEBD8: 48001669  bl 0x821f0240
	ctx.lr = 0x821EEBDC;
	sub_821F0240(ctx, base);
	// 821EEBDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EEBE0: 4803FC19  bl 0x8222e7f8
	ctx.lr = 0x821EEBE4;
	sub_8222E7F8(ctx, base);
	// 821EEBE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EEBE8: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEBEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821EEBF0: 419A004C  beq cr6, 0x821eec3c
	if ctx.cr[6].eq {
	pc = 0x821EEC3C; continue 'dispatch;
	}
	// 821EEBF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821EEBF8: 4BFFFFB9  bl 0x821eebb0
	ctx.lr = 0x821EEBFC;
	sub_821EEBB0(ctx, base);
	// 821EEBFC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EEC00: 40990038  ble cr6, 0x821eec38
	if !ctx.cr[6].gt {
	pc = 0x821EEC38; continue 'dispatch;
	}
	// 821EEC04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEC08: 7D6BF8AE  lbzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821EEC0C: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 821EEC10: 40980014  bge cr6, 0x821eec24
	if !ctx.cr[6].lt {
	pc = 0x821EEC24; continue 'dispatch;
	}
	// 821EEC14: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 821EEC18: 48000031  bl 0x821eec48
	ctx.lr = 0x821EEC1C;
	sub_821EEC48(ctx, base);
	// 821EEC1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EEC20: 7C6BF9AE  stbx r3, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[3].u8) };
	// 821EEC24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EEC28: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821EEC2C: 4BFFFF85  bl 0x821eebb0
	ctx.lr = 0x821EEC30;
	sub_821EEBB0(ctx, base);
	// 821EEC30: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821EEC34: 4198FFD0  blt cr6, 0x821eec04
	if ctx.cr[6].lt {
	pc = 0x821EEC04; continue 'dispatch;
	}
	// 821EEC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EEC3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EEC40: 48ABA81C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEC48 size=8
    let mut pc: u32 = 0x821EEC48;
    'dispatch: loop {
        match pc {
            0x821EEC48 => {
    //   block [0x821EEC48..0x821EEC50)
	// 821EEC48: 2F030061  cmpwi cr6, r3, 0x61
	ctx.cr[6].compare_i32(ctx.r[3].s32, 97, &mut ctx.xer);
	// 821EEC4C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEC50 size=8
    let mut pc: u32 = 0x821EEC50;
    'dispatch: loop {
        match pc {
            0x821EEC50 => {
    //   block [0x821EEC50..0x821EEC58)
	// 821EEC50: 2F03007A  cmpwi cr6, r3, 0x7a
	ctx.cr[6].compare_i32(ctx.r[3].s32, 122, &mut ctx.xer);
	// 821EEC54: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EEC58 size=8
    let mut pc: u32 = 0x821EEC58;
    'dispatch: loop {
        match pc {
            0x821EEC58 => {
    //   block [0x821EEC58..0x821EEC60)
	// 821EEC58: 3863FFE0  addi r3, r3, -0x20
	ctx.r[3].s64 = ctx.r[3].s64 + -32;
	// 821EEC5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EEC60 size=484
    let mut pc: u32 = 0x821EEC60;
    'dispatch: loop {
        match pc {
            0x821EEC60 => {
    //   block [0x821EEC60..0x821EEE44)
	// 821EEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EEC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EEC68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EEC6C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821EEC70: 81230098  lwz r9, 0x98(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 821EEC74: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EEE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EEE48 size=484
    let mut pc: u32 = 0x821EEE48;
    'dispatch: loop {
        match pc {
            0x821EEE48 => {
    //   block [0x821EEE48..0x821EF02C)
	// 821EEE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EEE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EEE50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EEE54: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821EEE58: 81230098  lwz r9, 0x98(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 821EEE5C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EF030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EF030 size=240
    let mut pc: u32 = 0x821EF030;
    'dispatch: loop {
        match pc {
            0x821EF030 => {
    //   block [0x821EF030..0x821EF120)
	// 821EF030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EF034: 48ABA3CD  bl 0x82ca9400
	ctx.lr = 0x821EF038;
	sub_82CA93D0(ctx, base);
	// 821EF038: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821EF03C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EF040: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821EF044: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821EF048: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821EF04C: 419A00C8  beq cr6, 0x821ef114
	if ctx.cr[6].eq {
	pc = 0x821EF114; continue 'dispatch;
	}
	// 821EF050: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821EF054: 482D6F1D  bl 0x824c5f70
	ctx.lr = 0x821EF058;
	sub_824C5F70(ctx, base);
	// 821EF058: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821EF05C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821EF060: 3BAB92B0  addi r29, r11, -0x6d50
	ctx.r[29].s64 = ctx.r[11].s64 + -27984;
	// 821EF064: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821EF068: 3B8AFFDF  addi r28, r10, -0x21
	ctx.r[28].s64 = ctx.r[10].s64 + -33;
	// 821EF06C: C3E99484  lfs f31, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EF070: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF074: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF078: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EF07C: 419A0098  beq cr6, 0x821ef114
	if ctx.cr[6].eq {
	pc = 0x821EF114; continue 'dispatch;
	}
	// 821EF080: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EF084: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EF088: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 821EF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF090: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821EF094: 419A0008  beq cr6, 0x821ef09c
	if ctx.cr[6].eq {
	pc = 0x821EF09C; continue 'dispatch;
	}
	// 821EF098: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF09C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821EF0A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821EF0A4: 481BE34D  bl 0x823ad3f0
	ctx.lr = 0x821EF0A8;
	sub_823AD3F0(ctx, base);
	// 821EF0A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821EF0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF0B0: 419A004C  beq cr6, 0x821ef0fc
	if ctx.cr[6].eq {
	pc = 0x821EF0FC; continue 'dispatch;
	}
	// 821EF0B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF0B8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EF0BC: 409A0008  bne cr6, 0x821ef0c4
	if !ctx.cr[6].eq {
	pc = 0x821EF0C4; continue 'dispatch;
	}
	// 821EF0C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EF0C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF0C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821EF0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF0D0: 419A0008  beq cr6, 0x821ef0d8
	if ctx.cr[6].eq {
	pc = 0x821EF0D8; continue 'dispatch;
	}
	// 821EF0D4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF0D8: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 821EF0DC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 821EF0E0: 48004C79  bl 0x821f3d58
	ctx.lr = 0x821EF0E4;
	sub_821F3D58(ctx, base);
	// 821EF0E4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EF0E8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821EF0EC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821EF0F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821EF0F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821EF0F8: 48652F69  bl 0x82842060
	ctx.lr = 0x821EF0FC;
	sub_82842060(ctx, base);
	// 821EF0FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF100: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EF104: 409A0008  bne cr6, 0x821ef10c
	if !ctx.cr[6].eq {
	pc = 0x821EF10C; continue 'dispatch;
	}
	// 821EF108: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EF10C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF110: 4BFFFF68  b 0x821ef078
	pc = 0x821EF078; continue 'dispatch;
	// 821EF114: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821EF118: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821EF11C: 48ABA334  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EF120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EF120 size=1804
    let mut pc: u32 = 0x821EF120;
    'dispatch: loop {
        match pc {
            0x821EF120 => {
    //   block [0x821EF120..0x821EF82C)
	// 821EF120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EF124: 48ABA2AD  bl 0x82ca93d0
	ctx.lr = 0x821EF128;
	sub_82CA93D0(ctx, base);
	// 821EF128: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821EF12C: 48ABEBAD  bl 0x82cadcd8
	ctx.lr = 0x821EF130;
	sub_82CADCA0(ctx, base);
	// 821EF130: 3981FF40  addi r12, r1, -0xc0
	ctx.r[12].s64 = ctx.r[1].s64 + -192;
	// 821EF134: 48E178A1  bl 0x830069d4
	ctx.lr = 0x821EF138;
	sub_83006760(ctx, base);
	// 821EF138: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EF13C: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 821EF140: 896F010C  lbz r11, 0x10c(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(268 as u32) ) } as u64;
	// 821EF144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF148: 409A06C4  bne cr6, 0x821ef80c
	if !ctx.cr[6].eq {
	pc = 0x821EF80C; continue 'dispatch;
	}
	// 821EF14C: 816F0100  lwz r11, 0x100(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(256 as u32) ) } as u64;
	// 821EF150: 3AAF00FC  addi r21, r15, 0xfc
	ctx.r[21].s64 = ctx.r[15].s64 + 252;
	// 821EF154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF158: 419A06BC  beq cr6, 0x821ef814
	if ctx.cr[6].eq {
	pc = 0x821EF814; continue 'dispatch;
	}
	// 821EF15C: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EF160: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821EF164: 7D2B2671  srawi. r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EF168: 418206AC  beq 0x821ef814
	if ctx.cr[0].eq {
	pc = 0x821EF814; continue 'dispatch;
	}
	// 821EF16C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821EF170: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821EF174: 38C79490  addi r6, r7, -0x6b70
	ctx.r[6].s64 = ctx.r[7].s64 + -27504;
	// 821EF178: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821EF17C: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821EF180: C3879490  lfs f28, -0x6b70(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821EF184: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821EF188: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821EF18C: 9A8F010C  stb r20, 0x10c(r15)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[15].u32.wrapping_add(268 as u32), ctx.r[20].u8 ) };
	// 821EF190: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821EF194: C3A6000C  lfs f29, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821EF198: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821EF19C: C3C6FFF4  lfs f30, -0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821EF1A0: 38A990C0  addi r5, r9, -0x6f40
	ctx.r[5].s64 = ctx.r[9].s64 + -28480;
	// 821EF1A4: 7F73DB78  mr r19, r27
	ctx.r[19].u64 = ctx.r[27].u64;
	// 821EF1A8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821EF1AC: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821EF1B0: 3E208332  lis r17, -0x7cce
	ctx.r[17].s64 = -2093875200;
	// 821EF1B4: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 821EF1B8: 3E00834C  lis r16, -0x7cb4
	ctx.r[16].s64 = -2092171264;
	// 821EF1BC: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 821EF1C0: 3A4B0E0C  addi r18, r11, 0xe0c
	ctx.r[18].s64 = ctx.r[11].s64 + 3596;
	// 821EF1C4: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 821EF1C8: 3B280AA4  addi r25, r8, 0xaa4
	ctx.r[25].s64 = ctx.r[8].s64 + 2724;
	// 821EF1CC: 3B070AB4  addi r24, r7, 0xab4
	ctx.r[24].s64 = ctx.r[7].s64 + 2740;
	// 821EF1D0: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF1D4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821EF1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF1DC: 419A0620  beq cr6, 0x821ef7fc
	if ctx.cr[6].eq {
	pc = 0x821EF7FC; continue 'dispatch;
	}
	// 821EF1E0: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EF1E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821EF1E8: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821EF1EC: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EF1F0: 4098060C  bge cr6, 0x821ef7fc
	if !ctx.cr[6].lt {
	pc = 0x821EF7FC; continue 'dispatch;
	}
	// 821EF1F4: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF1FC: 419A0018  beq cr6, 0x821ef214
	if ctx.cr[6].eq {
	pc = 0x821EF214; continue 'dispatch;
	}
	// 821EF200: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EF204: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821EF208: 7D2A2670  srawi r10, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821EF20C: 7F135040  cmplw cr6, r19, r10
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EF210: 41980008  blt cr6, 0x821ef218
	if ctx.cr[6].lt {
	pc = 0x821EF218; continue 'dispatch;
	}
	// 821EF214: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EF218: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821EF21C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821EF220: 483AAA59  bl 0x82599c78
	ctx.lr = 0x821EF224;
	sub_82599C78(ctx, base);
	// 821EF224: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821EF228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF22C: 419A0038  beq cr6, 0x821ef264
	if ctx.cr[6].eq {
	pc = 0x821EF264; continue 'dispatch;
	}
	// 821EF230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EF238: 419A01C4  beq cr6, 0x821ef3fc
	if ctx.cr[6].eq {
	pc = 0x821EF3FC; continue 'dispatch;
	}
	// 821EF23C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EF240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF244: 419A0020  beq cr6, 0x821ef264
	if ctx.cr[6].eq {
	pc = 0x821EF264; continue 'dispatch;
	}
	// 821EF248: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821EF24C: 4BF84BED  bl 0x82173e38
	ctx.lr = 0x821EF250;
	sub_82173E38(ctx, base);
	// 821EF250: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821EF254: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EF258: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821EF25C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EF260: 409A0008  bne cr6, 0x821ef268
	if !ctx.cr[6].eq {
	pc = 0x821EF268; continue 'dispatch;
	}
	// 821EF264: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821EF268: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EF26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EF270: 419A0568  beq cr6, 0x821ef7d8
	if ctx.cr[6].eq {
	pc = 0x821EF7D8; continue 'dispatch;
	}
	// 821EF274: 81766AB8  lwz r11, 0x6ab8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EF278: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EF27C: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821EF280: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821EF284: 409A0050  bne cr6, 0x821ef2d4
	if !ctx.cr[6].eq {
	pc = 0x821EF2D4; continue 'dispatch;
	}
	// 821EF288: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EF28C: 83EF0004  lwz r31, 4(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF290: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF294: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF298: 4803CF21  bl 0x8222c1b8
	ctx.lr = 0x821EF29C;
	sub_8222C1B8(ctx, base);
	// 821EF29C: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821EF2A0: 409A0034  bne cr6, 0x821ef2d4
	if !ctx.cr[6].eq {
	pc = 0x821EF2D4; continue 'dispatch;
	}
	// 821EF2A4: 81766AB8  lwz r11, 0x6ab8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EF2A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EF2AC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EF2B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EF2B4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EF2B8: 486F67C1  bl 0x828e5a78
	ctx.lr = 0x821EF2BC;
	sub_828E5A78(ctx, base);
	// 821EF2BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EF2C0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821EF2C4: 4819BED5  bl 0x8238b198
	ctx.lr = 0x821EF2C8;
	sub_8238B198(ctx, base);
	// 821EF2C8: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821EF2CC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EF2D0: 419A0508  beq cr6, 0x821ef7d8
	if ctx.cr[6].eq {
	pc = 0x821EF7D8; continue 'dispatch;
	}
	// 821EF2D4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821EF2D8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 821EF2DC: C3FA9A80  lfs f31, -0x6580(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EF2E0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821EF2E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EF830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EF830 size=652
    let mut pc: u32 = 0x821EF830;
    'dispatch: loop {
        match pc {
            0x821EF830 => {
    //   block [0x821EF830..0x821EFABC)
	// 821EF830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EF834: 48AB9BB9  bl 0x82ca93ec
	ctx.lr = 0x821EF838;
	sub_82CA93D0(ctx, base);
	// 821EF838: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 821EF83C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EF840: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 821EF844: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821EF848: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821EF84C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821EF850: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821EF854: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821EF858: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 821EF85C: 56EB87BF  rlwinm. r11, r23, 0x10, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EF860: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821EF864: 4082000C  bne 0x821ef870
	if !ctx.cr[0].eq {
	pc = 0x821EF870; continue 'dispatch;
	}
	// 821EF868: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821EF86C: 48000014  b 0x821ef880
	pc = 0x821EF880; continue 'dispatch;
	// 821EF870: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821EF874: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821EF878: 419A0008  beq cr6, 0x821ef880
	if ctx.cr[6].eq {
	pc = 0x821EF880; continue 'dispatch;
	}
	// 821EF87C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821EF880: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 821EF884: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 821EF888: 7D6BD830  slw r11, r11, r27
	if (ctx.r[27].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[27].u8 & 0x1F) as u32)) as u64;
	}
	// 821EF88C: 7D4AD030  slw r10, r10, r26
	if (ctx.r[26].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[26].u8 & 0x1F) as u32)) as u64;
	}
	// 821EF890: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821EF894: 7D0AE214  add r8, r10, r28
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821EF898: 3889FFFF  addi r4, r9, -1
	ctx.r[4].s64 = ctx.r[9].s64 + -1;
	// 821EF89C: 3BC8FFFF  addi r30, r8, -1
	ctx.r[30].s64 = ctx.r[8].s64 + -1;
	// 821EF8A0: 5489083E  rotlwi r9, r4, 1
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 821EF8A4: 57A6083E  rotlwi r6, r29, 1
	ctx.r[6].u64 = ((ctx.r[29].u32).rotate_left(1)) as u64;
	// 821EF8A8: 7C845BD6  divw r4, r4, r11
	ctx.r[4].s32 = ctx.r[4].s32 / ctx.r[11].s32;
	// 821EF8AC: 57C8083E  rotlwi r8, r30, 1
	ctx.r[8].u64 = ((ctx.r[30].u32).rotate_left(1)) as u64;
	// 821EF8B0: 54E5083E  rotlwi r5, r7, 1
	ctx.r[5].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 821EF8B4: 7F3D5BD6  divw r25, r29, r11
	ctx.r[25].s32 = ctx.r[29].s32 / ctx.r[11].s32;
	// 821EF8B8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821EF8BC: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 821EF8C0: 7FE459D6  mullw r31, r4, r11
	ctx.r[31].s64 = (ctx.r[4].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821EF8C4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821EF8C8: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 821EF8CC: 7C9E53D6  divw r4, r30, r10
	ctx.r[4].s32 = ctx.r[30].s32 / ctx.r[10].s32;
	// 821EF8D0: 7FD959D6  mullw r30, r25, r11
	ctx.r[30].s64 = (ctx.r[25].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821EF8D4: 7D694878  andc r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 & !ctx.r[9].u64;
	// 821EF8D8: 7D663078  andc r6, r11, r6
	ctx.r[6].u64 = ctx.r[11].u64 & !ctx.r[6].u64;
	// 821EF8DC: 0CCB0000  twi 6, r11, 0
	// 821EF8E0: 0CCB0000  twi 6, r11, 0
	// 821EF8E4: 7D484078  andc r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 & !ctx.r[8].u64;
	// 821EF8E8: 7D6753D6  divw r11, r7, r10
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	// 821EF8EC: 7D452878  andc r5, r10, r5
	ctx.r[5].u64 = ctx.r[10].u64 & !ctx.r[5].u64;
	// 821EF8F0: 0CCA0000  twi 6, r10, 0
	// 821EF8F4: 0CCA0000  twi 6, r10, 0
	// 821EF8F8: 0CA9FFFF  twi 5, r9, -1
	// 821EF8FC: 0CA8FFFF  twi 5, r8, -1
	// 821EF900: 7F2451D6  mullw r25, r4, r10
	ctx.r[25].s64 = (ctx.r[4].s32 as i64) * (ctx.r[10].s32 as i64);
	// 821EF904: 0CA6FFFF  twi 5, r6, -1
	// 821EF908: 0CA5FFFF  twi 5, r5, -1
	// 821EF90C: 7F0B51D6  mullw r24, r11, r10
	ctx.r[24].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 821EF910: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821EF914: 40980160  bge cr6, 0x821efa74
	if !ctx.cr[6].lt {
	pc = 0x821EFA74; continue 'dispatch;
	}
	// 821EF918: 7F19C000  cmpw cr6, r25, r24
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[24].s32, &mut ctx.xer);
	// 821EF91C: 40980158  bge cr6, 0x821efa74
	if !ctx.cr[6].lt {
	pc = 0x821EFA74; continue 'dispatch;
	}
	// 821EF920: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EF924: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821EF928: 40990018  ble cr6, 0x821ef940
	if !ctx.cr[6].gt {
	pc = 0x821EF940; continue 'dispatch;
	}
	// 821EF92C: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 821EF930: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821EF934: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 821EF938: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 821EF93C: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821EF940: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821EF944: 4098002C  bge cr6, 0x821ef970
	if !ctx.cr[6].lt {
	pc = 0x821EF970; continue 'dispatch;
	}
	// 821EF948: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EF94C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821EF950: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 821EF954: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 821EF958: 38C1007C  addi r6, r1, 0x7c
	ctx.r[6].s64 = ctx.r[1].s64 + 124;
	// 821EF95C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821EF960: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 821EF964: 7F8B492E  stwx r28, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	// 821EF968: 7FAB412E  stwx r29, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[29].u32) };
	// 821EF96C: 7CEB312E  stwx r7, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821EF970: 7F19E000  cmpw cr6, r25, r28
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821EF974: 4099002C  ble cr6, 0x821ef9a0
	if !ctx.cr[6].gt {
	pc = 0x821EF9A0; continue 'dispatch;
	}
	// 821EF978: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EF97C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821EF980: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 821EF984: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 821EF988: 38C1007C  addi r6, r1, 0x7c
	ctx.r[6].s64 = ctx.r[1].s64 + 124;
	// 821EF98C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821EF990: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 821EF994: 7F8B492E  stwx r28, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	// 821EF998: 7FCB412E  stwx r30, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 821EF99C: 7F2B312E  stwx r25, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[25].u32) };
	// 821EF9A0: 7F183800  cmpw cr6, r24, r7
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821EF9A4: 4098002C  bge cr6, 0x821ef9d0
	if !ctx.cr[6].lt {
	pc = 0x821EF9D0; continue 'dispatch;
	}
	// 821EF9A8: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EF9AC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821EF9B0: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 821EF9B4: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 821EF9B8: 38C1007C  addi r6, r1, 0x7c
	ctx.r[6].s64 = ctx.r[1].s64 + 124;
	// 821EF9BC: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821EF9C0: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 821EF9C4: 7F0B492E  stwx r24, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[24].u32) };
	// 821EF9C8: 7FCB412E  stwx r30, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 821EF9CC: 7CEB312E  stwx r7, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821EF9D0: 83A10174  lwz r29, 0x174(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 821EF9D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EF9D8: 419A002C  beq cr6, 0x821efa04
	if ctx.cr[6].eq {
	pc = 0x821EFA04; continue 'dispatch;
	}
	// 821EF9DC: 8161018C  lwz r11, 0x18c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 821EF9E0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821EF9E4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821EF9E8: 8141017C  lwz r10, 0x17c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 821EF9EC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 821EF9F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821EF9F4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821EF9F8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821EF9FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EFA00: 480000C1  bl 0x821efac0
	ctx.lr = 0x821EFA04;
	sub_821EFAC0(ctx, base);
	// 821EFA04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EFA08: 81210194  lwz r9, 0x194(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 821EFA0C: 7FE8DE30  sraw r8, r31, r27
	tmp.u32 = ctx.r[27].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[31].s32 >> tmp.u32) as i64;
	// 821EFA10: 81410184  lwz r10, 0x184(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 821EFA14: 51778B9E  rlwimi r23, r11, 0x11, 0xe, 0xf
	ctx.r[23].u64 = (((ctx.r[11].u32).rotate_left(17) as u64) & 0x0000000000030000) | (ctx.r[23].u64 & 0xFFFFFFFFFFFCFFFF);
	// 821EFA18: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821EFA1C: 7F2BD630  sraw r11, r25, r26
	tmp.u32 = ctx.r[26].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[25].s32 < 0) && ((ctx.r[25].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[25].s32 >> tmp.u32) as i64;
	// 821EFA20: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 821EFA24: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821EFA28: 7FCBDE30  sraw r11, r30, r27
	tmp.u32 = ctx.r[27].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[30].s32 >> tmp.u32) as i64;
	// 821EFA2C: 7F09D630  sraw r9, r24, r26
	tmp.u32 = ctx.r[26].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[24].s32 >> tmp.u32) as i64;
	// 821EFA30: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821EFA34: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 821EFA38: 56EB04BE  clrlwi r11, r23, 0x12
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00003FFFu64;
	// 821EFA3C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821EFA40: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821EFA44: 7D6BDC30  srw r11, r11, r27
	if (ctx.r[27].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) >> ((ctx.r[27].u8 & 0x1F) as u32)) as u64;
	}
	// 821EFA48: 52EB0022  rlwimi r11, r23, 0, 0, 0x11
	ctx.r[11].u64 = (((ctx.r[23].u32).rotate_left(0) as u64) & 0x00000000FFFFC000) | (ctx.r[11].u64 & 0xFFFFFFFF00003FFF);
	// 821EFA4C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 821EFA50: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821EFA54: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821EFA58: 550B74BE  srwi r11, r8, 0x12
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(18);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EFA5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821EFA60: 7D6BDC30  srw r11, r11, r27
	if (ctx.r[27].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) >> ((ctx.r[27].u8 & 0x1F) as u32)) as u64;
	}
	// 821EFA64: 5168901A  rlwimi r8, r11, 0x12, 0, 0xd
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(18) as u64) & 0x00000000FFFC0000) | (ctx.r[8].u64 & 0xFFFFFFFF0003FFFF);
	// 821EFA68: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821EFA6C: 48000055  bl 0x821efac0
	ctx.lr = 0x821EFA70;
	sub_821EFAC0(ctx, base);
	// 821EFA70: 48000040  b 0x821efab0
	pc = 0x821EFAB0; continue 'dispatch;
	// 821EFA74: 8161018C  lwz r11, 0x18c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 821EFA78: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821EFA7C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821EFA80: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 821EFA84: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821EFA88: 8141017C  lwz r10, 0x17c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 821EFA8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821EFA90: 81210174  lwz r9, 0x174(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 821EFA94: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821EFA98: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 821EFA9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EFAA0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821EFAA4: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821EFAA8: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 821EFAAC: 48000015  bl 0x821efac0
	ctx.lr = 0x821EFAB0;
	sub_821EFAC0(ctx, base);
	// 821EFAB0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821EFAB4: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821EFAB8: 48AB9984  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EFAC0 size=752
    let mut pc: u32 = 0x821EFAC0;
    'dispatch: loop {
        match pc {
            0x821EFAC0 => {
    //   block [0x821EFAC0..0x821EFDB0)
	// 821EFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EFAC4: 48AB9931  bl 0x82ca93f4
	ctx.lr = 0x821EFAC8;
	sub_82CA93D0(ctx, base);
	// 821EFAC8: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 821EFACC: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821EFAD0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EFAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EFAD8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821EFADC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EFAE0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821EFAE4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821EFAE8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821EFAEC: 817F29C0  lwz r11, 0x29c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10688 as u32) ) } as u64;
	// 821EFAF0: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 821EFAF4: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 821EFAF8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EFAFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EFB00: 40820010  bne 0x821efb10
	if !ctx.cr[0].eq {
	pc = 0x821EFB10; continue 'dispatch;
	}
	// 821EFB04: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 821EFB08: C3EBFE50  lfs f31, -0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EFB0C: 48000008  b 0x821efb14
	pc = 0x821EFB14; continue 'dispatch;
	// 821EFB10: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EFB14: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EFB18: 83BF0030  lwz r29, 0x30(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821EFB1C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EFB20: 40990010  ble cr6, 0x821efb30
	if !ctx.cr[6].gt {
	pc = 0x821EFB30; continue 'dispatch;
	}
	// 821EFB24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EFB28: 4BFF9399  bl 0x821e8ec0
	ctx.lr = 0x821EFB2C;
	sub_821E8EC0(ctx, base);
	// 821EFB2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821EFB30: 1F7C0015  mulli r27, r28, 0x15
	ctx.r[27].s64 = ctx.r[28].s64 * 21;
	// 821EFB34: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821EFB38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EFB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EFB40: 48016BA9  bl 0x822066e8
	ctx.lr = 0x821EFB44;
	sub_822066E8(ctx, base);
	// 821EFB44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821EFB48: 4082000C  bne 0x821efb54
	if !ctx.cr[0].eq {
	pc = 0x821EFB54; continue 'dispatch;
	}
	// 821EFB4C: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 821EFB50: 48000250  b 0x821efda0
	pc = 0x821EFDA0; continue 'dispatch;
	// 821EFB54: 546B653E  srwi r11, r3, 0x14
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EFB58: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EFB5C: 546A00FE  clrlwi r10, r3, 3
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x1FFFFFFFu64;
	// 821EFB60: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EFB64: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821EFB68: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821EFB6C: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821EFB70: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821EFB74: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EFB78: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821EFB7C: 419A00D8  beq cr6, 0x821efc54
	if ctx.cr[6].eq {
	pc = 0x821EFC54; continue 'dispatch;
	}
	// 821EFB80: 39790008  addi r11, r25, 8
	ctx.r[11].s64 = ctx.r[25].s64 + 8;
	// 821EFB84: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821EFB88: E90BFFFE  lwa r8, -4(r11)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as i32) as i64;
	// 821EFB8C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821EFB90: E8ABFFFA  lwa r5, -8(r11)
	ctx.r[5].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as i32) as i64;
	// 821EFB94: E8EB0002  lwa r7, 0(r11)
	ctx.r[7].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 821EFB98: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 821EFB9C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821EFBA0: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 821EFBA4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821EFBA8: E8CB0006  lwa r6, 4(r11)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 821EFBAC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821EFBB0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 821EFBB4: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821EFBB8: C8E10068  lfd f7, 0x68(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821EFBBC: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 821EFBC0: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EFBC4: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 821EFBC8: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 821EFBCC: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821EFBD0: C9010060  lfd f8, 0x60(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821EFBD4: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 821EFBD8: FCE03818  frsp f7, f7
	ctx.f[7].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821EFBDC: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821EFBE0: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821EFBE4: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821EFBE8: ECE7F828  fsubs f7, f7, f31
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EFBEC: D0E30000  stfs f7, 0(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821EFBF0: ED4AF828  fsubs f10, f10, f31
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EFBF4: D1430004  stfs f10, 4(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821EFBF8: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821EFBFC: ED29F828  fsubs f9, f9, f31
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EFC00: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821EFC04: ED08F828  fsubs f8, f8, f31
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EFC08: D1A30010  stfs f13, 0x10(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821EFC0C: D1830014  stfs f12, 0x14(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821EFC10: D1630018  stfs f11, 0x18(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821EFC14: D123001C  stfs f9, 0x1c(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821EFC18: D1430020  stfs f10, 0x20(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821EFC1C: D3C30024  stfs f30, 0x24(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821EFC20: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821EFC24: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821EFC28: D1830030  stfs f12, 0x30(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821EFC2C: D1630034  stfs f11, 0x34(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821EFC30: D1230038  stfs f9, 0x38(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821EFC34: D103003C  stfs f8, 0x3c(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821EFC38: D3C30040  stfs f30, 0x40(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821EFC3C: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821EFC40: D1A30048  stfs f13, 0x48(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821EFC44: D183004C  stfs f12, 0x4c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821EFC48: D1630050  stfs f11, 0x50(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EFC4C: 38630054  addi r3, r3, 0x54
	ctx.r[3].s64 = ctx.r[3].s64 + 84;
	// 821EFC50: 4082FF38  bne 0x821efb88
	if !ctx.cr[0].eq {
	pc = 0x821EFB88; continue 'dispatch;
	}
	// 821EFC54: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821EFC58: 612A0003  ori r10, r9, 3
	ctx.r[10].u64 = ctx.r[9].u64 | 3;
	// 821EFC5C: 616B4800  ori r11, r11, 0x4800
	ctx.r[11].u64 = ctx.r[11].u64 | 18432;
	// 821EFC60: 3D201000  lis r9, 0x1000
	ctx.r[9].s64 = 268435456;
	// 821EFC64: 957D0004  stwu r11, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[29].u32 = ea;
	// 821EFC68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EFC6C: 61290002  ori r9, r9, 2
	ctx.r[9].u64 = ctx.r[9].u64 | 2;
	// 821EFC70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821EFC74: 536911BA  rlwimi r9, r27, 2, 6, 0x1d
	ctx.r[9].u64 = (((ctx.r[27].u32).rotate_left(2) as u64) & 0x0000000003FFFFFC) | (ctx.r[9].u64 & 0xFFFFFFFFFC000003);
	// 821EFC78: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821EFC7C: 955D0004  stwu r10, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[29].u32 = ea;
	// 821EFC80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EFC84: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 821EFC88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EFC8C: 61445000  ori r4, r10, 0x5000
	ctx.r[4].u64 = ctx.r[10].u64 | 20480;
	// 821EFC90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EFC94: 953D0004  stwu r9, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[29].u32 = ea;
	// 821EFC98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821EFC9C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821EFCA0: 39202301  li r9, 0x2301
	ctx.r[9].s64 = 8961;
	// 821EFCA4: 615B2000  ori r27, r10, 0x2000
	ctx.r[27].u64 = ctx.r[10].u64 | 8192;
	// 821EFCA8: 574A87BF  rlwinm. r10, r26, 0x10, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821EFCAC: 957D0004  stwu r11, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCB0: 951D0004  stwu r8, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCB4: 94FD0004  stwu r7, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCB8: 94DD0004  stwu r6, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCBC: 949D0004  stwu r4, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[4].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCC0: 94BD0004  stwu r5, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[5].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCC4: 947D0004  stwu r3, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[3].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCC8: 97DD0004  stwu r30, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[30].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCCC: 977D0004  stwu r27, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[27].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCD0: 975D0004  stwu r26, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[26].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCD4: 971D0004  stwu r24, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[24].u32) };
	ctx.r[29].u32 = ea;
	// 821EFCD8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821EFCDC: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 821EFCE0: 4082000C  bne 0x821efcec
	if !ctx.cr[0].eq {
	pc = 0x821EFCEC; continue 'dispatch;
	}
	// 821EFCE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EFCE8: 4800001C  b 0x821efd04
	pc = 0x821EFD04; continue 'dispatch;
	// 821EFCEC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821EFCF0: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 821EFCF4: 409A000C  bne cr6, 0x821efd00
	if !ctx.cr[6].eq {
	pc = 0x821EFD00; continue 'dispatch;
	}
	// 821EFCF8: 614A8001  ori r10, r10, 0x8001
	ctx.r[10].u64 = ctx.r[10].u64 | 32769;
	// 821EFCFC: 48000008  b 0x821efd04
	pc = 0x821EFD04; continue 'dispatch;
	// 821EFD00: 614AC003  ori r10, r10, 0xc003
	ctx.r[10].u64 = ctx.r[10].u64 | 49155;
	// 821EFD04: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD08: 39402200  li r10, 0x2200
	ctx.r[10].s64 = 8704;
	// 821EFD0C: 39202208  li r9, 0x2208
	ctx.r[9].s64 = 8712;
	// 821EFD10: 81010124  lwz r8, 0x124(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 821EFD14: 3CE0C000  lis r7, -0x4000
	ctx.r[7].s64 = -1073741824;
	// 821EFD18: 3CC00003  lis r6, 3
	ctx.r[6].s64 = 196608;
	// 821EFD1C: 60E73601  ori r7, r7, 0x3601
	ctx.r[7].u64 = ctx.r[7].u64 | 13825;
	// 821EFD20: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD24: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 821EFD28: 7D5C31D6  mullw r10, r28, r6
	ctx.r[10].s64 = (ctx.r[28].s32 as i64) * (ctx.r[6].s32 as i64);
	// 821EFD2C: 96EB0004  stwu r23, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[23].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD30: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD34: 50AA1C3E  rlwimi r10, r5, 3, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[5].u32).rotate_left(3) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 821EFD38: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821EFD3C: 798CCFE6  rldicr r12, r12, 0x39, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(57) & 0xFFFFFFFFFFFFFFFF;
	// 821EFD40: 950B0004  stwu r8, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD44: 94EB0004  stwu r7, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD48: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 821EFD4C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821EFD50: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 821EFD54: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 821EFD58: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 821EFD5C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821EFD60: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821EFD64: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821EFD68: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821EFD6C: 798CC7E6  rldicr r12, r12, 0x38, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(56) & 0xFFFFFFFFFFFFFFFF;
	// 821EFD70: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821EFD74: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821EFD78: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821EFD7C: 798C27E6  rldicr r12, r12, 0x24, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(36) & 0xFFFFFFFFFFFFFFFF;
	// 821EFD80: E97F0020  ld r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 821EFD84: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821EFD88: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821EFD8C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821EFD90: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 821EFD94: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821EFD98: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 821EFD9C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821EFDA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821EFDA4: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821EFDA8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821EFDAC: 48AB9698  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EFDB0 size=76
    let mut pc: u32 = 0x821EFDB0;
    'dispatch: loop {
        match pc {
            0x821EFDB0 => {
    //   block [0x821EFDB0..0x821EFDFC)
	// 821EFDB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821EFDB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EFDB8: 396B57AC  addi r11, r11, 0x57ac
	ctx.r[11].s64 = ctx.r[11].s64 + 22444;
	// 821EFDBC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EFDC0: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EFDC4: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821EFDC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EFDCC: 419A0050  beq cr6, 0x821efe1c
	if ctx.cr[6].eq {
		sub_821EFE1C(ctx, base);
		return;
	}
	// 821EFDD0: 7D694050  subf r11, r9, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821EFDD4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821EFDD8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EFDDC: 40980040  bge cr6, 0x821efe1c
	if !ctx.cr[6].lt {
		sub_821EFE1C(ctx, base);
		return;
	}
	// 821EFDE0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EFDE4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EFDE8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821EFDEC: 419A0010  beq cr6, 0x821efdfc
	if ctx.cr[6].eq {
		sub_821EFDFC(ctx, base);
		return;
	}
	// 821EFDF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EFDF4: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 821EFDF8: 4BFFFFD0  b 0x821efdc8
	pc = 0x821EFDC8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFDFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EFDFC size=32
    let mut pc: u32 = 0x821EFDFC;
    'dispatch: loop {
        match pc {
            0x821EFDFC => {
    //   block [0x821EFDFC..0x821EFE1C)
	// 821EFDFC: 7D694050  subf r11, r9, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821EFE00: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821EFE04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EFE08: 41980008  blt cr6, 0x821efe10
	if ctx.cr[6].lt {
	pc = 0x821EFE10; continue 'dispatch;
	}
	// 821EFE0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821EFE10: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EFE14: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821EFE18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFE1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EFE1C size=8
    let mut pc: u32 = 0x821EFE1C;
    'dispatch: loop {
        match pc {
            0x821EFE1C => {
    //   block [0x821EFE1C..0x821EFE24)
	// 821EFE1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EFE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EFE28 size=28
    let mut pc: u32 = 0x821EFE28;
    'dispatch: loop {
        match pc {
            0x821EFE28 => {
    //   block [0x821EFE28..0x821EFE44)
	// 821EFE28: 89630081  lbz r11, 0x81(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(129 as u32) ) } as u64;
	// 821EFE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EFE30: 419A0014  beq cr6, 0x821efe44
	if ctx.cr[6].eq {
		sub_821EFE44(ctx, base);
		return;
	}
	// 821EFE34: 39640009  addi r11, r4, 9
	ctx.r[11].s64 = ctx.r[4].s64 + 9;
	// 821EFE38: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EFE3C: 7C2A1C2E  lfsx f1, r10, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EFE40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFE44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EFE44 size=12
    let mut pc: u32 = 0x821EFE44;
    'dispatch: loop {
        match pc {
            0x821EFE44 => {
    //   block [0x821EFE44..0x821EFE50)
	// 821EFE44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EFE48: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EFE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EFE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EFE50 size=492
    let mut pc: u32 = 0x821EFE50;
    'dispatch: loop {
        match pc {
            0x821EFE50 => {
    //   block [0x821EFE50..0x821F003C)
	// 821EFE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EFE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EFE58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EFE5C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821EFE60: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821EFE64: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F0040 size=296
    let mut pc: u32 = 0x821F0040;
    'dispatch: loop {
        match pc {
            0x821F0040 => {
    //   block [0x821F0040..0x821F0168)
	// 821F0040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F0048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F004C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F0050: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821F0054: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0058: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821F005C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821F0060: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F0064: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821F0068: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F006C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821F0070: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0074: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0078: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821F007C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821F0080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0084: 419A00DC  beq cr6, 0x821f0160
	if ctx.cr[6].eq {
	pc = 0x821F0160; continue 'dispatch;
	}
	// 821F0088: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F008C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F0090: 419A00CC  beq cr6, 0x821f015c
	if ctx.cr[6].eq {
	pc = 0x821F015C; continue 'dispatch;
	}
	// 821F0094: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821F0098: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F009C: 419A0018  beq cr6, 0x821f00b4
	if ctx.cr[6].eq {
	pc = 0x821F00B4; continue 'dispatch;
	}
	// 821F00A0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821F00A4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821F00A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F00AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F00B0: 409A0008  bne cr6, 0x821f00b8
	if !ctx.cr[6].eq {
	pc = 0x821F00B8; continue 'dispatch;
	}
	// 821F00B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F00B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F00BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F00C0: 419A007C  beq cr6, 0x821f013c
	if ctx.cr[6].eq {
	pc = 0x821F013C; continue 'dispatch;
	}
	// 821F00C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F00C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F00CC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F00D0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F00D4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821F00D8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821F00DC: 4E800421  bctrl
	ctx.lr = 0x821F00E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F00E0: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F00E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F00E8: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F00EC: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 821F00F0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821F00F4: 4E800421  bctrl
	ctx.lr = 0x821F00F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F00F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821F00FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821F0100: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 821F0104: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 821F0108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F010C: 396490F0  addi r11, r4, -0x6f10
	ctx.r[11].s64 = ctx.r[4].s64 + -28432;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F0168 size=216
    let mut pc: u32 = 0x821F0168;
    'dispatch: loop {
        match pc {
            0x821F0168 => {
    //   block [0x821F0168..0x821F0240)
	// 821F0168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F016C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F0170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F0174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F0178: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F017C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821F0180: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821F0184: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821F0188: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821F018C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0190: 83CA9650  lwz r30, -0x69b0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821F0194: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0198: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821F019C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F01A0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F01A4: 419A000C  beq cr6, 0x821f01b0
	if ctx.cr[6].eq {
	pc = 0x821F01B0; continue 'dispatch;
	}
	// 821F01A8: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821F01AC: 419A0008  beq cr6, 0x821f01b4
	if ctx.cr[6].eq {
	pc = 0x821F01B4; continue 'dispatch;
	}
	// 821F01B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F01B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F01B8: 419A0070  beq cr6, 0x821f0228
	if ctx.cr[6].eq {
	pc = 0x821F0228; continue 'dispatch;
	}
	// 821F01BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F01C0: 409A0008  bne cr6, 0x821f01c8
	if !ctx.cr[6].eq {
	pc = 0x821F01C8; continue 'dispatch;
	}
	// 821F01C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F01C8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F01CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821F01D0: 409A0008  bne cr6, 0x821f01d8
	if !ctx.cr[6].eq {
	pc = 0x821F01D8; continue 'dispatch;
	}
	// 821F01D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F01D8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821F01DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821F01E0: 419A0038  beq cr6, 0x821f0218
	if ctx.cr[6].eq {
	pc = 0x821F0218; continue 'dispatch;
	}
	// 821F01E4: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821F01E8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821F01EC: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821F01F0: 40980028  bge cr6, 0x821f0218
	if !ctx.cr[6].lt {
	pc = 0x821F0218; continue 'dispatch;
	}
	// 821F01F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821F01F8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821F01FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821F0200: 48210FD1  bl 0x824011d0
	ctx.lr = 0x821F0204;
	sub_824011D0(ctx, base);
	// 821F0204: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821F0208: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821F020C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821F0210: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821F0214: 4BFFFF88  b 0x821f019c
	pc = 0x821F019C; continue 'dispatch;
	// 821F0218: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821F021C: 409AFF78  bne cr6, 0x821f0194
	if !ctx.cr[6].eq {
	pc = 0x821F0194; continue 'dispatch;
	}
	// 821F0220: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F0224: 4BFFFF70  b 0x821f0194
	pc = 0x821F0194; continue 'dispatch;
	// 821F0228: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F022C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F0230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F0234: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821F0238: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F023C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F0240 size=176
    let mut pc: u32 = 0x821F0240;
    'dispatch: loop {
        match pc {
            0x821F0240 => {
    //   block [0x821F0240..0x821F02F0)
	// 821F0240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F0248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F024C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F0250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F0258: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821F025C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821F0260: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821F0264: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821F0268: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821F026C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821F0270: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0274: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821F0278: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F027C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F0280: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0284: 4082FFE8  bne 0x821f026c
	if !ctx.cr[0].eq {
	pc = 0x821F026C; continue 'dispatch;
	}
	// 821F0288: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821F028C: 419A0048  beq cr6, 0x821f02d4
	if ctx.cr[6].eq {
	pc = 0x821F02D4; continue 'dispatch;
	}
	// 821F0290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0298: 419A000C  beq cr6, 0x821f02a4
	if ctx.cr[6].eq {
	pc = 0x821F02A4; continue 'dispatch;
	}
	// 821F029C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F02A0: 4BFD64C9  bl 0x821c6768
	ctx.lr = 0x821F02A4;
	sub_821C6768(ctx, base);
	// 821F02A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F02A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F02AC: 419A0028  beq cr6, 0x821f02d4
	if ctx.cr[6].eq {
	pc = 0x821F02D4; continue 'dispatch;
	}
	// 821F02B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821F02B4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821F02B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821F02BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F02C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821F02C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F02C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F02CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F02D0: 4082FFE8  bne 0x821f02b8
	if !ctx.cr[0].eq {
	pc = 0x821F02B8; continue 'dispatch;
	}
	// 821F02D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F02D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821F02DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F02E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F02E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821F02E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F02EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F02F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F02F0 size=412
    let mut pc: u32 = 0x821F02F0;
    'dispatch: loop {
        match pc {
            0x821F02F0 => {
    //   block [0x821F02F0..0x821F048C)
	// 821F02F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F02F4: 48AB9115  bl 0x82ca9408
	ctx.lr = 0x821F02F8;
	sub_82CA93D0(ctx, base);
	// 821F02F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F02FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F0300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821F0304: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821F0308: 419A0178  beq cr6, 0x821f0480
	if ctx.cr[6].eq {
	pc = 0x821F0480; continue 'dispatch;
	}
	// 821F030C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0310: 3BA0000C  li r29, 0xc
	ctx.r[29].s64 = 12;
	// 821F0314: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0318: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F031C: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 821F0320: 7D0BEBD7  divw. r8, r11, r29
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821F0324: 40820038  bne 0x821f035c
	if !ctx.cr[0].eq {
	pc = 0x821F035C; continue 'dispatch;
	}
	// 821F0328: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F032C: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821F0330: 419A0150  beq cr6, 0x821f0480
	if ctx.cr[6].eq {
	pc = 0x821F0480; continue 'dispatch;
	}
	// 821F0334: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821F0338: 487FF859  bl 0x829efb90
	ctx.lr = 0x821F033C;
	sub_829EFB90(ctx, base);
	// 821F033C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821F0340: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F0348: 483766C9  bl 0x82566a10
	ctx.lr = 0x821F034C;
	sub_82566A10(ctx, base);
	// 821F034C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821F0350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F0358: 48AB9100  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821F035C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0360: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 821F0364: 7D4AEBD6  divw r10, r10, r29
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[29].s32;
	// 821F0368: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F036C: 41990050  bgt cr6, 0x821f03bc
	if ctx.cr[6].gt {
	pc = 0x821F03BC; continue 'dispatch;
	}
	// 821F0370: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821F0374: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821F0378: 487FF819  bl 0x829efb90
	ctx.lr = 0x821F037C;
	sub_829EFB90(ctx, base);
	// 821F037C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821F0380: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0384: 4837668D  bl 0x82566a10
	ctx.lr = 0x821F0388;
	sub_82566A10(ctx, base);
	// 821F0388: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F038C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0394: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0398: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821F039C: 7D68EBD6  divw r11, r8, r29
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[29].s32;
	// 821F03A0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821F03A4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821F03A8: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821F03AC: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821F03B0: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821F03B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F03B8: 48AB90A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821F03BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821F03C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F03C4: 409A000C  bne cr6, 0x821f03d0
	if !ctx.cr[6].eq {
	pc = 0x821F03D0; continue 'dispatch;
	}
	// 821F03C8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821F03CC: 48000010  b 0x821f03dc
	pc = 0x821F03DC; continue 'dispatch;
	// 821F03D0: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F03D4: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821F03D8: 7D27EBD6  divw r9, r7, r29
	ctx.r[9].s32 = ctx.r[7].s32 / ctx.r[29].s32;
	// 821F03DC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F03E0: 41990030  bgt cr6, 0x821f0410
	if ctx.cr[6].gt {
	pc = 0x821F0410; continue 'dispatch;
	}
	// 821F03E4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821F03E8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F03EC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821F03F0: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821F03F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821F03F8: 7FAB1A14  add r29, r11, r3
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821F03FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821F0400: 487FF791  bl 0x829efb90
	ctx.lr = 0x821F0404;
	sub_829EFB90(ctx, base);
	// 821F0404: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0408: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821F040C: 48000064  b 0x821f0470
	pc = 0x821F0470; continue 'dispatch;
	// 821F0410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0414: 419A0018  beq cr6, 0x821f042c
	if ctx.cr[6].eq {
	pc = 0x821F042C; continue 'dispatch;
	}
	// 821F0418: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821F041C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821F0420: 483765F1  bl 0x82566a10
	ctx.lr = 0x821F0424;
	sub_82566A10(ctx, base);
	// 821F0424: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0428: 4802B911  bl 0x8221bd38
	ctx.lr = 0x821F042C;
	sub_8221BD38(ctx, base);
	// 821F042C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0430: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0434: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 821F0438: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821F043C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821F0440: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 821F0444: 7C89EBD7  divw. r4, r9, r29
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821F0448: 4082000C  bne 0x821f0454
	if !ctx.cr[0].eq {
	pc = 0x821F0454; continue 'dispatch;
	}
	// 821F044C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821F0450: 4800000C  b 0x821f045c
	pc = 0x821F045C; continue 'dispatch;
	// 821F0454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0458: 488260D1  bl 0x82a16528
	ctx.lr = 0x821F045C;
	sub_82A16528(ctx, base);
	// 821F045C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821F0460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0464: 419A001C  beq cr6, 0x821f0480
	if ctx.cr[6].eq {
	pc = 0x821F0480; continue 'dispatch;
	}
	// 821F0468: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F046C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0470: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821F0474: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F0478: 48377791  bl 0x82567c08
	ctx.lr = 0x821F047C;
	sub_82567C08(ctx, base);
	// 821F047C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821F0480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0484: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F0488: 48AB8FD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F0490 size=24
    let mut pc: u32 = 0x821F0490;
    'dispatch: loop {
        match pc {
            0x821F0490 => {
    //   block [0x821F0490..0x821F04A8)
	// 821F0490: 81432E48  lwz r10, 0x2e48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821F0494: 81632E4C  lwz r11, 0x2e4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11852 as u32) ) } as u64;
	// 821F0498: 508A44EE  rlwimi r10, r4, 8, 0x13, 0x17
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x0000000000001F00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFE0FF);
	// 821F049C: 55690001  rlwinm. r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F04A0: 91432E48  stw r10, 0x2e48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11848 as u32), ctx.r[10].u32 ) };
	// 821F04A4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F04A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F04A8 size=100
    let mut pc: u32 = 0x821F04A8;
    'dispatch: loop {
        match pc {
            0x821F04A8 => {
    //   block [0x821F04A8..0x821F050C)
	// 821F04A8: 556A0043  rlwinm. r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821F04AC: 81632E48  lwz r11, 0x2e48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821F04B0: 40820024  bne 0x821f04d4
	if !ctx.cr[0].eq {
	pc = 0x821F04D4; continue 'dispatch;
	}
	// 821F04B4: 716A1010  andi. r10, r11, 0x1010
	ctx.r[10].u64 = ctx.r[11].u64 & 4112;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821F04B8: 55692336  rlwinm r9, r11, 4, 0xc, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821F04BC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821F04C0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821F04C4: 554A601E  rlwinm r10, r10, 0xc, 0, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 821F04C8: 554A0314  rlwinm r10, r10, 0, 0xc, 0xa
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821F04CC: 554A0104  rlwinm r10, r10, 0, 4, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821F04D0: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821F04D4: 91632938  stw r11, 0x2938(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10552 as u32), ctx.r[11].u32 ) };
	// 821F04D8: 91632958  stw r11, 0x2958(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10584 as u32), ctx.r[11].u32 ) };
	// 821F04DC: 9163295C  stw r11, 0x295c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10588 as u32), ctx.r[11].u32 ) };
	// 821F04E0: 91632960  stw r11, 0x2960(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10592 as u32), ctx.r[11].u32 ) };
	// 821F04E4: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821F04E8: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 821F04EC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821F04F0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 821F04F4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821F04F8: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821F04FC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821F0500: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821F0504: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821F0508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F0510 size=960
    let mut pc: u32 = 0x821F0510;
    'dispatch: loop {
        match pc {
            0x821F0510 => {
    //   block [0x821F0510..0x821F08D0)
	// 821F0510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0514: 48AB8EC5  bl 0x82ca93d8
	ctx.lr = 0x821F0518;
	sub_82CA93D0(ctx, base);
	// 821F0518: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 821F051C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0520: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821F0524: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821F0528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821F052C: 419A0398  beq cr6, 0x821f08c4
	if ctx.cr[6].eq {
	pc = 0x821F08C4; continue 'dispatch;
	}
	// 821F0530: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821F0534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821F0538: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 821F053C: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 821F0540: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 821F0544: 480BD1C5  bl 0x822ad708
	ctx.lr = 0x821F0548;
	sub_822AD708(ctx, base);
	// 821F0548: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821F054C: 82410074  lwz r18, 0x74(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821F0550: 82210078  lwz r17, 0x78(r1)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821F0554: 7D528850  subf r10, r18, r17
	ctx.r[10].s64 = ctx.r[17].s64 - ctx.r[18].s64;
	// 821F0558: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F055C: 41820348  beq 0x821f08a4
	if ctx.cr[0].eq {
	pc = 0x821F08A4; continue 'dispatch;
	}
	// 821F0560: 7D735B78  mr r19, r11
	ctx.r[19].u64 = ctx.r[11].u64;
	// 821F0564: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821F0568: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 821F056C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 821F0570: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821F0574: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821F0578: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821F057C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821F0580: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821F0584: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F0588: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821F058C: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 821F0590: 3AE7FFDF  addi r23, r7, -0x21
	ctx.r[23].s64 = ctx.r[7].s64 + -33;
	// 821F0594: 3B860CA0  addi r28, r6, 0xca0
	ctx.r[28].s64 = ctx.r[6].s64 + 3232;
	// 821F0598: 3BA57088  addi r29, r5, 0x7088
	ctx.r[29].s64 = ctx.r[5].s64 + 28808;
	// 821F059C: 3AA41F54  addi r21, r4, 0x1f54
	ctx.r[21].s64 = ctx.r[4].s64 + 8020;
	// 821F05A0: 3B681DD0  addi r27, r8, 0x1dd0
	ctx.r[27].s64 = ctx.r[8].s64 + 7632;
	// 821F05A4: 3A891818  addi r20, r9, 0x1818
	ctx.r[20].s64 = ctx.r[9].s64 + 6168;
	// 821F05A8: 3ACA0FD4  addi r22, r10, 0xfd4
	ctx.r[22].s64 = ctx.r[10].s64 + 4052;
	// 821F05AC: 3B4B1380  addi r26, r11, 0x1380
	ctx.r[26].s64 = ctx.r[11].s64 + 4992;
	// 821F05B0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 821F05B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F05B8: 4BFFFC89  bl 0x821f0240
	ctx.lr = 0x821F05BC;
	sub_821F0240(ctx, base);
	// 821F05BC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821F05C0: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 821F05C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821F05C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F05CC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821F05D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F05D4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F05D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F05DC: 4082FFE8  bne 0x821f05c4
	if !ctx.cr[0].eq {
	pc = 0x821F05C4; continue 'dispatch;
	}
	// 821F05E0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821F05E4: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 821F05E8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 821F05EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F05F0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 821F05F4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821F05F8: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F05FC: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0600: 4082FFE8  bne 0x821f05e8
	if !ctx.cr[0].eq {
	pc = 0x821F05E8; continue 'dispatch;
	}
	// 821F0604: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821F0608: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 821F060C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F0610: 48074F31  bl 0x82265540
	ctx.lr = 0x821F0614;
	sub_82265540(ctx, base);
	// 821F0614: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821F0618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F061C: 409A0038  bne cr6, 0x821f0654
	if !ctx.cr[6].eq {
	pc = 0x821F0654; continue 'dispatch;
	}
	// 821F0620: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821F0624: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821F0628: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F062C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0630: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F0634: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821F0638: 419A0014  beq cr6, 0x821f064c
	if ctx.cr[6].eq {
	pc = 0x821F064C; continue 'dispatch;
	}
	// 821F063C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F0640: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F0644: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F0648: 419AFFE0  beq cr6, 0x821f0628
	if ctx.cr[6].eq {
	pc = 0x821F0628; continue 'dispatch;
	}
	// 821F064C: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821F0650: 48000014  b 0x821f0664
	pc = 0x821F0664; continue 'dispatch;
	// 821F0654: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821F0658: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F065C: 4807D19D  bl 0x8226d7f8
	ctx.lr = 0x821F0660;
	sub_8226D7F8(ctx, base);
	// 821F0660: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821F0664: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821F0668: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821F066C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F0670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0674: 419A0074  beq cr6, 0x821f06e8
	if ctx.cr[6].eq {
	pc = 0x821F06E8; continue 'dispatch;
	}
	// 821F0678: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821F067C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821F0680: 4803C851  bl 0x8222ced0
	ctx.lr = 0x821F0684;
	sub_8222CED0(ctx, base);
	// 821F0684: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821F0688: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821F068C: 4BFFC16D  bl 0x821ec7f8
	ctx.lr = 0x821F0690;
	sub_821EC7F8(ctx, base);
	// 821F0690: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821F0694: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821F0698: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F069C: 48493E25  bl 0x826844c0
	ctx.lr = 0x821F06A0;
	sub_826844C0(ctx, base);
	// 821F06A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F06A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821F06A8: 48024731  bl 0x82214dd8
	ctx.lr = 0x821F06AC;
	sub_82214DD8(ctx, base);
	// 821F06AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F06B0: 419A016C  beq cr6, 0x821f081c
	if ctx.cr[6].eq {
	pc = 0x821F081C; continue 'dispatch;
	}
	// 821F06B4: C0180064  lfs f0, 0x64(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F06B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821F06BC: 4098000C  bge cr6, 0x821f06c8
	if !ctx.cr[6].lt {
	pc = 0x821F06C8; continue 'dispatch;
	}
	// 821F06C0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F06C4: D0180064  stfs f0, 0x64(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821F06C8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F06CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821F06D0: D0180068  stfs f0, 0x68(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821F06D4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821F06D8: C05F0000  lfs f2, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821F06DC: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F06E0: 4BFBA3A9  bl 0x821aaa88
	ctx.lr = 0x821F06E4;
	sub_821AAA88(ctx, base);
	// 821F06E4: 48000138  b 0x821f081c
	pc = 0x821F081C; continue 'dispatch;
	// 821F06E8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821F06EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F06F0: 4803C7E1  bl 0x8222ced0
	ctx.lr = 0x821F06F4;
	sub_8222CED0(ctx, base);
	// 821F06F4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821F06F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F06FC: 409A0010  bne cr6, 0x821f070c
	if !ctx.cr[6].eq {
	pc = 0x821F070C; continue 'dispatch;
	}
	// 821F0700: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821F0704: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821F0708: 4800000C  b 0x821f0714
	pc = 0x821F0714; continue 'dispatch;
	// 821F070C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0710: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0714: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821F0718: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821F071C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F0720: 419A0008  beq cr6, 0x821f0728
	if ctx.cr[6].eq {
	pc = 0x821F0728; continue 'dispatch;
	}
	// 821F0724: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0728: 48AB99C9  bl 0x82caa0f0
	ctx.lr = 0x821F072C;
	sub_82CAA0F0(ctx, base);
	// 821F072C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821F0730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F0734: 5570DFFE  rlwinm r16, r11, 0x1b, 0x1f, 0x1f
	ctx.r[16].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821F0738: 480246A1  bl 0x82214dd8
	ctx.lr = 0x821F073C;
	sub_82214DD8(ctx, base);
	// 821F073C: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 821F0740: 419A003C  beq cr6, 0x821f077c
	if ctx.cr[6].eq {
	pc = 0x821F077C; continue 'dispatch;
	}
	// 821F0744: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F0748: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 821F074C: 419A0008  beq cr6, 0x821f0754
	if ctx.cr[6].eq {
	pc = 0x821F0754; continue 'dispatch;
	}
	// 821F0750: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0754: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821F0758: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821F075C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 821F0760: 4BFF3631  bl 0x821e3d90
	ctx.lr = 0x821F0764;
	sub_821E3D90(ctx, base);
	// 821F0764: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 821F0768: 38780044  addi r3, r24, 0x44
	ctx.r[3].s64 = ctx.r[24].s64 + 68;
	// 821F076C: 48074A35  bl 0x822651a0
	ctx.lr = 0x821F0770;
	sub_822651A0(ctx, base);
	// 821F0770: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 821F0774: 48024665  bl 0x82214dd8
	ctx.lr = 0x821F0778;
	sub_82214DD8(ctx, base);
	// 821F0778: 480000A4  b 0x821f081c
	pc = 0x821F081C; continue 'dispatch;
	// 821F077C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F0780: 409A0038  bne cr6, 0x821f07b8
	if !ctx.cr[6].eq {
	pc = 0x821F07B8; continue 'dispatch;
	}
	// 821F0784: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821F0788: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821F078C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0790: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0794: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F0798: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821F079C: 419A0014  beq cr6, 0x821f07b0
	if ctx.cr[6].eq {
	pc = 0x821F07B0; continue 'dispatch;
	}
	// 821F07A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F07A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F07A8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F07AC: 419AFFE0  beq cr6, 0x821f078c
	if ctx.cr[6].eq {
	pc = 0x821F078C; continue 'dispatch;
	}
	// 821F07B0: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821F07B4: 48000014  b 0x821f07c8
	pc = 0x821F07C8; continue 'dispatch;
	// 821F07B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821F07BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F07C0: 4807D039  bl 0x8226d7f8
	ctx.lr = 0x821F07C4;
	sub_8226D7F8(ctx, base);
	// 821F07C4: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821F07C8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821F07CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F07D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F07D4: 419A0048  beq cr6, 0x821f081c
	if ctx.cr[6].eq {
	pc = 0x821F081C; continue 'dispatch;
	}
	// 821F07D8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821F07DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821F07E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821F07E4: 4803C6ED  bl 0x8222ced0
	ctx.lr = 0x821F07E8;
	sub_8222CED0(ctx, base);
	// 821F07E8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821F07EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821F07F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821F07F4: 48493CCD  bl 0x826844c0
	ctx.lr = 0x821F07F8;
	sub_826844C0(ctx, base);
	// 821F07F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F07FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821F0800: 480245D9  bl 0x82214dd8
	ctx.lr = 0x821F0804;
	sub_82214DD8(ctx, base);
	// 821F0804: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F0808: 419A0014  beq cr6, 0x821f081c
	if ctx.cr[6].eq {
	pc = 0x821F081C; continue 'dispatch;
	}
	// 821F080C: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F0810: D0180080  stfs f0, 0x80(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821F0814: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F0818: D1B80084  stfs f13, 0x84(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821F081C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821F0820: 4BFD5F49  bl 0x821c6768
	ctx.lr = 0x821F0824;
	sub_821C6768(ctx, base);
	// 821F0824: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821F0828: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821F082C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0830: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821F0834: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F0838: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F083C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0840: 4082FFE8  bne 0x821f0828
	if !ctx.cr[0].eq {
	pc = 0x821F0828; continue 'dispatch;
	}
	// 821F0844: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821F0848: 4BFD5F21  bl 0x821c6768
	ctx.lr = 0x821F084C;
	sub_821C6768(ctx, base);
	// 821F084C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821F0850: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 821F0854: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0858: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 821F085C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821F0860: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F0864: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0868: 4082FFE8  bne 0x821f0850
	if !ctx.cr[0].eq {
	pc = 0x821F0850; continue 'dispatch;
	}
	// 821F086C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F0870: 4BFD5EF9  bl 0x821c6768
	ctx.lr = 0x821F0874;
	sub_821C6768(ctx, base);
	// 821F0874: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821F0878: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 821F087C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0880: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 821F0884: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 821F0888: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F088C: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0890: 4082FFE8  bne 0x821f0878
	if !ctx.cr[0].eq {
	pc = 0x821F0878; continue 'dispatch;
	}
	// 821F0894: 3673FFFF  addic. r19, r19, -1
	ctx.xer.ca = (ctx.r[19].u32 > (!(-1 as u32)));
	ctx.r[19].s64 = ctx.r[19].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 821F0898: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821F089C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 821F08A0: 4082FD10  bne 0x821f05b0
	if !ctx.cr[0].eq {
	pc = 0x821F05B0; continue 'dispatch;
	}
	// 821F08A4: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 821F08A8: 419A001C  beq cr6, 0x821f08c4
	if ctx.cr[6].eq {
	pc = 0x821F08C4; continue 'dispatch;
	}
	// 821F08AC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821F08B0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821F08B4: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 821F08B8: 48376159  bl 0x82566a10
	ctx.lr = 0x821F08BC;
	sub_82566A10(ctx, base);
	// 821F08BC: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 821F08C0: 4802B479  bl 0x8221bd38
	ctx.lr = 0x821F08C4;
	sub_8221BD38(ctx, base);
	// 821F08C4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821F08C8: CBE1FF70  lfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821F08CC: 48AB8B5C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F08D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F08D0 size=244
    let mut pc: u32 = 0x821F08D0;
    'dispatch: loop {
        match pc {
            0x821F08D0 => {
    //   block [0x821F08D0..0x821F09C4)
	// 821F08D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F08D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F08D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F08DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F08E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F08E4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821F08E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F08EC: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821F08F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821F08F4: 892B6BE8  lbz r9, 0x6be8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27624 as u32) ) } as u64;
	// 821F08F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821F08FC: 409A00B0  bne cr6, 0x821f09ac
	if !ctx.cr[6].eq {
	pc = 0x821F09AC; continue 'dispatch;
	}
	// 821F0900: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0908: 419A00A4  beq cr6, 0x821f09ac
	if ctx.cr[6].eq {
	pc = 0x821F09AC; continue 'dispatch;
	}
	// 821F090C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821F0910: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821F0914: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F09C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F09C8 size=136
    let mut pc: u32 = 0x821F09C8;
    'dispatch: loop {
        match pc {
            0x821F09C8 => {
    //   block [0x821F09C8..0x821F0A50)
	// 821F09C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F09CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F09D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F09D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F09D8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F09DC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821F09E0: 1D6924A1  mulli r11, r9, 0x24a1
	ctx.r[11].s64 = ctx.r[9].s64 * 9377;
	// 821F09E4: C80A0F48  lfd f0, 0xf48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3912 as u32) ) };
	// 821F09E8: FC410032  fmul f2, f1, f0
	ctx.f[2].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821F09EC: C8080E10  lfd f0, 0xe10(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3600 as u32) ) };
	// 821F09F0: 38EB24DF  addi r7, r11, 0x24df
	ctx.r[7].s64 = ctx.r[11].s64 + 9439;
	// 821F09F4: 54EB983E  rotlwi r11, r7, 0x13
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 821F09F8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821F09FC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 821F0A00: 40990038  ble cr6, 0x821f0a38
	if !ctx.cr[6].gt {
	pc = 0x821F0A38; continue 'dispatch;
	}
	// 821F0A04: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821F0A08: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821F0A0C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821F0A10: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 821F0A14: 4800FEDD  bl 0x822008f0
	ctx.lr = 0x821F0A18;
	sub_822008F0(ctx, base);
	// 821F0A18: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F0A1C: C80A0CD8  lfd f0, 0xcd8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3288 as u32) ) };
	// 821F0A20: FDA10032  fmul f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821F0A24: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821F0A28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821F0A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F0A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F0A34: 4E800020  blr
	return;
	// 821F0A38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821F0A3C: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F0A40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821F0A44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F0A48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F0A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F0A50 size=832
    let mut pc: u32 = 0x821F0A50;
    'dispatch: loop {
        match pc {
            0x821F0A50 => {
    //   block [0x821F0A50..0x821F0D90)
	// 821F0A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0A54: 48AB89B1  bl 0x82ca9404
	ctx.lr = 0x821F0A58;
	sub_82CA93D0(ctx, base);
	// 821F0A58: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821F0A5C: 48ABD271  bl 0x82cadccc
	ctx.lr = 0x821F0A60;
	sub_82CADCA0(ctx, base);
	// 821F0A60: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0A64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F0A68: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821F0A6C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821F0A70: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821F0A74: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 821F0A78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0A7C: 409A00F8  bne cr6, 0x821f0b74
	if !ctx.cr[6].eq {
	pc = 0x821F0B74; continue 'dispatch;
	}
	// 821F0A80: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 821F0A84: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 821F0A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0A8C: 409900E8  ble cr6, 0x821f0b74
	if !ctx.cr[6].gt {
	pc = 0x821F0B74; continue 'dispatch;
	}
	// 821F0A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F0A94: 4BFBB005  bl 0x821aba98
	ctx.lr = 0x821F0A98;
	sub_821ABA98(ctx, base);
	// 821F0A98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F0A9C: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 821F0AA0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0AA4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821F0AA8: 419A007C  beq cr6, 0x821f0b24
	if ctx.cr[6].eq {
	pc = 0x821F0B24; continue 'dispatch;
	}
	// 821F0AAC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821F0AB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821F0AB4: 419A0040  beq cr6, 0x821f0af4
	if ctx.cr[6].eq {
	pc = 0x821F0AF4; continue 'dispatch;
	}
	// 821F0AB8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821F0ABC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821F0AC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0AC4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821F0AC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F0ACC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F0AD0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0AD4: 4082FFE8  bne 0x821f0abc
	if !ctx.cr[0].eq {
	pc = 0x821F0ABC; continue 'dispatch;
	}
	// 821F0AD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0ADC: 409A0014  bne cr6, 0x821f0af0
	if !ctx.cr[6].eq {
	pc = 0x821F0AF0; continue 'dispatch;
	}
	// 821F0AE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0AE4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0AE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F0AEC: 4E800421  bctrl
	ctx.lr = 0x821F0AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F0AF0: 939F01CC  stw r28, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[28].u32 ) };
	// 821F0AF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0AFC: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 821F0B00: 419A0024  beq cr6, 0x821f0b24
	if ctx.cr[6].eq {
	pc = 0x821F0B24; continue 'dispatch;
	}
	// 821F0B04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821F0B08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821F0B0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0B10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821F0B14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F0B18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F0B1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0B20: 4082FFE8  bne 0x821f0b08
	if !ctx.cr[0].eq {
	pc = 0x821F0B08; continue 'dispatch;
	}
	// 821F0B24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821F0B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F0B2C: 419A0048  beq cr6, 0x821f0b74
	if ctx.cr[6].eq {
	pc = 0x821F0B74; continue 'dispatch;
	}
	// 821F0B30: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821F0B34: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821F0B38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821F0B3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0B40: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821F0B44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821F0B48: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821F0B4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821F0B50: 4082FFE8  bne 0x821f0b38
	if !ctx.cr[0].eq {
	pc = 0x821F0B38; continue 'dispatch;
	}
	// 821F0B54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821F0B58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0B5C: 409A0014  bne cr6, 0x821f0b70
	if !ctx.cr[6].eq {
	pc = 0x821F0B70; continue 'dispatch;
	}
	// 821F0B60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0B64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0B68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F0B6C: 4E800421  bctrl
	ctx.lr = 0x821F0B70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F0B70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821F0B74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821F0B78: C81F01B0  lfd f0, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	// 821F0B7C: FDBF0028  fsub f13, f31, f0
	ctx.f[13].f64 = ctx.f[31].f64 - ctx.f[0].f64;
	// 821F0B80: DBFF01B0  stfd f31, 0x1b0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.f[31].u64 ) };
	// 821F0B84: 3BCBD5C8  addi r30, r11, -0x2a38
	ctx.r[30].s64 = ctx.r[11].s64 + -10808;
	// 821F0B88: C19F01BC  lfs f12, 0x1bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821F0B8C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821F0B90: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 821F0B94: 389F01B8  addi r4, r31, 0x1b8
	ctx.r[4].s64 = ctx.r[31].s64 + 440;
	// 821F0B98: C39F00E8  lfs f28, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821F0B9C: C37F00E0  lfs f27, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821F0BA0: 3BBF01BC  addi r29, r31, 0x1bc
	ctx.r[29].s64 = ctx.r[31].s64 + 444;
	// 821F0BA4: C3BF00E4  lfs f29, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821F0BA8: C3FEBEBC  lfs f31, -0x4144(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821F0BAC: D3FF01C8  stfs f31, 0x1c8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 821F0BB0: C80B9630  lfd f0, -0x69d0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27088 as u32) ) };
	// 821F0BB4: C3DEDEB8  lfs f30, -0x2148(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8520 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821F0BB8: FD4D0032  fmul f10, f13, f0
	ctx.f[10].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 821F0BBC: C01EBEC8  lfs f0, -0x4138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F0BC0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821F0BC4: EF4B0028  fsubs f26, f11, f0
	ctx.f[26].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821F0BC8: FF205018  frsp f25, f10
	ctx.f[25].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821F0BCC: 4BFFFDFD  bl 0x821f09c8
	ctx.lr = 0x821F0BD0;
	sub_821F09C8(ctx, base);
	// 821F0BD0: ED21D02A  fadds f9, f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 821F0BD4: C11F01BC  lfs f8, 0x1bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821F0BD8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821F0BDC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F0BE0: 396B0E68  addi r11, r11, 0xe68
	ctx.r[11].s64 = ctx.r[11].s64 + 3688;
	// 821F0BE4: C01EBEC8  lfs f0, -0x4138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F0BE8: ECE90732  fmuls f7, f9, f28
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[28].f64) as f32) as f64);
	// 821F0BEC: ECC7467A  fmadds f6, f7, f25, f8
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[25].f64 + ctx.f[8].f64) as f32) as f64);
	// 821F0BF0: D0DF01BC  stfs f6, 0x1bc(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 821F0BF4: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 821F0BF8: EC856828  fsubs f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 821F0BFC: FF04F800  fcmpu cr6, f4, f31
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[31].f64);
	// 821F0C00: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821F0C04: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821F0C08: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821F0C0C: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821F0C10: 7C6B3C2E  lfsx f3, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821F0C14: FC43696E  fsel f2, f3, f5, f13
	ctx.f[2].f64 = if ctx.f[3].f64 >= 0.0 { ctx.f[5].f64 } else { ctx.f[13].f64 };
	// 821F0C18: EC220028  fsubs f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 821F0C1C: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821F0C20: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821F0C24: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821F0C28: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 821F0C2C: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821F0C30: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F0C34: FD8D102E  fsel f12, f13, f0, f2
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[2].f64 };
	// 821F0C38: D19F01BC  stfs f12, 0x1bc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 821F0C3C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821F0C40: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 821F0C44: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821F0C48: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 821F0C4C: ED6D06FA  fmadds f11, f13, f27, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 821F0C50: D17F01C0  stfs f11, 0x1c0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 821F0C54: 419A0030  beq cr6, 0x821f0c84
	if ctx.cr[6].eq {
	pc = 0x821F0C84; continue 'dispatch;
	}
	// 821F0C58: 895F0150  lbz r10, 0x150(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 821F0C5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F0C60: 419A0014  beq cr6, 0x821f0c74
	if ctx.cr[6].eq {
	pc = 0x821F0C74; continue 'dispatch;
	}
	// 821F0C64: 895F0152  lbz r10, 0x152(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(338 as u32) ) } as u64;
	// 821F0C68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F0C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F0C70: 419A0008  beq cr6, 0x821f0c78
	if ctx.cr[6].eq {
	pc = 0x821F0C78; continue 'dispatch;
	}
	// 821F0C74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821F0C78: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821F0C7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F0C80: 409A000C  bne cr6, 0x821f0c8c
	if !ctx.cr[6].eq {
	pc = 0x821F0C8C; continue 'dispatch;
	}
	// 821F0C84: EDAD077A  fmadds f13, f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 821F0C88: D1BF01C4  stfs f13, 0x1c4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 821F0C8C: C1BF01C0  lfs f13, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F0C90: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821F0C94: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821F0C98: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821F0C9C: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821F0CA0: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821F0CA4: 7D8B3C2E  lfsx f12, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821F0CA8: FD6CFB6E  fsel f11, f12, f13, f31
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[31].f64 };
	// 821F0CAC: ED4BF028  fsubs f10, f11, f30
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[30].f64) as f32) as f64);
	// 821F0CB0: FF0AF800  fcmpu cr6, f10, f31
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[31].f64);
	// 821F0CB4: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821F0CB8: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821F0CBC: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 821F0CC0: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821F0CC4: 7D2B1C2E  lfsx f9, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821F0CC8: FD095FAE  fsel f8, f9, f30, f11
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[11].f64 };
	// 821F0CCC: D11F01C0  stfs f8, 0x1c0(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 821F0CD0: C17F014C  lfs f11, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821F0CD4: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 821F0CD8: C19F0148  lfs f12, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821F0CDC: 409900A4  ble cr6, 0x821f0d80
	if !ctx.cr[6].gt {
	pc = 0x821F0D80; continue 'dispatch;
	}
	// 821F0CE0: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 821F0CE4: C1BEE840  lfs f13, -0x17c0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6080 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F0CE8: 39200120  li r9, 0x120
	ctx.r[9].s64 = 288;
	// 821F0CEC: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821F0CF0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821F0CF4: FD204090  fmr f9, f8
	ctx.f[9].f64 = ctx.f[8].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F0D90 size=8
    let mut pc: u32 = 0x821F0D90;
    'dispatch: loop {
        match pc {
            0x821F0D90 => {
    //   block [0x821F0D90..0x821F0D98)
	// 821F0D90: 88630006  lbz r3, 6(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 821F0D94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F0D98 size=92
    let mut pc: u32 = 0x821F0D98;
    'dispatch: loop {
        match pc {
            0x821F0D98 => {
    //   block [0x821F0D98..0x821F0DF4)
	// 821F0D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F0DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F0DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F0DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0DAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821F0DB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F0DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F0DBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F0DC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F0DC4: 4E800421  bctrl
	ctx.lr = 0x821F0DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F0DC8: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 821F0DCC: 409A0010  bne cr6, 0x821f0ddc
	if !ctx.cr[6].eq {
	pc = 0x821F0DDC; continue 'dispatch;
	}
	// 821F0DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821F0DD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821F0DD8: 486AD769  bl 0x8289e540
	ctx.lr = 0x821F0DDC;
	sub_8289E540(ctx, base);
	// 821F0DDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821F0DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F0DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F0DE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821F0DEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F0DF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F0DF8 size=8
    let mut pc: u32 = 0x821F0DF8;
    'dispatch: loop {
        match pc {
            0x821F0DF8 => {
    //   block [0x821F0DF8..0x821F0E00)
	// 821F0DF8: 38630D54  addi r3, r3, 0xd54
	ctx.r[3].s64 = ctx.r[3].s64 + 3412;
	// 821F0DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F0E00 size=1384
    let mut pc: u32 = 0x821F0E00;
    'dispatch: loop {
        match pc {
            0x821F0E00 => {
    //   block [0x821F0E00..0x821F1368)
	// 821F0E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F0E04: 48AB85CD  bl 0x82ca93d0
	ctx.lr = 0x821F0E08;
	sub_82CA93D0(ctx, base);
	// 821F0E08: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821F0E0C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F0E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F0E14: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821F0E18: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821F0E1C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821F0E20: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821F0E24: 9321015C  stw r25, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[25].u32 ) };
	// 821F0E28: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821F0E2C: 93410164  stw r26, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[26].u32 ) };
	// 821F0E30: 3B600005  li r27, 5
	ctx.r[27].s64 = 5;
	// 821F0E34: 81FF2880  lwz r15, 0x2880(r31)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10368 as u32) ) } as u64;
	// 821F0E38: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821F0E3C: 9301016C  stw r24, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[24].u32 ) };
	// 821F0E40: 92E10174  stw r23, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[23].u32 ) };
	// 821F0E44: 7D505378  mr r16, r10
	ctx.r[16].u64 = ctx.r[10].u64;
	// 821F0E48: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821F0E4C: 7F6EDB78  mr r14, r27
	ctx.r[14].u64 = ctx.r[27].u64;
	// 821F0E50: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 821F0E54: 419A0048  beq cr6, 0x821f0e9c
	if ctx.cr[6].eq {
	pc = 0x821F0E9C; continue 'dispatch;
	}
	// 821F0E58: 39650C26  addi r11, r5, 0xc26
	ctx.r[11].s64 = ctx.r[5].s64 + 3110;
	// 821F0E5C: 3D40000A  lis r10, 0xa
	ctx.r[10].s64 = 655360;
	// 821F0E60: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821F0E64: 39C00004  li r14, 4
	ctx.r[14].s64 = 4;
	// 821F0E68: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821F0E6C: 82AB001C  lwz r21, 0x1c(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821F0E70: 56AB031E  rlwinm r11, r21, 0, 0xc, 0xf
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 821F0E74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F0E78: 409A000C  bne cr6, 0x821f0e84
	if !ctx.cr[6].eq {
	pc = 0x821F0E84; continue 'dispatch;
	}
	// 821F0E7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F0E80: 51758B1E  rlwimi r21, r11, 0x11, 0xc, 0xf
	ctx.r[21].u64 = (((ctx.r[11].u32).rotate_left(17) as u64) & 0x00000000000F0000) | (ctx.r[21].u64 & 0xFFFFFFFFFFF0FFFF);
	// 821F0E84: 56AB031E  rlwinm r11, r21, 0, 0xc, 0xf
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 821F0E88: 3D40000C  lis r10, 0xc
	ctx.r[10].s64 = 786432;
	// 821F0E8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F0E90: 409A000C  bne cr6, 0x821f0e9c
	if !ctx.cr[6].eq {
	pc = 0x821F0E9C; continue 'dispatch;
	}
	// 821F0E94: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821F0E98: 5175831E  rlwimi r21, r11, 0x10, 0xc, 0xf
	ctx.r[21].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000000F0000) | (ctx.r[21].u64 & 0xFFFFFFFFFFF0FFFF);
	// 821F0E9C: 817F2940  lwz r11, 0x2940(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10560 as u32) ) } as u64;
	// 821F0EA0: 578A06F7  rlwinm. r10, r28, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821F0EA4: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821F0EA8: 557E0036  rlwinm r30, r11, 0, 0, 0x1b
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821F0EAC: 4182000C  beq 0x821f0eb8
	if ctx.cr[0].eq {
	pc = 0x821F0EB8; continue 'dispatch;
	}
	// 821F0EB0: 3A800076  li r20, 0x76
	ctx.r[20].s64 = 118;
	// 821F0EB4: 63DE0001  ori r30, r30, 1
	ctx.r[30].u64 = ctx.r[30].u64 | 1;
	// 821F0EB8: 578B06B5  rlwinm. r11, r28, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0EBC: 41820070  beq 0x821f0f2c
	if ctx.cr[0].eq {
	pc = 0x821F0F2C; continue 'dispatch;
	}
	// 821F0EC0: 83A1018C  lwz r29, 0x18c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 821F0EC4: 578B0673  rlwinm. r11, r28, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0EC8: 62948701  ori r20, r20, 0x8701
	ctx.r[20].u64 = ctx.r[20].u64 | 34561;
	// 821F0ECC: 63DE0004  ori r30, r30, 4
	ctx.r[30].u64 = ctx.r[30].u64 | 4;
	// 821F0ED0: 41820010  beq 0x821f0ee0
	if ctx.cr[0].eq {
	pc = 0x821F0EE0; continue 'dispatch;
	}
	// 821F0ED4: 53BE442E  rlwimi r30, r29, 8, 0x10, 0x17
	ctx.r[30].u64 = (((ctx.r[29].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[30].u64 & 0xFFFFFFFFFFFF00FF);
	// 821F0ED8: 57DE06F2  rlwinm r30, r30, 0, 0x1b, 0x19
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821F0EDC: 48000014  b 0x821f0ef0
	pc = 0x821F0EF0; continue 'dispatch;
	// 821F0EE0: 578B0631  rlwinm. r11, r28, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0EE4: 4182000C  beq 0x821f0ef0
	if ctx.cr[0].eq {
	pc = 0x821F0EF0; continue 'dispatch;
	}
	// 821F0EE8: 53BE442E  rlwimi r30, r29, 8, 0x10, 0x17
	ctx.r[30].u64 = (((ctx.r[29].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[30].u64 & 0xFFFFFFFFFFFF00FF);
	// 821F0EEC: 63DE0020  ori r30, r30, 0x20
	ctx.r[30].u64 = ctx.r[30].u64 | 32;
	// 821F0EF0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821F0EF4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F0EF8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F0EFC: 4099000C  ble cr6, 0x821f0f08
	if !ctx.cr[6].gt {
	pc = 0x821F0F08; continue 'dispatch;
	}
	// 821F0F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0F04: 4BFF7FBD  bl 0x821e8ec0
	ctx.lr = 0x821F0F08;
	sub_821E8EC0(ctx, base);
	// 821F0F08: 3960210D  li r11, 0x210d
	ctx.r[11].s64 = 8461;
	// 821F0F0C: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 821F0F10: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821F0F14: 515D802E  rlwimi r29, r10, 0x10, 0, 0x17
	ctx.r[29].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFFFF00) | (ctx.r[29].u64 & 0xFFFFFFFF000000FF);
	// 821F0F18: 97A30004  stwu r29, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[29].u32) };
	ctx.r[3].u32 = ea;
	// 821F0F1C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821F0F20: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821F0F24: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 821F0F28: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821F0F2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821F0F30: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 821F0F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0F38: 48024579  bl 0x822154b0
	ctx.lr = 0x821F0F3C;
	sub_822154B0(ctx, base);
	// 821F0F3C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F0F40: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821F0F44: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F0F48: 4099000C  ble cr6, 0x821f0f54
	if !ctx.cr[6].gt {
	pc = 0x821F0F54; continue 'dispatch;
	}
	// 821F0F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F0F50: 4BFF7F71  bl 0x821e8ec0
	ctx.lr = 0x821F0F54;
	sub_821E8EC0(ctx, base);
	// 821F0F54: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 821F0F58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821F0F5C: 616B2080  ori r11, r11, 0x2080
	ctx.r[11].u64 = ctx.r[11].u64 | 8320;
	// 821F0F60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821F0F64: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821F0F68: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 821F0F6C: 579C06B7  rlwinm. r28, r28, 0, 0x1a, 0x1b
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821F0F70: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821F0F74: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	// 821F0F78: 7E91A378  mr r17, r20
	ctx.r[17].u64 = ctx.r[20].u64;
	// 821F0F7C: 7DD27378  mr r18, r14
	ctx.r[18].u64 = ctx.r[14].u64;
	// 821F0F80: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821F0F84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821F0F88: 957D0004  stwu r11, 4(r29)
	ea = ctx.r[29].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[29].u32 = ea;
	// 821F0F8C: 40820108  bne 0x821f1094
	if !ctx.cr[0].eq {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0F90: 56A3873E  rlwinm r3, r21, 0x10, 0x1c, 0x1f
	ctx.r[3].u64 = ctx.r[21].u32 as u64 & 0x0000FFFFu64;
	// 821F0F94: 2B030005  cmplwi cr6, r3, 5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 5 as u32, &mut ctx.xer);
	// 821F0F98: 419A00FC  beq cr6, 0x821f1094
	if ctx.cr[6].eq {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0F9C: 2B030007  cmplwi cr6, r3, 7
	ctx.cr[6].compare_u32(ctx.r[3].u32, 7 as u32, &mut ctx.xer);
	// 821F0FA0: 419A00F4  beq cr6, 0x821f1094
	if ctx.cr[6].eq {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0FA4: 2B03000F  cmplwi cr6, r3, 0xf
	ctx.cr[6].compare_u32(ctx.r[3].u32, 15 as u32, &mut ctx.xer);
	// 821F0FA8: 419A00EC  beq cr6, 0x821f1094
	if ctx.cr[6].eq {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0FAC: 55EB87BF  rlwinm. r11, r15, 0x10, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F0FB0: 40820010  bne 0x821f0fc0
	if !ctx.cr[0].eq {
	pc = 0x821F0FC0; continue 'dispatch;
	}
	// 821F0FB4: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 821F0FB8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821F0FBC: 48000018  b 0x821f0fd4
	pc = 0x821F0FD4; continue 'dispatch;
	// 821F0FC0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821F0FC4: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 821F0FC8: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 821F0FCC: 419A0008  beq cr6, 0x821f0fd4
	if ctx.cr[6].eq {
	pc = 0x821F0FD4; continue 'dispatch;
	}
	// 821F0FD0: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 821F0FD4: 7D39C050  subf r9, r25, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 821F0FD8: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821F0FDC: 419800B8  blt cr6, 0x821f1094
	if ctx.cr[6].lt {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0FE0: 7D7AB850  subf r11, r26, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[26].s64;
	// 821F0FE4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821F0FE8: 419800AC  blt cr6, 0x821f1094
	if ctx.cr[6].lt {
	pc = 0x821F1094; continue 'dispatch;
	}
	// 821F0FEC: 38C10088  addi r6, r1, 0x88
	ctx.r[6].s64 = ctx.r[1].s64 + 136;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F1368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F1368 size=20
    let mut pc: u32 = 0x821F1368;
    'dispatch: loop {
        match pc {
            0x821F1368 => {
    //   block [0x821F1368..0x821F137C)
	// 821F1368: 816301DC  lwz r11, 0x1dc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(476 as u32) ) } as u64;
	// 821F136C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F1370: 409A000C  bne cr6, 0x821f137c
	if !ctx.cr[6].eq {
		sub_821F137C(ctx, base);
		return;
	}
	// 821F1374: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821F1378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F137C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F137C size=4
    let mut pc: u32 = 0x821F137C;
    'dispatch: loop {
        match pc {
            0x821F137C => {
    //   block [0x821F137C..0x821F1380)
	// 821F137C: 48CBFA6C  b 0x82eb0de8
	sub_82EB0DE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F1380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F1380 size=348
    let mut pc: u32 = 0x821F1380;
    'dispatch: loop {
        match pc {
            0x821F1380 => {
    //   block [0x821F1380..0x821F14DC)
	// 821F1380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F1384: 48AB8081  bl 0x82ca9404
	ctx.lr = 0x821F1388;
	sub_82CA93D0(ctx, base);
	// 821F1388: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F138C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F1390: 39440004  addi r10, r4, 4
	ctx.r[10].s64 = ctx.r[4].s64 + 4;
	// 821F1394: 555D003A  rlwinm r29, r10, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1398: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F139C: 5569F87E  srwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821F13A0: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F13A4: 40990130  ble cr6, 0x821f14d4
	if !ctx.cr[6].gt {
	pc = 0x821F14D4; continue 'dispatch;
	}
	// 821F13A8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821F13AC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821F13B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F13B4: 419A00B8  beq cr6, 0x821f146c
	if ctx.cr[6].eq {
	pc = 0x821F146C; continue 'dispatch;
	}
	// 821F13B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821F13BC: 409A000C  bne cr6, 0x821f13c8
	if !ctx.cr[6].eq {
	pc = 0x821F13C8; continue 'dispatch;
	}
	// 821F13C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821F13C4: 480000A8  b 0x821f146c
	pc = 0x821F146C; continue 'dispatch;
	// 821F13C8: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821F13CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F13D0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F13D4: 4082000C  bne 0x821f13e0
	if !ctx.cr[0].eq {
	pc = 0x821F13E0; continue 'dispatch;
	}
	// 821F13D8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821F13DC: 4800008C  b 0x821f1468
	pc = 0x821F1468; continue 'dispatch;
	// 821F13E0: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 821F13E4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F13E8: 4198000C  blt cr6, 0x821f13f4
	if ctx.cr[6].lt {
	pc = 0x821F13F4; continue 'dispatch;
	}
	// 821F13EC: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821F13F0: 48000078  b 0x821f1468
	pc = 0x821F1468; continue 'dispatch;
	// 821F13F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F13F8: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821F13FC: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821F1400: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821F1404: 54E906F6  rlwinm r9, r7, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1408: 38C90008  addi r6, r9, 8
	ctx.r[6].s64 = ctx.r[9].s64 + 8;
	// 821F140C: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821F1410: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821F1414: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821F1418: 54680738  rlwinm r8, r3, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821F141C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821F1420: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 821F1424: 7D474030  slw r7, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 821F1428: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821F142C: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821F1430: 54A8077A  rlwinm r8, r5, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1434: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821F1438: 38890002  addi r4, r9, 2
	ctx.r[4].s64 = ctx.r[9].s64 + 2;
	// 821F143C: 7D432030  slw r3, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 821F1440: 7D0B1850  subf r8, r11, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821F1444: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821F1448: 54E807BC  rlwinm r8, r7, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821F144C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821F1450: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821F1454: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821F1458: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821F145C: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821F1460: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 821F1464: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821F1468: 7D5D5830  slw r29, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[29].u64 = 0;
	} else {
		ctx.r[29].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 821F146C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821F1470: 4802DDE9  bl 0x8221f258
	ctx.lr = 0x821F1474;
	sub_8221F258(ctx, base);
	// 821F1474: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F1478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F147C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F1480: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821F1484: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 821F1488: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821F148C: 5549003A  rlwinm r9, r10, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1490: 7CAB4850  subf r5, r11, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821F1494: 48AB851D  bl 0x82ca99b0
	ctx.lr = 0x821F1498;
	sub_82CA99B0(ctx, base);
	// 821F1498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F149C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F14A0: 837E0004  lwz r27, 4(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F14A4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821F14A8: 48016FF1  bl 0x82208498
	ctx.lr = 0x821F14AC;
	sub_82208498(ctx, base);
	// 821F14AC: 7F9BF9AE  stbx r28, r27, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[28].u8) };
	// 821F14B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821F14B8: 419A000C  beq cr6, 0x821f14c4
	if ctx.cr[6].eq {
	pc = 0x821F14C4; continue 'dispatch;
	}
	// 821F14BC: 4802A87D  bl 0x8221bd38
	ctx.lr = 0x821F14C0;
	sub_8221BD38(ctx, base);
	// 821F14C0: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821F14C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F14C8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821F14CC: 53AB083C  rlwimi r11, r29, 1, 0, 0x1e
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[11].u64 & 0xFFFFFFFF00000001);
	// 821F14D0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821F14D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F14D8: 48AB7F7C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F14E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F14E0 size=464
    let mut pc: u32 = 0x821F14E0;
    'dispatch: loop {
        match pc {
            0x821F14E0 => {
    //   block [0x821F14E0..0x821F16B0)
	// 821F14E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F14E4: 48AB7F29  bl 0x82ca940c
	ctx.lr = 0x821F14E8;
	sub_82CA93D0(ctx, base);
	// 821F14E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F14EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821F14F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821F14F4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F14F8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F14FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821F1500: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1504: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 821F1508: 4198019C  blt cr6, 0x821f16a4
	if ctx.cr[6].lt {
	pc = 0x821F16A4; continue 'dispatch;
	}
	// 821F150C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821F1510: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821F1514: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 821F1518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821F151C: 48036AAD  bl 0x82227fc8
	ctx.lr = 0x821F1520;
	sub_82227FC8(ctx, base);
	// 821F1520: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821F1524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F1528: 419A017C  beq cr6, 0x821f16a4
	if ctx.cr[6].eq {
	pc = 0x821F16A4; continue 'dispatch;
	}
	// 821F152C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821F1530: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821F1534: 48036BC5  bl 0x822280f8
	ctx.lr = 0x821F1538;
	sub_822280F8(ctx, base);
	// 821F1538: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F153C: 48036025  bl 0x82227560
	ctx.lr = 0x821F1540;
	sub_82227560(ctx, base);
	// 821F1540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F1544: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821F1548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821F154C: 4BFEEE3D  bl 0x821e0388
	ctx.lr = 0x821F1550;
	sub_821E0388(ctx, base);
	// 821F1550: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821F1554: 419A0018  beq cr6, 0x821f156c
	if ctx.cr[6].eq {
	pc = 0x821F156C; continue 'dispatch;
	}
	// 821F1558: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821F155C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821F1560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F1564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F1568: 409A0008  bne cr6, 0x821f1570
	if !ctx.cr[6].eq {
	pc = 0x821F1570; continue 'dispatch;
	}
	// 821F156C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F1570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F1574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F1578: 419A012C  beq cr6, 0x821f16a4
	if ctx.cr[6].eq {
	pc = 0x821F16A4; continue 'dispatch;
	}
	// 821F157C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821F1580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F1584: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821F1588: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821F158C: 419A00EC  beq cr6, 0x821f1678
	if ctx.cr[6].eq {
	pc = 0x821F1678; continue 'dispatch;
	}
	// 821F1590: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821F1594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F1598: 419A0020  beq cr6, 0x821f15b8
	if ctx.cr[6].eq {
	pc = 0x821F15B8; continue 'dispatch;
	}
	// 821F159C: 894B0047  lbz r10, 0x47(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 821F15A0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F15A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821F15A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821F15AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F15B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F15B4: 480000C8  b 0x821f167c
	pc = 0x821F167C; continue 'dispatch;
	// 821F15B8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F15BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F15C0: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821F15C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821F15C8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821F15CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F15D0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F15D4: 40810054  ble 0x821f1628
	if !ctx.cr[0].gt {
	pc = 0x821F1628; continue 'dispatch;
	}
	// 821F15D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821F15DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F15E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821F15E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F15E8: 2F070047  cmpwi cr6, r7, 0x47
	ctx.cr[6].compare_i32(ctx.r[7].s32, 71, &mut ctx.xer);
	// 821F15EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821F15F0: 41980008  blt cr6, 0x821f15f8
	if ctx.cr[6].lt {
	pc = 0x821F15F8; continue 'dispatch;
	}
	// 821F15F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821F15F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821F15FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F1600: 419A0014  beq cr6, 0x821f1614
	if ctx.cr[6].eq {
	pc = 0x821F1614; continue 'dispatch;
	}
	// 821F1604: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821F1608: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821F160C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F1610: 4800000C  b 0x821f161c
	pc = 0x821F161C; continue 'dispatch;
	// 821F1614: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821F1618: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821F161C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F1620: 4199FFB8  bgt cr6, 0x821f15d8
	if ctx.cr[6].gt {
	pc = 0x821F15D8; continue 'dispatch;
	}
	// 821F1624: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F1628: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821F162C: 419A003C  beq cr6, 0x821f1668
	if ctx.cr[6].eq {
	pc = 0x821F1668; continue 'dispatch;
	}
	// 821F1630: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F1634: 2F0B0047  cmpwi cr6, r11, 0x47
	ctx.cr[6].compare_i32(ctx.r[11].s32, 71, &mut ctx.xer);
	// 821F1638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F163C: 41990008  bgt cr6, 0x821f1644
	if ctx.cr[6].gt {
	pc = 0x821F1644; continue 'dispatch;
	}
	// 821F1640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F1644: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F1648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F164C: 409A001C  bne cr6, 0x821f1668
	if !ctx.cr[6].eq {
	pc = 0x821F1668; continue 'dispatch;
	}
	// 821F1650: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821F1654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F1658: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821F165C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821F1660: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F1664: 48000018  b 0x821f167c
	pc = 0x821F167C; continue 'dispatch;
	// 821F1668: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821F166C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F1670: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F1674: 48000008  b 0x821f167c
	pc = 0x821F167C; continue 'dispatch;
	// 821F1678: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821F167C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821F1680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F1684: 419A0020  beq cr6, 0x821f16a4
	if ctx.cr[6].eq {
	pc = 0x821F16A4; continue 'dispatch;
	}
	// 821F1688: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F168C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821F1690: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821F1694: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F1698: 4E800421  bctrl
	ctx.lr = 0x821F169C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F169C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F16A0: 48AB7DBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821F16A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821F16A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F16AC: 48AB7DB0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F16B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F16B0 size=3880
    let mut pc: u32 = 0x821F16B0;
    'dispatch: loop {
        match pc {
            0x821F16B0 => {
    //   block [0x821F16B0..0x821F25D8)
	// 821F16B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F16B4: 48AB7D1D  bl 0x82ca93d0
	ctx.lr = 0x821F16B8;
	sub_82CA93D0(ctx, base);
	// 821F16B8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821F16BC: 48ABC619  bl 0x82cadcd4
	ctx.lr = 0x821F16C0;
	sub_82CADCA0(ctx, base);
	// 821F16C0: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F16C4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821F16C8: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821F16CC: 932101EC  stw r25, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[25].u32 ) };
	// 821F16D0: 8177003C  lwz r11, 0x3c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(60 as u32) ) } as u64;
	// 821F16D4: 82AB0004  lwz r21, 4(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F16D8: 83CB001C  lwz r30, 0x1c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821F16DC: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 821F16E0: 4BF9DAC9  bl 0x8218f1a8
	ctx.lr = 0x821F16E4;
	sub_8218F1A8(ctx, base);
	// 821F16E4: 3F008332  lis r24, -0x7cce
	ctx.r[24].s64 = -2093875200;
	// 821F16E8: 3E808336  lis r20, -0x7cca
	ctx.r[20].s64 = -2093613056;
	// 821F16EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821F16F0: 90788058  stw r3, -0x7fa8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(-32680 as u32), ctx.r[3].u32 ) };
	// 821F16F4: 419A0EB8  beq cr6, 0x821f25ac
	if ctx.cr[6].eq {
	pc = 0x821F25AC; continue 'dispatch;
	}
	// 821F16F8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821F16FC: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821F1700: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821F1704: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 821F1708: 3BAA2390  addi r29, r10, 0x2390
	ctx.r[29].s64 = ctx.r[10].s64 + 9104;
	// 821F170C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821F1710: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821F1714: 891F008D  lbz r8, 0x8d(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(141 as u32) ) } as u64;
	// 821F1718: 3B6A0DB8  addi r27, r10, 0xdb8
	ctx.r[27].s64 = ctx.r[10].s64 + 3512;
	// 821F171C: 81297064  lwz r9, 0x7064(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28772 as u32) ) } as u64;
	// 821F1720: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821F1724: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s64 = ctx.r[8].s64 * 8200;
	// 821F1728: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F172C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821F1730: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F1734: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821F1738: 419A0080  beq cr6, 0x821f17b8
	if ctx.cr[6].eq {
	pc = 0x821F17B8; continue 'dispatch;
	}
	// 821F173C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821F1740: 811F0080  lwz r8, 0x80(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821F1744: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 821F1748: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F174C: 409A003C  bne cr6, 0x821f1788
	if !ctx.cr[6].eq {
	pc = 0x821F1788; continue 'dispatch;
	}
	// 821F1750: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821F1754: 7D0A5378  or r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 821F1758: 38DF0078  addi r6, r31, 0x78
	ctx.r[6].s64 = ctx.r[31].s64 + 120;
	// 821F175C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821F1760: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821F1764: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821F1768: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F176C: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821F1770: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F1774: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821F1778: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821F177C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821F1780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F1784: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821F1788: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821F178C: 913F007C  stw r9, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 821F1790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F1794: 409A0024  bne cr6, 0x821f17b8
	if !ctx.cr[6].eq {
	pc = 0x821F17B8; continue 'dispatch;
	}
	// 821F1798: 817C0DB0  lwz r11, 0xdb0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821F179C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821F17A0: 393F0078  addi r9, r31, 0x78
	ctx.r[9].s64 = ctx.r[31].s64 + 120;
	// 821F17A4: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F17A8: 995F008C  stb r10, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821F17AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F17B0: 917C0DB0  stw r11, 0xdb0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821F17B4: 7D28D92E  stwx r9, r8, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32), ctx.r[9].u32) };
	// 821F17B8: 81770034  lwz r11, 0x34(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(52 as u32) ) } as u64;
	// 821F17BC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821F17C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F17C4: 41980018  blt cr6, 0x821f17dc
	if ctx.cr[6].lt {
	pc = 0x821F17DC; continue 'dispatch;
	}
	// 821F17C8: 815E0058  lwz r10, 0x58(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 821F17CC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821F17D0: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821F17D4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821F17D8: 48000010  b 0x821f17e8
	pc = 0x821F17E8; continue 'dispatch;
	// 821F17DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821F17E0: 814B5760  lwz r10, 0x5760(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22368 as u32) ) } as u64;
	// 821F17E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821F17E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821F17EC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 821F17F0: 39CB9484  addi r14, r11, -0x6b7c
	ctx.r[14].s64 = ctx.r[11].s64 + -27516;
	// 821F17F4: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F17F8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821F17FC: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 821F1800: 39099160  addi r8, r9, -0x6ea0
	ctx.r[8].s64 = ctx.r[9].s64 + -28320;
	// 821F1804: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821F1808: C3AE000C  lfs f29, 0xc(r14)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821F180C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821F1810: D3A10058  stfs f29, 0x58(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821F1814: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F25D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F25D8 size=88
    let mut pc: u32 = 0x821F25D8;
    'dispatch: loop {
        match pc {
            0x821F25D8 => {
    //   block [0x821F25D8..0x821F2630)
	// 821F25D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F25DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F25E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F25E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F25E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F25EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F25F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F25F4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F25F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F25FC: 4E800421  bctrl
	ctx.lr = 0x821F2600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F2600: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821F2604: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821F2608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F2630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F2630 size=84
    let mut pc: u32 = 0x821F2630;
    'dispatch: loop {
        match pc {
            0x821F2630 => {
    //   block [0x821F2630..0x821F2684)
	// 821F2630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F2634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F2638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F263C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F2640: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821F2644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F2648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F264C: 419A0010  beq cr6, 0x821f265c
	if ctx.cr[6].eq {
	pc = 0x821F265C; continue 'dispatch;
	}
	// 821F2650: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821F2654: 48659B6D  bl 0x8284c1c0
	ctx.lr = 0x821F2658;
	sub_8284C1C0(ctx, base);
	// 821F2658: 48000014  b 0x821f266c
	pc = 0x821F266C; continue 'dispatch;
	// 821F265C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2660: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821F2664: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821F2668: 4E800421  bctrl
	ctx.lr = 0x821F266C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F266C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F2670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821F2674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F2678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F267C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F2680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F2688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F2688 size=652
    let mut pc: u32 = 0x821F2688;
    'dispatch: loop {
        match pc {
            0x821F2688 => {
    //   block [0x821F2688..0x821F2914)
	// 821F2688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F268C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F2690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F2694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F2698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F269C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F26A0: 897F0243  lbz r11, 0x243(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(579 as u32) ) } as u64;
	// 821F26A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F26A8: 419A0010  beq cr6, 0x821f26b8
	if ctx.cr[6].eq {
	pc = 0x821F26B8; continue 'dispatch;
	}
	// 821F26AC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821F26B0: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821F26B4: 48000248  b 0x821f28fc
	pc = 0x821F28FC; continue 'dispatch;
	// 821F26B8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F26BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F26C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821F26C4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821F26C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821F26CC: 81260024  lwz r9, 0x24(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821F26D0: C02A0A54  lfs f1, 0xa54(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F26D4: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 821F26D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F26DC: 419A00E8  beq cr6, 0x821f27c4
	if ctx.cr[6].eq {
	pc = 0x821F27C4; continue 'dispatch;
	}
	// 821F26E0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821F26E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F26E8: 419A0020  beq cr6, 0x821f2708
	if ctx.cr[6].eq {
	pc = 0x821F2708; continue 'dispatch;
	}
	// 821F26EC: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821F26F0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F26F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821F26F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821F26FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F2700: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2704: 480000C4  b 0x821f27c8
	pc = 0x821F27C8; continue 'dispatch;
	// 821F2708: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F270C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821F2710: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821F2714: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821F2718: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F271C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F2720: 40810054  ble 0x821f2774
	if !ctx.cr[0].gt {
	pc = 0x821F2774; continue 'dispatch;
	}
	// 821F2724: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821F2728: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F272C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821F2730: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2734: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 821F2738: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821F273C: 41980008  blt cr6, 0x821f2744
	if ctx.cr[6].lt {
	pc = 0x821F2744; continue 'dispatch;
	}
	// 821F2740: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821F2744: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821F2748: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F274C: 419A0014  beq cr6, 0x821f2760
	if ctx.cr[6].eq {
	pc = 0x821F2760; continue 'dispatch;
	}
	// 821F2750: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821F2754: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821F2758: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F275C: 4800000C  b 0x821f2768
	pc = 0x821F2768; continue 'dispatch;
	// 821F2760: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821F2764: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821F2768: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F276C: 4199FFB8  bgt cr6, 0x821f2724
	if ctx.cr[6].gt {
	pc = 0x821F2724; continue 'dispatch;
	}
	// 821F2770: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F2774: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821F2778: 419A003C  beq cr6, 0x821f27b4
	if ctx.cr[6].eq {
	pc = 0x821F27B4; continue 'dispatch;
	}
	// 821F277C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2780: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821F2784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F2788: 41990008  bgt cr6, 0x821f2790
	if ctx.cr[6].gt {
	pc = 0x821F2790; continue 'dispatch;
	}
	// 821F278C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821F2790: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F2794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F2798: 409A001C  bne cr6, 0x821f27b4
	if !ctx.cr[6].eq {
	pc = 0x821F27B4; continue 'dispatch;
	}
	// 821F279C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821F27A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F27A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821F27A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821F27AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F27B0: 48000018  b 0x821f27c8
	pc = 0x821F27C8; continue 'dispatch;
	// 821F27B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821F27B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F27BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F27C0: 48000008  b 0x821f27c8
	pc = 0x821F27C8; continue 'dispatch;
	// 821F27C4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821F27C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821F27CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F27D0: 419A0008  beq cr6, 0x821f27d8
	if ctx.cr[6].eq {
	pc = 0x821F27D8; continue 'dispatch;
	}
	// 821F27D4: C02B00DC  lfs f1, 0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F27D8: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821F27DC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821F27E0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 821F27E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821F27E8: 419A00E4  beq cr6, 0x821f28cc
	if ctx.cr[6].eq {
	pc = 0x821F28CC; continue 'dispatch;
	}
	// 821F27EC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821F27F0: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F27F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F27F8: 419A001C  beq cr6, 0x821f2814
	if ctx.cr[6].eq {
	pc = 0x821F2814; continue 'dispatch;
	}
	// 821F27FC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821F2800: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821F2804: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821F2808: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F280C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F2810: 480000C0  b 0x821f28d0
	pc = 0x821F28D0; continue 'dispatch;
	// 821F2814: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821F2818: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821F281C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821F2820: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F2824: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F2828: 40810054  ble 0x821f287c
	if !ctx.cr[0].gt {
	pc = 0x821F287C; continue 'dispatch;
	}
	// 821F282C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821F2830: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F2834: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821F2838: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F283C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821F2840: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821F2844: 41980008  blt cr6, 0x821f284c
	if ctx.cr[6].lt {
	pc = 0x821F284C; continue 'dispatch;
	}
	// 821F2848: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821F284C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821F2850: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F2854: 419A0014  beq cr6, 0x821f2868
	if ctx.cr[6].eq {
	pc = 0x821F2868; continue 'dispatch;
	}
	// 821F2858: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821F285C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821F2860: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F2864: 4800000C  b 0x821f2870
	pc = 0x821F2870; continue 'dispatch;
	// 821F2868: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821F286C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821F2870: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F2874: 4199FFB8  bgt cr6, 0x821f282c
	if ctx.cr[6].gt {
	pc = 0x821F282C; continue 'dispatch;
	}
	// 821F2878: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821F287C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821F2880: 419A003C  beq cr6, 0x821f28bc
	if ctx.cr[6].eq {
	pc = 0x821F28BC; continue 'dispatch;
	}
	// 821F2884: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2888: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821F288C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F2890: 41990008  bgt cr6, 0x821f2898
	if ctx.cr[6].gt {
	pc = 0x821F2898; continue 'dispatch;
	}
	// 821F2894: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821F2898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F289C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F28A0: 409A001C  bne cr6, 0x821f28bc
	if !ctx.cr[6].eq {
	pc = 0x821F28BC; continue 'dispatch;
	}
	// 821F28A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821F28A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F28AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821F28B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821F28B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F28B8: 48000018  b 0x821f28d0
	pc = 0x821F28D0; continue 'dispatch;
	// 821F28BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821F28C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821F28C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F28C8: 48000008  b 0x821f28d0
	pc = 0x821F28D0; continue 'dispatch;
	// 821F28CC: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821F28D0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821F28D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F28D8: 419A0020  beq cr6, 0x821f28f8
	if ctx.cr[6].eq {
	pc = 0x821F28F8; continue 'dispatch;
	}
	// 821F28DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821F28E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821F28E4: 48021A05  bl 0x822142e8
	ctx.lr = 0x821F28E8;
	sub_822142E8(ctx, base);
	// 821F28E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821F28EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F28F0: 419A0008  beq cr6, 0x821f28f8
	if ctx.cr[6].eq {
	pc = 0x821F28F8; continue 'dispatch;
	}
	// 821F28F4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 821F28F8: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 821F28FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821F2900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821F2904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821F2908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821F290C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F2910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F2918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F2918 size=860
    let mut pc: u32 = 0x821F2918;
    'dispatch: loop {
        match pc {
            0x821F2918 => {
    //   block [0x821F2918..0x821F2C74)
	// 821F2918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F291C: 48AB6AF1  bl 0x82ca940c
	ctx.lr = 0x821F2920;
	sub_82CA93D0(ctx, base);
	// 821F2920: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F2924: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821F2928: C1630000  lfs f11, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821F292C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821F2930: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821F2934: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 821F2938: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821F293C: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821F2940: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 821F2944: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821F2948: D02101C4  stfs f1, 0x1c4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 821F294C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F2950: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F2954: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821F2958: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821F295C: C1A91FFC  lfs f13, 0x1ffc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F2960: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821F2964: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821F2968: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821F296C: ECAA6378  fmsubs f5, f10, f13, f12
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821F2970: D0A10060  stfs f5, 0x60(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F2C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F2C78 size=784
    let mut pc: u32 = 0x821F2C78;
    'dispatch: loop {
        match pc {
            0x821F2C78 => {
    //   block [0x821F2C78..0x821F2F88)
	// 821F2C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F2C7C: 48AB6789  bl 0x82ca9404
	ctx.lr = 0x821F2C80;
	sub_82CA93D0(ctx, base);
	// 821F2C80: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F2C84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821F2C88: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2C8C: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 821F2C90: 3BFD002C  addi r31, r29, 0x2c
	ctx.r[31].s64 = ctx.r[29].s64 + 44;
	// 821F2C94: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F2C98: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821F2C9C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821F2CA0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821F2CA4: 7D69F3D6  divw r11, r9, r30
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[30].s32;
	// 821F2CA8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821F2CAC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821F2CB0: 55052036  slwi r5, r8, 4
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821F2CB4: 480157E5  bl 0x82208498
	ctx.lr = 0x821F2CB8;
	sub_82208498(ctx, base);
	// 821F2CB8: 80DD0098  lwz r6, 0x98(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 821F2CBC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821F2CC0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821F2CC4: 419A0174  beq cr6, 0x821f2e38
	if ctx.cr[6].eq {
	pc = 0x821F2E38; continue 'dispatch;
	}
	// 821F2CC8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2CCC: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 821F2CD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821F2CD4: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821F2CD8: 55286FFE  rlwinm r8, r9, 0xd, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 821F2CDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F2CE0: 419A00F8  beq cr6, 0x821f2dd8
	if ctx.cr[6].eq {
	pc = 0x821F2DD8; continue 'dispatch;
	}
	// 821F2CE4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821F2CE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F2CEC: 419A0024  beq cr6, 0x821f2d10
	if ctx.cr[6].eq {
	pc = 0x821F2D10; continue 'dispatch;
	}
	// 821F2CF0: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 821F2CF4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F2CF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821F2CFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821F2D00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2D04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821F2D08: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821F2D0C: 480000D0  b 0x821f2ddc
	pc = 0x821F2DDC; continue 'dispatch;
	// 821F2D10: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F2D14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821F2D18: 80AB004C  lwz r5, 0x4c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821F2D1C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821F2D20: 7D0A2850  subf r8, r10, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821F2D24: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821F2D28: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F2D2C: 40810054  ble 0x821f2d80
	if !ctx.cr[0].gt {
	pc = 0x821F2D80; continue 'dispatch;
	}
	// 821F2D30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821F2D34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821F2D38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821F2D3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2D40: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821F2D44: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821F2D48: 41980008  blt cr6, 0x821f2d50
	if ctx.cr[6].lt {
	pc = 0x821F2D50; continue 'dispatch;
	}
	// 821F2D4C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821F2D50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821F2D54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F2D58: 419A0014  beq cr6, 0x821f2d6c
	if ctx.cr[6].eq {
	pc = 0x821F2D6C; continue 'dispatch;
	}
	// 821F2D5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821F2D60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821F2D64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F2D68: 4800000C  b 0x821f2d74
	pc = 0x821F2D74; continue 'dispatch;
	// 821F2D6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821F2D70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821F2D74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821F2D78: 4199FFB8  bgt cr6, 0x821f2d30
	if ctx.cr[6].gt {
	pc = 0x821F2D30; continue 'dispatch;
	}
	// 821F2D7C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821F2D80: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821F2D84: 419A0040  beq cr6, 0x821f2dc4
	if ctx.cr[6].eq {
	pc = 0x821F2DC4; continue 'dispatch;
	}
	// 821F2D88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F2D8C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821F2D90: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821F2D94: 41990008  bgt cr6, 0x821f2d9c
	if ctx.cr[6].gt {
	pc = 0x821F2D9C; continue 'dispatch;
	}
	// 821F2D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F2D9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F2DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F2DA4: 409A0020  bne cr6, 0x821f2dc4
	if !ctx.cr[6].eq {
	pc = 0x821F2DC4; continue 'dispatch;
	}
	// 821F2DA8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821F2DAC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821F2DB0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821F2DB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2DB8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821F2DBC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821F2DC0: 4800001C  b 0x821f2ddc
	pc = 0x821F2DDC; continue 'dispatch;
	// 821F2DC4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821F2DC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2DCC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821F2DD0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821F2DD4: 48000008  b 0x821f2ddc
	pc = 0x821F2DDC; continue 'dispatch;
	// 821F2DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F2DDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F2DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F2DE4: 419A0008  beq cr6, 0x821f2dec
	if ctx.cr[6].eq {
	pc = 0x821F2DEC; continue 'dispatch;
	}
	// 821F2DE8: 838A0094  lwz r28, 0x94(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2DEC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2DF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F2DF4: 809D0094  lwz r4, 0x94(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2DF8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 821F2DFC: 7D2AF3D7  divw. r9, r10, r30
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[30].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F2E00: 40820008  bne 0x821f2e08
	if !ctx.cr[0].eq {
	pc = 0x821F2E08; continue 'dispatch;
	}
	// 821F2E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F2E08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821F2E0C: 480CCBAD  bl 0x822bf9b8
	ctx.lr = 0x821F2E10;
	sub_822BF9B8(ctx, base);
	// 821F2E10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2E14: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F2E18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821F2E1C: 7D09F3D7  divw. r8, r9, r30
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[30].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821F2E20: 809D0094  lwz r4, 0x94(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2E24: 40820008  bne 0x821f2e2c
	if !ctx.cr[0].eq {
	pc = 0x821F2E2C; continue 'dispatch;
	}
	// 821F2E28: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821F2E2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821F2E30: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821F2E34: 4BFF2C8D  bl 0x821e5ac0
	ctx.lr = 0x821F2E38;
	sub_821E5AC0(ctx, base);
	// 821F2E38: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F2E3C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821F2E40: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821F2E44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821F2E48: 419A0130  beq cr6, 0x821f2f78
	if ctx.cr[6].eq {
	pc = 0x821F2F78; continue 'dispatch;
	}
	// 821F2E4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821F2E50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821F2E54: 388B37C8  addi r4, r11, 0x37c8
	ctx.r[4].s64 = ctx.r[11].s64 + 14280;
	// 821F2E58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F2E5C: 4803A075  bl 0x8222ced0
	ctx.lr = 0x821F2E60;
	sub_8222CED0(ctx, base);
	// 821F2E60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821F2E64: 807D0094  lwz r3, 0x94(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2E68: 4BFC26A1  bl 0x821b5508
	ctx.lr = 0x821F2E6C;
	sub_821B5508(ctx, base);
	// 821F2E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F2E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F2E74: 48021F65  bl 0x82214dd8
	ctx.lr = 0x821F2E78;
	sub_82214DD8(ctx, base);
	// 821F2E78: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821F2E7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821F2E80: 388A37D8  addi r4, r10, 0x37d8
	ctx.r[4].s64 = ctx.r[10].s64 + 14296;
	// 821F2E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F2E88: 4803A049  bl 0x8222ced0
	ctx.lr = 0x821F2E8C;
	sub_8222CED0(ctx, base);
	// 821F2E8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821F2E90: 807D0094  lwz r3, 0x94(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2E94: 4BFC2675  bl 0x821b5508
	ctx.lr = 0x821F2E98;
	sub_821B5508(ctx, base);
	// 821F2E98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821F2E9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821F2EA0: 48021F39  bl 0x82214dd8
	ctx.lr = 0x821F2EA4;
	sub_82214DD8(ctx, base);
	// 821F2EA4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821F2EA8: 409900D0  ble cr6, 0x821f2f78
	if !ctx.cr[6].gt {
	pc = 0x821F2F78; continue 'dispatch;
	}
	// 821F2EAC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821F2EB0: 409900C8  ble cr6, 0x821f2f78
	if !ctx.cr[6].gt {
	pc = 0x821F2F78; continue 'dispatch;
	}
	// 821F2EB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821F2EB8: 80DD0094  lwz r6, 0x94(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2EBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821F2EC0: 80BD0030  lwz r5, 0x30(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F2EC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F2EC8: 48002BE9  bl 0x821f5ab0
	ctx.lr = 0x821F2ECC;
	sub_821F5AB0(ctx, base);
	// 821F2ECC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821F2ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821F2ED4: 80DD0094  lwz r6, 0x94(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821F2ED8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821F2EDC: 80BD0030  lwz r5, 0x30(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F2EE0: 48002BD1  bl 0x821f5ab0
	ctx.lr = 0x821F2EE4;
	sub_821F5AB0(ctx, base);
	// 821F2EE4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821F2EE8: C1A10078  lfs f13, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821F2EEC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821F2EF0: C18100A8  lfs f12, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821F2EF4: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 821F2EF8: ED4D6028  fsubs f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821F2EFC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 821F2F00: 38E90E68  addi r7, r9, 0xe68
	ctx.r[7].s64 = ctx.r[9].s64 + 3688;
	// 821F2F04: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821F2F08: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F2F0C: 3CA0834C  lis r5, -0x7cb4
	ctx.r[5].s64 = -2092171264;
	// 821F2F10: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821F2F14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821F2F18: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821F2F1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821F2F20: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821F2F24: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821F2F28: C165EAC0  lfs f11, -0x1540(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-5440 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821F2F2C: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 821F2F30: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F2F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F2F88 size=120
    let mut pc: u32 = 0x821F2F88;
    'dispatch: loop {
        match pc {
            0x821F2F88 => {
    //   block [0x821F2F88..0x821F3000)
	// 821F2F88: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821F2F8C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 821F2F90: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821F2F94: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821F2F98: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 821F2F9C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821F2FA0: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821F2FA4: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3000 size=44
    let mut pc: u32 = 0x821F3000;
    'dispatch: loop {
        match pc {
            0x821F3000 => {
    //   block [0x821F3000..0x821F302C)
	// 821F3000: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821F3004: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821F3008: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 821F300C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821F3030 size=392
    let mut pc: u32 = 0x821F3030;
    'dispatch: loop {
        match pc {
            0x821F3030 => {
    //   block [0x821F3030..0x821F31B8)
	// 821F3030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F3034: 48AB63D5  bl 0x82ca9408
	ctx.lr = 0x821F3038;
	sub_82CA93D0(ctx, base);
	// 821F3038: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821F303C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F3040: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821F3044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F3048: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821F304C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821F3050: 419A0018  beq cr6, 0x821f3068
	if ctx.cr[6].eq {
	pc = 0x821F3068; continue 'dispatch;
	}
	// 821F3054: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821F3058: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821F305C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F3060: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F3064: 409A0008  bne cr6, 0x821f306c
	if !ctx.cr[6].eq {
	pc = 0x821F306C; continue 'dispatch;
	}
	// 821F3068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F306C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F3070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F3074: 409A0038  bne cr6, 0x821f30ac
	if !ctx.cr[6].eq {
	pc = 0x821F30AC; continue 'dispatch;
	}
	// 821F3078: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821F307C: C03F004C  lfs f1, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F3080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F3084: 48000245  bl 0x821f32c8
	ctx.lr = 0x821F3088;
	sub_821F32C8(ctx, base);
	// 821F3088: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F308C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F3090: 4099006C  ble cr6, 0x821f30fc
	if !ctx.cr[6].gt {
	pc = 0x821F30FC; continue 'dispatch;
	}
	// 821F3094: D03F004C  stfs f1, 0x4c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821F3098: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821F309C: 5783003E  slwi r3, r28, 0
	ctx.r[3].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821F30A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F30A4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821F30A8: 48AB63B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821F30AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821F30B0: 419A0018  beq cr6, 0x821f30c8
	if ctx.cr[6].eq {
	pc = 0x821F30C8; continue 'dispatch;
	}
	// 821F30B4: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 821F30B8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821F30BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821F30C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F30C4: 409A0008  bne cr6, 0x821f30cc
	if !ctx.cr[6].eq {
	pc = 0x821F30CC; continue 'dispatch;
	}
	// 821F30C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821F30CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821F30D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F30D4: 409A0038  bne cr6, 0x821f310c
	if !ctx.cr[6].eq {
	pc = 0x821F310C; continue 'dispatch;
	}
	// 821F30D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821F30DC: C03F004C  lfs f1, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F30E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F30E4: 480001E5  bl 0x821f32c8
	ctx.lr = 0x821F30E8;
	sub_821F32C8(ctx, base);
	// 821F30E8: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F30EC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F30F0: 4099000C  ble cr6, 0x821f30fc
	if !ctx.cr[6].gt {
	pc = 0x821F30FC; continue 'dispatch;
	}
	// 821F30F4: D03F004C  stfs f1, 0x4c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821F30F8: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 821F30FC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F3100: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F3104: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821F3108: 48AB6350  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821F310C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821F3110: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F3114: 409A000C  bne cr6, 0x821f3120
	if !ctx.cr[6].eq {
	pc = 0x821F3120; continue 'dispatch;
	}
	// 821F3118: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821F311C: 48000010  b 0x821f312c
	pc = 0x821F312C; continue 'dispatch;
	// 821F3120: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F3124: 409A0044  bne cr6, 0x821f3168
	if !ctx.cr[6].eq {
	pc = 0x821F3168; continue 'dispatch;
	}
	// 821F3128: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821F312C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821F3130: 419A0038  beq cr6, 0x821f3168
	if ctx.cr[6].eq {
	pc = 0x821F3168; continue 'dispatch;
	}
	// 821F3134: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821F3138: C03F004C  lfs f1, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F313C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F3140: 48000189  bl 0x821f32c8
	ctx.lr = 0x821F3144;
	sub_821F32C8(ctx, base);
	// 821F3144: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F3148: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F314C: 4099FFB0  ble cr6, 0x821f30fc
	if !ctx.cr[6].gt {
	pc = 0x821F30FC; continue 'dispatch;
	}
	// 821F3150: D03F004C  stfs f1, 0x4c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821F3154: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 821F3158: 57C3003E  slwi r3, r30, 0
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821F315C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F3160: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821F3164: 48AB62F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821F3168: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821F316C: C03F004C  lfs f1, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F3170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F3174: 48000155  bl 0x821f32c8
	ctx.lr = 0x821F3178;
	sub_821F32C8(ctx, base);
	// 821F3178: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821F317C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F3180: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821F3184: C03F004C  lfs f1, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821F3188: 48000141  bl 0x821f32c8
	ctx.lr = 0x821F318C;
	sub_821F32C8(ctx, base);
	// 821F318C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821F3190: 4099FF58  ble cr6, 0x821f30e8
	if !ctx.cr[6].gt {
	pc = 0x821F30E8; continue 'dispatch;
	}
	// 821F3194: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821F3198: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821F319C: 4099FF60  ble cr6, 0x821f30fc
	if !ctx.cr[6].gt {
	pc = 0x821F30FC; continue 'dispatch;
	}
	// 821F31A0: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821F31A4: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821F31A8: 5783003E  slwi r3, r28, 0
	ctx.r[3].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821F31AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821F31B0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821F31B4: 48AB62A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F31B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F31B8 size=272
    let mut pc: u32 = 0x821F31B8;
    'dispatch: loop {
        match pc {
            0x821F31B8 => {
    //   block [0x821F31B8..0x821F32C8)
	// 821F31B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F31BC: 48AB6251  bl 0x82ca940c
	ctx.lr = 0x821F31C0;
	sub_82CA93D0(ctx, base);
	// 821F31C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F31C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821F31C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821F31CC: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821F31D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F31D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F31D8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F31DC: 419A0070  beq cr6, 0x821f324c
	if ctx.cr[6].eq {
	pc = 0x821F324C; continue 'dispatch;
	}
	// 821F31E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F31E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821F31E8: 549D003E  slwi r29, r4, 0
	ctx.r[29].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821F31EC: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821F31F0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821F31F4: 4E800421  bctrl
	ctx.lr = 0x821F31F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F31F8: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F31FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821F3200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821F3204: 80E80044  lwz r7, 0x44(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 821F3208: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821F320C: 4E800421  bctrl
	ctx.lr = 0x821F3210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F3210: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821F3214: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821F3218: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821F321C: E8850000  ld r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F32C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F32C8 size=952
    let mut pc: u32 = 0x821F32C8;
    'dispatch: loop {
        match pc {
            0x821F32C8 => {
    //   block [0x821F32C8..0x821F3680)
	// 821F32C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F32CC: 48AB6135  bl 0x82ca9400
	ctx.lr = 0x821F32D0;
	sub_82CA93D0(ctx, base);
	// 821F32D0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821F32D4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821F32D8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821F32DC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3680 size=504
    let mut pc: u32 = 0x821F3680;
    'dispatch: loop {
        match pc {
            0x821F3680 => {
    //   block [0x821F3680..0x821F3878)
	// 821F3680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F3684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F3688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F368C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F3690: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 821F3694: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 821F3698: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821F369C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821F3878 size=944
    let mut pc: u32 = 0x821F3878;
    'dispatch: loop {
        match pc {
            0x821F3878 => {
    //   block [0x821F3878..0x821F3C28)
	// 821F3878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F387C: 48AB5B8D  bl 0x82ca9408
	ctx.lr = 0x821F3880;
	sub_82CA93D0(ctx, base);
	// 821F3880: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821F3884: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821F3888: 3BBC0038  addi r29, r28, 0x38
	ctx.r[29].s64 = ctx.r[28].s64 + 56;
	// 821F388C: 83FC003C  lwz r31, 0x3c(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 821F3890: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821F3894: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F3898: 40990008  ble cr6, 0x821f38a0
	if !ctx.cr[6].gt {
	pc = 0x821F38A0; continue 'dispatch;
	}
	// 821F389C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F38A0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821F38A4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821F38A8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821F38AC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F38B0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F38B4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F38B8: 40990008  ble cr6, 0x821f38c0
	if !ctx.cr[6].gt {
	pc = 0x821F38C0; continue 'dispatch;
	}
	// 821F38BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F38C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F38C4: 419A000C  beq cr6, 0x821f38d0
	if ctx.cr[6].eq {
	pc = 0x821F38D0; continue 'dispatch;
	}
	// 821F38C8: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821F38CC: 419A0008  beq cr6, 0x821f38d4
	if ctx.cr[6].eq {
	pc = 0x821F38D4; continue 'dispatch;
	}
	// 821F38D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F38D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F38D8: 419A00C8  beq cr6, 0x821f39a0
	if ctx.cr[6].eq {
	pc = 0x821F39A0; continue 'dispatch;
	}
	// 821F38DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821F38E0: 409A0008  bne cr6, 0x821f38e8
	if !ctx.cr[6].eq {
	pc = 0x821F38E8; continue 'dispatch;
	}
	// 821F38E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F38E8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F38EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F38F0: 41980008  blt cr6, 0x821f38f8
	if ctx.cr[6].lt {
	pc = 0x821F38F8; continue 'dispatch;
	}
	// 821F38F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F38F8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F38FC: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3900: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F3904: 409A006C  bne cr6, 0x821f3970
	if !ctx.cr[6].eq {
	pc = 0x821F3970; continue 'dispatch;
	}
	// 821F3908: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F390C: 41980008  blt cr6, 0x821f3914
	if ctx.cr[6].lt {
	pc = 0x821F3914; continue 'dispatch;
	}
	// 821F3910: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3914: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821F3918: 486D0F11  bl 0x828c4828
	ctx.lr = 0x821F391C;
	sub_828C4828(ctx, base);
	// 821F391C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821F3920: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 821F3924: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3928: 48977151  bl 0x82b6aa78
	ctx.lr = 0x821F392C;
	sub_82B6AA78(ctx, base);
	// 821F392C: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3930: 3BFEFFF8  addi r31, r30, -8
	ctx.r[31].s64 = ctx.r[30].s64 + -8;
	// 821F3934: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821F3938: 419A0018  beq cr6, 0x821f3950
	if ctx.cr[6].eq {
	pc = 0x821F3950; continue 'dispatch;
	}
	// 821F393C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821F3940: 4BFC41D9  bl 0x821b7b18
	ctx.lr = 0x821F3944;
	sub_821B7B18(ctx, base);
	// 821F3944: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821F3948: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821F394C: 409AFFF0  bne cr6, 0x821f393c
	if !ctx.cr[6].eq {
	pc = 0x821F393C; continue 'dispatch;
	}
	// 821F3950: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821F3954: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3958: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 821F395C: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821F3960: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821F3964: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821F3968: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821F396C: 4BFFFF40  b 0x821f38ac
	pc = 0x821F38AC; continue 'dispatch;
	// 821F3970: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821F3974: 41980008  blt cr6, 0x821f397c
	if ctx.cr[6].lt {
	pc = 0x821F397C; continue 'dispatch;
	}
	// 821F3978: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F397C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3980: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821F3984: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821F3988: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F398C: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F3990: 41980008  blt cr6, 0x821f3998
	if ctx.cr[6].lt {
	pc = 0x821F3998; continue 'dispatch;
	}
	// 821F3994: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3998: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821F399C: 4BFFFF0C  b 0x821f38a8
	pc = 0x821F38A8; continue 'dispatch;
	// 821F39A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821F39A4: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F39A8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821F39AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F39B0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821F39B4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F39B8: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F39BC: 4803EDBD  bl 0x82232778
	ctx.lr = 0x821F39C0;
	sub_82232778(ctx, base);
	// 821F39C0: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821F39C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821F39C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821F39CC: 409A01D0  bne cr6, 0x821f3b9c
	if !ctx.cr[6].eq {
	pc = 0x821F3B9C; continue 'dispatch;
	}
	// 821F39D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821F39D4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F39D8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821F39DC: 4807F6FD  bl 0x822730d8
	ctx.lr = 0x821F39E0;
	sub_822730D8(ctx, base);
	// 821F39E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821F39E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821F39E8: 409A018C  bne cr6, 0x821f3b74
	if !ctx.cr[6].eq {
	pc = 0x821F3B74; continue 'dispatch;
	}
	// 821F39EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F39F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821F39F4: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821F39F8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F39FC: 812A004C  lwz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 821F3A00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821F3A04: 4E800421  bctrl
	ctx.lr = 0x821F3A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821F3A08: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821F3A0C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821F3A10: 38C890F0  addi r6, r8, -0x6f10
	ctx.r[6].s64 = ctx.r[8].s64 + -28432;
	// 821F3A14: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 821F3A18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3C28 size=276
    let mut pc: u32 = 0x821F3C28;
    'dispatch: loop {
        match pc {
            0x821F3C28 => {
    //   block [0x821F3C28..0x821F3D3C)
	// 821F3C28: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821F3C2C: 34E4006C  addic. r7, r4, 0x6c
	ctx.xer.ca = (ctx.r[4].u32 > (!(108 as u32)));
	ctx.r[7].s64 = ctx.r[4].s64 + 108;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821F3C30: 40820008  bne 0x821f3c38
	if !ctx.cr[0].eq {
	pc = 0x821F3C38; continue 'dispatch;
	}
	// 821F3C34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3C38: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3C3C: 90E1FFE0  stw r7, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u32 ) };
	// 821F3C40: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821F3C44: 9161FFE4  stw r11, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[11].u32 ) };
	// 821F3C48: E921FFE0  ld r9, -0x20(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821F3C4C: F921FFEC  std r9, -0x14(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), ctx.r[9].u64 ) };
	// 821F3C50: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F3C54: 8101FFEC  lwz r8, -0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 821F3C58: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821F3C5C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F3C60: 419A000C  beq cr6, 0x821f3c6c
	if ctx.cr[6].eq {
	pc = 0x821F3C6C; continue 'dispatch;
	}
	// 821F3C64: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821F3C68: 419A0008  beq cr6, 0x821f3c70
	if ctx.cr[6].eq {
	pc = 0x821F3C70; continue 'dispatch;
	}
	// 821F3C6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3C70: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821F3C74: 419A00B4  beq cr6, 0x821f3d28
	if ctx.cr[6].eq {
	pc = 0x821F3D28; continue 'dispatch;
	}
	// 821F3C78: E881FFEC  ld r4, -0x14(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) };
	// 821F3C7C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F3C80: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 821F3C84: 409A0008  bne cr6, 0x821f3c8c
	if !ctx.cr[6].eq {
	pc = 0x821F3C8C; continue 'dispatch;
	}
	// 821F3C88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3C8C: 8141FFE0  lwz r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 821F3C90: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3C94: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3C98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F3C9C: 409A000C  bne cr6, 0x821f3ca8
	if !ctx.cr[6].eq {
	pc = 0x821F3CA8; continue 'dispatch;
	}
	// 821F3CA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3CA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3CA8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821F3CAC: 83EA001C  lwz r31, 0x1c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821F3CB0: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 821F3CB4: 419A0010  beq cr6, 0x821f3cc4
	if ctx.cr[6].eq {
	pc = 0x821F3CC4; continue 'dispatch;
	}
	// 821F3CB8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821F3CBC: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821F3CC0: 419A002C  beq cr6, 0x821f3cec
	if ctx.cr[6].eq {
	pc = 0x821F3CEC; continue 'dispatch;
	}
	// 821F3CC4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F3CC8: 409A0008  bne cr6, 0x821f3cd0
	if !ctx.cr[6].eq {
	pc = 0x821F3CD0; continue 'dispatch;
	}
	// 821F3CCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3CD0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3CD4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821F3CD8: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 821F3CDC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F3CE0: 409AFF7C  bne cr6, 0x821f3c5c
	if !ctx.cr[6].eq {
	pc = 0x821F3C5C; continue 'dispatch;
	}
	// 821F3CE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3CE8: 4BFFFF74  b 0x821f3c5c
	pc = 0x821F3C5C; continue 'dispatch;
	// 821F3CEC: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 821F3CF0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821F3CF4: 409A0008  bne cr6, 0x821f3cfc
	if !ctx.cr[6].eq {
	pc = 0x821F3CFC; continue 'dispatch;
	}
	// 821F3CF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3CFC: 8141FFE0  lwz r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 821F3D00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3D04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3D08: 9161FFE4  stw r11, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[11].u32 ) };
	// 821F3D0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821F3D10: 409A0008  bne cr6, 0x821f3d18
	if !ctx.cr[6].eq {
	pc = 0x821F3D18; continue 'dispatch;
	}
	// 821F3D14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821F3D18: E961FFE0  ld r11, -0x20(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821F3D1C: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821F3D20: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821F3D24: 4E800020  blr
	return;
	// 821F3D28: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821F3D2C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821F3D30: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821F3D34: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821F3D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3D40 size=24
    let mut pc: u32 = 0x821F3D40;
    'dispatch: loop {
        match pc {
            0x821F3D40 => {
    //   block [0x821F3D40..0x821F3D58)
	// 821F3D40: E9440030  ld r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	// 821F3D44: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821F3D48: E9240038  ld r9, 0x38(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	// 821F3D4C: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821F3D50: F9230008  std r9, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821F3D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3D58 size=52
    let mut pc: u32 = 0x821F3D58;
    'dispatch: loop {
        match pc {
            0x821F3D58 => {
    //   block [0x821F3D58..0x821F3D8C)
	// 821F3D58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821F3D5C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821F3D60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821F3D64: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F3D68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821F3D6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821F3D70: 409AFFF4  bne cr6, 0x821f3d64
	if !ctx.cr[6].eq {
	pc = 0x821F3D64; continue 'dispatch;
	}
	// 821F3D74: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821F3D78: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821F3D7C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821F3D80: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821F3D84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F3D88: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3D8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3D8C size=36
    let mut pc: u32 = 0x821F3D8C;
    'dispatch: loop {
        match pc {
            0x821F3D8C => {
    //   block [0x821F3D8C..0x821F3DB0)
	// 821F3D8C: 3D200100  lis r9, 0x100
	ctx.r[9].s64 = 16777216;
	// 821F3D90: 61290193  ori r9, r9, 0x193
	ctx.r[9].u64 = ctx.r[9].u64 | 403;
	// 821F3D94: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821F3D98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821F3D9C: 7CE349D6  mullw r7, r3, r9
	ctx.r[7].s64 = (ctx.r[3].s32 as i64) * (ctx.r[9].s32 as i64);
	// 821F3DA0: 7CE34278  xor r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 ^ ctx.r[8].u64;
	// 821F3DA4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821F3DA8: 4198FFEC  blt cr6, 0x821f3d94
	if ctx.cr[6].lt {
	pc = 0x821F3D94; continue 'dispatch;
	}
	// 821F3DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3DB0 size=32
    let mut pc: u32 = 0x821F3DB0;
    'dispatch: loop {
        match pc {
            0x821F3DB0 => {
    //   block [0x821F3DB0..0x821F3DD0)
	// 821F3DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821F3DB4: D8210010  stfd f1, 0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.f[1].u64 ) };
	// 821F3DB8: C8CB0CB8  lfd f6, 0xcb8(r11)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 821F3DBC: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 821F3DC0: 409A0010  bne cr6, 0x821f3dd0
	if !ctx.cr[6].eq {
		sub_821F3DD0(ctx, base);
		return;
	}
	// 821F3DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821F3DC8: C82B0D38  lfd f1, 0xd38(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 821F3DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3DD0 size=36
    let mut pc: u32 = 0x821F3DD0;
    'dispatch: loop {
        match pc {
            0x821F3DD0 => {
    //   block [0x821F3DD0..0x821F3DF4)
	// 821F3DD0: A1410010  lhz r10, 0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(16 as u32) ) } as u64;
	// 821F3DD4: 554B0476  rlwinm r11, r10, 0, 0x11, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821F3DD8: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821F3DDC: 2B0B7FF0  cmplwi cr6, r11, 0x7ff0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32752 as u32, &mut ctx.xer);
	// 821F3DE0: 409A0024  bne cr6, 0x821f3e04
	if !ctx.cr[6].eq {
		sub_821F3E04(ctx, base);
		return;
	}
	// 821F3DE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821F3DE8: C80B0F10  lfd f0, 0xf10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3856 as u32) ) };
	// 821F3DEC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F3DF0: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3DF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3DF4 size=16
    let mut pc: u32 = 0x821F3DF4;
    'dispatch: loop {
        match pc {
            0x821F3DF4 => {
    //   block [0x821F3DF4..0x821F3E04)
	// 821F3DF4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 821F3DF8: C80BF4B8  lfd f0, -0xb48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-2888 as u32) ) };
	// 821F3DFC: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821F3E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3E04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3E04 size=36
    let mut pc: u32 = 0x821F3E04;
    'dispatch: loop {
        match pc {
            0x821F3E04 => {
    //   block [0x821F3E04..0x821F3E28)
	// 821F3E04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F3E08: C80A0D38  lfd f0, 0xd38(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3384 as u32) ) };
	// 821F3E0C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F3E10: 41990018  bgt cr6, 0x821f3e28
	if ctx.cr[6].gt {
		sub_821F3E28(ctx, base);
		return;
	}
	// 821F3E14: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F3E18: 409AFFDC  bne cr6, 0x821f3df4
	if !ctx.cr[6].eq {
		sub_821F3DF4(ctx, base);
		return;
	}
	// 821F3E1C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 821F3E20: C80BF4B0  lfd f0, -0xb50(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-2896 as u32) ) };
	// 821F3E24: 4BFFFFD8  b 0x821f3dfc
	sub_821F3DF4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3E28 size=56
    let mut pc: u32 = 0x821F3E28;
    'dispatch: loop {
        match pc {
            0x821F3E28 => {
    //   block [0x821F3E28..0x821F3E60)
	// 821F3E28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F3E2C: C80A0E38  lfd f0, 0xe38(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3640 as u32) ) };
	// 821F3E30: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821F3E34: 4098002C  bge cr6, 0x821f3e60
	if !ctx.cr[6].lt {
		sub_821F3E60(ctx, base);
		return;
	}
	// 821F3E38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821F3E3C: C80B0F08  lfd f0, 0xf08(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3848 as u32) ) };
	// 821F3E40: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821F3E44: D8210010  stfd f1, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.f[1].u64 ) };
	// 821F3E48: A1610010  lhz r11, 0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(16 as u32) ) } as u64;
	// 821F3E4C: 556AE57E  rlwinm r10, r11, 0x1c, 0x15, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821F3E50: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821F3E54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821F3E58: 394BFBCD  addi r10, r11, -0x433
	ctx.r[10].s64 = ctx.r[11].s64 + -1075;
	// 821F3E5C: 4800000C  b 0x821f3e68
	sub_821F3E60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3E60 size=76
    let mut pc: u32 = 0x821F3E60;
    'dispatch: loop {
        match pc {
            0x821F3E60 => {
    //   block [0x821F3E60..0x821F3EAC)
	// 821F3E60: 556BE53E  rlwinm r11, r11, 0x1c, 0x14, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821F3E64: 394BFC02  addi r10, r11, -0x3fe
	ctx.r[10].s64 = ctx.r[11].s64 + -1022;
	// 821F3E68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821F3E6C: D821FFF0  stfd f1, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[1].u64 ) };
	// 821F3E70: 7129800F  andi. r9, r9, 0x800f
	ctx.r[9].u64 = ctx.r[9].u64 & 32783;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821F3E74: 396B0EB8  addi r11, r11, 0xeb8
	ctx.r[11].s64 = ctx.r[11].s64 + 3768;
	// 821F3E78: 61293FE0  ori r9, r9, 0x3fe0
	ctx.r[9].u64 = ctx.r[9].u64 | 16352;
	// 821F3E7C: B121FFF0  sth r9, -0x10(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u16 ) };
	// 821F3E80: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F3E84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821F3E88: C80B0000  lfd f0, 0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821F3E8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821F3E90: 4099001C  ble cr6, 0x821f3eac
	if !ctx.cr[6].gt {
		sub_821F3EAC(ctx, base);
		return;
	}
	// 821F3E94: C8090D30  lfd f0, 0xd30(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3376 as u32) ) };
	// 821F3E98: FD8D302A  fadd f12, f13, f6
	ctx.f[12].f64 = ctx.f[13].f64 + ctx.f[6].f64;
	// 821F3E9C: FD6D0028  fsub f11, f13, f0
	ctx.f[11].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 821F3EA0: FDAC0032  fmul f13, f12, f0
	ctx.f[13].f64 = ctx.f[12].f64 * ctx.f[0].f64;
	// 821F3EA4: FC0B0028  fsub f0, f11, f0
	ctx.f[0].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821F3EA8: 48000018  b 0x821f3ec0
	sub_821F3EAC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3EAC size=144
    let mut pc: u32 = 0x821F3EAC;
    'dispatch: loop {
        match pc {
            0x821F3EAC => {
    //   block [0x821F3EAC..0x821F3F3C)
	// 821F3EAC: C9890D30  lfd f12, 0xd30(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3376 as u32) ) };
	// 821F3EB0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821F3EB4: FC0D6028  fsub f0, f13, f12
	ctx.f[0].f64 = ctx.f[13].f64 - ctx.f[12].f64;
	// 821F3EB8: FDA0302A  fadd f13, f0, f6
	ctx.f[13].f64 = ctx.f[0].f64 + ctx.f[6].f64;
	// 821F3EBC: FDAD0332  fmul f13, f13, f12
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[12].f64;
	// 821F3EC0: FCA06824  fdiv f5, f0, f13
	ctx.f[5].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 821F3EC4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821F3EC8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821F3ECC: C98B0028  lfd f12, 0x28(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	// 821F3ED0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821F3ED4: C92B0040  lfd f9, 0x40(r11)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	// 821F3ED8: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 821F3EDC: C8EB0008  lfd f7, 8(r11)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821F3EE0: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 821F3EE4: C9A90E40  lfd f13, 0xe40(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3648 as u32) ) };
	// 821F3EE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821F3EEC: C9680E70  lfd f11, 0xe70(r8)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3696 as u32) ) };
	// 821F3EF0: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821F3EF4: C9470E78  lfd f10, 0xe78(r7)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(3704 as u32) ) };
	// 821F3EF8: C9060E80  lfd f8, 0xe80(r6)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(3712 as u32) ) };
	// 821F3EFC: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821F3F00: FC80069C  fcfid f4, f0
	ctx.f[4].f64 = (ctx.f[0].s64 as f64);
	// 821F3F04: FC650172  fmul f3, f5, f5
	ctx.f[3].f64 = ctx.f[5].f64 * ctx.f[5].f64;
	// 821F3F08: C80A0E60  lfd f0, 0xe60(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3680 as u32) ) };
	// 821F3F0C: FC040032  fmul f0, f4, f0
	ctx.f[0].f64 = ctx.f[4].f64 * ctx.f[0].f64;
	// 821F3F10: FDA3637C  fnmsub f13, f3, f13, f12
	ctx.f[13].f64 = -(ctx.f[3].f64 * ctx.f[13].f64 - ctx.f[12].f64);
	// 821F3F14: FD835828  fsub f12, f3, f11
	ctx.f[12].f64 = ctx.f[3].f64 - ctx.f[11].f64;
	// 821F3F18: FDAD50F8  fmsub f13, f13, f3, f10
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[3].f64 - ctx.f[10].f64;
	// 821F3F1C: FD8C48FA  fmadd f12, f12, f3, f9
	ctx.f[12].f64 = ctx.f[12].f64 * ctx.f[3].f64 + ctx.f[9].f64;
	// 821F3F20: FDAD00F2  fmul f13, f13, f3
	ctx.f[13].f64 = ctx.f[13].f64 * ctx.f[3].f64;
	// 821F3F24: FD8C40F8  fmsub f12, f12, f3, f8
	ctx.f[12].f64 = ctx.f[12].f64 * ctx.f[3].f64 - ctx.f[8].f64;
	// 821F3F28: FDAD6024  fdiv f13, f13, f12
	ctx.f[13].f64 = ctx.f[13].f64 / ctx.f[12].f64;
	// 821F3F2C: FDAD302A  fadd f13, f13, f6
	ctx.f[13].f64 = ctx.f[13].f64 + ctx.f[6].f64;
	// 821F3F30: FC0D0178  fmsub f0, f13, f5, f0
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[5].f64 - ctx.f[0].f64;
	// 821F3F34: FC2401FA  fmadd f1, f4, f7, f0
	ctx.f[1].f64 = ctx.f[4].f64 * ctx.f[7].f64 + ctx.f[0].f64;
	// 821F3F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821F3F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821F3F40 size=896
    let mut pc: u32 = 0x821F3F40;
    'dispatch: loop {
        match pc {
            0x821F3F40 => {
    //   block [0x821F3F40..0x821F42C0)
	// 821F3F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821F3F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821F3F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821F3F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821F3F50: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 821F3F54: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821F3F58: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


