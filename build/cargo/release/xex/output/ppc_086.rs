pub fn sub_828B9320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9320 size=1920
    let mut pc: u32 = 0x828B9320;
    'dispatch: loop {
        match pc {
            0x828B9320 => {
    //   block [0x828B9320..0x828B9AA0)
	// 828B9320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9324: 483F00B9  bl 0x82ca93dc
	ctx.lr = 0x828B9328;
	sub_82CA93D0(ctx, base);
	// 828B9328: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B932C: 3FA0834C  lis r29, -0x7cb4
	ctx.r[29].s64 = -2092171264;
	// 828B9330: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828B9334: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828B9338: 3AAB3780  addi r21, r11, 0x3780
	ctx.r[21].s64 = ctx.r[11].s64 + 14208;
	// 828B933C: 3BEA7088  addi r31, r10, 0x7088
	ctx.r[31].s64 = ctx.r[10].s64 + 28808;
	// 828B9340: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	// 828B9344: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 828B9348: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 828B934C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828B9350: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 828B9354: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B9358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B935C: 409A0054  bne cr6, 0x828b93b0
	if !ctx.cr[6].eq {
	pc = 0x828B93B0; continue 'dispatch;
	}
	// 828B9360: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B9364: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 828B9368: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B936C: 39600027  li r11, 0x27
	ctx.r[11].s64 = 39;
	// 828B9370: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B9374: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B9378: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B937C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9380: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B9384: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9388: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B938C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9390: 4082FFE8  bne 0x828b9378
	if !ctx.cr[0].eq {
	pc = 0x828B9378; continue 'dispatch;
	}
	// 828B9394: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9398: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B939C: 4080FFD4  bge 0x828b9370
	if !ctx.cr[0].lt {
	pc = 0x828B9370; continue 'dispatch;
	}
	// 828B93A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B93A4: 386BEBE8  addi r3, r11, -0x1418
	ctx.r[3].s64 = ctx.r[11].s64 + -5144;
	// 828B93A8: 483F0B79  bl 0x82ca9f20
	ctx.lr = 0x828B93AC;
	sub_82CA9F20(ctx, base);
	// 828B93AC: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	// 828B93B0: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B93B4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B93B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B93BC: 3ACA36E0  addi r22, r10, 0x36e0
	ctx.r[22].s64 = ctx.r[10].s64 + 14048;
	// 828B93C0: 409A0054  bne cr6, 0x828b9414
	if !ctx.cr[6].eq {
	pc = 0x828B9414; continue 'dispatch;
	}
	// 828B93C4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828B93C8: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 828B93CC: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B93D0: 39600027  li r11, 0x27
	ctx.r[11].s64 = 39;
	// 828B93D4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B93D8: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B93DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B93E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B93E4: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B93E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B93EC: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B93F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B93F4: 4082FFE8  bne 0x828b93dc
	if !ctx.cr[0].eq {
	pc = 0x828B93DC; continue 'dispatch;
	}
	// 828B93F8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B93FC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9400: 4080FFD4  bge 0x828b93d4
	if !ctx.cr[0].lt {
	pc = 0x828B93D4; continue 'dispatch;
	}
	// 828B9404: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B9408: 386BEB80  addi r3, r11, -0x1480
	ctx.r[3].s64 = ctx.r[11].s64 + -5248;
	// 828B940C: 483F0B15  bl 0x82ca9f20
	ctx.lr = 0x828B9410;
	sub_82CA9F20(ctx, base);
	// 828B9410: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	// 828B9414: 5569077A  rlwinm r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B9418: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B941C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9420: 3A8A36B4  addi r20, r10, 0x36b4
	ctx.r[20].s64 = ctx.r[10].s64 + 14004;
	// 828B9424: 409A0050  bne cr6, 0x828b9474
	if !ctx.cr[6].eq {
	pc = 0x828B9474; continue 'dispatch;
	}
	// 828B9428: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 828B942C: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B9430: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B9434: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 828B9438: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B943C: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B9440: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B9444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9448: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B944C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9450: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9454: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9458: 4082FFE8  bne 0x828b9440
	if !ctx.cr[0].eq {
	pc = 0x828B9440; continue 'dispatch;
	}
	// 828B945C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9460: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9464: 4080FFD4  bge 0x828b9438
	if !ctx.cr[0].lt {
	pc = 0x828B9438; continue 'dispatch;
	}
	// 828B9468: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B946C: 386BEB18  addi r3, r11, -0x14e8
	ctx.r[3].s64 = ctx.r[11].s64 + -5352;
	// 828B9470: 483F0AB1  bl 0x82ca9f20
	ctx.lr = 0x828B9474;
	sub_82CA9F20(ctx, base);
	// 828B9474: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B9478: 896AEBC8  lbz r11, -0x1438(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-5176 as u32) ) } as u64;
	// 828B947C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9480: 409A0554  bne cr6, 0x828b99d4
	if !ctx.cr[6].eq {
	pc = 0x828B99D4; continue 'dispatch;
	}
	// 828B9484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9488: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828B948C: 996AEBC8  stb r11, -0x1438(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-5176 as u32), ctx.r[11].u8 ) };
	// 828B9490: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B9494: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B9498: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B949C: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828B94A0: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 828B94A4: 3B880B34  addi r28, r8, 0xb34
	ctx.r[28].s64 = ctx.r[8].s64 + 2868;
	// 828B94A8: 3B092D5C  addi r24, r9, 0x2d5c
	ctx.r[24].s64 = ctx.r[9].s64 + 11612;
	// 828B94AC: 3AEA2D40  addi r23, r10, 0x2d40
	ctx.r[23].s64 = ctx.r[10].s64 + 11584;
	// 828B94B0: 3B4B0B70  addi r26, r11, 0xb70
	ctx.r[26].s64 = ctx.r[11].s64 + 2928;
	// 828B94B4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828B94B8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B94BC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B94C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B94C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94C8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B94CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B94D0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B94D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94D8: 4082FFE8  bne 0x828b94c0
	if !ctx.cr[0].eq {
	pc = 0x828B94C0; continue 'dispatch;
	}
	// 828B94DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B94E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B94E4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B94E8: 4B92A969  bl 0x821e3e50
	ctx.lr = 0x828B94EC;
	sub_821E3E50(ctx, base);
	// 828B94EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B94F0: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828B94F4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B94F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94FC: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9500: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B9504: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9508: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B950C: 4082FFE8  bne 0x828b94f4
	if !ctx.cr[0].eq {
	pc = 0x828B94F4; continue 'dispatch;
	}
	// 828B9510: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9514: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B9518: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B951C: 4B92A935  bl 0x821e3e50
	ctx.lr = 0x828B9520;
	sub_821E3E50(ctx, base);
	// 828B9520: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B9524: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9528: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B952C: 4B9739A5  bl 0x8222ced0
	ctx.lr = 0x828B9530;
	sub_8222CED0(ctx, base);
	// 828B9530: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B9534: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9538: 4B9332C1  bl 0x821ec7f8
	ctx.lr = 0x828B953C;
	sub_821EC7F8(ctx, base);
	// 828B953C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 828B9540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B9544: 4B936CFD  bl 0x821f0240
	ctx.lr = 0x828B9548;
	sub_821F0240(ctx, base);
	// 828B9548: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B954C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B9550: 4B921471  bl 0x821da9c0
	ctx.lr = 0x828B9554;
	sub_821DA9C0(ctx, base);
	// 828B9554: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 828B9558: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828B955C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828B9560: 4B929BA9  bl 0x821e3108
	ctx.lr = 0x828B9564;
	sub_821E3108(ctx, base);
	// 828B9564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B9568: 7C7BAA14  add r3, r27, r21
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[21].u64;
	// 828B956C: 4B9ABC35  bl 0x822651a0
	ctx.lr = 0x828B9570;
	sub_822651A0(ctx, base);
	// 828B9570: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828B9574: 4B90D1F5  bl 0x821c6768
	ctx.lr = 0x828B9578;
	sub_821C6768(ctx, base);
	// 828B9578: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B957C: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828B9580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9584: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828B9588: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 828B958C: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9590: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9594: 4082FFE8  bne 0x828b957c
	if !ctx.cr[0].eq {
	pc = 0x828B957C; continue 'dispatch;
	}
	// 828B9598: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828B959C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B95A0: 4B90D1C9  bl 0x821c6768
	ctx.lr = 0x828B95A4;
	sub_821C6768(ctx, base);
	// 828B95A4: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828B95A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B95AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95B0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B95B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B95B8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B95BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95C0: 4082FFE8  bne 0x828b95a8
	if !ctx.cr[0].eq {
	pc = 0x828B95A8; continue 'dispatch;
	}
	// 828B95C4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B95C8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B95CC: 4B90D19D  bl 0x821c6768
	ctx.lr = 0x828B95D0;
	sub_821C6768(ctx, base);
	// 828B95D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B95D4: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B95D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95DC: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B95E0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828B95E4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B95E8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95EC: 4082FFE8  bne 0x828b95d4
	if !ctx.cr[0].eq {
	pc = 0x828B95D4; continue 'dispatch;
	}
	// 828B95F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B95F4: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828B95F8: 4B90D171  bl 0x821c6768
	ctx.lr = 0x828B95FC;
	sub_821C6768(ctx, base);
	// 828B95FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B9600: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9604: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9608: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B960C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9610: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9614: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9618: 4082FFE8  bne 0x828b9600
	if !ctx.cr[0].eq {
	pc = 0x828B9600; continue 'dispatch;
	}
	// 828B961C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9620: 4B90D149  bl 0x821c6768
	ctx.lr = 0x828B9624;
	sub_821C6768(ctx, base);
	// 828B9624: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828B9628: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B962C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9630: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9634: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B9638: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B963C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9640: 4082FFE8  bne 0x828b9628
	if !ctx.cr[0].eq {
	pc = 0x828B9628; continue 'dispatch;
	}
	// 828B9644: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B9648: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828B964C: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B9650: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9654: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B9658: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828B965C: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9660: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9664: 4082FFE8  bne 0x828b964c
	if !ctx.cr[0].eq {
	pc = 0x828B964C; continue 'dispatch;
	}
	// 828B9668: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B966C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B9670: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9674: 4B92A7DD  bl 0x821e3e50
	ctx.lr = 0x828B9678;
	sub_821E3E50(ctx, base);
	// 828B9678: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B967C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B9680: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9684: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9688: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B968C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 828B9690: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9694: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9698: 4082FFE8  bne 0x828b9680
	if !ctx.cr[0].eq {
	pc = 0x828B9680; continue 'dispatch;
	}
	// 828B969C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B96A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B96A4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B96A8: 4B92A7A9  bl 0x821e3e50
	ctx.lr = 0x828B96AC;
	sub_821E3E50(ctx, base);
	// 828B96AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B96B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B96B4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B96B8: 4B973819  bl 0x8222ced0
	ctx.lr = 0x828B96BC;
	sub_8222CED0(ctx, base);
	// 828B96BC: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828B96C0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B96C4: 4B933135  bl 0x821ec7f8
	ctx.lr = 0x828B96C8;
	sub_821EC7F8(ctx, base);
	// 828B96C8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 828B96CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B96D0: 4B936B71  bl 0x821f0240
	ctx.lr = 0x828B96D4;
	sub_821F0240(ctx, base);
	// 828B96D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B96D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B96DC: 4B9212E5  bl 0x821da9c0
	ctx.lr = 0x828B96E0;
	sub_821DA9C0(ctx, base);
	// 828B96E0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828B96E4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828B96E8: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 828B96EC: 4B929A1D  bl 0x821e3108
	ctx.lr = 0x828B96F0;
	sub_821E3108(ctx, base);
	// 828B96F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B96F4: 7C7BB214  add r3, r27, r22
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[22].u64;
	// 828B96F8: 4B9ABAA9  bl 0x822651a0
	ctx.lr = 0x828B96FC;
	sub_822651A0(ctx, base);
	// 828B96FC: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 828B9700: 4B90D069  bl 0x821c6768
	ctx.lr = 0x828B9704;
	sub_821C6768(ctx, base);
	// 828B9704: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828B9708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B970C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9710: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9714: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B9718: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B971C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9720: 4082FFE8  bne 0x828b9708
	if !ctx.cr[0].eq {
	pc = 0x828B9708; continue 'dispatch;
	}
	// 828B9724: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 828B9728: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B972C: 4B90D03D  bl 0x821c6768
	ctx.lr = 0x828B9730;
	sub_821C6768(ctx, base);
	// 828B9730: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B9734: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 828B9738: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B973C: 7CC03828  lwarx r6, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 828B9740: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 828B9744: 7CC0392D  stwcx. r6, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9748: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B974C: 4082FFE8  bne 0x828b9734
	if !ctx.cr[0].eq {
	pc = 0x828B9734; continue 'dispatch;
	}
	// 828B9750: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B9754: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828B9758: 4B90D011  bl 0x821c6768
	ctx.lr = 0x828B975C;
	sub_821C6768(ctx, base);
	// 828B975C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B9760: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9768: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B976C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9770: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9774: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9778: 4082FFE8  bne 0x828b9760
	if !ctx.cr[0].eq {
	pc = 0x828B9760; continue 'dispatch;
	}
	// 828B977C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9780: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 828B9784: 4B90CFE5  bl 0x821c6768
	ctx.lr = 0x828B9788;
	sub_821C6768(ctx, base);
	// 828B9788: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828B978C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9794: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9798: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B979C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B97A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97A4: 4082FFE8  bne 0x828b978c
	if !ctx.cr[0].eq {
	pc = 0x828B978C; continue 'dispatch;
	}
	// 828B97A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B97AC: 4B90CFBD  bl 0x821c6768
	ctx.lr = 0x828B97B0;
	sub_821C6768(ctx, base);
	// 828B97B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B97B4: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B97B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97BC: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B97C0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828B97C4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B97C8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97CC: 4082FFE8  bne 0x828b97b4
	if !ctx.cr[0].eq {
	pc = 0x828B97B4; continue 'dispatch;
	}
	// 828B97D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B97D4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B97D8: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 828B97DC: 4198FCDC  blt cr6, 0x828b94b8
	if ctx.cr[6].lt {
	pc = 0x828B94B8; continue 'dispatch;
	}
	// 828B97E0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828B97E4: 2F1B00A0  cmpwi cr6, r27, 0xa0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 160, &mut ctx.xer);
	// 828B97E8: 4198FCCC  blt cr6, 0x828b94b4
	if ctx.cr[6].lt {
	pc = 0x828B94B4; continue 'dispatch;
	}
	// 828B97EC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B97F0: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 828B97F4: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828B97F8: 3B0B2D7C  addi r24, r11, 0x2d7c
	ctx.r[24].s64 = ctx.r[11].s64 + 11644;
	// 828B97FC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828B9800: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B9804: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828B9808: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B980C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9810: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B9814: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9818: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B981C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9820: 4082FFE8  bne 0x828b9808
	if !ctx.cr[0].eq {
	pc = 0x828B9808; continue 'dispatch;
	}
	// 828B9824: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9828: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B982C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9830: 4B92A621  bl 0x821e3e50
	ctx.lr = 0x828B9834;
	sub_821E3E50(ctx, base);
	// 828B9834: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B9838: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 828B983C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B9840: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9844: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9848: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B984C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9850: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9854: 4082FFE8  bne 0x828b983c
	if !ctx.cr[0].eq {
	pc = 0x828B983C; continue 'dispatch;
	}
	// 828B9858: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B985C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B9860: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9864: 4B92A5ED  bl 0x821e3e50
	ctx.lr = 0x828B9868;
	sub_821E3E50(ctx, base);
	// 828B9868: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B986C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9870: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9874: 4B97365D  bl 0x8222ced0
	ctx.lr = 0x828B9878;
	sub_8222CED0(ctx, base);
	// 828B9878: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828B987C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9880: 4B932F79  bl 0x821ec7f8
	ctx.lr = 0x828B9884;
	sub_821EC7F8(ctx, base);
	// 828B9884: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 828B9888: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B988C: 4B9369B5  bl 0x821f0240
	ctx.lr = 0x828B9890;
	sub_821F0240(ctx, base);
	// 828B9890: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B9894: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B9898: 4B921129  bl 0x821da9c0
	ctx.lr = 0x828B989C;
	sub_821DA9C0(ctx, base);
	// 828B989C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B98A0: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 828B98A4: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828B98A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98AC: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828B98B0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828B98B4: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B98B8: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98BC: 4082FFE8  bne 0x828b98a4
	if !ctx.cr[0].eq {
	pc = 0x828B98A4; continue 'dispatch;
	}
	// 828B98C0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828B98C4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98C8: 4B9AB8D9  bl 0x822651a0
	ctx.lr = 0x828B98CC;
	sub_822651A0(ctx, base);
	// 828B98CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B98D0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98D4: 4B932F25  bl 0x821ec7f8
	ctx.lr = 0x828B98D8;
	sub_821EC7F8(ctx, base);
	// 828B98D8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 828B98DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B98E0: 4B9AB8C1  bl 0x822651a0
	ctx.lr = 0x828B98E4;
	sub_822651A0(ctx, base);
	// 828B98E4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98E8: 4B90CE81  bl 0x821c6768
	ctx.lr = 0x828B98EC;
	sub_821C6768(ctx, base);
	// 828B98EC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B98F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B98F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98F8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B98FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9900: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9904: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9908: 4082FFE8  bne 0x828b98f0
	if !ctx.cr[0].eq {
	pc = 0x828B98F0; continue 'dispatch;
	}
	// 828B990C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B9910: 4B90CE59  bl 0x821c6768
	ctx.lr = 0x828B9914;
	sub_821C6768(ctx, base);
	// 828B9914: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B9918: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B991C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9920: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9924: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828B9928: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B992C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9930: 4082FFE8  bne 0x828b9918
	if !ctx.cr[0].eq {
	pc = 0x828B9918; continue 'dispatch;
	}
	// 828B9934: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9938: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828B993C: 4B90CE2D  bl 0x821c6768
	ctx.lr = 0x828B9940;
	sub_821C6768(ctx, base);
	// 828B9940: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B9944: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9948: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B994C: 7C802828  lwarx r4, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B9950: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9954: 7C80292D  stwcx. r4, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9958: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B995C: 4082FFE8  bne 0x828b9944
	if !ctx.cr[0].eq {
	pc = 0x828B9944; continue 'dispatch;
	}
	// 828B9960: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9964: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828B9968: 4B90CE01  bl 0x821c6768
	ctx.lr = 0x828B996C;
	sub_821C6768(ctx, base);
	// 828B996C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B9970: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B9974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9978: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B997C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9980: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9984: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9988: 4082FFE8  bne 0x828b9970
	if !ctx.cr[0].eq {
	pc = 0x828B9970; continue 'dispatch;
	}
	// 828B998C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9990: 4B90CDD9  bl 0x821c6768
	ctx.lr = 0x828B9994;
	sub_821C6768(ctx, base);
	// 828B9994: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B9998: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B999C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99A0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B99A4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828B99A8: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B99AC: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99B0: 4082FFE8  bne 0x828b9998
	if !ctx.cr[0].eq {
	pc = 0x828B9998; continue 'dispatch;
	}
	// 828B99B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B99B8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B99BC: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 828B99C0: 4198FE40  blt cr6, 0x828b9800
	if ctx.cr[6].lt {
	pc = 0x828B9800; continue 'dispatch;
	}
	// 828B99C4: 39740028  addi r11, r20, 0x28
	ctx.r[11].s64 = ctx.r[20].s64 + 40;
	// 828B99C8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828B99CC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B99D0: 4198FE2C  blt cr6, 0x828b97fc
	if ctx.cr[6].lt {
	pc = 0x828B97FC; continue 'dispatch;
	}
	// 828B99D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B99D8: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 828B99DC: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	// 828B99E0: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	// 828B99E4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B99E8: 7D5BF8AE  lbzx r10, r27, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828B99EC: 7F9BFA14  add r28, r27, r31
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 828B99F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B99F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B99F8: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 828B99FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9A00: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 828B9A04: 419A0008  beq cr6, 0x828b9a0c
	if ctx.cr[6].eq {
	pc = 0x828B9A0C; continue 'dispatch;
	}
	// 828B9A08: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9A0C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 828B9A10: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828B9A14: 4BBC6DB5  bl 0x824807c8
	ctx.lr = 0x828B9A18;
	sub_824807C8(ctx, base);
	// 828B9A18: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B9A1C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828B9A20: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828B9A24: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 828B9A28: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828B9A2C: 4198FFBC  blt cr6, 0x828b99e8
	if ctx.cr[6].lt {
	pc = 0x828B99E8; continue 'dispatch;
	}
	// 828B9A30: 39740028  addi r11, r20, 0x28
	ctx.r[11].s64 = ctx.r[20].s64 + 40;
	// 828B9A34: 3B7B0005  addi r27, r27, 5
	ctx.r[27].s64 = ctx.r[27].s64 + 5;
	// 828B9A38: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B9A3C: 4198FFA8  blt cr6, 0x828b99e4
	if ctx.cr[6].lt {
	pc = 0x828B99E4; continue 'dispatch;
	}
	// 828B9A40: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B9A44: 3BB20044  addi r29, r18, 0x44
	ctx.r[29].s64 = ctx.r[18].s64 + 68;
	// 828B9A48: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 828B9A4C: 38BDFFD8  addi r5, r29, -0x28
	ctx.r[5].s64 = ctx.r[29].s64 + -40;
	// 828B9A50: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828B9A54: 7C7FAA14  add r3, r31, r21
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[21].u64;
	// 828B9A58: 481633F1  bl 0x82a1ce48
	ctx.lr = 0x828B9A5C;
	sub_82A1CE48(ctx, base);
	// 828B9A5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B9A60: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828B9A64: 7C7FB214  add r3, r31, r22
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[22].u64;
	// 828B9A68: 481633E1  bl 0x82a1ce48
	ctx.lr = 0x828B9A6C;
	sub_82A1CE48(ctx, base);
	// 828B9A6C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B9A70: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828B9A74: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B9A78: 4082FFD4  bne 0x828b9a4c
	if !ctx.cr[0].eq {
	pc = 0x828B9A4C; continue 'dispatch;
	}
	// 828B9A7C: 2F1F00A0  cmpwi cr6, r31, 0xa0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 160, &mut ctx.xer);
	// 828B9A80: 4198FFC8  blt cr6, 0x828b9a48
	if ctx.cr[6].lt {
	pc = 0x828B9A48; continue 'dispatch;
	}
	// 828B9A84: 562B063E  clrlwi r11, r17, 0x18
	ctx.r[11].u64 = ctx.r[17].u32 as u64 & 0x000000FFu64;
	// 828B9A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9A8C: 409A000C  bne cr6, 0x828b9a98
	if !ctx.cr[6].eq {
	pc = 0x828B9A98; continue 'dispatch;
	}
	// 828B9A90: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828B9A94: 4BFFF5BD  bl 0x828b9050
	ctx.lr = 0x828B9A98;
	sub_828B9050(ctx, base);
	// 828B9A98: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 828B9A9C: 483EF990  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9AA0 size=60
    let mut pc: u32 = 0x828B9AA0;
    'dispatch: loop {
        match pc {
            0x828B9AA0 => {
    //   block [0x828B9AA0..0x828B9ADC)
	// 828B9AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9AA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9AAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9AB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B9AB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9AB8: 388B9E28  addi r4, r11, -0x61d8
	ctx.r[4].s64 = ctx.r[11].s64 + -25048;
	// 828B9ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9AC0: 4B973411  bl 0x8222ced0
	ctx.lr = 0x828B9AC4;
	sub_8222CED0(ctx, base);
	// 828B9AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9AC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9AD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9AD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9AE0 size=84
    let mut pc: u32 = 0x828B9AE0;
    'dispatch: loop {
        match pc {
            0x828B9AE0 => {
    //   block [0x828B9AE0..0x828B9B34)
	// 828B9AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9AE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9AEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9AF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9AF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9AF8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9AFC: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828B9B00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9B04: 419A000C  beq cr6, 0x828b9b10
	if ctx.cr[6].eq {
	pc = 0x828B9B10; continue 'dispatch;
	}
	// 828B9B08: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 828B9B0C: 4BAD306D  bl 0x8238cb78
	ctx.lr = 0x828B9B10;
	sub_8238CB78(ctx, base);
	// 828B9B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9B14: C05F0010  lfs f2, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B9B18: C03F0014  lfs f1, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B9B1C: 4800001D  bl 0x828b9b38
	ctx.lr = 0x828B9B20;
	sub_828B9B38(ctx, base);
	// 828B9B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9B38 size=412
    let mut pc: u32 = 0x828B9B38;
    'dispatch: loop {
        match pc {
            0x828B9B38 => {
    //   block [0x828B9B38..0x828B9CD4)
	// 828B9B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9B44: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B9B48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9B4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9B50: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 828B9B54: D021009C  stfs f1, 0x9c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828B9B58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B9B5C: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828B9B60: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9B64: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828B9B68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9B6C: 419A00F4  beq cr6, 0x828b9c60
	if ctx.cr[6].eq {
	pc = 0x828B9C60; continue 'dispatch;
	}
	// 828B9B70: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B9B74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9B78: 419A0024  beq cr6, 0x828b9b9c
	if ctx.cr[6].eq {
	pc = 0x828B9B9C; continue 'dispatch;
	}
	// 828B9B7C: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B9B80: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9B84: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B9B88: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B9B8C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9B90: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9B94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9B98: 480000CC  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
	// 828B9B9C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9BA0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B9BA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B9BA8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B9BAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9BB0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9BB4: 40810054  ble 0x828b9c08
	if !ctx.cr[0].gt {
	pc = 0x828B9C08; continue 'dispatch;
	}
	// 828B9BB8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B9BBC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B9BC0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B9BC4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9BC8: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B9BCC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B9BD0: 41980008  blt cr6, 0x828b9bd8
	if ctx.cr[6].lt {
	pc = 0x828B9BD8; continue 'dispatch;
	}
	// 828B9BD4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B9BD8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B9BDC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B9BE0: 419A0014  beq cr6, 0x828b9bf4
	if ctx.cr[6].eq {
	pc = 0x828B9BF4; continue 'dispatch;
	}
	// 828B9BE4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B9BE8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B9BEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9BF0: 4800000C  b 0x828b9bfc
	pc = 0x828B9BFC; continue 'dispatch;
	// 828B9BF4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B9BF8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B9BFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9C00: 4199FFB8  bgt cr6, 0x828b9bb8
	if ctx.cr[6].gt {
	pc = 0x828B9BB8; continue 'dispatch;
	}
	// 828B9C04: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9C08: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B9C0C: 419A0040  beq cr6, 0x828b9c4c
	if ctx.cr[6].eq {
	pc = 0x828B9C4C; continue 'dispatch;
	}
	// 828B9C10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9C14: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B9C18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C1C: 41990008  bgt cr6, 0x828b9c24
	if ctx.cr[6].gt {
	pc = 0x828B9C24; continue 'dispatch;
	}
	// 828B9C20: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B9C24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9C2C: 409A0020  bne cr6, 0x828b9c4c
	if !ctx.cr[6].eq {
	pc = 0x828B9C4C; continue 'dispatch;
	}
	// 828B9C30: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B9C34: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B9C38: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B9C3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9C40: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9C44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C48: 4800001C  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
	// 828B9C4C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B9C50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9C54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C5C: 48000008  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
	// 828B9C60: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B9C64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9C6C: 419A0050  beq cr6, 0x828b9cbc
	if ctx.cr[6].eq {
	pc = 0x828B9CBC; continue 'dispatch;
	}
	// 828B9C70: 3961009C  addi r11, r1, 0x9c
	ctx.r[11].s64 = ctx.r[1].s64 + 156;
	// 828B9C74: 3941009C  addi r10, r1, 0x9c
	ctx.r[10].s64 = ctx.r[1].s64 + 156;
	// 828B9C78: 392100A4  addi r9, r1, 0xa4
	ctx.r[9].s64 = ctx.r[1].s64 + 164;
	// 828B9C7C: 3901009C  addi r8, r1, 0x9c
	ctx.r[8].s64 = ctx.r[1].s64 + 156;
	// 828B9C80: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9CD8 size=144
    let mut pc: u32 = 0x828B9CD8;
    'dispatch: loop {
        match pc {
            0x828B9CD8 => {
    //   block [0x828B9CD8..0x828B9D68)
	// 828B9CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9CEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B9CF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9CF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B9CF8: 419A0038  beq cr6, 0x828b9d30
	if ctx.cr[6].eq {
	pc = 0x828B9D30; continue 'dispatch;
	}
	// 828B9CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9D00: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828B9D04: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 828B9D08: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828B9D0C: 388A34A0  addi r4, r10, 0x34a0
	ctx.r[4].s64 = ctx.r[10].s64 + 13472;
	// 828B9D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9D14: 4BAF36DD  bl 0x823ad3f0
	ctx.lr = 0x828B9D18;
	sub_823AD3F0(ctx, base);
	// 828B9D18: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B9D1C: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828B9D20: 38892D8C  addi r4, r9, 0x2d8c
	ctx.r[4].s64 = ctx.r[9].s64 + 11660;
	// 828B9D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9D28: 4BAF36C9  bl 0x823ad3f0
	ctx.lr = 0x828B9D2C;
	sub_823AD3F0(ctx, base);
	// 828B9D2C: 48000024  b 0x828b9d50
	pc = 0x828B9D50; continue 'dispatch;
	// 828B9D30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9D34: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828B9D38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B9D3C: 993F000C  stb r9, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 828B9D40: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B9D44: C1AA15A0  lfs f13, 0x15a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B9D48: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B9D4C: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B9D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B9D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9D68 size=92
    let mut pc: u32 = 0x828B9D68;
    'dispatch: loop {
        match pc {
            0x828B9D68 => {
    //   block [0x828B9D68..0x828B9DC4)
	// 828B9D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9D7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B9D80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B9D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9D88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9D8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9D90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B9D94: 4E800421  bctrl
	ctx.lr = 0x828B9D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9D98: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 828B9D9C: 409A0010  bne cr6, 0x828b9dac
	if !ctx.cr[6].eq {
	pc = 0x828B9DAC; continue 'dispatch;
	}
	// 828B9DA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B9DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9DA8: 48000021  bl 0x828b9dc8
	ctx.lr = 0x828B9DAC;
	sub_828B9DC8(ctx, base);
	// 828B9DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B9DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9DC8 size=320
    let mut pc: u32 = 0x828B9DC8;
    'dispatch: loop {
        match pc {
            0x828B9DC8 => {
    //   block [0x828B9DC8..0x828B9F08)
	// 828B9DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9DD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9DD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B9DDC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9DE0: 554957FE  rlwinm r9, r10, 0xa, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x003FFFFFu64;
	// 828B9DE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9DE8: 419A00F4  beq cr6, 0x828b9edc
	if ctx.cr[6].eq {
	pc = 0x828B9EDC; continue 'dispatch;
	}
	// 828B9DEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B9DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9DF4: 419A0024  beq cr6, 0x828b9e18
	if ctx.cr[6].eq {
	pc = 0x828B9E18; continue 'dispatch;
	}
	// 828B9DF8: 894A0016  lbz r10, 0x16(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(22 as u32) ) } as u64;
	// 828B9DFC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9E00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B9E04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B9E08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9E0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9E10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9E14: 480000CC  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
	// 828B9E18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9E1C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B9E20: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828B9E24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B9E28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9E2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9E30: 40810054  ble 0x828b9e84
	if !ctx.cr[0].gt {
	pc = 0x828B9E84; continue 'dispatch;
	}
	// 828B9E34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B9E38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B9E3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B9E40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9E44: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 828B9E48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B9E4C: 41980008  blt cr6, 0x828b9e54
	if ctx.cr[6].lt {
	pc = 0x828B9E54; continue 'dispatch;
	}
	// 828B9E50: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B9E54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B9E58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B9E5C: 419A0014  beq cr6, 0x828b9e70
	if ctx.cr[6].eq {
	pc = 0x828B9E70; continue 'dispatch;
	}
	// 828B9E60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B9E64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B9E68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9E6C: 4800000C  b 0x828b9e78
	pc = 0x828B9E78; continue 'dispatch;
	// 828B9E70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B9E74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B9E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9E7C: 4199FFB8  bgt cr6, 0x828b9e34
	if ctx.cr[6].gt {
	pc = 0x828B9E34; continue 'dispatch;
	}
	// 828B9E80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9E84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B9E88: 419A0040  beq cr6, 0x828b9ec8
	if ctx.cr[6].eq {
	pc = 0x828B9EC8; continue 'dispatch;
	}
	// 828B9E8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9E90: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 828B9E94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9E98: 41990008  bgt cr6, 0x828b9ea0
	if ctx.cr[6].gt {
	pc = 0x828B9EA0; continue 'dispatch;
	}
	// 828B9E9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B9EA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9EA8: 409A0020  bne cr6, 0x828b9ec8
	if !ctx.cr[6].eq {
	pc = 0x828B9EC8; continue 'dispatch;
	}
	// 828B9EAC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B9EB0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B9EB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B9EB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9EBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9EC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9EC4: 4800001C  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
	// 828B9EC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B9ECC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9ED0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9ED4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9ED8: 48000008  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
	// 828B9EDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B9EE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9EE8: 419A0010  beq cr6, 0x828b9ef8
	if ctx.cr[6].eq {
	pc = 0x828B9EF8; continue 'dispatch;
	}
	// 828B9EEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9EF0: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B9EF4: 4BD35745  bl 0x825ef638
	ctx.lr = 0x828B9EF8;
	sub_825EF638(ctx, base);
	// 828B9EF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9EFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9F00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9F08 size=204
    let mut pc: u32 = 0x828B9F08;
    'dispatch: loop {
        match pc {
            0x828B9F08 => {
    //   block [0x828B9F08..0x828B9FD4)
	// 828B9F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9F18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9F1C: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B9F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9F28: 419A0028  beq cr6, 0x828b9f50
	if ctx.cr[6].eq {
	pc = 0x828B9F50; continue 'dispatch;
	}
	// 828B9F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F30: 4B920481  bl 0x821da3b0
	ctx.lr = 0x828B9F34;
	sub_821DA3B0(ctx, base);
	// 828B9F34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B9F38: 38AB2D60  addi r5, r11, 0x2d60
	ctx.r[5].s64 = ctx.r[11].s64 + 11616;
	// 828B9F3C: 4B8F85BD  bl 0x821b24f8
	ctx.lr = 0x828B9F40;
	sub_821B24F8(ctx, base);
	// 828B9F40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B9F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9F48: 4BEC94D1  bl 0x82783418
	ctx.lr = 0x828B9F4C;
	sub_82783418(ctx, base);
	// 828B9F4C: 4800006C  b 0x828b9fb8
	pc = 0x828B9FB8; continue 'dispatch;
	// 828B9F50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9F54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9F58: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828B9F5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F60: 4B972F71  bl 0x8222ced0
	ctx.lr = 0x828B9F64;
	sub_8222CED0(ctx, base);
	// 828B9F64: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B9F68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B9F6C: 388A2D94  addi r4, r10, 0x2d94
	ctx.r[4].s64 = ctx.r[10].s64 + 11668;
	// 828B9F70: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9F78: 4B972F59  bl 0x8222ced0
	ctx.lr = 0x828B9F7C;
	sub_8222CED0(ctx, base);
	// 828B9F7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B9F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9F84: 4B932875  bl 0x821ec7f8
	ctx.lr = 0x828B9F88;
	sub_821EC7F8(ctx, base);
	// 828B9F88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B9F8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9F90: 4B934BA9  bl 0x821eeb38
	ctx.lr = 0x828B9F94;
	sub_821EEB38(ctx, base);
	// 828B9F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9F98: 48349859  bl 0x82c037f0
	ctx.lr = 0x828B9F9C;
	sub_82C037F0(ctx, base);
	// 828B9F9C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828B9FA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9FA4: 4B95AE35  bl 0x82214dd8
	ctx.lr = 0x828B9FA8;
	sub_82214DD8(ctx, base);
	// 828B9FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9FAC: 4B95AE2D  bl 0x82214dd8
	ctx.lr = 0x828B9FB0;
	sub_82214DD8(ctx, base);
	// 828B9FB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9FB4: 4B95AE25  bl 0x82214dd8
	ctx.lr = 0x828B9FB8;
	sub_82214DD8(ctx, base);
	// 828B9FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9FBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B9FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9FD8 size=204
    let mut pc: u32 = 0x828B9FD8;
    'dispatch: loop {
        match pc {
            0x828B9FD8 => {
    //   block [0x828B9FD8..0x828BA0A4)
	// 828B9FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9FE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9FE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9FE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9FEC: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B9FF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9FF8: 419A0028  beq cr6, 0x828ba020
	if ctx.cr[6].eq {
	pc = 0x828BA020; continue 'dispatch;
	}
	// 828B9FFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA000: 4B9203B1  bl 0x821da3b0
	ctx.lr = 0x828BA004;
	sub_821DA3B0(ctx, base);
	// 828BA004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BA008: 38AB2D70  addi r5, r11, 0x2d70
	ctx.r[5].s64 = ctx.r[11].s64 + 11632;
	// 828BA00C: 4B8F84ED  bl 0x821b24f8
	ctx.lr = 0x828BA010;
	sub_821B24F8(ctx, base);
	// 828BA010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BA014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA018: 4BEC9401  bl 0x82783418
	ctx.lr = 0x828BA01C;
	sub_82783418(ctx, base);
	// 828BA01C: 4800006C  b 0x828ba088
	pc = 0x828BA088; continue 'dispatch;
	// 828BA020: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BA024: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA028: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828BA02C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA030: 4B972EA1  bl 0x8222ced0
	ctx.lr = 0x828BA034;
	sub_8222CED0(ctx, base);
	// 828BA034: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BA038: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA03C: 388A2DC4  addi r4, r10, 0x2dc4
	ctx.r[4].s64 = ctx.r[10].s64 + 11716;
	// 828BA040: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA048: 4B972E89  bl 0x8222ced0
	ctx.lr = 0x828BA04C;
	sub_8222CED0(ctx, base);
	// 828BA04C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BA050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA054: 4B9327A5  bl 0x821ec7f8
	ctx.lr = 0x828BA058;
	sub_821EC7F8(ctx, base);
	// 828BA058: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA05C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA060: 4B934AD9  bl 0x821eeb38
	ctx.lr = 0x828BA064;
	sub_821EEB38(ctx, base);
	// 828BA064: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA068: 48349789  bl 0x82c037f0
	ctx.lr = 0x828BA06C;
	sub_82C037F0(ctx, base);
	// 828BA06C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828BA070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA074: 4B95AD65  bl 0x82214dd8
	ctx.lr = 0x828BA078;
	sub_82214DD8(ctx, base);
	// 828BA078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA07C: 4B95AD5D  bl 0x82214dd8
	ctx.lr = 0x828BA080;
	sub_82214DD8(ctx, base);
	// 828BA080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA084: 4B95AD55  bl 0x82214dd8
	ctx.lr = 0x828BA088;
	sub_82214DD8(ctx, base);
	// 828BA088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA08C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BA09C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA0A8 size=204
    let mut pc: u32 = 0x828BA0A8;
    'dispatch: loop {
        match pc {
            0x828BA0A8 => {
    //   block [0x828BA0A8..0x828BA174)
	// 828BA0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA0B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BA0B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA0B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA0BC: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BA0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA0C8: 419A0028  beq cr6, 0x828ba0f0
	if ctx.cr[6].eq {
	pc = 0x828BA0F0; continue 'dispatch;
	}
	// 828BA0CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA0D0: 4B9202E1  bl 0x821da3b0
	ctx.lr = 0x828BA0D4;
	sub_821DA3B0(ctx, base);
	// 828BA0D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BA0D8: 38AB2D80  addi r5, r11, 0x2d80
	ctx.r[5].s64 = ctx.r[11].s64 + 11648;
	// 828BA0DC: 4B8F841D  bl 0x821b24f8
	ctx.lr = 0x828BA0E0;
	sub_821B24F8(ctx, base);
	// 828BA0E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BA0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA0E8: 4BEC9331  bl 0x82783418
	ctx.lr = 0x828BA0EC;
	sub_82783418(ctx, base);
	// 828BA0EC: 4800006C  b 0x828ba158
	pc = 0x828BA158; continue 'dispatch;
	// 828BA0F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BA0F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA0F8: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828BA0FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA100: 4B972DD1  bl 0x8222ced0
	ctx.lr = 0x828BA104;
	sub_8222CED0(ctx, base);
	// 828BA104: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BA108: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA10C: 388A2DF8  addi r4, r10, 0x2df8
	ctx.r[4].s64 = ctx.r[10].s64 + 11768;
	// 828BA110: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA118: 4B972DB9  bl 0x8222ced0
	ctx.lr = 0x828BA11C;
	sub_8222CED0(ctx, base);
	// 828BA11C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BA120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA124: 4B9326D5  bl 0x821ec7f8
	ctx.lr = 0x828BA128;
	sub_821EC7F8(ctx, base);
	// 828BA128: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA12C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA130: 4B934A09  bl 0x821eeb38
	ctx.lr = 0x828BA134;
	sub_821EEB38(ctx, base);
	// 828BA134: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA138: 483496B9  bl 0x82c037f0
	ctx.lr = 0x828BA13C;
	sub_82C037F0(ctx, base);
	// 828BA13C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828BA140: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA144: 4B95AC95  bl 0x82214dd8
	ctx.lr = 0x828BA148;
	sub_82214DD8(ctx, base);
	// 828BA148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA14C: 4B95AC8D  bl 0x82214dd8
	ctx.lr = 0x828BA150;
	sub_82214DD8(ctx, base);
	// 828BA150: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA154: 4B95AC85  bl 0x82214dd8
	ctx.lr = 0x828BA158;
	sub_82214DD8(ctx, base);
	// 828BA158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA15C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BA16C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA178 size=3192
    let mut pc: u32 = 0x828BA178;
    'dispatch: loop {
        match pc {
            0x828BA178 => {
    //   block [0x828BA178..0x828BADF0)
	// 828BA178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA17C: 483EF281  bl 0x82ca93fc
	ctx.lr = 0x828BA180;
	sub_82CA93D0(ctx, base);
	// 828BA180: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828BA184: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA188: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BA18C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BA190: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BA194: 419A0018  beq cr6, 0x828ba1ac
	if ctx.cr[6].eq {
	pc = 0x828BA1AC; continue 'dispatch;
	}
	// 828BA198: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BA19C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BA1A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA1A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA1A8: 409A0008  bne cr6, 0x828ba1b0
	if !ctx.cr[6].eq {
	pc = 0x828BA1B0; continue 'dispatch;
	}
	// 828BA1AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BA1B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA1B8: 419A0C2C  beq cr6, 0x828bade4
	if ctx.cr[6].eq {
	pc = 0x828BADE4; continue 'dispatch;
	}
	// 828BA1BC: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BA1C0: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828BA1C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA1C8: 419A05D4  beq cr6, 0x828ba79c
	if ctx.cr[6].eq {
	pc = 0x828BA79C; continue 'dispatch;
	}
	// 828BA1CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BA1D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA1D4: 3BAB2E2C  addi r29, r11, 0x2e2c
	ctx.r[29].s64 = ctx.r[11].s64 + 11820;
	// 828BA1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BA1DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BA1E0: 4B972CF1  bl 0x8222ced0
	ctx.lr = 0x828BA1E4;
	sub_8222CED0(ctx, base);
	// 828BA1E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BA1E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA1EC: 3B8B7564  addi r28, r11, 0x7564
	ctx.r[28].s64 = ctx.r[11].s64 + 30052;
	// 828BA1F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BA1F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BA1F8: 4B972CD9  bl 0x8222ced0
	ctx.lr = 0x828BA1FC;
	sub_8222CED0(ctx, base);
	// 828BA1FC: 809A007C  lwz r4, 0x7c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BA200: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828BA204: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA208: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BA20C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BA210: 4E800421  bctrl
	ctx.lr = 0x828BA214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA214: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 828BA218: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 828BA21C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BA220: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BA224: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828BA228: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BADF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BADF0 size=316
    let mut pc: u32 = 0x828BADF0;
    'dispatch: loop {
        match pc {
            0x828BADF0 => {
    //   block [0x828BADF0..0x828BAF2C)
	// 828BADF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BADF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BADF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BADFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BAE00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAE04: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BAE08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BAE0C: 3BCB2E50  addi r30, r11, 0x2e50
	ctx.r[30].s64 = ctx.r[11].s64 + 11856;
	// 828BAE10: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE1C: 4B9720B5  bl 0x8222ced0
	ctx.lr = 0x828BAE20;
	sub_8222CED0(ctx, base);
	// 828BAE20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAE28: 48000109  bl 0x828baf30
	ctx.lr = 0x828BAE2C;
	sub_828BAF30(ctx, base);
	// 828BAE2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE30: 4B959FA9  bl 0x82214dd8
	ctx.lr = 0x828BAE34;
	sub_82214DD8(ctx, base);
	// 828BAE34: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828BAE38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE3C: 388A3118  addi r4, r10, 0x3118
	ctx.r[4].s64 = ctx.r[10].s64 + 12568;
	// 828BAE40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAE44: 4B97208D  bl 0x8222ced0
	ctx.lr = 0x828BAE48;
	sub_8222CED0(ctx, base);
	// 828BAE48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE54: 4B97207D  bl 0x8222ced0
	ctx.lr = 0x828BAE58;
	sub_8222CED0(ctx, base);
	// 828BAE58: 3D20828A  lis r9, -0x7d76
	ctx.r[9].s64 = -2104885248;
	// 828BAE5C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828BAE60: 38C93120  addi r6, r9, 0x3120
	ctx.r[6].s64 = ctx.r[9].s64 + 12576;
	// 828BAE64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAE6C: 4800030D  bl 0x828bb178
	ctx.lr = 0x828BAE70;
	sub_828BB178(ctx, base);
	// 828BAE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE74: 4B959F65  bl 0x82214dd8
	ctx.lr = 0x828BAE78;
	sub_82214DD8(ctx, base);
	// 828BAE78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAE7C: 4B959F5D  bl 0x82214dd8
	ctx.lr = 0x828BAE80;
	sub_82214DD8(ctx, base);
	// 828BAE80: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828BAE84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE88: 38882E60  addi r4, r8, 0x2e60
	ctx.r[4].s64 = ctx.r[8].s64 + 11872;
	// 828BAE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE90: 4B972041  bl 0x8222ced0
	ctx.lr = 0x828BAE94;
	sub_8222CED0(ctx, base);
	// 828BAE94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEA0: 4B972031  bl 0x8222ced0
	ctx.lr = 0x828BAEA4;
	sub_8222CED0(ctx, base);
	// 828BAEA4: 3CE08295  lis r7, -0x7d6b
	ctx.r[7].s64 = -2104164352;
	// 828BAEA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BAEAC: 38C795D0  addi r6, r7, -0x6a30
	ctx.r[6].s64 = ctx.r[7].s64 + -27184;
	// 828BAEB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BAEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAEB8: 480002C1  bl 0x828bb178
	ctx.lr = 0x828BAEBC;
	sub_828BB178(ctx, base);
	// 828BAEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEC0: 4B959F19  bl 0x82214dd8
	ctx.lr = 0x828BAEC4;
	sub_82214DD8(ctx, base);
	// 828BAEC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAEC8: 4B959F11  bl 0x82214dd8
	ctx.lr = 0x828BAECC;
	sub_82214DD8(ctx, base);
	// 828BAECC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAED4: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAED8: 4BB136E9  bl 0x823ce5c0
	ctx.lr = 0x828BAEDC;
	sub_823CE5C0(ctx, base);
	// 828BAEDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BAEE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAEE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEE8: 4BB13319  bl 0x823ce200
	ctx.lr = 0x828BAEEC;
	sub_823CE200(ctx, base);
	// 828BAEEC: 3CA0828C  lis r5, -0x7d74
	ctx.r[5].s64 = -2104754176;
	// 828BAEF0: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828BAEF4: 38A5A178  addi r5, r5, -0x5e88
	ctx.r[5].s64 = ctx.r[5].s64 + -24200;
	// 828BAEF8: 38842E68  addi r4, r4, 0x2e68
	ctx.r[4].s64 = ctx.r[4].s64 + 11880;
	// 828BAEFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAF00: 4BA4E511  bl 0x82309410
	ctx.lr = 0x828BAF04;
	sub_82309410(ctx, base);
	// 828BAF04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAF08: 4B8FCC11  bl 0x821b7b18
	ctx.lr = 0x828BAF0C;
	sub_821B7B18(ctx, base);
	// 828BAF0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAF10: 4B8FCC09  bl 0x821b7b18
	ctx.lr = 0x828BAF14;
	sub_821B7B18(ctx, base);
	// 828BAF14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BAF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BAF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BAF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BAF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BAF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BAF30 size=584
    let mut pc: u32 = 0x828BAF30;
    'dispatch: loop {
        match pc {
            0x828BAF30 => {
    //   block [0x828BAF30..0x828BB178)
	// 828BAF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAF34: 483EE4CD  bl 0x82ca9400
	ctx.lr = 0x828BAF38;
	sub_82CA93D0(ctx, base);
	// 828BAF38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAF3C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAF40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BAF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAF48: 409A0010  bne cr6, 0x828baf58
	if !ctx.cr[6].eq {
	pc = 0x828BAF58; continue 'dispatch;
	}
	// 828BAF4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BAF50: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828BAF54: 48000008  b 0x828baf5c
	pc = 0x828BAF5C; continue 'dispatch;
	// 828BAF58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAF5C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAF60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAF64: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAF68: 4BB13659  bl 0x823ce5c0
	ctx.lr = 0x828BAF6C;
	sub_823CE5C0(ctx, base);
	// 828BAF6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BAF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAF74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BAF78: 4BB13289  bl 0x823ce200
	ctx.lr = 0x828BAF7C;
	sub_823CE200(ctx, base);
	// 828BAF7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAF80: 4B8FCB99  bl 0x821b7b18
	ctx.lr = 0x828BAF84;
	sub_821B7B18(ctx, base);
	// 828BAF84: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828BAF88: 4B9642D1  bl 0x8221f258
	ctx.lr = 0x828BAF8C;
	sub_8221F258(ctx, base);
	// 828BAF8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BAF90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BAF94: 419A0040  beq cr6, 0x828bafd4
	if ctx.cr[6].eq {
	pc = 0x828BAFD4; continue 'dispatch;
	}
	// 828BAF98: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828BAF9C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828BAFA0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828BAFA4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BAFA8: 4B9642B1  bl 0x8221f258
	ctx.lr = 0x828BAFAC;
	sub_8221F258(ctx, base);
	// 828BAFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BAFB0: 419A0028  beq cr6, 0x828bafd8
	if ctx.cr[6].eq {
	pc = 0x828BAFD8; continue 'dispatch;
	}
	// 828BAFB4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828BAFB8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BAFBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BAFC0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828BAFC4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BAFC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BAFCC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828BAFD0: 4800000C  b 0x828bafdc
	pc = 0x828BAFDC; continue 'dispatch;
	// 828BAFD4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BAFD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BAFDC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BAFE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BAFE4: 419A00FC  beq cr6, 0x828bb0e0
	if ctx.cr[6].eq {
	pc = 0x828BB0E0; continue 'dispatch;
	}
	// 828BAFE8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAFEC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BAFF0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAFF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BAFF8: 4B96E111  bl 0x82229108
	ctx.lr = 0x828BAFFC;
	sub_82229108(ctx, base);
	// 828BAFFC: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828BB000: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB004: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB008: 3BCBB378  addi r30, r11, -0x4c88
	ctx.r[30].s64 = ctx.r[11].s64 + -19592;
	// 828BB00C: 4B96C875  bl 0x82227880
	ctx.lr = 0x828BB010;
	sub_82227880(ctx, base);
	// 828BB010: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BB014: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828BB018: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB01C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828BB020: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB024: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BB028: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BB02C: 4B8DFA55  bl 0x8219aa80
	ctx.lr = 0x828BB030;
	sub_8219AA80(ctx, base);
	// 828BB030: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828BB034: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BB038: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828BB03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB040: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BB044: 4BB133DD  bl 0x823ce420
	ctx.lr = 0x828BB048;
	sub_823CE420(ctx, base);
	// 828BB048: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BB04C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB050: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB054: 48169675  bl 0x82a246c8
	ctx.lr = 0x828BB058;
	sub_82A246C8(ctx, base);
	// 828BB058: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB05C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BB060: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828BB064: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828BB068: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB06C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB074: 4B96E095  bl 0x82229108
	ctx.lr = 0x828BB078;
	sub_82229108(ctx, base);
	// 828BB078: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 828BB07C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB084: 3BEB2268  addi r31, r11, 0x2268
	ctx.r[31].s64 = ctx.r[11].s64 + 8808;
	// 828BB088: 4B96C7F9  bl 0x82227880
	ctx.lr = 0x828BB08C;
	sub_82227880(ctx, base);
	// 828BB08C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828BB090: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828BB094: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB098: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828BB09C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB0A0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BB0A4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB0A8: 4B8DF9D9  bl 0x8219aa80
	ctx.lr = 0x828BB0AC;
	sub_8219AA80(ctx, base);
	// 828BB0AC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828BB0B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB0B4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828BB0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB0BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB0C0: 4BB13361  bl 0x823ce420
	ctx.lr = 0x828BB0C4;
	sub_823CE420(ctx, base);
	// 828BB0C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB0C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB0CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB0D0: 481695F9  bl 0x82a246c8
	ctx.lr = 0x828BB0D4;
	sub_82A246C8(ctx, base);
	// 828BB0D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB0D8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828BB0DC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828BB0E0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828BB0E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BB0E8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828BB0EC: 419A0020  beq cr6, 0x828bb10c
	if ctx.cr[6].eq {
	pc = 0x828BB10C; continue 'dispatch;
	}
	// 828BB0F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB0F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB0F8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB0FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BB100: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB104: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB108: 4082FFE8  bne 0x828bb0f0
	if !ctx.cr[0].eq {
	pc = 0x828BB0F0; continue 'dispatch;
	}
	// 828BB10C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB110: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BB114: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828BB118: 4BA3A831  bl 0x822f5948
	ctx.lr = 0x828BB11C;
	sub_822F5948(ctx, base);
	// 828BB11C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB120: 4B8FC9F9  bl 0x821b7b18
	ctx.lr = 0x828BB124;
	sub_821B7B18(ctx, base);
	// 828BB124: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BB128: 419A0040  beq cr6, 0x828bb168
	if ctx.cr[6].eq {
	pc = 0x828BB168; continue 'dispatch;
	}
	// 828BB12C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB130: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB134: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB138: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB13C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB140: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB144: 4082FFE8  bne 0x828bb12c
	if !ctx.cr[0].eq {
	pc = 0x828BB12C; continue 'dispatch;
	}
	// 828BB148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB14C: 409A001C  bne cr6, 0x828bb168
	if !ctx.cr[6].eq {
	pc = 0x828BB168; continue 'dispatch;
	}
	// 828BB150: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB154: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB15C: 4E800421  bctrl
	ctx.lr = 0x828BB160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BB164: 4B960BD5  bl 0x8221bd38
	ctx.lr = 0x828BB168;
	sub_8221BD38(ctx, base);
	// 828BB168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB16C: 4B8FC9AD  bl 0x821b7b18
	ctx.lr = 0x828BB170;
	sub_821B7B18(ctx, base);
	// 828BB170: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BB174: 483EE2DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB178 size=512
    let mut pc: u32 = 0x828BB178;
    'dispatch: loop {
        match pc {
            0x828BB178 => {
    //   block [0x828BB178..0x828BB378)
	// 828BB178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB17C: 483EE281  bl 0x82ca93fc
	ctx.lr = 0x828BB180;
	sub_82CA93D0(ctx, base);
	// 828BB180: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB188: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BB18C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828BB190: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828BB194: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BB198: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB19C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828BB1A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BB1A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB1A8: 419A0008  beq cr6, 0x828bb1b0
	if ctx.cr[6].eq {
	pc = 0x828BB1B0; continue 'dispatch;
	}
	// 828BB1AC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB1B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB1B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BB1B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB1BC: 4BB13405  bl 0x823ce5c0
	ctx.lr = 0x828BB1C0;
	sub_823CE5C0(ctx, base);
	// 828BB1C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BB1C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB1C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB1CC: 4BB12F45  bl 0x823ce110
	ctx.lr = 0x828BB1D0;
	sub_823CE110(ctx, base);
	// 828BB1D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BB1D4: 4B8FC945  bl 0x821b7b18
	ctx.lr = 0x828BB1D8;
	sub_821B7B18(ctx, base);
	// 828BB1D8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BB1DC: 4B96407D  bl 0x8221f258
	ctx.lr = 0x828BB1E0;
	sub_8221F258(ctx, base);
	// 828BB1E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB1E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BB1E8: 419A005C  beq cr6, 0x828bb244
	if ctx.cr[6].eq {
	pc = 0x828BB244; continue 'dispatch;
	}
	// 828BB1EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BB1F0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BB1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BB1F8: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828BB1FC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BB200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB204: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB208: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828BB20C: 4B935035  bl 0x821f0240
	ctx.lr = 0x828BB210;
	sub_821F0240(ctx, base);
	// 828BB210: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828BB214: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BB218: 4B964041  bl 0x8221f258
	ctx.lr = 0x828BB21C;
	sub_8221F258(ctx, base);
	// 828BB21C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB220: 419A0028  beq cr6, 0x828bb248
	if ctx.cr[6].eq {
	pc = 0x828BB248; continue 'dispatch;
	}
	// 828BB224: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828BB228: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB22C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB230: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828BB234: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB238: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BB23C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828BB240: 4800000C  b 0x828bb24c
	pc = 0x828BB24C; continue 'dispatch;
	// 828BB244: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BB248: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BB24C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB250: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BB254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB258: 419A0008  beq cr6, 0x828bb260
	if ctx.cr[6].eq {
	pc = 0x828BB260; continue 'dispatch;
	}
	// 828BB25C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB260: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BB264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB268: 419A0078  beq cr6, 0x828bb2e0
	if ctx.cr[6].eq {
	pc = 0x828BB2E0; continue 'dispatch;
	}
	// 828BB26C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB270: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BB274: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB278: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB27C: 4B96DE8D  bl 0x82229108
	ctx.lr = 0x828BB280;
	sub_82229108(ctx, base);
	// 828BB280: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828BB284: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB288: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB28C: 3BCBB3B8  addi r30, r11, -0x4c48
	ctx.r[30].s64 = ctx.r[11].s64 + -19528;
	// 828BB290: 4B96C5F1  bl 0x82227880
	ctx.lr = 0x828BB294;
	sub_82227880(ctx, base);
	// 828BB294: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BB298: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828BB29C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB2A0: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828BB2A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB2A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828BB2AC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BB2B0: 4B8DF7D1  bl 0x8219aa80
	ctx.lr = 0x828BB2B4;
	sub_8219AA80(ctx, base);
	// 828BB2B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB2B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BB2BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB2C0: 4BB13161  bl 0x823ce420
	ctx.lr = 0x828BB2C4;
	sub_823CE420(ctx, base);
	// 828BB2C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB2C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB2CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB2D0: 481693F9  bl 0x82a246c8
	ctx.lr = 0x828BB2D4;
	sub_82A246C8(ctx, base);
	// 828BB2D4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB2D8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828BB2DC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828BB2E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828BB2E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BB2E8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BB2EC: 419A0020  beq cr6, 0x828bb30c
	if ctx.cr[6].eq {
	pc = 0x828BB30C; continue 'dispatch;
	}
	// 828BB2F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB2F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB2F8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB2FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BB300: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB304: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB308: 4082FFE8  bne 0x828bb2f0
	if !ctx.cr[0].eq {
	pc = 0x828BB2F0; continue 'dispatch;
	}
	// 828BB30C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB314: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828BB318: 4BA3A631  bl 0x822f5948
	ctx.lr = 0x828BB31C;
	sub_822F5948(ctx, base);
	// 828BB31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB320: 4B8FC7F9  bl 0x821b7b18
	ctx.lr = 0x828BB324;
	sub_821B7B18(ctx, base);
	// 828BB324: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BB328: 419A0040  beq cr6, 0x828bb368
	if ctx.cr[6].eq {
	pc = 0x828BB368; continue 'dispatch;
	}
	// 828BB32C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB330: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB334: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB338: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB33C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB340: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB344: 4082FFE8  bne 0x828bb32c
	if !ctx.cr[0].eq {
	pc = 0x828BB32C; continue 'dispatch;
	}
	// 828BB348: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB34C: 409A001C  bne cr6, 0x828bb368
	if !ctx.cr[6].eq {
	pc = 0x828BB368; continue 'dispatch;
	}
	// 828BB350: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB354: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB35C: 4E800421  bctrl
	ctx.lr = 0x828BB360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BB364: 4B9609D5  bl 0x8221bd38
	ctx.lr = 0x828BB368;
	sub_8221BD38(ctx, base);
	// 828BB368: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB36C: 4B8FC7AD  bl 0x821b7b18
	ctx.lr = 0x828BB370;
	sub_821B7B18(ctx, base);
	// 828BB370: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BB374: 483EE0D8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BB378 size=56
    let mut pc: u32 = 0x828BB378;
    'dispatch: loop {
        match pc {
            0x828BB378 => {
    //   block [0x828BB378..0x828BB3B0)
	// 828BB378: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB37C: 419A0018  beq cr6, 0x828bb394
	if ctx.cr[6].eq {
	pc = 0x828BB394; continue 'dispatch;
	}
	// 828BB380: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BB384: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB38C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB390: 409A0008  bne cr6, 0x828bb398
	if !ctx.cr[6].eq {
	pc = 0x828BB398; continue 'dispatch;
	}
	// 828BB394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB3A0: 419A0010  beq cr6, 0x828bb3b0
	if ctx.cr[6].eq {
		sub_828BB3B0(ctx, base);
		return;
	}
	// 828BB3A4: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BB3A8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828BB3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BB3B0 size=8
    let mut pc: u32 = 0x828BB3B0;
    'dispatch: loop {
        match pc {
            0x828BB3B0 => {
    //   block [0x828BB3B0..0x828BB3B8)
	// 828BB3B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BB3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BB3B8 size=380
    let mut pc: u32 = 0x828BB3B8;
    'dispatch: loop {
        match pc {
            0x828BB3B8 => {
    //   block [0x828BB3B8..0x828BB534)
	// 828BB3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB3C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB3C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB3C8: 419A0018  beq cr6, 0x828bb3e0
	if ctx.cr[6].eq {
	pc = 0x828BB3E0; continue 'dispatch;
	}
	// 828BB3CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BB3D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB3D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB3D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB3DC: 409A0008  bne cr6, 0x828bb3e4
	if !ctx.cr[6].eq {
	pc = 0x828BB3E4; continue 'dispatch;
	}
	// 828BB3E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB3E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB3EC: 419A0130  beq cr6, 0x828bb51c
	if ctx.cr[6].eq {
	pc = 0x828BB51C; continue 'dispatch;
	}
	// 828BB3F0: 81440040  lwz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BB3F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB3F8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828BB3FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BB400: 419A00EC  beq cr6, 0x828bb4ec
	if ctx.cr[6].eq {
	pc = 0x828BB4EC; continue 'dispatch;
	}
	// 828BB404: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BB408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB40C: 419A0020  beq cr6, 0x828bb42c
	if ctx.cr[6].eq {
	pc = 0x828BB42C; continue 'dispatch;
	}
	// 828BB410: 894B00E5  lbz r10, 0xe5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(229 as u32) ) } as u64;
	// 828BB414: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BB418: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BB41C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BB420: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB424: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB428: 480000C8  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
	// 828BB42C: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB434: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BB438: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BB43C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BB440: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BB444: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB448: 40810054  ble 0x828bb49c
	if !ctx.cr[0].gt {
	pc = 0x828BB49C; continue 'dispatch;
	}
	// 828BB44C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BB450: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BB454: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BB458: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB45C: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 828BB460: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BB464: 41980008  blt cr6, 0x828bb46c
	if ctx.cr[6].lt {
	pc = 0x828BB46C; continue 'dispatch;
	}
	// 828BB468: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BB46C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BB470: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BB474: 419A0014  beq cr6, 0x828bb488
	if ctx.cr[6].eq {
	pc = 0x828BB488; continue 'dispatch;
	}
	// 828BB478: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BB47C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BB480: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB484: 4800000C  b 0x828bb490
	pc = 0x828BB490; continue 'dispatch;
	// 828BB488: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BB48C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BB490: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB494: 4199FFB8  bgt cr6, 0x828bb44c
	if ctx.cr[6].gt {
	pc = 0x828BB44C; continue 'dispatch;
	}
	// 828BB498: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BB49C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BB4A0: 419A003C  beq cr6, 0x828bb4dc
	if ctx.cr[6].eq {
	pc = 0x828BB4DC; continue 'dispatch;
	}
	// 828BB4A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB4A8: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 828BB4AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB4B0: 41990008  bgt cr6, 0x828bb4b8
	if ctx.cr[6].gt {
	pc = 0x828BB4B8; continue 'dispatch;
	}
	// 828BB4B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB4B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB4C0: 409A001C  bne cr6, 0x828bb4dc
	if !ctx.cr[6].eq {
	pc = 0x828BB4DC; continue 'dispatch;
	}
	// 828BB4C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BB4C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB4CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828BB4D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB4D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB4D8: 48000018  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
	// 828BB4DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BB4E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB4E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB4E8: 48000008  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
	// 828BB4EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BB4F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828BB4F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB4F8: 419A0024  beq cr6, 0x828bb51c
	if ctx.cr[6].eq {
	pc = 0x828BB51C; continue 'dispatch;
	}
	// 828BB4FC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB500: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BB504: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB508: 4E800421  bctrl
	ctx.lr = 0x828BB50C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB50C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BB510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB518: 4E800020  blr
	return;
	// 828BB51C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BB520: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BB524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BB528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB538 size=80
    let mut pc: u32 = 0x828BB538;
    'dispatch: loop {
        match pc {
            0x828BB538 => {
    //   block [0x828BB538..0x828BB588)
	// 828BB538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB54C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB550: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB554: 48000035  bl 0x828bb588
	ctx.lr = 0x828BB558;
	sub_828BB588(ctx, base);
	// 828BB558: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828BB55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB564: 419A000C  beq cr6, 0x828bb570
	if ctx.cr[6].eq {
	pc = 0x828BB570; continue 'dispatch;
	}
	// 828BB568: 4B9607D1  bl 0x8221bd38
	ctx.lr = 0x828BB56C;
	sub_8221BD38(ctx, base);
	// 828BB56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB57C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB588 size=272
    let mut pc: u32 = 0x828BB588;
    'dispatch: loop {
        match pc {
            0x828BB588 => {
    //   block [0x828BB588..0x828BB698)
	// 828BB588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB58C: 483EDE81  bl 0x82ca940c
	ctx.lr = 0x828BB590;
	sub_82CA93D0(ctx, base);
	// 828BB590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB598: 387E003C  addi r3, r30, 0x3c
	ctx.r[3].s64 = ctx.r[30].s64 + 60;
	// 828BB59C: 4BDB52ED  bl 0x82670888
	ctx.lr = 0x828BB5A0;
	sub_82670888(ctx, base);
	// 828BB5A0: 809E002C  lwz r4, 0x2c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BB5A4: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 828BB5A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB5AC: 419A0018  beq cr6, 0x828bb5c4
	if ctx.cr[6].eq {
	pc = 0x828BB5C4; continue 'dispatch;
	}
	// 828BB5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB5B4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB5B8: 48000F09  bl 0x828bc4c0
	ctx.lr = 0x828BB5BC;
	sub_828BC4C0(ctx, base);
	// 828BB5BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB5C0: 4B960779  bl 0x8221bd38
	ctx.lr = 0x828BB5C4;
	sub_8221BD38(ctx, base);
	// 828BB5C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BB5C8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828BB5CC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BB5D0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828BB5D4: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BB5D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB5DC: 419A0040  beq cr6, 0x828bb61c
	if ctx.cr[6].eq {
	pc = 0x828BB61C; continue 'dispatch;
	}
	// 828BB5E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 828BB5E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB5E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB5EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB5F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB5F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB5F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB5FC: 4082FFE8  bne 0x828bb5e4
	if !ctx.cr[0].eq {
	pc = 0x828BB5E4; continue 'dispatch;
	}
	// 828BB600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB604: 409A0014  bne cr6, 0x828bb618
	if !ctx.cr[6].eq {
	pc = 0x828BB618; continue 'dispatch;
	}
	// 828BB608: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB60C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB614: 4E800421  bctrl
	ctx.lr = 0x828BB618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB618: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 828BB61C: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BB620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB624: 419A0040  beq cr6, 0x828bb664
	if ctx.cr[6].eq {
	pc = 0x828BB664; continue 'dispatch;
	}
	// 828BB628: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 828BB62C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB630: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB634: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB638: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB63C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB640: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB644: 4082FFE8  bne 0x828bb62c
	if !ctx.cr[0].eq {
	pc = 0x828BB62C; continue 'dispatch;
	}
	// 828BB648: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB64C: 409A0014  bne cr6, 0x828bb660
	if !ctx.cr[6].eq {
	pc = 0x828BB660; continue 'dispatch;
	}
	// 828BB650: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB654: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB658: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB65C: 4E800421  bctrl
	ctx.lr = 0x828BB660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB660: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 828BB664: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828BB668: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB66C: 394B2B98  addi r10, r11, 0x2b98
	ctx.r[10].s64 = ctx.r[11].s64 + 11160;
	// 828BB670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB674: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB678: 419A000C  beq cr6, 0x828bb684
	if ctx.cr[6].eq {
	pc = 0x828BB684; continue 'dispatch;
	}
	// 828BB67C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB680: 48168199  bl 0x82a23818
	ctx.lr = 0x828BB684;
	sub_82A23818(ctx, base);
	// 828BB684: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BB688: 394B0FD0  addi r10, r11, 0xfd0
	ctx.r[10].s64 = ctx.r[11].s64 + 4048;
	// 828BB68C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB694: 483EDDC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB698 size=328
    let mut pc: u32 = 0x828BB698;
    'dispatch: loop {
        match pc {
            0x828BB698 => {
    //   block [0x828BB698..0x828BB7E0)
	// 828BB698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB6A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB6AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB6B0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 828BB6B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB6B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BB6BC: 48165C75  bl 0x82a21330
	ctx.lr = 0x828BB6C0;
	sub_82A21330(ctx, base);
	// 828BB6C0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BB6C4: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828BB6C8: 4198004C  blt cr6, 0x828bb714
	if ctx.cr[6].lt {
	pc = 0x828BB714; continue 'dispatch;
	}
	// 828BB6CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BB6D0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828BB6D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB6D8: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 828BB6DC: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 828BB6E0: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 828BB6E4: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB6E8: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 828BB6EC: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BB6F0: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 828BB6F4: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BB6F8: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 828BB6FC: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BB700: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 828BB704: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 828BB708: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 828BB70C: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828BB710: 48000014  b 0x828bb724
	pc = 0x828BB724; continue 'dispatch;
	// 828BB714: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BB718: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BB71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB720: 481657C9  bl 0x82a20ee8
	ctx.lr = 0x828BB724;
	sub_82A20EE8(ctx, base);
	// 828BB724: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB728: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BB72C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB730: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BB734: 419A0024  beq cr6, 0x828bb758
	if ctx.cr[6].eq {
	pc = 0x828BB758; continue 'dispatch;
	}
	// 828BB738: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BB73C: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BB740: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 828BB744: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB748: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 828BB74C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 828BB750: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 828BB754: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	// 828BB758: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BB75C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB760: 388B2EB8  addi r4, r11, 0x2eb8
	ctx.r[4].s64 = ctx.r[11].s64 + 11960;
	// 828BB764: 4B9DFA55  bl 0x8229b1b8
	ctx.lr = 0x828BB768;
	sub_8229B1B8(ctx, base);
	// 828BB768: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BB76C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB770: 419A0014  beq cr6, 0x828bb784
	if ctx.cr[6].eq {
	pc = 0x828BB784; continue 'dispatch;
	}
	// 828BB774: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB778: 4B959661  bl 0x82214dd8
	ctx.lr = 0x828BB77C;
	sub_82214DD8(ctx, base);
	// 828BB77C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BB780: 48000048  b 0x828bb7c8
	pc = 0x828BB7C8; continue 'dispatch;
	// 828BB784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BB788: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828BB78C: 409AFFE8  bne cr6, 0x828bb774
	if !ctx.cr[6].eq {
	pc = 0x828BB774; continue 'dispatch;
	}
	// 828BB790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB798: 48000049  bl 0x828bb7e0
	ctx.lr = 0x828BB79C;
	sub_828BB7E0(ctx, base);
	// 828BB79C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7A4: 48000255  bl 0x828bb9f8
	ctx.lr = 0x828BB7A8;
	sub_828BB9F8(ctx, base);
	// 828BB7A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7B0: 480005A1  bl 0x828bbd50
	ctx.lr = 0x828BB7B4;
	sub_828BBD50(ctx, base);
	// 828BB7B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7B8: 480008E9  bl 0x828bc0a0
	ctx.lr = 0x828BB7BC;
	sub_828BC0A0(ctx, base);
	// 828BB7BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB7C0: 4B959619  bl 0x82214dd8
	ctx.lr = 0x828BB7C4;
	sub_82214DD8(ctx, base);
	// 828BB7C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BB7C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BB7CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB7D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB7D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB7D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB7DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB7E0 size=284
    let mut pc: u32 = 0x828BB7E0;
    'dispatch: loop {
        match pc {
            0x828BB7E0 => {
    //   block [0x828BB7E0..0x828BB8FC)
	// 828BB7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB7E4: 483EDC29  bl 0x82ca940c
	ctx.lr = 0x828BB7E8;
	sub_82CA93D0(ctx, base);
	// 828BB7E8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB7EC: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828BB7F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BB7F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB7F8: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 828BB7FC: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 828BB800: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BB804: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828BB808: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 828BB80C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB810: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828BB814: 38E838C0  addi r7, r8, 0x38c0
	ctx.r[7].s64 = ctx.r[8].s64 + 14528;
	// 828BB818: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828BB81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB820: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB824: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB828: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BB82C: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828BB830: 93E90004  stw r31, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB834: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB838: 93E9000C  stw r31, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BB83C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828BB840: 93E100E0  stw r31, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[31].u32 ) };
	// 828BB844: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 828BB848: 93E100E8  stw r31, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u32 ) };
	// 828BB84C: 9BE10088  stb r31, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u8 ) };
	// 828BB850: 9BE10089  stb r31, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[31].u8 ) };
	// 828BB854: 9BE1008A  stb r31, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[31].u8 ) };
	// 828BB858: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 828BB85C: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 828BB860: 482BF269  bl 0x82b7aac8
	ctx.lr = 0x828BB864;
	sub_82B7AAC8(ctx, base);
	// 828BB864: 80C10080  lwz r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BB868: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BB86C: 7C853050  subf r4, r5, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 828BB870: 54830038  rlwinm r3, r4, 0, 0, 0x1c
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB874: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BB878: 40990074  ble cr6, 0x828bb8ec
	if !ctx.cr[6].gt {
	pc = 0x828BB8EC; continue 'dispatch;
	}
	// 828BB87C: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 828BB880: 4B9639D9  bl 0x8221f258
	ctx.lr = 0x828BB884;
	sub_8221F258(ctx, base);
	// 828BB884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB888: 419A0014  beq cr6, 0x828bb89c
	if ctx.cr[6].eq {
	pc = 0x828BB89C; continue 'dispatch;
	}
	// 828BB88C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB890: 48000071  bl 0x828bb900
	ctx.lr = 0x828BB894;
	sub_828BB900(ctx, base);
	// 828BB894: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BB898: 48000008  b 0x828bb8a0
	pc = 0x828BB8A0; continue 'dispatch;
	// 828BB89C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828BB8A0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BB8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB8A8: 419A0040  beq cr6, 0x828bb8e8
	if ctx.cr[6].eq {
	pc = 0x828BB8E8; continue 'dispatch;
	}
	// 828BB8AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 828BB8B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB8B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB8B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB8BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB8C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB8C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB8C8: 4082FFE8  bne 0x828bb8b0
	if !ctx.cr[0].eq {
	pc = 0x828BB8B0; continue 'dispatch;
	}
	// 828BB8CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB8D0: 409A0014  bne cr6, 0x828bb8e4
	if !ctx.cr[6].eq {
	pc = 0x828BB8E4; continue 'dispatch;
	}
	// 828BB8D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB8D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB8DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB8E0: 4E800421  bctrl
	ctx.lr = 0x828BB8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB8E4: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 828BB8E8: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 828BB8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB8F0: 4BCC0C11  bl 0x8257c500
	ctx.lr = 0x828BB8F4;
	sub_8257C500(ctx, base);
	// 828BB8F4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828BB8F8: 483EDB64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB900 size=248
    let mut pc: u32 = 0x828BB900;
    'dispatch: loop {
        match pc {
            0x828BB900 => {
    //   block [0x828BB900..0x828BB9F8)
	// 828BB900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB918: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB91C: 4BCA81B5  bl 0x82563ad0
	ctx.lr = 0x828BB920;
	sub_82563AD0(ctx, base);
	// 828BB920: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BB924: 395F003C  addi r10, r31, 0x3c
	ctx.r[10].s64 = ctx.r[31].s64 + 60;
	// 828BB928: 392B38C0  addi r9, r11, 0x38c0
	ctx.r[9].s64 = ctx.r[11].s64 + 14528;
	// 828BB92C: 397E003C  addi r11, r30, 0x3c
	ctx.r[11].s64 = ctx.r[30].s64 + 60;
	// 828BB930: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB934: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828BB938: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BB93C: 991F0038  stb r8, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 828BB940: 88FE0039  lbz r7, 0x39(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 828BB944: 98FF0039  stb r7, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[7].u8 ) };
	// 828BB948: 88DE003A  lbz r6, 0x3a(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 828BB94C: 98DF003A  stb r6, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[6].u8 ) };
	// 828BB950: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BB954: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB95C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB960: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB964: 4200FFF0  bdnz 0x828bb954
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB954; continue 'dispatch;
	}
	// 828BB968: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 828BB96C: 397E0050  addi r11, r30, 0x50
	ctx.r[11].s64 = ctx.r[30].s64 + 80;
	// 828BB970: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 828BB974: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BB978: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB97C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB980: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB984: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB988: 4200FFF0  bdnz 0x828bb978
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB978; continue 'dispatch;
	}
	// 828BB98C: 891E0068  lbz r8, 0x68(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BB990: 395F0074  addi r10, r31, 0x74
	ctx.r[10].s64 = ctx.r[31].s64 + 116;
	// 828BB994: 397E0074  addi r11, r30, 0x74
	ctx.r[11].s64 = ctx.r[30].s64 + 116;
	// 828BB998: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 828BB99C: 991F0068  stb r8, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u8 ) };
	// 828BB9A0: 88FE0069  lbz r7, 0x69(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(105 as u32) ) } as u64;
	// 828BB9A4: 98FF0069  stb r7, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[7].u8 ) };
	// 828BB9A8: 80DE006C  lwz r6, 0x6c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BB9AC: 90DF006C  stw r6, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 828BB9B0: 80BE0070  lwz r5, 0x70(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BB9B4: 90BF0070  stw r5, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 828BB9B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BB9BC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB9C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB9C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB9C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB9CC: 4200FFF0  bdnz 0x828bb9bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB9BC; continue 'dispatch;
	}
	// 828BB9D0: 389E008C  addi r4, r30, 0x8c
	ctx.r[4].s64 = ctx.r[30].s64 + 140;
	// 828BB9D4: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828BB9D8: 4BCC4421  bl 0x8257fdf8
	ctx.lr = 0x828BB9DC;
	sub_8257FDF8(ctx, base);
	// 828BB9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB9E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB9EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB9F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB9F8 size=852
    let mut pc: u32 = 0x828BB9F8;
    'dispatch: loop {
        match pc {
            0x828BB9F8 => {
    //   block [0x828BB9F8..0x828BBD4C)
	// 828BB9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB9FC: 483ED9FD  bl 0x82ca93f8
	ctx.lr = 0x828BBA00;
	sub_82CA93D0(ctx, base);
	// 828BBA00: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBA04: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BBA08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBA0C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBA10: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBA14: 4198004C  blt cr6, 0x828bba60
	if ctx.cr[6].lt {
	pc = 0x828BBA60; continue 'dispatch;
	}
	// 828BBA18: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBA1C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBA20: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 828BBA24: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBA28: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBA2C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBA30: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBA34: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBA38: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBA3C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBA40: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBA44: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBA48: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBA4C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBA50: 90FD000C  stw r7, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBA54: 913D0014  stw r9, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBA58: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBA5C: 48000014  b 0x828bba70
	pc = 0x828BBA70; continue 'dispatch;
	// 828BBA60: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBA64: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BBA68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BBA6C: 4816547D  bl 0x82a20ee8
	ctx.lr = 0x828BBA70;
	sub_82A20EE8(ctx, base);
	// 828BBA70: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBA74: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBA78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBA7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BBA80: 419A0028  beq cr6, 0x828bbaa8
	if ctx.cr[6].eq {
	pc = 0x828BBAA8; continue 'dispatch;
	}
	// 828BBA84: 8901005B  lbz r8, 0x5b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 828BBA88: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBA8C: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBA90: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBA94: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBA98: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 828BBA9C: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 828BBAA0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 828BBAA4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BBAA8: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 828BBAAC: 3B400050  li r26, 0x50
	ctx.r[26].s64 = 80;
	// 828BBAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBAB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BBAB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBABC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BBAC0: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 828BBAC4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BBAC8: 480007F1  bl 0x828bc2b8
	ctx.lr = 0x828BBACC;
	sub_828BC2B8(ctx, base);
	// 828BBACC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BBAD0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828BBAD4: 40990230  ble cr6, 0x828bbd04
	if !ctx.cr[6].gt {
	pc = 0x828BBD04; continue 'dispatch;
	}
	// 828BBAD8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BBADC: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828BBAE0: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828BBAE4: 3B6B7088  addi r27, r11, 0x7088
	ctx.r[27].s64 = ctx.r[11].s64 + 28808;
	// 828BBAE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBAEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBAF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BBAF4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBAF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BBAFC: 4E800421  bctrl
	ctx.lr = 0x828BBB00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBB00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBB04: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828BBB08: 48166071  bl 0x82a21b78
	ctx.lr = 0x828BBB0C;
	sub_82A21B78(ctx, base);
	// 828BBB0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828BBB10: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 828BBB14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBB18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BBD50 size=844
    let mut pc: u32 = 0x828BBD50;
    'dispatch: loop {
        match pc {
            0x828BBD50 => {
    //   block [0x828BBD50..0x828BC09C)
	// 828BBD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBD54: 483ED6AD  bl 0x82ca9400
	ctx.lr = 0x828BBD58;
	sub_82CA93D0(ctx, base);
	// 828BBD58: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828BBD5C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828BBD60: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBD64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BBD68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBD6C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBD70: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBD74: 4198004C  blt cr6, 0x828bbdc0
	if ctx.cr[6].lt {
	pc = 0x828BBDC0; continue 'dispatch;
	}
	// 828BBD78: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBD7C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBD80: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828BBD84: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBD88: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBD8C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBD90: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBD94: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBD98: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBD9C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBDA0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBDA4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBDA8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBDAC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBDB0: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBDB4: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBDB8: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBDBC: 48000014  b 0x828bbdd0
	pc = 0x828BBDD0; continue 'dispatch;
	// 828BBDC0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBDC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BBDC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBDCC: 4816511D  bl 0x82a20ee8
	ctx.lr = 0x828BBDD0;
	sub_82A20EE8(ctx, base);
	// 828BBDD0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BBDD4: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBDDC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BBDE0: 419A0028  beq cr6, 0x828bbe08
	if ctx.cr[6].eq {
	pc = 0x828BBE08; continue 'dispatch;
	}
	// 828BBDE4: 89010057  lbz r8, 0x57(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 828BBDE8: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBDEC: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBDF0: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BBDF4: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBDF8: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 828BBDFC: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 828BBE00: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 828BBE04: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BBE08: 3B9D003C  addi r28, r29, 0x3c
	ctx.r[28].s64 = ctx.r[29].s64 + 60;
	// 828BBE0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BBE10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBE14: 480005BD  bl 0x828bc3d0
	ctx.lr = 0x828BBE18;
	sub_828BC3D0(ctx, base);
	// 828BBE18: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BBE1C: 40990270  ble cr6, 0x828bc08c
	if !ctx.cr[6].gt {
	pc = 0x828BC08C; continue 'dispatch;
	}
	// 828BBE20: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BBE24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BBE28: 392AB650  addi r9, r10, -0x49b0
	ctx.r[9].s64 = ctx.r[10].s64 + -18864;
	// 828BBE2C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828BBE30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BBE34: C3CAB650  lfs f30, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828BBE38: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 828BBE3C: C3E9DE34  lfs f31, -0x21cc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8652 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BBE40: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828BBE44: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 828BBE48: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828BBE4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BBE50: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 828BBE54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BBE58: 4BF3C751  bl 0x827f85a8
	ctx.lr = 0x828BBE5C;
	sub_827F85A8(ctx, base);
	// 828BBE5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BBE64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BBE68: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBE6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BBE70: 4E800421  bctrl
	ctx.lr = 0x828BBE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBE74: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBE78: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBE7C: 4198004C  blt cr6, 0x828bbec8
	if ctx.cr[6].lt {
	pc = 0x828BBEC8; continue 'dispatch;
	}
	// 828BBE80: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBE84: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBE88: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 828BBE8C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBE90: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBE94: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBE98: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBE9C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBEA0: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBEA4: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBEA8: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBEAC: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBEB0: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBEB4: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBEB8: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBEBC: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBEC0: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBEC4: 48000014  b 0x828bbed8
	pc = 0x828BBED8; continue 'dispatch;
	// 828BBEC8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBECC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BBED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBED4: 48165015  bl 0x82a20ee8
	ctx.lr = 0x828BBED8;
	sub_82A20EE8(ctx, base);
	// 828BBED8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBEDC: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBEE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BBEE8: 419A0028  beq cr6, 0x828bbf10
	if ctx.cr[6].eq {
	pc = 0x828BBF10; continue 'dispatch;
	}
	// 828BBEEC: 89410058  lbz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBEF0: 8901005B  lbz r8, 0x5b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 828BBEF4: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBEF8: 89210051  lbz r9, 0x51(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBEFC: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 828BBF00: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBF04: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 828BBF08: 99210052  stb r9, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 828BBF0C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BBF10: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BBF14: 4099009C  ble cr6, 0x828bbfb0
	if !ctx.cr[6].gt {
	pc = 0x828BBFB0; continue 'dispatch;
	}
	// 828BBF18: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828BBF1C: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828BBF20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BBF24: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828BBF28: 48165C51  bl 0x82a21b78
	ctx.lr = 0x828BBF2C;
	sub_82A21B78(ctx, base);
	// 828BBF2C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 828BBF30: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828BBF34: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828BBF38: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828BBF3C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC0A0 size=252
    let mut pc: u32 = 0x828BC0A0;
    'dispatch: loop {
        match pc {
            0x828BC0A0 => {
    //   block [0x828BC0A0..0x828BC19C)
	// 828BC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC0A4: 483ED35D  bl 0x82ca9400
	ctx.lr = 0x828BC0A8;
	sub_82CA93D0(ctx, base);
	// 828BC0A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC0AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC0B0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC0B8: 419A00DC  beq cr6, 0x828bc194
	if ctx.cr[6].eq {
	pc = 0x828BC194; continue 'dispatch;
	}
	// 828BC0BC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC0C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BC0C4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC0C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC0CC: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828BC0D0: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828BC0D4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828BC0D8: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828BC0DC: 7D051E71  srawi. r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BC0E0: 41820020  beq 0x828bc100
	if ctx.cr[0].eq {
	pc = 0x828BC100; continue 'dispatch;
	}
	// 828BC0E4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828BC0E8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC0EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC0F0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828BC0F4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BC0F8: 48000881  bl 0x828bc978
	ctx.lr = 0x828BC0FC;
	sub_828BC978(ctx, base);
	// 828BC0FC: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC100: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BC104: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 828BC108: 7D493671  srawi. r9, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828BC10C: 40820008  bne 0x828bc114
	if !ctx.cr[0].eq {
	pc = 0x828BC114; continue 'dispatch;
	}
	// 828BC110: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BC114: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC118: 482BE799  bl 0x82b7a8b0
	ctx.lr = 0x828BC11C;
	sub_82B7A8B0(ctx, base);
	// 828BC11C: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC120: 3B600050  li r27, 0x50
	ctx.r[27].s64 = 80;
	// 828BC124: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC128: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 828BC12C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BC130: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC134: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828BC138: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC13C: 41820048  beq 0x828bc184
	if ctx.cr[0].eq {
	pc = 0x828BC184; continue 'dispatch;
	}
	// 828BC140: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC144: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC148: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828BC14C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BC150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC154: 41980010  blt cr6, 0x828bc164
	if ctx.cr[6].lt {
	pc = 0x828BC164; continue 'dispatch;
	}
	// 828BC158: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC15C: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC160: 4B97F7D9  bl 0x8223b938
	ctx.lr = 0x828BC164;
	sub_8223B938(ctx, base);
	// 828BC164: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC168: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BC16C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC170: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BC174: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC178: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 828BC17C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC180: 4198FFC0  blt cr6, 0x828bc140
	if ctx.cr[6].lt {
	pc = 0x828BC140; continue 'dispatch;
	}
	// 828BC184: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC188: 419A000C  beq cr6, 0x828bc194
	if ctx.cr[6].eq {
	pc = 0x828BC194; continue 'dispatch;
	}
	// 828BC18C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BC190: 4B95FBA9  bl 0x8221bd38
	ctx.lr = 0x828BC194;
	sub_8221BD38(ctx, base);
	// 828BC194: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BC198: 483ED2B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC1A0 size=116
    let mut pc: u32 = 0x828BC1A0;
    'dispatch: loop {
        match pc {
            0x828BC1A0 => {
    //   block [0x828BC1A0..0x828BC214)
	// 828BC1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC1A4: 483ED269  bl 0x82ca940c
	ctx.lr = 0x828BC1A8;
	sub_82CA93D0(ctx, base);
	// 828BC1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC1B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BC1B4: 4BAF4885  bl 0x823b0a38
	ctx.lr = 0x828BC1B8;
	sub_823B0A38(ctx, base);
	// 828BC1B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC1BC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828BC1C0: 83BF0030  lwz r29, 0x30(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC1C4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC1C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BC1CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC1D0: 4B9A8E61  bl 0x82265030
	ctx.lr = 0x828BC1D4;
	sub_82265030(ctx, base);
	// 828BC1D4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC1D8: 57AB003E  slwi r11, r29, 0
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC1DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BC1E0: 419A001C  beq cr6, 0x828bc1fc
	if ctx.cr[6].eq {
	pc = 0x828BC1FC; continue 'dispatch;
	}
	// 828BC1E4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC1E8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BC1EC: 41980010  blt cr6, 0x828bc1fc
	if ctx.cr[6].lt {
	pc = 0x828BC1FC; continue 'dispatch;
	}
	// 828BC1F0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BC1F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828BC1F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC1FC: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BC200: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828BC204: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828BC208: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 828BC20C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC210: 483ED24C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC218 size=160
    let mut pc: u32 = 0x828BC218;
    'dispatch: loop {
        match pc {
            0x828BC218 => {
    //   block [0x828BC218..0x828BC2B8)
	// 828BC218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC21C: 483ED1E5  bl 0x82ca9400
	ctx.lr = 0x828BC220;
	sub_82CA93D0(ctx, base);
	// 828BC220: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC224: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BC228: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BC22C: 3B400050  li r26, 0x50
	ctx.r[26].s64 = 80;
	// 828BC230: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC234: 3BFB0028  addi r31, r27, 0x28
	ctx.r[31].s64 = ctx.r[27].s64 + 40;
	// 828BC238: 813B0030  lwz r9, 0x30(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC23C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC240: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC244: 811B002C  lwz r8, 0x2c(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC248: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC24C: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828BC250: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 828BC254: 7D66D3D6  divw r11, r6, r26
	ctx.r[11].s32 = ctx.r[6].s32 / ctx.r[26].s32;
	// 828BC258: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BC25C: 4BBA4B1D  bl 0x82460d78
	ctx.lr = 0x828BC260;
	sub_82460D78(ctx, base);
	// 828BC260: 80BB0030  lwz r5, 0x30(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC264: 809B002C  lwz r4, 0x2c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC268: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BC26C: 7C642850  subf r3, r4, r5
	ctx.r[3].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BC270: 7D63D3D7  divw. r11, r3, r26
	ctx.r[11].s32 = ctx.r[3].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC274: 4182003C  beq 0x828bc2b0
	if ctx.cr[0].eq {
	pc = 0x828BC2B0; continue 'dispatch;
	}
	// 828BC278: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BC27C: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC280: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC284: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BC288: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828BC28C: 4BA6507D  bl 0x82321308
	ctx.lr = 0x828BC290;
	sub_82321308(ctx, base);
	// 828BC290: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC294: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC298: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BC29C: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BC2A0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC2A4: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 828BC2A8: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC2AC: 4198FFD0  blt cr6, 0x828bc27c
	if ctx.cr[6].lt {
	pc = 0x828BC27C; continue 'dispatch;
	}
	// 828BC2B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BC2B4: 483ED19C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC2B8 size=280
    let mut pc: u32 = 0x828BC2B8;
    'dispatch: loop {
        match pc {
            0x828BC2B8 => {
    //   block [0x828BC2B8..0x828BC3D0)
	// 828BC2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC2BC: 483ED141  bl 0x82ca93fc
	ctx.lr = 0x828BC2C0;
	sub_82CA93D0(ctx, base);
	// 828BC2C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC2C4: 3D600333  lis r11, 0x333
	ctx.r[11].s64 = 53673984;
	// 828BC2C8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BC2CC: 616A3333  ori r10, r11, 0x3333
	ctx.r[10].u64 = ctx.r[11].u64 | 13107;
	// 828BC2D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC2D4: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BC2D8: 40990010  ble cr6, 0x828bc2e8
	if !ctx.cr[6].gt {
	pc = 0x828BC2E8; continue 'dispatch;
	}
	// 828BC2DC: 4818B1ED  bl 0x82a474c8
	ctx.lr = 0x828BC2E0;
	sub_82A474C8(ctx, base);
	// 828BC2E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BC2E4: 483ED168  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828BC2E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC2EC: 3B200050  li r25, 0x50
	ctx.r[25].s64 = 80;
	// 828BC2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC2F4: 419A0010  beq cr6, 0x828bc304
	if ctx.cr[6].eq {
	pc = 0x828BC304; continue 'dispatch;
	}
	// 828BC2F8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC2FC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC300: 7D69CBD6  divw r11, r9, r25
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	// 828BC304: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC308: 409800C0  bge cr6, 0x828bc3c8
	if !ctx.cr[6].lt {
	pc = 0x828BC3C8; continue 'dispatch;
	}
	// 828BC30C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BC310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC314: 481DBC35  bl 0x82a97f48
	ctx.lr = 0x828BC318;
	sub_82A97F48(ctx, base);
	// 828BC318: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC31C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BC320: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC324: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC328: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BC32C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC330: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC334: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BC338: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BC33C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828BC340: 419A0034  beq cr6, 0x828bc374
	if ctx.cr[6].eq {
	pc = 0x828BC374; continue 'dispatch;
	}
	// 828BC344: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BC348: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC34C: 419A0018  beq cr6, 0x828bc364
	if ctx.cr[6].eq {
	pc = 0x828BC364; continue 'dispatch;
	}
	// 828BC350: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC354: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828BC358: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828BC35C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BC360: 480001D1  bl 0x828bc530
	ctx.lr = 0x828BC364;
	sub_828BC530(ctx, base);
	// 828BC364: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BC368: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BC36C: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC370: 409AFFD8  bne cr6, 0x828bc348
	if !ctx.cr[6].eq {
	pc = 0x828BC348; continue 'dispatch;
	}
	// 828BC374: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC378: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC37C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BC380: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BC384: 7FCBCBD6  divw r30, r11, r25
	ctx.r[30].s32 = ctx.r[11].s32 / ctx.r[25].s32;
	// 828BC388: 419A0014  beq cr6, 0x828bc39c
	if ctx.cr[6].eq {
	pc = 0x828BC39C; continue 'dispatch;
	}
	// 828BC38C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC390: 48000131  bl 0x828bc4c0
	ctx.lr = 0x828BC394;
	sub_828BC4C0(ctx, base);
	// 828BC394: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC398: 4B95F9A1  bl 0x8221bd38
	ctx.lr = 0x828BC39C;
	sub_8221BD38(ctx, base);
	// 828BC39C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC3A0: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828BC3A4: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC3A8: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC3AC: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 828BC3B0: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC3B4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC3B8: 7CEBE214  add r7, r11, r28
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BC3BC: 7D0AE214  add r8, r10, r28
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828BC3C0: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BC3C4: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 828BC3C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BC3CC: 483ED080  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC3D0 size=236
    let mut pc: u32 = 0x828BC3D0;
    'dispatch: loop {
        match pc {
            0x828BC3D0 => {
    //   block [0x828BC3D0..0x828BC4BC)
	// 828BC3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC3D4: 483ED02D  bl 0x82ca9400
	ctx.lr = 0x828BC3D8;
	sub_82CA93D0(ctx, base);
	// 828BC3D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC3DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BC3E0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BC3E4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828BC3E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC3EC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828BC3F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC3F4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828BC3F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC3FC: 4BF3C1AD  bl 0x827f85a8
	ctx.lr = 0x828BC400;
	sub_827F85A8(ctx, base);
	// 828BC400: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC404: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC408: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 828BC40C: 7D6A2671  srawi. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BC410: 41820094  beq 0x828bc4a4
	if ctx.cr[0].eq {
	pc = 0x828BC4A4; continue 'dispatch;
	}
	// 828BC414: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC418: 419A008C  beq cr6, 0x828bc4a4
	if ctx.cr[6].eq {
	pc = 0x828BC4A4; continue 'dispatch;
	}
	// 828BC41C: 7D7FF850  subf r11, r31, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 828BC420: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC424: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC428: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC42C: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BC430: 419A0034  beq cr6, 0x828bc464
	if ctx.cr[6].eq {
	pc = 0x828BC464; continue 'dispatch;
	}
	// 828BC434: 7FBEF850  subf r29, r30, r31
	ctx.r[29].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 828BC438: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC43C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC444: 4BF3C165  bl 0x827f85a8
	ctx.lr = 0x828BC448;
	sub_827F85A8(ctx, base);
	// 828BC448: 7C9DF214  add r4, r29, r30
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828BC44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC450: 4BF90C71  bl 0x8284d0c0
	ctx.lr = 0x828BC454;
	sub_8284D0C0(ctx, base);
	// 828BC454: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC458: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828BC45C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC460: 409AFFD8  bne cr6, 0x828bc438
	if !ctx.cr[6].eq {
	pc = 0x828BC438; continue 'dispatch;
	}
	// 828BC464: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC468: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC46C: 419A0034  beq cr6, 0x828bc4a0
	if ctx.cr[6].eq {
	pc = 0x828BC4A0; continue 'dispatch;
	}
	// 828BC470: 3BFB0004  addi r31, r27, 4
	ctx.r[31].s64 = ctx.r[27].s64 + 4;
	// 828BC474: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC47C: 419A0008  beq cr6, 0x828bc484
	if ctx.cr[6].eq {
	pc = 0x828BC484; continue 'dispatch;
	}
	// 828BC480: 4B95F8B9  bl 0x8221bd38
	ctx.lr = 0x828BC484;
	sub_8221BD38(ctx, base);
	// 828BC484: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828BC488: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828BC48C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828BC490: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC494: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 828BC498: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC49C: 409AFFD8  bne cr6, 0x828bc474
	if !ctx.cr[6].eq {
	pc = 0x828BC474; continue 'dispatch;
	}
	// 828BC4A0: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828BC4A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BC4A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC4AC: 419A0008  beq cr6, 0x828bc4b4
	if ctx.cr[6].eq {
	pc = 0x828BC4B4; continue 'dispatch;
	}
	// 828BC4B0: 4B95F889  bl 0x8221bd38
	ctx.lr = 0x828BC4B4;
	sub_8221BD38(ctx, base);
	// 828BC4B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BC4B8: 483ECF98  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC4C0 size=108
    let mut pc: u32 = 0x828BC4C0;
    'dispatch: loop {
        match pc {
            0x828BC4C0 => {
    //   block [0x828BC4C0..0x828BC52C)
	// 828BC4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC4C4: 483ECF45  bl 0x82ca9408
	ctx.lr = 0x828BC4C8;
	sub_82CA93D0(ctx, base);
	// 828BC4C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC4CC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BC4D0: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC4D4: 419A0050  beq cr6, 0x828bc524
	if ctx.cr[6].eq {
	pc = 0x828BC524; continue 'dispatch;
	}
	// 828BC4D8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BC4DC: 3BE40010  addi r31, r4, 0x10
	ctx.r[31].s64 = ctx.r[4].s64 + 16;
	// 828BC4E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BC4E4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 828BC4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC4EC: 4B90A27D  bl 0x821c6768
	ctx.lr = 0x828BC4F0;
	sub_821C6768(ctx, base);
	// 828BC4F0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BC4F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BC4F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC4FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BC500: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BC504: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BC508: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC50C: 4082FFE8  bne 0x828bc4f4
	if !ctx.cr[0].eq {
	pc = 0x828BC4F4; continue 'dispatch;
	}
	// 828BC510: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BC514: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BC518: 391FFFF0  addi r8, r31, -0x10
	ctx.r[8].s64 = ctx.r[31].s64 + -16;
	// 828BC51C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC520: 409AFFC8  bne cr6, 0x828bc4e8
	if !ctx.cr[6].eq {
	pc = 0x828BC4E8; continue 'dispatch;
	}
	// 828BC524: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC528: 483ECF30  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC530 size=112
    let mut pc: u32 = 0x828BC530;
    'dispatch: loop {
        match pc {
            0x828BC530 => {
    //   block [0x828BC530..0x828BC5A0)
	// 828BC530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BC53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC548: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BC54C: 4B933CF5  bl 0x821f0240
	ctx.lr = 0x828BC550;
	sub_821F0240(ctx, base);
	// 828BC550: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BC554: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828BC558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC55C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BC560: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BC564: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BC568: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BC56C: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 828BC570: 80FE001C  lwz r7, 0x1c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC574: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC5A0 size=104
    let mut pc: u32 = 0x828BC5A0;
    'dispatch: loop {
        match pc {
            0x828BC5A0 => {
    //   block [0x828BC5A0..0x828BC608)
	// 828BC5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC5A4: 483ECE61  bl 0x82ca9404
	ctx.lr = 0x828BC5A8;
	sub_82CA93D0(ctx, base);
	// 828BC5A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC5AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BC5B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BC5B4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828BC5B8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BC5BC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC5C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC5C4: 419A002C  beq cr6, 0x828bc5f0
	if ctx.cr[6].eq {
	pc = 0x828BC5F0; continue 'dispatch;
	}
	// 828BC5C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC5CC: 419A0018  beq cr6, 0x828bc5e4
	if ctx.cr[6].eq {
	pc = 0x828BC5E4; continue 'dispatch;
	}
	// 828BC5D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC5D4: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 828BC5D8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BC5DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BC5E0: 4BFFFF51  bl 0x828bc530
	ctx.lr = 0x828BC5E4;
	sub_828BC530(ctx, base);
	// 828BC5E4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828BC5E8: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BC5EC: 4082FFDC  bne 0x828bc5c8
	if !ctx.cr[0].eq {
	pc = 0x828BC5C8; continue 'dispatch;
	}
	// 828BC5F0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC5F4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC5F8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC5FC: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BC600: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC604: 483ECE50  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC608 size=876
    let mut pc: u32 = 0x828BC608;
    'dispatch: loop {
        match pc {
            0x828BC608 => {
    //   block [0x828BC608..0x828BC974)
	// 828BC608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC60C: 483ECDE9  bl 0x82ca93f4
	ctx.lr = 0x828BC610;
	sub_82CA93D0(ctx, base);
	// 828BC610: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC614: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828BC618: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 828BC61C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828BC620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC624: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BC628: 4BF90739  bl 0x8284cd60
	ctx.lr = 0x828BC62C;
	sub_8284CD60(ctx, base);
	// 828BC62C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC630: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828BC634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC638: 409A000C  bne cr6, 0x828bc644
	if !ctx.cr[6].eq {
	pc = 0x828BC644; continue 'dispatch;
	}
	// 828BC63C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 828BC640: 48000010  b 0x828bc650
	pc = 0x828BC650; continue 'dispatch;
	// 828BC644: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC648: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC64C: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 828BC650: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC654: 419A0308  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	// 828BC658: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC65C: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 828BC660: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828BC664: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828BC668: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 828BC66C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC670: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC674: 4098000C  bge cr6, 0x828bc680
	if !ctx.cr[6].lt {
	pc = 0x828BC680; continue 'dispatch;
	}
	// 828BC678: 4818AE51  bl 0x82a474c8
	ctx.lr = 0x828BC67C;
	sub_82A474C8(ctx, base);
	// 828BC67C: 480002E0  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
	// 828BC680: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC684: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC688: 4098015C  bge cr6, 0x828bc7e4
	if !ctx.cr[6].lt {
	pc = 0x828BC7E4; continue 'dispatch;
	}
	// 828BC68C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC690: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 828BC694: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC698: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BC69C: 41980008  blt cr6, 0x828bc6a4
	if ctx.cr[6].lt {
	pc = 0x828BC6A4; continue 'dispatch;
	}
	// 828BC6A0: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BC6A4: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC6A8: 40980008  bge cr6, 0x828bc6b0
	if !ctx.cr[6].lt {
	pc = 0x828BC6B0; continue 'dispatch;
	}
	// 828BC6AC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 828BC6B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BC6B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BC6B8: 4BB66B81  bl 0x82423238
	ctx.lr = 0x828BC6BC;
	sub_82423238(ctx, base);
	// 828BC6BC: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC6C0: 838100DC  lwz r28, 0xdc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BC6C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BC6C8: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC6CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC6D0: 419A0028  beq cr6, 0x828bc6f8
	if ctx.cr[6].eq {
	pc = 0x828BC6F8; continue 'dispatch;
	}
	// 828BC6D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC6D8: 419A0010  beq cr6, 0x828bc6e8
	if ctx.cr[6].eq {
	pc = 0x828BC6E8; continue 'dispatch;
	}
	// 828BC6DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC6E4: 4BF9067D  bl 0x8284cd60
	ctx.lr = 0x828BC6E8;
	sub_8284CD60(ctx, base);
	// 828BC6E8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC6EC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC6F0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC6F4: 409AFFE0  bne cr6, 0x828bc6d4
	if !ctx.cr[6].eq {
	pc = 0x828BC6D4; continue 'dispatch;
	}
	// 828BC6F8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828BC6FC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828BC700: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC704: 419A0024  beq cr6, 0x828bc728
	if ctx.cr[6].eq {
	pc = 0x828BC728; continue 'dispatch;
	}
	// 828BC708: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC70C: 419A0010  beq cr6, 0x828bc71c
	if ctx.cr[6].eq {
	pc = 0x828BC71C; continue 'dispatch;
	}
	// 828BC710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC718: 4BF90649  bl 0x8284cd60
	ctx.lr = 0x828BC71C;
	sub_8284CD60(ctx, base);
	// 828BC71C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828BC720: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC724: 4082FFE4  bne 0x828bc708
	if !ctx.cr[0].eq {
	pc = 0x828BC708; continue 'dispatch;
	}
	// 828BC728: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC72C: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC730: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BC734: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC738: 419A0034  beq cr6, 0x828bc76c
	if ctx.cr[6].eq {
	pc = 0x828BC76C; continue 'dispatch;
	}
	// 828BC73C: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 828BC740: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC744: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BC748: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC74C: 419A0010  beq cr6, 0x828bc75c
	if ctx.cr[6].eq {
	pc = 0x828BC75C; continue 'dispatch;
	}
	// 828BC750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC758: 4BF90609  bl 0x8284cd60
	ctx.lr = 0x828BC75C;
	sub_8284CD60(ctx, base);
	// 828BC75C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC760: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC764: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC768: 409AFFE0  bne cr6, 0x828bc748
	if !ctx.cr[6].eq {
	pc = 0x828BC748; continue 'dispatch;
	}
	// 828BC76C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC770: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC774: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC778: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 828BC77C: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC780: 7F8BD214  add r28, r11, r26
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC784: 419A0040  beq cr6, 0x828bc7c4
	if ctx.cr[6].eq {
	pc = 0x828BC7C4; continue 'dispatch;
	}
	// 828BC788: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC78C: 419A0030  beq cr6, 0x828bc7bc
	if ctx.cr[6].eq {
	pc = 0x828BC7BC; continue 'dispatch;
	}
	// 828BC790: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC794: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 828BC798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC79C: 419A0008  beq cr6, 0x828bc7a4
	if ctx.cr[6].eq {
	pc = 0x828BC7A4; continue 'dispatch;
	}
	// 828BC7A0: 4B95F599  bl 0x8221bd38
	ctx.lr = 0x828BC7A4;
	sub_8221BD38(ctx, base);
	// 828BC7A4: 92FF0008  stw r23, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 828BC7A8: 92FF000C  stw r23, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 828BC7AC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC7B0: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 828BC7B4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC7B8: 409AFFD8  bne cr6, 0x828bc790
	if !ctx.cr[6].eq {
	pc = 0x828BC790; continue 'dispatch;
	}
	// 828BC7BC: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC7C0: 4B95F579  bl 0x8221bd38
	ctx.lr = 0x828BC7C4;
	sub_8221BD38(ctx, base);
	// 828BC7C4: 570A2036  slwi r10, r24, 4
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC7C8: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828BC7CC: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC7D0: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828BC7D4: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BC7D8: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828BC7DC: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828BC7E0: 4800017C  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
	// 828BC7E4: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BC7E8: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 828BC7EC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC7F0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC7F4: 409800B8  bge cr6, 0x828bc8ac
	if !ctx.cr[6].lt {
	pc = 0x828BC8AC; continue 'dispatch;
	}
	// 828BC7F8: 575C2036  slwi r28, r26, 4
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 828BC7FC: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC800: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 828BC804: 419A002C  beq cr6, 0x828bc830
	if ctx.cr[6].eq {
	pc = 0x828BC830; continue 'dispatch;
	}
	// 828BC808: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 828BC80C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC810: 419A0010  beq cr6, 0x828bc820
	if ctx.cr[6].eq {
	pc = 0x828BC820; continue 'dispatch;
	}
	// 828BC814: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC81C: 4BF90545  bl 0x8284cd60
	ctx.lr = 0x828BC820;
	sub_8284CD60(ctx, base);
	// 828BC820: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828BC824: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC828: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC82C: 409AFFE0  bne cr6, 0x828bc80c
	if !ctx.cr[6].eq {
	pc = 0x828BC80C; continue 'dispatch;
	}
	// 828BC830: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC834: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828BC838: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC83C: 7FEAD051  subf. r31, r10, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BC840: 41820024  beq 0x828bc864
	if ctx.cr[0].eq {
	pc = 0x828BC864; continue 'dispatch;
	}
	// 828BC844: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC848: 419A0010  beq cr6, 0x828bc858
	if ctx.cr[6].eq {
	pc = 0x828BC858; continue 'dispatch;
	}
	// 828BC84C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC854: 4BF9050D  bl 0x8284cd60
	ctx.lr = 0x828BC858;
	sub_8284CD60(ctx, base);
	// 828BC858: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BC85C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC860: 4082FFE4  bne 0x828bc844
	if !ctx.cr[0].eq {
	pc = 0x828BC844; continue 'dispatch;
	}
	// 828BC864: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC868: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC86C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BC870: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 828BC874: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BC878: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC87C: 419A00E0  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	// 828BC880: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC884: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC88C: 4BF3BD1D  bl 0x827f85a8
	ctx.lr = 0x828BC890;
	sub_827F85A8(ctx, base);
	// 828BC890: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC898: 4BF90829  bl 0x8284d0c0
	ctx.lr = 0x828BC89C;
	sub_8284D0C0(ctx, base);
	// 828BC89C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC8A0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC8A4: 409AFFDC  bne cr6, 0x828bc880
	if !ctx.cr[6].eq {
	pc = 0x828BC880; continue 'dispatch;
	}
	// 828BC8A8: 480000B4  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
	// 828BC8AC: 575A2036  slwi r26, r26, 4
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 828BC8B0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828BC8B4: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 828BC8B8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828BC8BC: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC8C0: 419A0028  beq cr6, 0x828bc8e8
	if ctx.cr[6].eq {
	pc = 0x828BC8E8; continue 'dispatch;
	}
	// 828BC8C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC8C8: 419A0010  beq cr6, 0x828bc8d8
	if ctx.cr[6].eq {
	pc = 0x828BC8D8; continue 'dispatch;
	}
	// 828BC8CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC8D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC8D4: 4BF9048D  bl 0x8284cd60
	ctx.lr = 0x828BC8D8;
	sub_8284CD60(ctx, base);
	// 828BC8D8: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828BC8DC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC8E0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC8E4: 409AFFE0  bne cr6, 0x828bc8c4
	if !ctx.cr[6].eq {
	pc = 0x828BC8C4; continue 'dispatch;
	}
	// 828BC8E8: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828BC8EC: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC8F0: 419A0034  beq cr6, 0x828bc924
	if ctx.cr[6].eq {
	pc = 0x828BC924; continue 'dispatch;
	}
	// 828BC8F4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC8F8: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 828BC8FC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC908: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 828BC90C: 4BF3BC9D  bl 0x827f85a8
	ctx.lr = 0x828BC910;
	sub_827F85A8(ctx, base);
	// 828BC910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC918: 4BF907A9  bl 0x8284d0c0
	ctx.lr = 0x828BC91C;
	sub_8284D0C0(ctx, base);
	// 828BC91C: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC920: 409AFFD8  bne cr6, 0x828bc8f8
	if !ctx.cr[6].eq {
	pc = 0x828BC8F8; continue 'dispatch;
	}
	// 828BC924: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 828BC928: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC92C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC930: 419A002C  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	// 828BC934: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC938: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC93C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC940: 4BF3BC69  bl 0x827f85a8
	ctx.lr = 0x828BC944;
	sub_827F85A8(ctx, base);
	// 828BC944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC94C: 4BF90775  bl 0x8284d0c0
	ctx.lr = 0x828BC950;
	sub_8284D0C0(ctx, base);
	// 828BC950: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC954: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC958: 409AFFDC  bne cr6, 0x828bc934
	if !ctx.cr[6].eq {
	pc = 0x828BC934; continue 'dispatch;
	}
	// 828BC95C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BC960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC964: 419A0008  beq cr6, 0x828bc96c
	if ctx.cr[6].eq {
	pc = 0x828BC96C; continue 'dispatch;
	}
	// 828BC968: 4B95F3D1  bl 0x8221bd38
	ctx.lr = 0x828BC96C;
	sub_8221BD38(ctx, base);
	// 828BC96C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BC970: 483ECAD4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC978 size=1004
    let mut pc: u32 = 0x828BC978;
    'dispatch: loop {
        match pc {
            0x828BC978 => {
    //   block [0x828BC978..0x828BCD64)
	// 828BC978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC97C: 483ECA8D  bl 0x82ca9408
	ctx.lr = 0x828BC980;
	sub_82CA93D0(ctx, base);
	// 828BC980: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC984: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC988: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 828BC98C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828BC990: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BC994: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828BC998: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BC99C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BC9A0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BC9A4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BC9A8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BC9AC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BC9B0: 4200FFF0  bdnz 0x828bc9a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BC9A0; continue 'dispatch;
	}
	// 828BC9B4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC9BC: 409A000C  bne cr6, 0x828bc9c8
	if !ctx.cr[6].eq {
	pc = 0x828BC9C8; continue 'dispatch;
	}
	// 828BC9C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BC9C4: 48000010  b 0x828bc9d4
	pc = 0x828BC9D4; continue 'dispatch;
	// 828BC9C8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC9CC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC9D0: 7D293670  srawi r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	// 828BC9D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC9D8: 419A0384  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	// 828BC9DC: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC9E0: 3D4003FF  lis r10, 0x3ff
	ctx.r[10].s64 = 67043328;
	// 828BC9E4: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 828BC9E8: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828BC9EC: 7D0B3670  srawi r11, r8, 6
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 6) as i64;
	// 828BC9F0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC9F4: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC9F8: 40980010  bge cr6, 0x828bca08
	if !ctx.cr[6].lt {
	pc = 0x828BCA08; continue 'dispatch;
	}
	// 828BC9FC: 4818AACD  bl 0x82a474c8
	ctx.lr = 0x828BCA00;
	sub_82A474C8(ctx, base);
	// 828BCA00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCA04: 483ECA54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828BCA08: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BCA0C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCA10: 40980170  bge cr6, 0x828bcb80
	if !ctx.cr[6].lt {
	pc = 0x828BCB80; continue 'dispatch;
	}
	// 828BCA14: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCA18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BCA1C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCA20: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BCA24: 41980008  blt cr6, 0x828bca2c
	if ctx.cr[6].lt {
	pc = 0x828BCA2C; continue 'dispatch;
	}
	// 828BCA28: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BCA2C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCA30: 40980008  bge cr6, 0x828bca38
	if !ctx.cr[6].lt {
	pc = 0x828BCA38; continue 'dispatch;
	}
	// 828BCA34: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 828BCA38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BCA3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCA40: 481121F1  bl 0x829cec30
	ctx.lr = 0x828BCA44;
	sub_829CEC30(ctx, base);
	// 828BCA44: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCA48: 80A100DC  lwz r5, 0xdc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BCA4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCA50: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCA54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828BCA58: 419A0040  beq cr6, 0x828bca98
	if ctx.cr[6].eq {
	pc = 0x828BCA98; continue 'dispatch;
	}
	// 828BCA5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BCA60: 419A0028  beq cr6, 0x828bca88
	if ctx.cr[6].eq {
	pc = 0x828BCA88; continue 'dispatch;
	}
	// 828BCA64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BCA68: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828BCA6C: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCA70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828BCA74: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCA78: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCA7C: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCA80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCA84: 4200FFF0  bdnz 0x828bca74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCA74; continue 'dispatch;
	}
	// 828BCA88: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCA8C: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCA90: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCA94: 409AFFC8  bne cr6, 0x828bca5c
	if !ctx.cr[6].eq {
	pc = 0x828BCA5C; continue 'dispatch;
	}
	// 828BCA98: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828BCA9C: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828BCAA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCAA4: 419A003C  beq cr6, 0x828bcae0
	if ctx.cr[6].eq {
	pc = 0x828BCAE0; continue 'dispatch;
	}
	// 828BCAA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCAAC: 419A0028  beq cr6, 0x828bcad4
	if ctx.cr[6].eq {
	pc = 0x828BCAD4; continue 'dispatch;
	}
	// 828BCAB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCAB4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCAB8: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCABC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BCAC0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCAC4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCAC8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCACC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCAD0: 4200FFF0  bdnz 0x828bcac0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCAC0; continue 'dispatch;
	}
	// 828BCAD4: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BCAD8: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCADC: 4082FFCC  bne 0x828bcaa8
	if !ctx.cr[0].eq {
	pc = 0x828BCAA8; continue 'dispatch;
	}
	// 828BCAE0: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCAE4: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCAE8: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 828BCAEC: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BCAF0: 419A004C  beq cr6, 0x828bcb3c
	if ctx.cr[6].eq {
	pc = 0x828BCB3C; continue 'dispatch;
	}
	// 828BCAF4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828BCAF8: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 828BCAFC: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 828BCB00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BCB04: 419A0028  beq cr6, 0x828bcb2c
	if ctx.cr[6].eq {
	pc = 0x828BCB2C; continue 'dispatch;
	}
	// 828BCB08: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 828BCB0C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCB10: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 828BCB14: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828BCB18: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCB1C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCB20: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 828BCB24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCB28: 4200FFF0  bdnz 0x828bcb18
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCB18; continue 'dispatch;
	}
	// 828BCB2C: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCB30: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCB34: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BCB38: 409AFFC8  bne cr6, 0x828bcb00
	if !ctx.cr[6].eq {
	pc = 0x828BCB00; continue 'dispatch;
	}
	// 828BCB3C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCB40: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BCB48: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828BCB4C: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 828BCB50: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BCB54: 419A0008  beq cr6, 0x828bcb5c
	if ctx.cr[6].eq {
	pc = 0x828BCB5C; continue 'dispatch;
	}
	// 828BCB58: 4B95F1E1  bl 0x8221bd38
	ctx.lr = 0x828BCB5C;
	sub_8221BD38(ctx, base);
	// 828BCB5C: 57AA3032  slwi r10, r29, 6
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCB60: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BCB64: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCB68: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828BCB6C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BCB70: 915C000C  stw r10, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828BCB74: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828BCB78: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCB7C: 483EC8DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828BCB80: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BCB84: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 828BCB88: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 828BCB8C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BCB90: 409800F4  bge cr6, 0x828bcc84
	if !ctx.cr[6].lt {
	pc = 0x828BCC84; continue 'dispatch;
	}
	// 828BCB94: 57E63032  slwi r6, r31, 6
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828BCB98: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCB9C: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 828BCBA0: 419A0044  beq cr6, 0x828bcbe4
	if ctx.cr[6].eq {
	pc = 0x828BCBE4; continue 'dispatch;
	}
	// 828BCBA4: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 828BCBA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BCBAC: 419A0028  beq cr6, 0x828bcbd4
	if ctx.cr[6].eq {
	pc = 0x828BCBD4; continue 'dispatch;
	}
	// 828BCBB0: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828BCBB4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCBB8: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCBBC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828BCBC0: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCBC4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCBC8: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCBCC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCBD0: 4200FFF0  bdnz 0x828bcbc0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCBC0; continue 'dispatch;
	}
	// 828BCBD4: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCBD8: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCBDC: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCBE0: 409AFFC8  bne cr6, 0x828bcba8
	if !ctx.cr[6].eq {
	pc = 0x828BCBA8; continue 'dispatch;
	}
	// 828BCBE4: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCBE8: 7D634050  subf r11, r3, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 828BCBEC: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 828BCBF0: 7CEAF851  subf. r7, r10, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828BCBF4: 4182003C  beq 0x828bcc30
	if ctx.cr[0].eq {
	pc = 0x828BCC30; continue 'dispatch;
	}
	// 828BCBF8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCBFC: 419A0028  beq cr6, 0x828bcc24
	if ctx.cr[6].eq {
	pc = 0x828BCC24; continue 'dispatch;
	}
	// 828BCC00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCC04: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCC08: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCC0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BCC10: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCC14: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCC18: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCC1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCC20: 4200FFF0  bdnz 0x828bcc10
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCC10; continue 'dispatch;
	}
	// 828BCC24: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828BCC28: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCC2C: 4082FFCC  bne 0x828bcbf8
	if !ctx.cr[0].eq {
	pc = 0x828BCBF8; continue 'dispatch;
	}
	// 828BCC30: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCC34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828BCC38: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828BCC3C: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 828BCC40: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BCC44: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCC48: 419A0114  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	// 828BCC4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCC50: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCC54: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCC58: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828BCC5C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCC60: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCC64: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCC68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCC6C: 4200FFF0  bdnz 0x828bcc5c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCC5C; continue 'dispatch;
	}
	// 828BCC70: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCC74: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCC78: 409AFFD4  bne cr6, 0x828bcc4c
	if !ctx.cr[6].eq {
	pc = 0x828BCC4C; continue 'dispatch;
	}
	// 828BCC7C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCC80: 483EC7D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828BCC84: 57E43032  slwi r4, r31, 6
	ctx.r[4].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828BCC88: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 828BCC8C: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BCC90: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828BCC94: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCC98: 419A0040  beq cr6, 0x828bccd8
	if ctx.cr[6].eq {
	pc = 0x828BCCD8; continue 'dispatch;
	}
	// 828BCC9C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCCA0: 419A0028  beq cr6, 0x828bccc8
	if ctx.cr[6].eq {
	pc = 0x828BCCC8; continue 'dispatch;
	}
	// 828BCCA4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828BCCA8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 828BCCAC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 828BCCB0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828BCCB4: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BCCB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCCBC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 828BCCC0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828BCCC4: 4200FFF0  bdnz 0x828bccb4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCCB4; continue 'dispatch;
	}
	// 828BCCC8: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCCCC: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCCD0: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCCD4: 409AFFC8  bne cr6, 0x828bcc9c
	if !ctx.cr[6].eq {
	pc = 0x828BCC9C; continue 'dispatch;
	}
	// 828BCCD8: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828BCCDC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BCCE0: 419A003C  beq cr6, 0x828bcd1c
	if ctx.cr[6].eq {
	pc = 0x828BCD1C; continue 'dispatch;
	}
	// 828BCCE4: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828BCCE8: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 828BCCEC: 3908FFC0  addi r8, r8, -0x40
	ctx.r[8].s64 = ctx.r[8].s64 + -64;
	// 828BCCF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828BCCF4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 828BCCF8: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 828BCCFC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828BCD00: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BCD04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCD08: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 828BCD0C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828BCD10: 4200FFF0  bdnz 0x828bcd00
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCD00; continue 'dispatch;
	}
	// 828BCD14: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BCD18: 409AFFD0  bne cr6, 0x828bcce8
	if !ctx.cr[6].eq {
	pc = 0x828BCCE8; continue 'dispatch;
	}
	// 828BCD1C: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 828BCD20: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828BCD24: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCD28: 419A0034  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	// 828BCD2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCD30: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCD34: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCD38: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BCD3C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCD40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCD44: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCD48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCD4C: 4200FFF0  bdnz 0x828bcd3c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCD3C; continue 'dispatch;
	}
	// 828BCD50: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCD54: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCD58: 409AFFD4  bne cr6, 0x828bcd2c
	if !ctx.cr[6].eq {
	pc = 0x828BCD2C; continue 'dispatch;
	}
	// 828BCD5C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCD60: 483EC6F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BCD68 size=756
    let mut pc: u32 = 0x828BCD68;
    'dispatch: loop {
        match pc {
            0x828BCD68 => {
    //   block [0x828BCD68..0x828BD05C)
	// 828BCD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCD6C: 483EC68D  bl 0x82ca93f8
	ctx.lr = 0x828BCD70;
	sub_82CA93D0(ctx, base);
	// 828BCD70: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCD74: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCD78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BCD7C: F8810108  std r4, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[4].u64 ) };
	// 828BCD80: 38860010  addi r4, r6, 0x10
	ctx.r[4].s64 = ctx.r[6].s64 + 16;
	// 828BCD84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCD88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BCD8C: 4BFFF7A5  bl 0x828bc530
	ctx.lr = 0x828BCD90;
	sub_828BC530(ctx, base);
	// 828BCD90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCD94: 3B000050  li r24, 0x50
	ctx.r[24].s64 = 80;
	// 828BCD98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BCD9C: 409A000C  bne cr6, 0x828bcda8
	if !ctx.cr[6].eq {
	pc = 0x828BCDA8; continue 'dispatch;
	}
	// 828BCDA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BCDA4: 48000010  b 0x828bcdb4
	pc = 0x828BCDB4; continue 'dispatch;
	// 828BCDA8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BCDAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCDB0: 7D29C3D6  divw r9, r9, r24
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828BCDB4: 837C0008  lwz r27, 8(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCDB8: 3D400333  lis r10, 0x333
	ctx.r[10].s64 = 53673984;
	// 828BCDBC: 7D0BD850  subf r8, r11, r27
	ctx.r[8].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 828BCDC0: 614A3333  ori r10, r10, 0x3333
	ctx.r[10].u64 = ctx.r[10].u64 | 13107;
	// 828BCDC4: 7D68C3D6  divw r11, r8, r24
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 828BCDC8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCDCC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828BCDD0: 40980018  bge cr6, 0x828bcde8
	if !ctx.cr[6].lt {
	pc = 0x828BCDE8; continue 'dispatch;
	}
	// 828BCDD4: 4818A6F5  bl 0x82a474c8
	ctx.lr = 0x828BCDD8;
	sub_82A474C8(ctx, base);
	// 828BCDD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCDDC: 4B957FFD  bl 0x82214dd8
	ctx.lr = 0x828BCDE0;
	sub_82214DD8(ctx, base);
	// 828BCDE0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BCDE4: 483EC664  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828BCDE8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 828BCDEC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCDF0: 40980134  bge cr6, 0x828bcf24
	if !ctx.cr[6].lt {
	pc = 0x828BCF24; continue 'dispatch;
	}
	// 828BCDF4: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCDF8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BCDFC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCE00: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BCE04: 41980008  blt cr6, 0x828bce0c
	if ctx.cr[6].lt {
	pc = 0x828BCE0C; continue 'dispatch;
	}
	// 828BCE08: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BCE0C: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCE10: 40980008  bge cr6, 0x828bce18
	if !ctx.cr[6].lt {
	pc = 0x828BCE18; continue 'dispatch;
	}
	// 828BCE14: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 828BCE18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828BCE1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCE20: 481DB129  bl 0x82a97f48
	ctx.lr = 0x828BCE24;
	sub_82A97F48(ctx, base);
	// 828BCE24: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCE28: 83A1010C  lwz r29, 0x10c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828BCE2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BCE30: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BCE34: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828BCE38: 419A0030  beq cr6, 0x828bce68
	if ctx.cr[6].eq {
	pc = 0x828BCE68; continue 'dispatch;
	}
	// 828BCE3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BCE40: 419A0018  beq cr6, 0x828bce58
	if ctx.cr[6].eq {
	pc = 0x828BCE58; continue 'dispatch;
	}
	// 828BCE44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCE48: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828BCE4C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828BCE50: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCE54: 4BFFF6DD  bl 0x828bc530
	ctx.lr = 0x828BCE58;
	sub_828BC530(ctx, base);
	// 828BCE58: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCE5C: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BCE60: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BCE64: 409AFFD8  bne cr6, 0x828bce3c
	if !ctx.cr[6].eq {
	pc = 0x828BCE3C; continue 'dispatch;
	}
	// 828BCE68: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BCE6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BCE70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BCE74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCE78: 4BFFF729  bl 0x828bc5a0
	ctx.lr = 0x828BCE7C;
	sub_828BC5A0(ctx, base);
	// 828BCE7C: 837C0008  lwz r27, 8(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCE84: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCE88: 419A0034  beq cr6, 0x828bcebc
	if ctx.cr[6].eq {
	pc = 0x828BCEBC; continue 'dispatch;
	}
	// 828BCE8C: 7FC3E850  subf r30, r3, r29
	ctx.r[30].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 828BCE90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCE94: 419A0018  beq cr6, 0x828bceac
	if ctx.cr[6].eq {
	pc = 0x828BCEAC; continue 'dispatch;
	}
	// 828BCE98: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828BCE9C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BCEA0: 7C83F214  add r4, r3, r30
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 828BCEA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCEA8: 4BFFF689  bl 0x828bc530
	ctx.lr = 0x828BCEAC;
	sub_828BC530(ctx, base);
	// 828BCEAC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCEB0: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 828BCEB4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCEB8: 409AFFD8  bne cr6, 0x828bce90
	if !ctx.cr[6].eq {
	pc = 0x828BCE90; continue 'dispatch;
	}
	// 828BCEBC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCEC0: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCEC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BCEC8: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BCECC: 7D6BC3D6  divw r11, r11, r24
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCED0: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 828BCED4: 419A0014  beq cr6, 0x828bcee8
	if ctx.cr[6].eq {
	pc = 0x828BCEE8; continue 'dispatch;
	}
	// 828BCED8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCEDC: 4BFFF5E5  bl 0x828bc4c0
	ctx.lr = 0x828BCEE0;
	sub_828BC4C0(ctx, base);
	// 828BCEE0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCEE4: 4B95EE55  bl 0x8221bd38
	ctx.lr = 0x828BCEE8;
	sub_8221BD38(ctx, base);
	// 828BCEE8: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCEEC: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828BCEF0: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCEF4: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 828BCEF8: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BCEFC: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCF00: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCF04: 7D0AD214  add r8, r10, r26
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 828BCF08: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BCF0C: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 828BCF10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCF14: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BCF18: 4B957EC1  bl 0x82214dd8
	ctx.lr = 0x828BCF1C;
	sub_82214DD8(ctx, base);
	// 828BCF1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BCF20: 483EC528  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828BCF24: 8341010C  lwz r26, 0x10c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828BCF28: 7D7AD850  subf r11, r26, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 828BCF2C: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCF30: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828BCF34: 40980070  bge cr6, 0x828bcfa4
	if !ctx.cr[6].lt {
	pc = 0x828BCFA4; continue 'dispatch;
	}
	// 828BCF38: 3BDA0050  addi r30, r26, 0x50
	ctx.r[30].s64 = ctx.r[26].s64 + 80;
	// 828BCF3C: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCF40: 419A0034  beq cr6, 0x828bcf74
	if ctx.cr[6].eq {
	pc = 0x828BCF74; continue 'dispatch;
	}
	// 828BCF44: 3BFEFFB0  addi r31, r30, -0x50
	ctx.r[31].s64 = ctx.r[30].s64 + -80;
	// 828BCF48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BCF4C: 419A0018  beq cr6, 0x828bcf64
	if ctx.cr[6].eq {
	pc = 0x828BCF64; continue 'dispatch;
	}
	// 828BCF50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCF54: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828BCF58: 3883FFB0  addi r4, r3, -0x50
	ctx.r[4].s64 = ctx.r[3].s64 + -80;
	// 828BCF5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCF60: 4BFFF5D1  bl 0x828bc530
	ctx.lr = 0x828BCF64;
	sub_828BC530(ctx, base);
	// 828BCF64: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCF68: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BCF6C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCF70: 409AFFD8  bne cr6, 0x828bcf48
	if !ctx.cr[6].eq {
	pc = 0x828BCF48; continue 'dispatch;
	}
	// 828BCF74: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCF78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BCF7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCF80: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 828BCF84: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCF88: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 828BCF8C: 4BFFF615  bl 0x828bc5a0
	ctx.lr = 0x828BCF90;
	sub_828BC5A0(ctx, base);
	// 828BCF90: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCF94: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 828BCF98: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BCF9C: 388BFFB0  addi r4, r11, -0x50
	ctx.r[4].s64 = ctx.r[11].s64 + -80;
	// 828BCFA0: 480000A0  b 0x828bd040
	pc = 0x828BD040; continue 'dispatch;
	// 828BCFA4: 3BDBFFB0  addi r30, r27, -0x50
	ctx.r[30].s64 = ctx.r[27].s64 + -80;
	// 828BCFA8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BCFAC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BCFB0: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCFB4: 419A0030  beq cr6, 0x828bcfe4
	if ctx.cr[6].eq {
	pc = 0x828BCFE4; continue 'dispatch;
	}
	// 828BCFB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCFBC: 419A0018  beq cr6, 0x828bcfd4
	if ctx.cr[6].eq {
	pc = 0x828BCFD4; continue 'dispatch;
	}
	// 828BCFC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCFC4: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828BCFC8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BCFCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCFD0: 4BFFF561  bl 0x828bc530
	ctx.lr = 0x828BCFD4;
	sub_828BC530(ctx, base);
	// 828BCFD4: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BCFD8: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCFDC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCFE0: 409AFFD8  bne cr6, 0x828bcfb8
	if !ctx.cr[6].eq {
	pc = 0x828BCFB8; continue 'dispatch;
	}
	// 828BCFE4: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BCFE8: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BCFEC: 419A0050  beq cr6, 0x828bd03c
	if ctx.cr[6].eq {
	pc = 0x828BD03C; continue 'dispatch;
	}
	// 828BCFF0: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 828BCFF4: 3BA0FFB0  li r29, -0x50
	ctx.r[29].s64 = -80;
	// 828BCFF8: 3BDEFFB0  addi r30, r30, -0x50
	ctx.r[30].s64 = ctx.r[30].s64 + -80;
	// 828BCFFC: 3BFFFFB0  addi r31, r31, -0x50
	ctx.r[31].s64 = ctx.r[31].s64 + -80;
	// 828BD000: 389FFF90  addi r4, r31, -0x70
	ctx.r[4].s64 = ctx.r[31].s64 + -112;
	// 828BD004: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 828BD008: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD00C: 917FFFD0  stw r11, -0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 828BD010: 4B9A8191  bl 0x822651a0
	ctx.lr = 0x828BD014;
	sub_822651A0(ctx, base);
	// 828BD014: E95FFFA0  ld r10, -0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-96 as u32) ) };
	// 828BD018: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BD01C: F95FFFF0  std r10, -0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BD020: E93FFFA8  ld r9, -0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-88 as u32) ) };
	// 828BD024: F93FFFF8  std r9, -8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD060 size=120
    let mut pc: u32 = 0x828BD060;
    'dispatch: loop {
        match pc {
            0x828BD060 => {
    //   block [0x828BD060..0x828BD0D8)
	// 828BD060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD064: 483EC39D  bl 0x82ca9400
	ctx.lr = 0x828BD068;
	sub_82CA93D0(ctx, base);
	// 828BD068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD06C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BD070: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BD074: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BD078: 419A0058  beq cr6, 0x828bd0d0
	if ctx.cr[6].eq {
	pc = 0x828BD0D0; continue 'dispatch;
	}
	// 828BD07C: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828BD080: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 828BD084: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BD088: 3B7E0020  addi r27, r30, 0x20
	ctx.r[27].s64 = ctx.r[30].s64 + 32;
	// 828BD08C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD094: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 828BD098: 917FFFD0  stw r11, -0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 828BD09C: 4B9A8105  bl 0x822651a0
	ctx.lr = 0x828BD0A0;
	sub_822651A0(ctx, base);
	// 828BD0A0: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828BD0A4: F95FFFF0  std r10, -0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BD0A8: E93D0008  ld r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 828BD0AC: F93FFFF8  std r9, -8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD0D8 size=436
    let mut pc: u32 = 0x828BD0D8;
    'dispatch: loop {
        match pc {
            0x828BD0D8 => {
    //   block [0x828BD0D8..0x828BD28C)
	// 828BD0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD0DC: 483EC31D  bl 0x82ca93f8
	ctx.lr = 0x828BD0E0;
	sub_82CA93D0(ctx, base);
	// 828BD0E0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD0E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BD0E8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828BD0EC: FB610110  std r27, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[27].u64 ) };
	// 828BD0F0: 3BC00050  li r30, 0x50
	ctx.r[30].s64 = 80;
	// 828BD0F4: FB010118  std r24, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[24].u64 ) };
	// 828BD0F8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828BD0FC: 83A10114  lwz r29, 0x114(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828BD100: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828BD104: 8341011C  lwz r26, 0x11c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828BD108: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD10C: 7D6BF3D6  divw r11, r11, r30
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD110: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD114: 409900A0  ble cr6, 0x828bd1b4
	if !ctx.cr[6].gt {
	pc = 0x828BD1B4; continue 'dispatch;
	}
	// 828BD118: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BD11C: 409900B8  ble cr6, 0x828bd1d4
	if !ctx.cr[6].gt {
	pc = 0x828BD1D4; continue 'dispatch;
	}
	// 828BD120: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828BD124: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828BD128: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BD12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD130: 48000161  bl 0x828bd290
	ctx.lr = 0x828BD134;
	sub_828BD290(ctx, base);
	// 828BD134: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 828BD138: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BD13C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD140: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD144: 7CE9D050  subf r7, r9, r26
	ctx.r[7].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	// 828BD148: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BD14C: 7CDD4050  subf r6, r29, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 828BD150: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 828BD154: 7CA7F3D6  divw r5, r7, r30
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[30].s32;
	// 828BD158: 7C86F3D6  divw r4, r6, r30
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[30].s32;
	// 828BD15C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BD160: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 828BD164: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828BD168: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BD16C: 40980020  bge cr6, 0x828bd18c
	if !ctx.cr[6].lt {
	pc = 0x828BD18C; continue 'dispatch;
	}
	// 828BD170: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD174: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD178: 4BFFFF61  bl 0x828bd0d8
	ctx.lr = 0x828BD17C;
	sub_828BD0D8(ctx, base);
	// 828BD17C: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD180: FB610110  std r27, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[27].u64 ) };
	// 828BD184: 83A10114  lwz r29, 0x114(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828BD188: 4800001C  b 0x828bd1a4
	pc = 0x828BD1A4; continue 'dispatch;
	// 828BD18C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BD190: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD194: 4BFFFF45  bl 0x828bd0d8
	ctx.lr = 0x828BD198;
	sub_828BD0D8(ctx, base);
	// 828BD198: EB010050  ld r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD19C: FB010118  std r24, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[24].u64 ) };
	// 828BD1A0: 8341011C  lwz r26, 0x11c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828BD1A4: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD1A8: 7D6BF3D6  divw r11, r11, r30
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD1AC: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD1B0: 4199FF68  bgt cr6, 0x828bd118
	if ctx.cr[6].gt {
	pc = 0x828BD118; continue 'dispatch;
	}
	// 828BD1B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD1B8: 40990014  ble cr6, 0x828bd1cc
	if !ctx.cr[6].gt {
	pc = 0x828BD1CC; continue 'dispatch;
	}
	// 828BD1BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD1C0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BD1C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD1C8: 48000331  bl 0x828bd4f8
	ctx.lr = 0x828BD1CC;
	sub_828BD4F8(ctx, base);
	// 828BD1CC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828BD1D0: 483EC278  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828BD1D4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD1D8: 4099FFDC  ble cr6, 0x828bd1b4
	if !ctx.cr[6].gt {
	pc = 0x828BD1B4; continue 'dispatch;
	}
	// 828BD1DC: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD1E0: 7F4BF3D6  divw r26, r11, r30
	ctx.r[26].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD1E4: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828BD1E8: 4099008C  ble cr6, 0x828bd274
	if !ctx.cr[6].gt {
	pc = 0x828BD274; continue 'dispatch;
	}
	// 828BD1EC: 7F4B0E70  srawi r11, r26, 1
	ctx.xer.ca = (ctx.r[26].s32 < 0) && ((ctx.r[26].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[26].s32 >> 1) as i64;
	// 828BD1F0: 7FCB0195  addze. r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828BD1F4: 40810080  ble 0x828bd274
	if !ctx.cr[0].gt {
	pc = 0x828BD274; continue 'dispatch;
	}
	// 828BD1F8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD1FC: 3B200020  li r25, 0x20
	ctx.r[25].s64 = 32;
	// 828BD200: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BD204: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD208: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BD20C: 3BFFFFB0  addi r31, r31, -0x50
	ctx.r[31].s64 = ctx.r[31].s64 + -80;
	// 828BD210: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BD214: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828BD218: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 828BD21C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD224: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BD228: 4B933019  bl 0x821f0240
	ctx.lr = 0x828BD22C;
	sub_821F0240(ctx, base);
	// 828BD22C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD290 size=616
    let mut pc: u32 = 0x828BD290;
    'dispatch: loop {
        match pc {
            0x828BD290 => {
    //   block [0x828BD290..0x828BD4F8)
	// 828BD290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD294: 483EC161  bl 0x82ca93f4
	ctx.lr = 0x828BD298;
	sub_82CA93D0(ctx, base);
	// 828BD298: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD29C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 828BD2A0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828BD2A4: 832100EC  lwz r25, 0xec(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828BD2A8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828BD2AC: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 828BD2B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BD2B4: 830100F4  lwz r24, 0xf4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828BD2B8: 3958FFB0  addi r10, r24, -0x50
	ctx.r[10].s64 = ctx.r[24].s64 + -80;
	// 828BD2BC: 7D39C050  subf r9, r25, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828BD2C0: F8A10068  std r5, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u64 ) };
	// 828BD2C4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828BD2C8: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828BD2CC: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 828BD2D0: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 828BD2D4: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD2D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD2DC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BD2E0: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD2E4: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 828BD2E8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828BD2EC: EBC10060  ld r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD2F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD2F4: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD2F8: 480002F1  bl 0x828bd5e8
	ctx.lr = 0x828BD2FC;
	sub_828BD5E8(ctx, base);
	// 828BD2FC: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 828BD300: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 828BD304: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD308: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD30C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828BD310: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD314: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD318: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 828BD31C: 40980034  bge cr6, 0x828bd350
	if !ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	// 828BD320: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD324: 813DFFB0  lwz r9, -0x50(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD328: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD32C: 41980024  blt cr6, 0x828bd350
	if ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	// 828BD330: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BD334: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD338: 41980018  blt cr6, 0x828bd350
	if ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	// 828BD33C: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD340: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD344: 7F19E840  cmplw cr6, r25, r29
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BD348: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD34C: 4198FFD4  blt cr6, 0x828bd320
	if ctx.cr[6].lt {
	pc = 0x828BD320; continue 'dispatch;
	}
	// 828BD350: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BD354: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD358: 40980028  bge cr6, 0x828bd380
	if !ctx.cr[6].lt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD35C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD360: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD364: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD368: 41990018  bgt cr6, 0x828bd380
	if ctx.cr[6].gt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD36C: 41980014  blt cr6, 0x828bd380
	if ctx.cr[6].lt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD370: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD374: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD378: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD37C: 4198FFE4  blt cr6, 0x828bd360
	if ctx.cr[6].lt {
	pc = 0x828BD360; continue 'dispatch;
	}
	// 828BD380: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD384: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 828BD388: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BD38C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BD390: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BD394: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD398: 4098003C  bge cr6, 0x828bd3d4
	if !ctx.cr[6].lt {
	pc = 0x828BD3D4; continue 'dispatch;
	}
	// 828BD39C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3A0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD3A8: 4199001C  bgt cr6, 0x828bd3c4
	if ctx.cr[6].gt {
	pc = 0x828BD3C4; continue 'dispatch;
	}
	// 828BD3AC: 41980028  blt cr6, 0x828bd3d4
	if ctx.cr[6].lt {
	pc = 0x828BD3D4; continue 'dispatch;
	}
	// 828BD3B0: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD3B4: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD3B8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD3BC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD3C0: 48000351  bl 0x828bd710
	ctx.lr = 0x828BD3C4;
	sub_828BD710(ctx, base);
	// 828BD3C4: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD3C8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD3CC: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD3D0: 4198FFCC  blt cr6, 0x828bd39c
	if ctx.cr[6].lt {
	pc = 0x828BD39C; continue 'dispatch;
	}
	// 828BD3D4: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828BD3D8: 4099005C  ble cr6, 0x828bd434
	if !ctx.cr[6].gt {
	pc = 0x828BD434; continue 'dispatch;
	}
	// 828BD3DC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3E0: 3BFCFFB0  addi r31, r28, -0x50
	ctx.r[31].s64 = ctx.r[28].s64 + -80;
	// 828BD3E4: 815CFFB0  lwz r10, -0x50(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD3E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD3EC: 41980034  blt cr6, 0x828bd420
	if ctx.cr[6].lt {
	pc = 0x828BD420; continue 'dispatch;
	}
	// 828BD3F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD3F8: 41980038  blt cr6, 0x828bd430
	if ctx.cr[6].lt {
	pc = 0x828BD430; continue 'dispatch;
	}
	// 828BD3FC: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD400: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD404: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD408: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828BD40C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828BD410: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD418: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828BD41C: 480002F5  bl 0x828bd710
	ctx.lr = 0x828BD420;
	sub_828BD710(ctx, base);
	// 828BD420: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BD424: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828BD428: 7F19E040  cmplw cr6, r25, r28
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD42C: 4198FFB0  blt cr6, 0x828bd3dc
	if ctx.cr[6].lt {
	pc = 0x828BD3DC; continue 'dispatch;
	}
	// 828BD430: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828BD434: 409A004C  bne cr6, 0x828bd480
	if !ctx.cr[6].eq {
	pc = 0x828BD480; continue 'dispatch;
	}
	// 828BD438: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD43C: 419A00A4  beq cr6, 0x828bd4e0
	if ctx.cr[6].eq {
	pc = 0x828BD4E0; continue 'dispatch;
	}
	// 828BD440: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BD444: 419A0010  beq cr6, 0x828bd454
	if ctx.cr[6].eq {
	pc = 0x828BD454; continue 'dispatch;
	}
	// 828BD448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD44C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD450: 480002C1  bl 0x828bd710
	ctx.lr = 0x828BD454;
	sub_828BD710(ctx, base);
	// 828BD454: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD458: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD45C: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD460: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BD464: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD46C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD470: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD474: 4800029D  bl 0x828bd710
	ctx.lr = 0x828BD478;
	sub_828BD710(ctx, base);
	// 828BD478: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD47C: 4BFFFF18  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
	// 828BD480: 3B9CFFB0  addi r28, r28, -0x50
	ctx.r[28].s64 = ctx.r[28].s64 + -80;
	// 828BD484: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD488: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828BD48C: 409A003C  bne cr6, 0x828bd4c8
	if !ctx.cr[6].eq {
	pc = 0x828BD4C8; continue 'dispatch;
	}
	// 828BD490: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD494: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD498: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BD49C: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD4A0: 419A0010  beq cr6, 0x828bd4b0
	if ctx.cr[6].eq {
	pc = 0x828BD4B0; continue 'dispatch;
	}
	// 828BD4A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD4A8: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD4AC: 48000265  bl 0x828bd710
	ctx.lr = 0x828BD4B0;
	sub_828BD710(ctx, base);
	// 828BD4B0: 3B5AFFB0  addi r26, r26, -0x50
	ctx.r[26].s64 = ctx.r[26].s64 + -80;
	// 828BD4B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD4B8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD4BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD4C0: 48000251  bl 0x828bd710
	ctx.lr = 0x828BD4C4;
	sub_828BD710(ctx, base);
	// 828BD4C4: 4BFFFED0  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
	// 828BD4C8: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD4CC: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD4D0: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD4D4: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD4D8: 48000239  bl 0x828bd710
	ctx.lr = 0x828BD4DC;
	sub_828BD710(ctx, base);
	// 828BD4DC: 4BFFFEB8  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
	// 828BD4E0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD4E4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828BD4E8: FBD70000  std r30, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 828BD4EC: F9770008  std r11, 8(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828BD4F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828BD4F4: 483EBF50  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD4F8 size=236
    let mut pc: u32 = 0x828BD4F8;
    'dispatch: loop {
        match pc {
            0x828BD4F8 => {
    //   block [0x828BD4F8..0x828BD5E4)
	// 828BD4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD4FC: 483EBF0D  bl 0x82ca9408
	ctx.lr = 0x828BD500;
	sub_82CA93D0(ctx, base);
	// 828BD500: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD504: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BD508: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 828BD50C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 828BD510: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828BD514: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828BD518: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD51C: 419A00C0  beq cr6, 0x828bd5dc
	if ctx.cr[6].eq {
	pc = 0x828BD5DC; continue 'dispatch;
	}
	// 828BD520: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 828BD524: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 828BD528: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BD52C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD530: 419A00AC  beq cr6, 0x828bd5dc
	if ctx.cr[6].eq {
	pc = 0x828BD5DC; continue 'dispatch;
	}
	// 828BD534: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD538: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD53C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD540: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD544: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 828BD548: 40980024  bge cr6, 0x828bd56c
	if !ctx.cr[6].lt {
	pc = 0x828BD56C; continue 'dispatch;
	}
	// 828BD54C: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 828BD550: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD554: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD558: 419A0074  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD55C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD560: 419A006C  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BD568: 48000054  b 0x828bd5bc
	pc = 0x828BD5BC; continue 'dispatch;
	// 828BD56C: 397FFFB0  addi r11, r31, -0x50
	ctx.r[11].s64 = ctx.r[31].s64 + -80;
	// 828BD570: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD574: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD578: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD57C: 40980050  bge cr6, 0x828bd5cc
	if !ctx.cr[6].lt {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD580: 396BFFB0  addi r11, r11, -0x50
	ctx.r[11].s64 = ctx.r[11].s64 + -80;
	// 828BD584: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD588: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD58C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD590: F8610060  std r3, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u64 ) };
	// 828BD594: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD598: 4198FFE8  blt cr6, 0x828bd580
	if ctx.cr[6].lt {
	pc = 0x828BD580; continue 'dispatch;
	}
	// 828BD59C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BD5A0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD5A4: 419A0028  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD5A8: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 828BD5AC: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 828BD5B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD5B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD5B8: 419A0014  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD5BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BD5C0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD5C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BD5C8: 48000609  bl 0x828bdbd0
	ctx.lr = 0x828BD5CC;
	sub_828BDBD0(ctx, base);
	// 828BD5CC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BD5D0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BD5D4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD5D8: 409AFF5C  bne cr6, 0x828bd534
	if !ctx.cr[6].eq {
	pc = 0x828BD534; continue 'dispatch;
	}
	// 828BD5DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BD5E0: 483EBE78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD5E8 size=296
    let mut pc: u32 = 0x828BD5E8;
    'dispatch: loop {
        match pc {
            0x828BD5E8 => {
    //   block [0x828BD5E8..0x828BD710)
	// 828BD5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD5EC: 483EBE0D  bl 0x82ca93f8
	ctx.lr = 0x828BD5F0;
	sub_82CA93D0(ctx, base);
	// 828BD5F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD5F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD5F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BD5FC: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 828BD600: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828BD604: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 828BD608: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BD60C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828BD610: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828BD614: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828BD618: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 828BD61C: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828BD620: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 828BD624: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 828BD628: 409900D4  ble cr6, 0x828bd6fc
	if !ctx.cr[6].gt {
	pc = 0x828BD6FC; continue 'dispatch;
	}
	// 828BD62C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BD630: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD634: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 828BD638: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828BD63C: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD640: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BD644: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BD648: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BD64C: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828BD650: 54FF2036  slwi r31, r7, 4
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD654: 54B92834  slwi r25, r5, 5
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 828BD658: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BD65C: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 828BD660: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD664: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828BD668: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD66C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD670: 48000201  bl 0x828bd870
	ctx.lr = 0x828BD674;
	sub_828BD870(ctx, base);
	// 828BD674: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828BD678: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD67C: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 828BD680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD684: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BD688: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 828BD68C: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828BD690: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 828BD694: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BD698: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD69C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6A0: 480001D1  bl 0x828bd870
	ctx.lr = 0x828BD6A4;
	sub_828BD870(ctx, base);
	// 828BD6A4: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828BD6A8: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828BD6AC: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 828BD6B0: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828BD6B4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD6B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BD6BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD6C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828BD6C4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD6C8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6CC: 480001A5  bl 0x828bd870
	ctx.lr = 0x828BD6D0;
	sub_828BD870(ctx, base);
	// 828BD6D0: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828BD6D4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD6D8: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD6DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD6E0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828BD6E4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828BD6E8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD6EC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6F0: 48000181  bl 0x828bd870
	ctx.lr = 0x828BD6F4;
	sub_828BD870(ctx, base);
	// 828BD6F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD6F8: 483EBD50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828BD6FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD700: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD704: 4800016D  bl 0x828bd870
	ctx.lr = 0x828BD708;
	sub_828BD870(ctx, base);
	// 828BD708: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD70C: 483EBD3C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD710 size=128
    let mut pc: u32 = 0x828BD710;
    'dispatch: loop {
        match pc {
            0x828BD710 => {
    //   block [0x828BD710..0x828BD790)
	// 828BD710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD720: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD724: F86100C0  std r3, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[3].u64 ) };
	// 828BD728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD72C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828BD730: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 828BD734: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828BD738: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 828BD73C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD740: 3BEA0010  addi r31, r10, 0x10
	ctx.r[31].s64 = ctx.r[10].s64 + 16;
	// 828BD744: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD74C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BD750: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828BD754: 4BFFEDDD  bl 0x828bc530
	ctx.lr = 0x828BD758;
	sub_828BC530(ctx, base);
	// 828BD758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD760: 4B9A79E1  bl 0x82265140
	ctx.lr = 0x828BD764;
	sub_82265140(ctx, base);
	// 828BD764: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD76C: 4B9A79D5  bl 0x82265140
	ctx.lr = 0x828BD770;
	sub_82265140(ctx, base);
	// 828BD770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD774: 4B957665  bl 0x82214dd8
	ctx.lr = 0x828BD778;
	sub_82214DD8(ctx, base);
	// 828BD778: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD77C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD784: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD78C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD790 size=224
    let mut pc: u32 = 0x828BD790;
    'dispatch: loop {
        match pc {
            0x828BD790 => {
    //   block [0x828BD790..0x828BD870)
	// 828BD790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD794: 483EBC69  bl 0x82ca93fc
	ctx.lr = 0x828BD798;
	sub_82CA93D0(ctx, base);
	// 828BD798: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD79C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BD7A0: 3B800050  li r28, 0x50
	ctx.r[28].s64 = 80;
	// 828BD7A4: FB610140  std r27, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[27].u64 ) };
	// 828BD7A8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BD7AC: F8810148  std r4, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[4].u64 ) };
	// 828BD7B0: 83C10144  lwz r30, 0x144(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 828BD7B4: 83A1014C  lwz r29, 0x14c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 828BD7B8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 828BD7BC: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 828BD7C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD7C4: 409900A4  ble cr6, 0x828bd868
	if !ctx.cr[6].gt {
	pc = 0x828BD868; continue 'dispatch;
	}
	// 828BD7C8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828BD7CC: 3B2A7088  addi r25, r10, 0x7088
	ctx.r[25].s64 = ctx.r[10].s64 + 28808;
	// 828BD7D0: 817DFFB0  lwz r11, -0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD7D4: 3BFDFFB0  addi r31, r29, -0x50
	ctx.r[31].s64 = ctx.r[29].s64 + -80;
	// 828BD7D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD7DC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828BD7E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BD7E4: 4BFFED4D  bl 0x828bc530
	ctx.lr = 0x828BD7E8;
	sub_828BC530(ctx, base);
	// 828BD7E8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD7EC: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828BD7F0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BD7F4: 915DFFB0  stw r10, -0x50(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-80 as u32), ctx.r[10].u32 ) };
	// 828BD7F8: 4B9A7949  bl 0x82265140
	ctx.lr = 0x828BD7FC;
	sub_82265140(ctx, base);
	// 828BD7FC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD800: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BD804: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828BD808: 912100A0  stw r9, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 828BD80C: 4BFFED25  bl 0x828bc530
	ctx.lr = 0x828BD810;
	sub_828BC530(ctx, base);
	// 828BD810: 7D1EF850  subf r8, r30, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 828BD814: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BD818: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828BD81C: 7CA8E3D6  divw r5, r8, r28
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 828BD820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BD824: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD828: 480000D9  bl 0x828bd900
	ctx.lr = 0x828BD82C;
	sub_828BD900(ctx, base);
	// 828BD82C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD830: 4B908F39  bl 0x821c6768
	ctx.lr = 0x828BD834;
	sub_821C6768(ctx, base);
	// 828BD834: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828BD838: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828BD83C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD840: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828BD844: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828BD848: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BD84C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD850: 4082FFE8  bne 0x828bd838
	if !ctx.cr[0].eq {
	pc = 0x828BD838; continue 'dispatch;
	}
	// 828BD854: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD858: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 828BD85C: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 828BD860: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD864: 4199FF6C  bgt cr6, 0x828bd7d0
	if ctx.cr[6].gt {
	pc = 0x828BD7D0; continue 'dispatch;
	}
	// 828BD868: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828BD86C: 483EBBE0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD870 size=140
    let mut pc: u32 = 0x828BD870;
    'dispatch: loop {
        match pc {
            0x828BD870 => {
    //   block [0x828BD870..0x828BD8FC)
	// 828BD870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD874: 483EBB91  bl 0x82ca9404
	ctx.lr = 0x828BD878;
	sub_82CA93D0(ctx, base);
	// 828BD878: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD87C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD880: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD884: FBC10090  std r30, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u64 ) };
	// 828BD888: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828BD88C: FBE10098  std r31, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u64 ) };
	// 828BD890: 8381009C  lwz r28, 0x9c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828BD894: 83610094  lwz r27, 0x94(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828BD898: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 828BD89C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8A0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8A8: 40980010  bge cr6, 0x828bd8b8
	if !ctx.cr[6].lt {
	pc = 0x828BD8B8; continue 'dispatch;
	}
	// 828BD8AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD8B4: 4BFFFE5D  bl 0x828bd710
	ctx.lr = 0x828BD8B8;
	sub_828BD710(ctx, base);
	// 828BD8B8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828BD8BC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8C8: 40980010  bge cr6, 0x828bd8d8
	if !ctx.cr[6].lt {
	pc = 0x828BD8D8; continue 'dispatch;
	}
	// 828BD8CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD8D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BD8D4: 4BFFFE3D  bl 0x828bd710
	ctx.lr = 0x828BD8D8;
	sub_828BD710(ctx, base);
	// 828BD8D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8E4: 40980010  bge cr6, 0x828bd8f4
	if !ctx.cr[6].lt {
	pc = 0x828BD8F4; continue 'dispatch;
	}
	// 828BD8E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD8F0: 4BFFFE21  bl 0x828bd710
	ctx.lr = 0x828BD8F4;
	sub_828BD710(ctx, base);
	// 828BD8F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BD8F8: 483EBB5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD900 size=436
    let mut pc: u32 = 0x828BD900;
    'dispatch: loop {
        match pc {
            0x828BD900 => {
    //   block [0x828BD900..0x828BDAB4)
	// 828BD900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD904: 483EBAE1  bl 0x82ca93e4
	ctx.lr = 0x828BD908;
	sub_82CA93D0(ctx, base);
	// 828BD908: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD90C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BD910: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 828BD914: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 828BD918: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828BD91C: FAA10130  std r21, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[21].u64 ) };
	// 828BD920: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD924: 83610134  lwz r27, 0x134(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 828BD928: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 828BD92C: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 828BD930: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 828BD934: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 828BD938: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 828BD93C: 409800A4  bge cr6, 0x828bd9e0
	if !ctx.cr[6].lt {
	pc = 0x828BD9E0; continue 'dispatch;
	}
	// 828BD940: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD944: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BD948: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD94C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BD950: 394BFFB0  addi r10, r11, -0x50
	ctx.r[10].s64 = ctx.r[11].s64 + -80;
	// 828BD954: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BD958: 812BFFB0  lwz r9, -0x50(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD95C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD960: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD964: 40980008  bge cr6, 0x828bd96c
	if !ctx.cr[6].lt {
	pc = 0x828BD96C; continue 'dispatch;
	}
	// 828BD968: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 828BD96C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD970: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD974: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BD978: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 828BD97C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD980: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD984: 7FCADA14  add r30, r10, r27
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828BD988: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BD98C: 3B5E0010  addi r26, r30, 0x10
	ctx.r[26].s64 = ctx.r[30].s64 + 16;
	// 828BD990: 7D0AD82E  lwzx r8, r10, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 828BD994: 3B3D0010  addi r25, r29, 0x10
	ctx.r[25].s64 = ctx.r[29].s64 + 16;
	// 828BD998: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BD99C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BD9A0: 7D0BD92E  stwx r8, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[8].u32) };
	// 828BD9A4: 4B9A77FD  bl 0x822651a0
	ctx.lr = 0x828BD9A8;
	sub_822651A0(ctx, base);
	// 828BD9A8: E8DE0020  ld r6, 0x20(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 828BD9AC: 38FF0001  addi r7, r31, 1
	ctx.r[7].s64 = ctx.r[31].s64 + 1;
	// 828BD9B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BD9B4: 54FF083C  slwi r31, r7, 1
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD9B8: F8DD0020  std r6, 0x20(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[6].u64 ) };
	// 828BD9BC: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 828BD9C0: E8BE0028  ld r5, 0x28(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 828BD9C4: F8BD0028  std r5, 0x28(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[5].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BDAB8 size=280
    let mut pc: u32 = 0x828BDAB8;
    'dispatch: loop {
        match pc {
            0x828BDAB8 => {
    //   block [0x828BDAB8..0x828BDBD0)
	// 828BDAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDABC: 483EB94D  bl 0x82ca9408
	ctx.lr = 0x828BDAC0;
	sub_82CA93D0(ctx, base);
	// 828BDAC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDAC4: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 828BDAC8: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 828BDACC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828BDAD0: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828BDAD4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BDAD8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828BDADC: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828BDAE0: 7FEA0194  addze r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828BDAE4: 40980060  bge cr6, 0x828bdb44
	if !ctx.cr[6].lt {
	pc = 0x828BDB44; continue 'dispatch;
	}
	// 828BDAE8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDAEC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDAF0: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BDAF4: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDAF8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BDAFC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB00: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDB04: 40980040  bge cr6, 0x828bdb44
	if !ctx.cr[6].lt {
	pc = 0x828BDB44; continue 'dispatch;
	}
	// 828BDB08: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDB0C: 5509003E  slwi r9, r8, 0
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BDB10: 7D045214  add r8, r4, r10
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 828BDB14: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828BDB18: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDB1C: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828BDB20: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 828BDB24: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BDB28: 4B9A7619  bl 0x82265140
	ctx.lr = 0x828BDB2C;
	sub_82265140(ctx, base);
	// 828BDB2C: 38FFFFFF  addi r7, r31, -1
	ctx.r[7].s64 = ctx.r[31].s64 + -1;
	// 828BDB30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BDB34: 7CE60E70  srawi r6, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 828BDB38: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828BDB3C: 7FE60194  addze r31, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828BDB40: 4198FFA8  blt cr6, 0x828bdae8
	if ctx.cr[6].lt {
	pc = 0x828BDAE8; continue 'dispatch;
	}
	// 828BDB44: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDB48: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB4C: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BDB50: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828BDB54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BDB58: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDB5C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BDB60: 7D4BE12E  stwx r10, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 828BDB64: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 828BDB68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BDB6C: 4B9A7635  bl 0x822651a0
	ctx.lr = 0x828BDB70;
	sub_822651A0(ctx, base);
	// 828BDB70: E91E0020  ld r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 828BDB74: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828BDB78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BDB7C: F91F0020  std r8, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u64 ) };
	// 828BDB80: E8FE0028  ld r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 828BDB84: F8FF0028  std r7, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDBD0 size=512
    let mut pc: u32 = 0x828BDBD0;
    'dispatch: loop {
        match pc {
            0x828BDBD0 => {
    //   block [0x828BDBD0..0x828BDDD0)
	// 828BDBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDBD4: 483EB805  bl 0x82ca93d8
	ctx.lr = 0x828BDBD8;
	sub_82CA93D0(ctx, base);
	// 828BDBD8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDBDC: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 828BDBE0: 3A600050  li r19, 0x50
	ctx.r[19].s64 = 80;
	// 828BDBE4: FAA10170  std r21, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[21].u64 ) };
	// 828BDBE8: F8A10180  std r5, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[5].u64 ) };
	// 828BDBEC: 82E10184  lwz r23, 0x184(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 828BDBF0: F8810178  std r4, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[4].u64 ) };
	// 828BDBF4: 82810174  lwz r20, 0x174(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 828BDBF8: 8161017C  lwz r11, 0x17c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 828BDBFC: 7D545850  subf r10, r20, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[20].s64;
	// 828BDC00: 7D34B850  subf r9, r20, r23
	ctx.r[9].s64 = ctx.r[23].s64 - ctx.r[20].s64;
	// 828BDC04: 7F4A9BD7  divw. r26, r10, r19
	ctx.r[26].s32 = ctx.r[10].s32 / ctx.r[19].s32;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828BDC08: 7D299BD6  divw r9, r9, r19
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[19].s32;
	// 828BDC0C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BDC10: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 828BDC14: 4182001C  beq 0x828bdc30
	if ctx.cr[0].eq {
	pc = 0x828BDC30; continue 'dispatch;
	}
	// 828BDC18: 7D565BD6  divw r10, r22, r11
	ctx.r[10].s32 = ctx.r[22].s32 / ctx.r[11].s32;
	// 828BDC1C: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 828BDC20: 7D48B051  subf. r10, r8, r22
	ctx.r[10].s64 = ctx.r[22].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BDC24: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 828BDC28: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828BDC2C: 4082FFEC  bne 0x828bdc18
	if !ctx.cr[0].eq {
	pc = 0x828BDC18; continue 'dispatch;
	}
	// 828BDC30: 7F164800  cmpw cr6, r22, r9
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828BDC34: 40980194  bge cr6, 0x828bddc8
	if !ctx.cr[6].lt {
	pc = 0x828BDDC8; continue 'dispatch;
	}
	// 828BDC38: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 828BDC3C: 4099018C  ble cr6, 0x828bddc8
	if !ctx.cr[6].gt {
	pc = 0x828BDDC8; continue 'dispatch;
	}
	// 828BDC40: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDC44: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDC48: 7D765A14  add r11, r22, r11
	ctx.r[11].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 828BDC4C: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 828BDC50: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDC54: 55522036  slwi r18, r10, 4
	ctx.r[18].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 828BDC58: 7F2BA214  add r25, r11, r20
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 828BDC5C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BDC60: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 828BDC64: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 828BDC68: 3A2B7088  addi r17, r11, 0x7088
	ctx.r[17].s64 = ctx.r[11].s64 + 28808;
	// 828BDC6C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDC70: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 828BDC74: FAA10058  std r21, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u64 ) };
	// 828BDC78: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828BDC7C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 828BDC80: EBE10058  ld r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BDC84: FBE10058  std r31, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u64 ) };
	// 828BDC88: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828BDC8C: 4BFFE8A5  bl 0x828bc530
	ctx.lr = 0x828BDC90;
	sub_828BC530(ctx, base);
	// 828BDC90: 7D799214  add r11, r25, r18
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[18].u64;
	// 828BDC94: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828BDC98: 409A000C  bne cr6, 0x828bdca4
	if !ctx.cr[6].eq {
	pc = 0x828BDCA4; continue 'dispatch;
	}
	// 828BDC9C: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 828BDCA0: 48000018  b 0x828bdcb8
	pc = 0x828BDCB8; continue 'dispatch;
	// 828BDCA4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 828BDCA8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828BDCAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BDCB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BDCB4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BDCB8: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BDCBC: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 828BDCC0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BDCC4: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828BDCC8: 419A00B0  beq cr6, 0x828bdd78
	if ctx.cr[6].eq {
	pc = 0x828BDD78; continue 'dispatch;
	}
	// 828BDCCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDCD0: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828BDCD4: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDCD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BDCDC: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 828BDCE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BDCE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDCE8: 4B9A74B9  bl 0x822651a0
	ctx.lr = 0x828BDCEC;
	sub_822651A0(ctx, base);
	// 828BDCEC: E93F0020  ld r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828BDCF0: 7D5FB850  subf r10, r31, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 828BDCF4: FB610058  std r27, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u64 ) };
	// 828BDCF8: 7D6A9BD6  divw r11, r10, r19
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[19].s32;
	// 828BDCFC: F93E0020  std r9, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[9].u64 ) };
	// 828BDD00: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828BDD04: E91F0028  ld r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 828BDD08: F91E0028  std r8, 0x28(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[8].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDDD0 size=60
    let mut pc: u32 = 0x828BDDD0;
    'dispatch: loop {
        match pc {
            0x828BDDD0 => {
    //   block [0x828BDDD0..0x828BDE0C)
	// 828BDDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDDDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDDE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BDDE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BDDE8: 388B9938  addi r4, r11, -0x66c8
	ctx.r[4].s64 = ctx.r[11].s64 + -26312;
	// 828BDDEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDDF0: 4B96F0E1  bl 0x8222ced0
	ctx.lr = 0x828BDDF4;
	sub_8222CED0(ctx, base);
	// 828BDDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BDDF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BDDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDE04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDE10 size=324
    let mut pc: u32 = 0x828BDE10;
    'dispatch: loop {
        match pc {
            0x828BDE10 => {
    //   block [0x828BDE10..0x828BDF54)
	// 828BDE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDE14: 483EB5ED  bl 0x82ca9400
	ctx.lr = 0x828BDE18;
	sub_82CA93D0(ctx, base);
	// 828BDE18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDE20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BDE24: 419A0128  beq cr6, 0x828bdf4c
	if ctx.cr[6].eq {
	pc = 0x828BDF4C; continue 'dispatch;
	}
	// 828BDE28: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BDE2C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BDE30: 388B2ED8  addi r4, r11, 0x2ed8
	ctx.r[4].s64 = ctx.r[11].s64 + 11992;
	// 828BDE34: 4B9EBBB5  bl 0x822a99e8
	ctx.lr = 0x828BDE38;
	sub_822A99E8(ctx, base);
	// 828BDE38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BDE3C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BDE40: 419A010C  beq cr6, 0x828bdf4c
	if ctx.cr[6].eq {
	pc = 0x828BDF4C; continue 'dispatch;
	}
	// 828BDE44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BDE48: 48142B49  bl 0x82a00990
	ctx.lr = 0x828BDE4C;
	sub_82A00990(ctx, base);
	// 828BDE4C: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BDE50: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BDE54: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BDE58: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BDE5C: 419A00E8  beq cr6, 0x828bdf44
	if ctx.cr[6].eq {
	pc = 0x828BDF44; continue 'dispatch;
	}
	// 828BDE60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828BDE64: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828BDE68: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	// 828BDE6C: 3B8BE460  addi r28, r11, -0x1ba0
	ctx.r[28].s64 = ctx.r[11].s64 + -7072;
	// 828BDE70: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDE74: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BDE78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDE7C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BDE80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDE84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDE88: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828BDE8C: 419A0020  beq cr6, 0x828bdeac
	if ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDE90: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BDE94: 409A0018  bne cr6, 0x828bdeac
	if !ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDE98: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDE9C: 813BE454  lwz r9, -0x1bac(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828BDEA0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDEA4: 409A0008  bne cr6, 0x828bdeac
	if !ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDEA8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828BDEAC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDEB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDEB8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828BDEBC: 409A000C  bne cr6, 0x828bdec8
	if !ctx.cr[6].eq {
	pc = 0x828BDEC8; continue 'dispatch;
	}
	// 828BDEC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BDEC4: 48000010  b 0x828bded4
	pc = 0x828BDED4; continue 'dispatch;
	// 828BDEC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDECC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BDED0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 828BDED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDED8: 419A0034  beq cr6, 0x828bdf0c
	if ctx.cr[6].eq {
	pc = 0x828BDF0C; continue 'dispatch;
	}
	// 828BDEDC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BDEE0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BDEE4: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 828BDEE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDEEC: 40980020  bge cr6, 0x828bdf0c
	if !ctx.cr[6].lt {
	pc = 0x828BDF0C; continue 'dispatch;
	}
	// 828BDEF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDEF8: 419A0008  beq cr6, 0x828bdf00
	if ctx.cr[6].eq {
	pc = 0x828BDF00; continue 'dispatch;
	}
	// 828BDEFC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828BDF00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BDF04: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BDF08: 48000030  b 0x828bdf38
	pc = 0x828BDF38; continue 'dispatch;
	// 828BDF0C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDF10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDF14: 40990008  ble cr6, 0x828bdf1c
	if !ctx.cr[6].gt {
	pc = 0x828BDF1C; continue 'dispatch;
	}
	// 828BDF18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDF1C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BDF20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828BDF24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BDF28: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828BDF2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BDF30: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BDF34: 4BCC1715  bl 0x8257f648
	ctx.lr = 0x828BDF38;
	sub_8257F648(ctx, base);
	// 828BDF38: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BDF3C: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BDF40: 409AFF30  bne cr6, 0x828bde70
	if !ctx.cr[6].eq {
	pc = 0x828BDE70; continue 'dispatch;
	}
	// 828BDF44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BDF48: 4B95DDF1  bl 0x8221bd38
	ctx.lr = 0x828BDF4C;
	sub_8221BD38(ctx, base);
	// 828BDF4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BDF50: 483EB500  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BDF58 size=288
    let mut pc: u32 = 0x828BDF58;
    'dispatch: loop {
        match pc {
            0x828BDF58 => {
    //   block [0x828BDF58..0x828BE078)
	// 828BDF58: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BDF5C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 828BDF60: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BDF64: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDF68: 40990008  ble cr6, 0x828bdf70
	if !ctx.cr[6].gt {
	pc = 0x828BDF70; continue 'dispatch;
	}
	// 828BDF6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDF70: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDF74: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDF78: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDF7C: 40990008  ble cr6, 0x828bdf84
	if !ctx.cr[6].gt {
	pc = 0x828BDF84; continue 'dispatch;
	}
	// 828BDF80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDF84: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 828BDF88: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDF8C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828BDF90: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDF94: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828BDF98: 419A001C  beq cr6, 0x828bdfb4
	if ctx.cr[6].eq {
	pc = 0x828BDFB4; continue 'dispatch;
	}
	// 828BDF9C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDFA0: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828BDFA4: 419A0010  beq cr6, 0x828bdfb4
	if ctx.cr[6].eq {
	pc = 0x828BDFB4; continue 'dispatch;
	}
	// 828BDFA8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BDFAC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDFB0: 409AFFEC  bne cr6, 0x828bdf9c
	if !ctx.cr[6].eq {
	pc = 0x828BDF9C; continue 'dispatch;
	}
	// 828BDFB4: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDFB8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDFBC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDFC0: 40990008  ble cr6, 0x828bdfc8
	if !ctx.cr[6].gt {
	pc = 0x828BDFC8; continue 'dispatch;
	}
	// 828BDFC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDFC8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828BDFCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BDFD0: 419A000C  beq cr6, 0x828bdfdc
	if ctx.cr[6].eq {
	pc = 0x828BDFDC; continue 'dispatch;
	}
	// 828BDFD4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BDFD8: 419A0008  beq cr6, 0x828bdfe0
	if ctx.cr[6].eq {
	pc = 0x828BDFE0; continue 'dispatch;
	}
	// 828BDFDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDFE0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDFE4: 409A0094  bne cr6, 0x828be078
	if !ctx.cr[6].eq {
		sub_828BE078(ctx, base);
		return;
	}
	// 828BDFE8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDFEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDFF0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDFF4: 40990008  ble cr6, 0x828bdffc
	if !ctx.cr[6].gt {
	pc = 0x828BDFFC; continue 'dispatch;
	}
	// 828BDFF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BDFFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE000: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BE004: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE008: 40990008  ble cr6, 0x828be010
	if !ctx.cr[6].gt {
	pc = 0x828BE010; continue 'dispatch;
	}
	// 828BE00C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BE010: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 828BE014: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BE018: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828BE01C: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE020: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828BE024: 419A001C  beq cr6, 0x828be040
	if ctx.cr[6].eq {
	pc = 0x828BE040; continue 'dispatch;
	}
	// 828BE028: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE02C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828BE030: 419A0010  beq cr6, 0x828be040
	if ctx.cr[6].eq {
	pc = 0x828BE040; continue 'dispatch;
	}
	// 828BE034: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BE038: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BE03C: 409AFFEC  bne cr6, 0x828be028
	if !ctx.cr[6].eq {
	pc = 0x828BE028; continue 'dispatch;
	}
	// 828BE040: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BE044: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE048: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE04C: 40990008  ble cr6, 0x828be054
	if !ctx.cr[6].gt {
	pc = 0x828BE054; continue 'dispatch;
	}
	// 828BE050: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BE054: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828BE058: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BE05C: 419A000C  beq cr6, 0x828be068
	if ctx.cr[6].eq {
	pc = 0x828BE068; continue 'dispatch;
	}
	// 828BE060: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BE064: 419A0008  beq cr6, 0x828be06c
	if ctx.cr[6].eq {
	pc = 0x828BE06C; continue 'dispatch;
	}
	// 828BE068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BE06C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE074: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE078 size=8
    let mut pc: u32 = 0x828BE078;
    'dispatch: loop {
        match pc {
            0x828BE078 => {
    //   block [0x828BE078..0x828BE080)
	// 828BE078: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BE07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE080 size=60
    let mut pc: u32 = 0x828BE080;
    'dispatch: loop {
        match pc {
            0x828BE080 => {
    //   block [0x828BE080..0x828BE0BC)
	// 828BE080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE08C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE090: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BE094: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE098: 388B9500  addi r4, r11, -0x6b00
	ctx.r[4].s64 = ctx.r[11].s64 + -27392;
	// 828BE09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE0A0: 4B96EE31  bl 0x8222ced0
	ctx.lr = 0x828BE0A4;
	sub_8222CED0(ctx, base);
	// 828BE0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE0A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BE0AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE0B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE0B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE0B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE0C0 size=96
    let mut pc: u32 = 0x828BE0C0;
    'dispatch: loop {
        match pc {
            0x828BE0C0 => {
    //   block [0x828BE0C0..0x828BE120)
	// 828BE0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE0C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE0CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE0D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE0D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE0DC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828BE0E0: 48002531  bl 0x828c0610
	ctx.lr = 0x828BE0E4;
	sub_828C0610(ctx, base);
	// 828BE0E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828BE0E8: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828BE0EC: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828BE0F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE0F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BE0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE0FC: 419A000C  beq cr6, 0x828be108
	if ctx.cr[6].eq {
	pc = 0x828BE108; continue 'dispatch;
	}
	// 828BE100: 4B95DC39  bl 0x8221bd38
	ctx.lr = 0x828BE104;
	sub_8221BD38(ctx, base);
	// 828BE104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE108: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE10C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE114: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BE118: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE120 size=8
    let mut pc: u32 = 0x828BE120;
    'dispatch: loop {
        match pc {
            0x828BE120 => {
    //   block [0x828BE120..0x828BE128)
	// 828BE120: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 828BE124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE128 size=160
    let mut pc: u32 = 0x828BE128;
    'dispatch: loop {
        match pc {
            0x828BE128 => {
    //   block [0x828BE128..0x828BE1C8)
	// 828BE128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE144: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BE148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE14C: 388B2F30  addi r4, r11, 0x2f30
	ctx.r[4].s64 = ctx.r[11].s64 + 12080;
	// 828BE150: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828BE154: 4BAEF29D  bl 0x823ad3f0
	ctx.lr = 0x828BE158;
	sub_823AD3F0(ctx, base);
	// 828BE158: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BE15C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE160: 388A2F40  addi r4, r10, 0x2f40
	ctx.r[4].s64 = ctx.r[10].s64 + 12096;
	// 828BE164: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828BE168: 4BAEF289  bl 0x823ad3f0
	ctx.lr = 0x828BE16C;
	sub_823AD3F0(ctx, base);
	// 828BE16C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828BE170: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828BE174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE178: 38892F5C  addi r4, r9, 0x2f5c
	ctx.r[4].s64 = ctx.r[9].s64 + 12124;
	// 828BE17C: 4BAEF275  bl 0x823ad3f0
	ctx.lr = 0x828BE180;
	sub_823AD3F0(ctx, base);
	// 828BE180: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 828BE184: C1BF001C  lfs f13, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE188: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 828BE18C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828BE190: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828BE194: 38862F6C  addi r4, r6, 0x2f6c
	ctx.r[4].s64 = ctx.r[6].s64 + 12140;
	// 828BE198: C8089660  lfd f0, -0x69a0(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(-27040 as u32) ) };
	// 828BE19C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE1A0: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 828BE1A4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 828BE1A8: 7D7F3FAE  stfiwx f11, r31, r7
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 828BE1AC: 4BAEF245  bl 0x823ad3f0
	ctx.lr = 0x828BE1B0;
	sub_823AD3F0(ctx, base);
	// 828BE1B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE1BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BE1C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE1C8 size=164
    let mut pc: u32 = 0x828BE1C8;
    'dispatch: loop {
        match pc {
            0x828BE1C8 => {
    //   block [0x828BE1C8..0x828BE26C)
	// 828BE1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE1CC: 483EB241  bl 0x82ca940c
	ctx.lr = 0x828BE1D0;
	sub_82CA93D0(ctx, base);
	// 828BE1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BE1DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BE1E0: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 828BE1E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE1E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE1EC: 409A0038  bne cr6, 0x828be224
	if !ctx.cr[6].eq {
	pc = 0x828BE224; continue 'dispatch;
	}
	// 828BE1F0: 807D0064  lwz r3, 0x64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE1F8: 419A002C  beq cr6, 0x828be224
	if ctx.cr[6].eq {
	pc = 0x828BE224; continue 'dispatch;
	}
	// 828BE1FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828BE200: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 828BE204: 485C94CD  bl 0x82e876d0
	ctx.lr = 0x828BE208;
	sub_82E876D0(ctx, base);
	// 828BE208: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828BE20C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE210: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE218: 4B96ECB9  bl 0x8222ced0
	ctx.lr = 0x828BE21C;
	sub_8222CED0(ctx, base);
	// 828BE21C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE220: 4B956BB9  bl 0x82214dd8
	ctx.lr = 0x828BE224;
	sub_82214DD8(ctx, base);
	// 828BE224: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BE228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE22C: 409A0038  bne cr6, 0x828be264
	if !ctx.cr[6].eq {
	pc = 0x828BE264; continue 'dispatch;
	}
	// 828BE230: 807D0064  lwz r3, 0x64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE238: 419A002C  beq cr6, 0x828be264
	if ctx.cr[6].eq {
	pc = 0x828BE264; continue 'dispatch;
	}
	// 828BE23C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828BE240: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 828BE244: 485C948D  bl 0x82e876d0
	ctx.lr = 0x828BE248;
	sub_82E876D0(ctx, base);
	// 828BE248: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 828BE24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE258: 4B96EC79  bl 0x8222ced0
	ctx.lr = 0x828BE25C;
	sub_8222CED0(ctx, base);
	// 828BE25C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE260: 4B956B79  bl 0x82214dd8
	ctx.lr = 0x828BE264;
	sub_82214DD8(ctx, base);
	// 828BE264: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BE268: 483EB1F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE270 size=992
    let mut pc: u32 = 0x828BE270;
    'dispatch: loop {
        match pc {
            0x828BE270 => {
    //   block [0x828BE270..0x828BE650)
	// 828BE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE274: 483EB18D  bl 0x82ca9400
	ctx.lr = 0x828BE278;
	sub_82CA93D0(ctx, base);
	// 828BE278: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE27C: 83830010  lwz r28, 0x10(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BE280: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BE284: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BE288: 419A03BC  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE28C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BE290: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828BE294: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828BE298: 419A0018  beq cr6, 0x828be2b0
	if ctx.cr[6].eq {
	pc = 0x828BE2B0; continue 'dispatch;
	}
	// 828BE29C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BE2A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BE2A4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE2A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE2AC: 409A0008  bne cr6, 0x828be2b4
	if !ctx.cr[6].eq {
	pc = 0x828BE2B4; continue 'dispatch;
	}
	// 828BE2B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BE2B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE2BC: 419A0388  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE2C0: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE2C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE2C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE2CC: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE2D0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE2D8: 419A00F4  beq cr6, 0x828be3cc
	if ctx.cr[6].eq {
	pc = 0x828BE3CC; continue 'dispatch;
	}
	// 828BE2DC: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE2E4: 419A0024  beq cr6, 0x828be308
	if ctx.cr[6].eq {
	pc = 0x828BE308; continue 'dispatch;
	}
	// 828BE2E8: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE2EC: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE2F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE2F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE2F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE2FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE300: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE304: 480000CC  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
	// 828BE308: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE30C: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE310: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828BE314: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE318: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE31C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE320: 40810054  ble 0x828be374
	if !ctx.cr[0].gt {
	pc = 0x828BE374; continue 'dispatch;
	}
	// 828BE324: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE328: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE32C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE330: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE334: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE338: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BE33C: 41980008  blt cr6, 0x828be344
	if ctx.cr[6].lt {
	pc = 0x828BE344; continue 'dispatch;
	}
	// 828BE340: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828BE344: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE348: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE34C: 419A0014  beq cr6, 0x828be360
	if ctx.cr[6].eq {
	pc = 0x828BE360; continue 'dispatch;
	}
	// 828BE350: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE354: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE358: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE35C: 4800000C  b 0x828be368
	pc = 0x828BE368; continue 'dispatch;
	// 828BE360: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE364: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BE368: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE36C: 4199FFB8  bgt cr6, 0x828be324
	if ctx.cr[6].gt {
	pc = 0x828BE324; continue 'dispatch;
	}
	// 828BE370: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE374: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE378: 419A0040  beq cr6, 0x828be3b8
	if ctx.cr[6].eq {
	pc = 0x828BE3B8; continue 'dispatch;
	}
	// 828BE37C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE380: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE384: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE388: 41990008  bgt cr6, 0x828be390
	if ctx.cr[6].gt {
	pc = 0x828BE390; continue 'dispatch;
	}
	// 828BE38C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BE390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE398: 409A0020  bne cr6, 0x828be3b8
	if !ctx.cr[6].eq {
	pc = 0x828BE3B8; continue 'dispatch;
	}
	// 828BE39C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE3A0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE3A4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE3A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE3AC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE3B0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE3B4: 4800001C  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
	// 828BE3B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE3BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE3C0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE3C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE3C8: 48000008  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
	// 828BE3CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BE3D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE3D8: 419A026C  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE3DC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE3E0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE3E8: 419A00F0  beq cr6, 0x828be4d8
	if ctx.cr[6].eq {
	pc = 0x828BE4D8; continue 'dispatch;
	}
	// 828BE3EC: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE3F0: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE3F8: 419A0020  beq cr6, 0x828be418
	if ctx.cr[6].eq {
	pc = 0x828BE418; continue 'dispatch;
	}
	// 828BE3FC: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE400: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BE404: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BE408: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE40C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE410: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE414: 480000C8  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
	// 828BE418: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE41C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828BE420: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE424: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE428: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE42C: 40810054  ble 0x828be480
	if !ctx.cr[0].gt {
	pc = 0x828BE480; continue 'dispatch;
	}
	// 828BE430: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE434: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE438: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE43C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE440: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE444: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BE448: 41980008  blt cr6, 0x828be450
	if ctx.cr[6].lt {
	pc = 0x828BE450; continue 'dispatch;
	}
	// 828BE44C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828BE450: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE454: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE458: 419A0014  beq cr6, 0x828be46c
	if ctx.cr[6].eq {
	pc = 0x828BE46C; continue 'dispatch;
	}
	// 828BE45C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE460: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE464: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE468: 4800000C  b 0x828be474
	pc = 0x828BE474; continue 'dispatch;
	// 828BE46C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE470: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BE474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE478: 4199FFB8  bgt cr6, 0x828be430
	if ctx.cr[6].gt {
	pc = 0x828BE430; continue 'dispatch;
	}
	// 828BE47C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE480: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE484: 419A0040  beq cr6, 0x828be4c4
	if ctx.cr[6].eq {
	pc = 0x828BE4C4; continue 'dispatch;
	}
	// 828BE488: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE48C: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE490: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE494: 41990008  bgt cr6, 0x828be49c
	if ctx.cr[6].gt {
	pc = 0x828BE49C; continue 'dispatch;
	}
	// 828BE498: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BE49C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE4A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE4A4: 409A0020  bne cr6, 0x828be4c4
	if !ctx.cr[6].eq {
	pc = 0x828BE4C4; continue 'dispatch;
	}
	// 828BE4A8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE4AC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE4B0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE4B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE4B8: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE4BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE4C0: 4800001C  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
	// 828BE4C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE4C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE4CC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE4D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE4D4: 48000008  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
	// 828BE4D8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BE4DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE4E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE4E4: 419A0160  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE4E8: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 828BE4EC: 83E4000C  lwz r31, 0xc(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE4F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE4F4: 83C5000C  lwz r30, 0xc(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE4F8: 419A00E4  beq cr6, 0x828be5dc
	if ctx.cr[6].eq {
	pc = 0x828BE5DC; continue 'dispatch;
	}
	// 828BE4FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BE500: 419A00DC  beq cr6, 0x828be5dc
	if ctx.cr[6].eq {
	pc = 0x828BE5DC; continue 'dispatch;
	}
	// 828BE504: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828BE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE50C: 409A0070  bne cr6, 0x828be57c
	if !ctx.cr[6].eq {
	pc = 0x828BE57C; continue 'dispatch;
	}
	// 828BE510: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE51C: 480041E5  bl 0x828c2700
	ctx.lr = 0x828BE520;
	sub_828C2700(ctx, base);
	// 828BE520: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE528: 419A0054  beq cr6, 0x828be57c
	if ctx.cr[6].eq {
	pc = 0x828BE57C; continue 'dispatch;
	}
	// 828BE52C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE534: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE538: 48004229  bl 0x828c2760
	ctx.lr = 0x828BE53C;
	sub_828C2760(ctx, base);
	// 828BE53C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BE540: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828BE544: 419A0100  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE548: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 828BE54C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BE550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BE554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE558: 48004019  bl 0x828c2570
	ctx.lr = 0x828BE55C;
	sub_828C2570(ctx, base);
	// 828BE55C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BE560: 419A00E4  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE564: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE568: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828BE56C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828BE570: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828BE574: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE578: 483EAED8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828BE57C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 828BE580: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BE584: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE588: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE58C: 4BA14DCD  bl 0x822d3358
	ctx.lr = 0x828BE590;
	sub_822D3358(ctx, base);
	// 828BE590: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE594: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 828BE598: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 828BE59C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BE5A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE5A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE5A8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BE5AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE5B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BE5B4: 4E800421  bctrl
	ctx.lr = 0x828BE5B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BE5B8: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BE5BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BE5C0: 419AFFC0  beq cr6, 0x828be580
	if ctx.cr[6].eq {
	pc = 0x828BE580; continue 'dispatch;
	}
	// 828BE5C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE5CC: 409AFF98  bne cr6, 0x828be564
	if !ctx.cr[6].eq {
	pc = 0x828BE564; continue 'dispatch;
	}
	// 828BE5D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE5D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE5D8: 483EAE78  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828BE5DC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BE5E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE5E4: 388B2F8C  addi r4, r11, 0x2f8c
	ctx.r[4].s64 = ctx.r[11].s64 + 12172;
	// 828BE5E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE5EC: 3BFB0080  addi r31, r27, 0x80
	ctx.r[31].s64 = ctx.r[27].s64 + 128;
	// 828BE5F0: 4B96E8E1  bl 0x8222ced0
	ctx.lr = 0x828BE5F4;
	sub_8222CED0(ctx, base);
	// 828BE5F4: 389D0080  addi r4, r29, 0x80
	ctx.r[4].s64 = ctx.r[29].s64 + 128;
	// 828BE5F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE5FC: 4B92E1FD  bl 0x821ec7f8
	ctx.lr = 0x828BE600;
	sub_821EC7F8(ctx, base);
	// 828BE600: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BE604: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE608: 4B931C39  bl 0x821f0240
	ctx.lr = 0x828BE60C;
	sub_821F0240(ctx, base);
	// 828BE60C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BE610: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE614: 388A4A00  addi r4, r10, 0x4a00
	ctx.r[4].s64 = ctx.r[10].s64 + 18944;
	// 828BE618: 4B91C3A9  bl 0x821da9c0
	ctx.lr = 0x828BE61C;
	sub_821DA9C0(ctx, base);
	// 828BE61C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE620: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BE624: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE628: 4B924AE1  bl 0x821e3108
	ctx.lr = 0x828BE62C;
	sub_821E3108(ctx, base);
	// 828BE62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE630: 4B9567A9  bl 0x82214dd8
	ctx.lr = 0x828BE634;
	sub_82214DD8(ctx, base);
	// 828BE634: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE638: 4B9567A1  bl 0x82214dd8
	ctx.lr = 0x828BE63C;
	sub_82214DD8(ctx, base);
	// 828BE63C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE640: 4B956799  bl 0x82214dd8
	ctx.lr = 0x828BE644;
	sub_82214DD8(ctx, base);
	// 828BE644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE648: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE64C: 483EAE04  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE650 size=1404
    let mut pc: u32 = 0x828BE650;
    'dispatch: loop {
        match pc {
            0x828BE650 => {
    //   block [0x828BE650..0x828BEBCC)
	// 828BE650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE654: 483EADA1  bl 0x82ca93f4
	ctx.lr = 0x828BE658;
	sub_82CA93D0(ctx, base);
	// 828BE658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE65C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828BE660: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BE664: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BE668: C1B70018  lfs f13, 0x18(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE66C: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE670: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828BE674: 4099054C  ble cr6, 0x828bebc0
	if !ctx.cr[6].gt {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE678: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE680: 419A0540  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE684: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BE688: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828BE68C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BE690: 419A0018  beq cr6, 0x828be6a8
	if ctx.cr[6].eq {
	pc = 0x828BE6A8; continue 'dispatch;
	}
	// 828BE694: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BE698: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BE69C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE6A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE6A4: 409A0008  bne cr6, 0x828be6ac
	if !ctx.cr[6].eq {
	pc = 0x828BE6AC; continue 'dispatch;
	}
	// 828BE6A8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE6AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE6B4: 419A050C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE6B8: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BE6BC: 3BDA0024  addi r30, r26, 0x24
	ctx.r[30].s64 = ctx.r[26].s64 + 36;
	// 828BE6C0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 828BE6C4: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828BE6C8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828BE6CC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828BE6D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE6D4: 419A00F4  beq cr6, 0x828be7c8
	if ctx.cr[6].eq {
	pc = 0x828BE7C8; continue 'dispatch;
	}
	// 828BE6D8: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE6E0: 419A0024  beq cr6, 0x828be704
	if ctx.cr[6].eq {
	pc = 0x828BE704; continue 'dispatch;
	}
	// 828BE6E4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828BE6E8: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE6EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE6F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE6F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE6F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE6FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE700: 480000CC  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
	// 828BE704: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE708: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE70C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE710: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE714: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE718: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE71C: 40810054  ble 0x828be770
	if !ctx.cr[0].gt {
	pc = 0x828BE770; continue 'dispatch;
	}
	// 828BE720: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE724: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE728: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE72C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE730: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828BE734: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE738: 41980008  blt cr6, 0x828be740
	if ctx.cr[6].lt {
	pc = 0x828BE740; continue 'dispatch;
	}
	// 828BE73C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BE740: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE744: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE748: 419A0014  beq cr6, 0x828be75c
	if ctx.cr[6].eq {
	pc = 0x828BE75C; continue 'dispatch;
	}
	// 828BE74C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE750: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE754: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE758: 4800000C  b 0x828be764
	pc = 0x828BE764; continue 'dispatch;
	// 828BE75C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE760: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BE764: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE768: 4199FFB8  bgt cr6, 0x828be720
	if ctx.cr[6].gt {
	pc = 0x828BE720; continue 'dispatch;
	}
	// 828BE76C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE770: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE774: 419A0040  beq cr6, 0x828be7b4
	if ctx.cr[6].eq {
	pc = 0x828BE7B4; continue 'dispatch;
	}
	// 828BE778: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE77C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828BE780: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE784: 41990008  bgt cr6, 0x828be78c
	if ctx.cr[6].gt {
	pc = 0x828BE78C; continue 'dispatch;
	}
	// 828BE788: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE78C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE794: 409A0020  bne cr6, 0x828be7b4
	if !ctx.cr[6].eq {
	pc = 0x828BE7B4; continue 'dispatch;
	}
	// 828BE798: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE79C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE7A0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE7A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE7A8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE7AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE7B0: 4800001C  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
	// 828BE7B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE7B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE7BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE7C0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE7C4: 48000008  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
	// 828BE7C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE7CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE7D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE7D4: 419A0034  beq cr6, 0x828be808
	if ctx.cr[6].eq {
	pc = 0x828BE808; continue 'dispatch;
	}
	// 828BE7D8: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 828BE7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE7E0: 4B940DE9  bl 0x821ff5c8
	ctx.lr = 0x828BE7E4;
	sub_821FF5C8(ctx, base);
	// 828BE7E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE7EC: 409A03D4  bne cr6, 0x828bebc0
	if !ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE7F0: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828BE7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE7F8: 4B940DD1  bl 0x821ff5c8
	ctx.lr = 0x828BE7FC;
	sub_821FF5C8(ctx, base);
	// 828BE7FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE804: 409A03BC  bne cr6, 0x828bebc0
	if !ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE808: 83970004  lwz r28, 4(r23)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE80C: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE810: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE818: 419A00F4  beq cr6, 0x828be90c
	if ctx.cr[6].eq {
	pc = 0x828BE90C; continue 'dispatch;
	}
	// 828BE81C: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE824: 419A0024  beq cr6, 0x828be848
	if ctx.cr[6].eq {
	pc = 0x828BE848; continue 'dispatch;
	}
	// 828BE828: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE82C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE830: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE834: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE838: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE83C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE840: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE844: 480000CC  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
	// 828BE848: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE84C: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE850: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE854: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE858: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE85C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE860: 40810054  ble 0x828be8b4
	if !ctx.cr[0].gt {
	pc = 0x828BE8B4; continue 'dispatch;
	}
	// 828BE864: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE868: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE86C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE870: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE874: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE878: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE87C: 41980008  blt cr6, 0x828be884
	if ctx.cr[6].lt {
	pc = 0x828BE884; continue 'dispatch;
	}
	// 828BE880: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BE884: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE888: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE88C: 419A0014  beq cr6, 0x828be8a0
	if ctx.cr[6].eq {
	pc = 0x828BE8A0; continue 'dispatch;
	}
	// 828BE890: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE894: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE898: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE89C: 4800000C  b 0x828be8a8
	pc = 0x828BE8A8; continue 'dispatch;
	// 828BE8A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE8A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BE8A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE8AC: 4199FFB8  bgt cr6, 0x828be864
	if ctx.cr[6].gt {
	pc = 0x828BE864; continue 'dispatch;
	}
	// 828BE8B0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE8B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE8B8: 419A0040  beq cr6, 0x828be8f8
	if ctx.cr[6].eq {
	pc = 0x828BE8F8; continue 'dispatch;
	}
	// 828BE8BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE8C0: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE8C4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE8C8: 41990008  bgt cr6, 0x828be8d0
	if ctx.cr[6].gt {
	pc = 0x828BE8D0; continue 'dispatch;
	}
	// 828BE8CC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE8D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE8D8: 409A0020  bne cr6, 0x828be8f8
	if !ctx.cr[6].eq {
	pc = 0x828BE8F8; continue 'dispatch;
	}
	// 828BE8DC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE8E0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE8E4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE8E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE8EC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE8F0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE8F4: 4800001C  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
	// 828BE8F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE8FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE900: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE904: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE908: 48000008  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
	// 828BE90C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE910: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE918: 419A02A8  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE91C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE920: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE928: 419A00F0  beq cr6, 0x828bea18
	if ctx.cr[6].eq {
	pc = 0x828BEA18; continue 'dispatch;
	}
	// 828BE92C: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE930: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE938: 419A0020  beq cr6, 0x828be958
	if ctx.cr[6].eq {
	pc = 0x828BE958; continue 'dispatch;
	}
	// 828BE93C: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE940: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BE944: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BE948: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE94C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BE950: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE954: 480000C8  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
	// 828BE958: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE95C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE960: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE964: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE968: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE96C: 40810054  ble 0x828be9c0
	if !ctx.cr[0].gt {
	pc = 0x828BE9C0; continue 'dispatch;
	}
	// 828BE970: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE974: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE978: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BE97C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE980: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE984: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE988: 41980008  blt cr6, 0x828be990
	if ctx.cr[6].lt {
	pc = 0x828BE990; continue 'dispatch;
	}
	// 828BE98C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BE990: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE994: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE998: 419A0014  beq cr6, 0x828be9ac
	if ctx.cr[6].eq {
	pc = 0x828BE9AC; continue 'dispatch;
	}
	// 828BE99C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE9A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE9A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE9A8: 4800000C  b 0x828be9b4
	pc = 0x828BE9B4; continue 'dispatch;
	// 828BE9AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE9B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BE9B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE9B8: 4199FFB8  bgt cr6, 0x828be970
	if ctx.cr[6].gt {
	pc = 0x828BE970; continue 'dispatch;
	}
	// 828BE9BC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE9C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE9C4: 419A0040  beq cr6, 0x828bea04
	if ctx.cr[6].eq {
	pc = 0x828BEA04; continue 'dispatch;
	}
	// 828BE9C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE9CC: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE9D0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE9D4: 41990008  bgt cr6, 0x828be9dc
	if ctx.cr[6].gt {
	pc = 0x828BE9DC; continue 'dispatch;
	}
	// 828BE9D8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BE9DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE9E4: 409A0020  bne cr6, 0x828bea04
	if !ctx.cr[6].eq {
	pc = 0x828BEA04; continue 'dispatch;
	}
	// 828BE9E8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE9EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE9F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE9F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE9F8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BE9FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BEA00: 4800001C  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
	// 828BEA04: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BEA08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEA0C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BEA10: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BEA14: 48000008  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
	// 828BEA18: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BEA1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA24: 419A019C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEA28: 83DB000C  lwz r30, 0xc(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA2C: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA30: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BEA34: 419A0124  beq cr6, 0x828beb58
	if ctx.cr[6].eq {
	pc = 0x828BEB58; continue 'dispatch;
	}
	// 828BEA38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BEA3C: 419A011C  beq cr6, 0x828beb58
	if ctx.cr[6].eq {
	pc = 0x828BEB58; continue 'dispatch;
	}
	// 828BEA40: 83F7000C  lwz r31, 0xc(r23)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA44: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 828BEA48: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 828BEA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA50: 409A0070  bne cr6, 0x828beac0
	if !ctx.cr[6].eq {
	pc = 0x828BEAC0; continue 'dispatch;
	}
	// 828BEA54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEA58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA60: 48003CA1  bl 0x828c2700
	ctx.lr = 0x828BEA64;
	sub_828C2700(ctx, base);
	// 828BEA64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA6C: 419A0054  beq cr6, 0x828beac0
	if ctx.cr[6].eq {
	pc = 0x828BEAC0; continue 'dispatch;
	}
	// 828BEA70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEA74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA7C: 48003CE5  bl 0x828c2760
	ctx.lr = 0x828BEA80;
	sub_828C2760(ctx, base);
	// 828BEA80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BEA84: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828BEA88: 419A0138  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEA8C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BEA90: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BEA94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BEA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA9C: 48003AD5  bl 0x828c2570
	ctx.lr = 0x828BEAA0;
	sub_828C2570(ctx, base);
	// 828BEAA0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BEAA4: 419A011C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEAA8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BEAAC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828BEAB0: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828BEAB4: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828BEAB8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEABC: 483EA988  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828BEAC0: 4B9A1EF9  bl 0x822609b8
	ctx.lr = 0x828BEAC4;
	sub_822609B8(ctx, base);
	// 828BEAC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BEAC8: 485C2B89  bl 0x82e81650
	ctx.lr = 0x828BEACC;
	sub_82E81650(ctx, base);
	// 828BEACC: 897B006C  lbz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BEAD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828BEAD4: 419A00EC  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEAD8: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 828BEADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BEAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BEAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEAE8: 4BA14871  bl 0x822d3358
	ctx.lr = 0x828BEAEC;
	sub_822D3358(ctx, base);
	// 828BEAEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEAF0: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 828BEAF4: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 828BEAF8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BEAFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEB00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEB04: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BEB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEB0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BEB10: 4E800421  bctrl
	ctx.lr = 0x828BEB14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEB14: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BEB18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BEB1C: 409A0024  bne cr6, 0x828beb40
	if !ctx.cr[6].eq {
	pc = 0x828BEB40; continue 'dispatch;
	}
	// 828BEB20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BEB24: 485C2B2D  bl 0x82e81650
	ctx.lr = 0x828BEB28;
	sub_82E81650(ctx, base);
	// 828BEB28: 897B006C  lbz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BEB2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828BEB30: 409AFFAC  bne cr6, 0x828beadc
	if !ctx.cr[6].eq {
	pc = 0x828BEADC; continue 'dispatch;
	}
	// 828BEB34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEB38: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEB3C: 483EA908  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828BEB40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEB48: 409AFF60  bne cr6, 0x828beaa8
	if !ctx.cr[6].eq {
	pc = 0x828BEAA8; continue 'dispatch;
	}
	// 828BEB4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEB50: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEB54: 483EA8F0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828BEB58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BEB5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BEB60: 388B2F8C  addi r4, r11, 0x2f8c
	ctx.r[4].s64 = ctx.r[11].s64 + 12172;
	// 828BEB64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEB68: 3BFA0080  addi r31, r26, 0x80
	ctx.r[31].s64 = ctx.r[26].s64 + 128;
	// 828BEB6C: 4B96E365  bl 0x8222ced0
	ctx.lr = 0x828BEB70;
	sub_8222CED0(ctx, base);
	// 828BEB70: 389C0080  addi r4, r28, 0x80
	ctx.r[4].s64 = ctx.r[28].s64 + 128;
	// 828BEB74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEB78: 4B92DC81  bl 0x821ec7f8
	ctx.lr = 0x828BEB7C;
	sub_821EC7F8(ctx, base);
	// 828BEB7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BEB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEB84: 4B9316BD  bl 0x821f0240
	ctx.lr = 0x828BEB88;
	sub_821F0240(ctx, base);
	// 828BEB88: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BEB8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEB90: 388A4A00  addi r4, r10, 0x4a00
	ctx.r[4].s64 = ctx.r[10].s64 + 18944;
	// 828BEB94: 4B91BE2D  bl 0x821da9c0
	ctx.lr = 0x828BEB98;
	sub_821DA9C0(ctx, base);
	// 828BEB98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BEB9C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BEBA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEBA4: 4B924565  bl 0x821e3108
	ctx.lr = 0x828BEBA8;
	sub_821E3108(ctx, base);
	// 828BEBA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEBAC: 4B95622D  bl 0x82214dd8
	ctx.lr = 0x828BEBB0;
	sub_82214DD8(ctx, base);
	// 828BEBB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEBB4: 4B956225  bl 0x82214dd8
	ctx.lr = 0x828BEBB8;
	sub_82214DD8(ctx, base);
	// 828BEBB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEBBC: 4B95621D  bl 0x82214dd8
	ctx.lr = 0x828BEBC0;
	sub_82214DD8(ctx, base);
	// 828BEBC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEBC4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEBC8: 483EA87C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BEBD0 size=160
    let mut pc: u32 = 0x828BEBD0;
    'dispatch: loop {
        match pc {
            0x828BEBD0 => {
    //   block [0x828BEBD0..0x828BEC70)
	// 828BEBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEBD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEBDC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828BEBE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEBE4: 8084007C  lwz r4, 0x7c(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BEBE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEBF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEBF4: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BEBF8: EFE00032  fmuls f31, f0, f0
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BEBFC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BEC00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BEC04: 4E800421  bctrl
	ctx.lr = 0x828BEC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEC08: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEC0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEC10: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BEC14: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEC18: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BEC1C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828BEC20: 4E800421  bctrl
	ctx.lr = 0x828BEC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEC24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BEC28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BEC2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BEC30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEC70 size=672
    let mut pc: u32 = 0x828BEC70;
    'dispatch: loop {
        match pc {
            0x828BEC70 => {
    //   block [0x828BEC70..0x828BEF10)
	// 828BEC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEC74: 483EA77D  bl 0x82ca93f0
	ctx.lr = 0x828BEC78;
	sub_82CA93D0(ctx, base);
	// 828BEC78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEC7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BEC80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BEC84: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BEC88: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BEC8C: 3BC30028  addi r30, r3, 0x28
	ctx.r[30].s64 = ctx.r[3].s64 + 40;
	// 828BEC90: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BEC94: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 828BEC98: 3F208332  lis r25, -0x7cce
	ctx.r[25].s64 = -2093875200;
	// 828BEC9C: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 828BECA0: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	// 828BECA4: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BECA8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828BECAC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BECB0: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BECB4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BECB8: 40990008  ble cr6, 0x828becc0
	if !ctx.cr[6].gt {
	pc = 0x828BECC0; continue 'dispatch;
	}
	// 828BECBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BECC0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BECC4: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BECC8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BECCC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BECD0: 40990008  ble cr6, 0x828becd8
	if !ctx.cr[6].gt {
	pc = 0x828BECD8; continue 'dispatch;
	}
	// 828BECD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BECD8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BECDC: 419A0008  beq cr6, 0x828bece4
	if ctx.cr[6].eq {
	pc = 0x828BECE4; continue 'dispatch;
	}
	// 828BECE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BECE4: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BECE8: 419A00F4  beq cr6, 0x828beddc
	if ctx.cr[6].eq {
	pc = 0x828BEDDC; continue 'dispatch;
	}
	// 828BECEC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BECF0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BECF4: 41980008  blt cr6, 0x828becfc
	if ctx.cr[6].lt {
	pc = 0x828BECFC; continue 'dispatch;
	}
	// 828BECF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BECFC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BED04: 41990008  bgt cr6, 0x828bed0c
	if ctx.cr[6].gt {
	pc = 0x828BED0C; continue 'dispatch;
	}
	// 828BED08: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828BED0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED10: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BED14: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BED18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BED20: 419A001C  beq cr6, 0x828bed3c
	if ctx.cr[6].eq {
	pc = 0x828BED3C; continue 'dispatch;
	}
	// 828BED24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BED28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BED2C: 419A000C  beq cr6, 0x828bed38
	if ctx.cr[6].eq {
	pc = 0x828BED38; continue 'dispatch;
	}
	// 828BED30: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BED34: 4800000C  b 0x828bed40
	pc = 0x828BED40; continue 'dispatch;
	// 828BED38: 4B8D5101  bl 0x82193e38
	ctx.lr = 0x828BED3C;
	sub_82193E38(ctx, base);
	// 828BED3C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BED40: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BED44: 409A0078  bne cr6, 0x828bedbc
	if !ctx.cr[6].eq {
	pc = 0x828BEDBC; continue 'dispatch;
	}
	// 828BED48: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BED4C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BED50: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BED54: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BED58: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BED5C: 41980008  blt cr6, 0x828bed64
	if ctx.cr[6].lt {
	pc = 0x828BED64; continue 'dispatch;
	}
	// 828BED60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BED64: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED68: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BED6C: 41990008  bgt cr6, 0x828bed74
	if ctx.cr[6].gt {
	pc = 0x828BED74; continue 'dispatch;
	}
	// 828BED70: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828BED74: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED78: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BED7C: 7D2B382E  lwzx r9, r11, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828BED80: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED84: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BED88: 40990030  ble cr6, 0x828bedb8
	if !ctx.cr[6].gt {
	pc = 0x828BEDB8; continue 'dispatch;
	}
	// 828BED8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BED90: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BED94: 41980008  blt cr6, 0x828bed9c
	if ctx.cr[6].lt {
	pc = 0x828BED9C; continue 'dispatch;
	}
	// 828BED98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BED9C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEDA0: 41990008  bgt cr6, 0x828beda8
	if ctx.cr[6].gt {
	pc = 0x828BEDA8; continue 'dispatch;
	}
	// 828BEDA4: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828BEDA8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BEDAC: 81799650  lwz r11, -0x69b0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BEDB0: 7D2A382E  lwzx r9, r10, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828BEDB4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BEDB8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828BEDBC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEDC0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEDC4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BEDC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEDCC: 41980008  blt cr6, 0x828bedd4
	if ctx.cr[6].lt {
	pc = 0x828BEDD4; continue 'dispatch;
	}
	// 828BEDD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BEDD4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BEDD8: 4BFFFEE8  b 0x828becc0
	pc = 0x828BECC0; continue 'dispatch;
	// 828BEDDC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828BEDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEDE4: 409A003C  bne cr6, 0x828bee20
	if !ctx.cr[6].eq {
	pc = 0x828BEE20; continue 'dispatch;
	}
	// 828BEDE8: 81799650  lwz r11, -0x69b0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BEDEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEDF0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 828BEDF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEDF8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BEDFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828BEE00: 4B955A99  bl 0x82214898
	ctx.lr = 0x828BEE04;
	sub_82214898(ctx, base);
	// 828BEE04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BEE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BEE0C: 48001895  bl 0x828c06a0
	ctx.lr = 0x828BEE10;
	sub_828C06A0(ctx, base);
	// 828BEE10: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828BEE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEE18: 4B8D5021  bl 0x82193e38
	ctx.lr = 0x828BEE1C;
	sub_82193E38(ctx, base);
	// 828BEE1C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BEE20: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828BEE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEE28: 419A00E0  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEE2C: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEE34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE38: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE3C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE40: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE44: 4B973935  bl 0x82232778
	ctx.lr = 0x828BEE48;
	sub_82232778(ctx, base);
	// 828BEE48: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEE4C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BEE50: 419A00B8  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEE54: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE5C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE60: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE64: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE68: 4B96D351  bl 0x8222c1b8
	ctx.lr = 0x828BEE6C;
	sub_8222C1B8(ctx, base);
	// 828BEE6C: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEE74: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE78: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE7C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE80: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE84: 48026BF5  bl 0x828e5a78
	ctx.lr = 0x828BEE88;
	sub_828E5A78(ctx, base);
	// 828BEE88: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEE8C: 409A003C  bne cr6, 0x828beec8
	if !ctx.cr[6].eq {
	pc = 0x828BEEC8; continue 'dispatch;
	}
	// 828BEE90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEE94: 419A0018  beq cr6, 0x828beeac
	if ctx.cr[6].eq {
	pc = 0x828BEEAC; continue 'dispatch;
	}
	// 828BEE98: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BEE9C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BEEA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BEEA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEEA8: 409A0008  bne cr6, 0x828beeb0
	if !ctx.cr[6].eq {
	pc = 0x828BEEB0; continue 'dispatch;
	}
	// 828BEEAC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BEEB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEEB8: 419A0010  beq cr6, 0x828beec8
	if ctx.cr[6].eq {
	pc = 0x828BEEC8; continue 'dispatch;
	}
	// 828BEEBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BEEC0: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BEEC4: 4BFFFDE0  b 0x828beca4
	pc = 0x828BECA4; continue 'dispatch;
	// 828BEEC8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BEECC: 409A003C  bne cr6, 0x828bef08
	if !ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BEED4: 419A0018  beq cr6, 0x828beeec
	if ctx.cr[6].eq {
	pc = 0x828BEEEC; continue 'dispatch;
	}
	// 828BEED8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BEEDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BEEE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BEEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEEE8: 409A0008  bne cr6, 0x828beef0
	if !ctx.cr[6].eq {
	pc = 0x828BEEF0; continue 'dispatch;
	}
	// 828BEEEC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BEEF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEEF8: 419A0010  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEEFC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BEF00: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BEF04: 4BFFFDA0  b 0x828beca4
	pc = 0x828BECA4; continue 'dispatch;
	// 828BEF08: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEF0C: 483EA534  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEF10 size=616
    let mut pc: u32 = 0x828BEF10;
    'dispatch: loop {
        match pc {
            0x828BEF10 => {
    //   block [0x828BEF10..0x828BF178)
	// 828BEF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEF14: 483EA4DD  bl 0x82ca93f0
	ctx.lr = 0x828BEF18;
	sub_82CA93D0(ctx, base);
	// 828BEF18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEF1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BEF20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BEF24: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BEF28: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BEF2C: 3BC30028  addi r30, r3, 0x28
	ctx.r[30].s64 = ctx.r[3].s64 + 40;
	// 828BEF30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BEF34: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 828BEF38: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 828BEF3C: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 828BEF40: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	// 828BEF44: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEF48: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828BEF4C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEF50: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BEF54: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEF58: 40990008  ble cr6, 0x828bef60
	if !ctx.cr[6].gt {
	pc = 0x828BEF60; continue 'dispatch;
	}
	// 828BEF5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BEF60: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEF64: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEF68: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BEF6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BEF70: 40990008  ble cr6, 0x828bef78
	if !ctx.cr[6].gt {
	pc = 0x828BEF78; continue 'dispatch;
	}
	// 828BEF74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BEF78: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BEF7C: 419A0008  beq cr6, 0x828bef84
	if ctx.cr[6].eq {
	pc = 0x828BEF84; continue 'dispatch;
	}
	// 828BEF80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BEF84: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BEF88: 419A00C0  beq cr6, 0x828bf048
	if ctx.cr[6].eq {
	pc = 0x828BF048; continue 'dispatch;
	}
	// 828BEF8C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BEF90: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEF94: 41980008  blt cr6, 0x828bef9c
	if ctx.cr[6].lt {
	pc = 0x828BEF9C; continue 'dispatch;
	}
	// 828BEF98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BEF9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BEFA0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEFA4: 41990008  bgt cr6, 0x828befac
	if ctx.cr[6].gt {
	pc = 0x828BEFAC; continue 'dispatch;
	}
	// 828BEFA8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828BEFAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEFB0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BEFB4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BEFB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEFC0: 419A001C  beq cr6, 0x828befdc
	if ctx.cr[6].eq {
	pc = 0x828BEFDC; continue 'dispatch;
	}
	// 828BEFC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEFC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEFCC: 419A000C  beq cr6, 0x828befd8
	if ctx.cr[6].eq {
	pc = 0x828BEFD8; continue 'dispatch;
	}
	// 828BEFD0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BEFD4: 4800000C  b 0x828befe0
	pc = 0x828BEFE0; continue 'dispatch;
	// 828BEFD8: 4B8D4E61  bl 0x82193e38
	ctx.lr = 0x828BEFDC;
	sub_82193E38(ctx, base);
	// 828BEFDC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BEFE0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BEFE4: 409A0044  bne cr6, 0x828bf028
	if !ctx.cr[6].eq {
	pc = 0x828BF028; continue 'dispatch;
	}
	// 828BEFE8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEFEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BEFF0: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEFF4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828BEFF8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEFFC: 41980008  blt cr6, 0x828bf004
	if ctx.cr[6].lt {
	pc = 0x828BF004; continue 'dispatch;
	}
	// 828BF000: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF004: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF008: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF00C: 41990008  bgt cr6, 0x828bf014
	if ctx.cr[6].gt {
	pc = 0x828BF014; continue 'dispatch;
	}
	// 828BF010: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828BF014: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF018: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF01C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828BF020: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF024: 93280008  stw r25, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828BF028: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF02C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF030: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF034: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF038: 41980008  blt cr6, 0x828bf040
	if ctx.cr[6].lt {
	pc = 0x828BF040; continue 'dispatch;
	}
	// 828BF03C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF040: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BF044: 4BFFFF1C  b 0x828bef60
	pc = 0x828BEF60; continue 'dispatch;
	// 828BF048: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828BF04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF050: 409A0038  bne cr6, 0x828bf088
	if !ctx.cr[6].eq {
	pc = 0x828BF088; continue 'dispatch;
	}
	// 828BF054: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 828BF058: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF05C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BF060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF064: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828BF068: 4B955831  bl 0x82214898
	ctx.lr = 0x828BF06C;
	sub_82214898(ctx, base);
	// 828BF06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF074: 4800162D  bl 0x828c06a0
	ctx.lr = 0x828BF078;
	sub_828C06A0(ctx, base);
	// 828BF078: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828BF07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF080: 4B8D4DB9  bl 0x82193e38
	ctx.lr = 0x828BF084;
	sub_82193E38(ctx, base);
	// 828BF084: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BF088: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828BF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF090: 419A00E0  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF094: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF098: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF09C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0A0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0A4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0A8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0AC: 4B9736CD  bl 0x82232778
	ctx.lr = 0x828BF0B0;
	sub_82232778(ctx, base);
	// 828BF0B0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BF0B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BF0B8: 419A00B8  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF0BC: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF0C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0C4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0C8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0CC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0D0: 4B96D0E9  bl 0x8222c1b8
	ctx.lr = 0x828BF0D4;
	sub_8222C1B8(ctx, base);
	// 828BF0D4: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF0DC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0E0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0E8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0EC: 4802698D  bl 0x828e5a78
	ctx.lr = 0x828BF0F0;
	sub_828E5A78(ctx, base);
	// 828BF0F0: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF0F4: 409A003C  bne cr6, 0x828bf130
	if !ctx.cr[6].eq {
	pc = 0x828BF130; continue 'dispatch;
	}
	// 828BF0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BF0FC: 419A0018  beq cr6, 0x828bf114
	if ctx.cr[6].eq {
	pc = 0x828BF114; continue 'dispatch;
	}
	// 828BF100: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF104: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF10C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF110: 409A0008  bne cr6, 0x828bf118
	if !ctx.cr[6].eq {
	pc = 0x828BF118; continue 'dispatch;
	}
	// 828BF114: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BF118: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF120: 419A0010  beq cr6, 0x828bf130
	if ctx.cr[6].eq {
	pc = 0x828BF130; continue 'dispatch;
	}
	// 828BF124: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BF128: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BF12C: 4BFFFE18  b 0x828bef44
	pc = 0x828BEF44; continue 'dispatch;
	// 828BF130: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BF134: 409A003C  bne cr6, 0x828bf170
	if !ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF138: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF13C: 419A0018  beq cr6, 0x828bf154
	if ctx.cr[6].eq {
	pc = 0x828BF154; continue 'dispatch;
	}
	// 828BF140: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF144: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF148: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF14C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF150: 409A0008  bne cr6, 0x828bf158
	if !ctx.cr[6].eq {
	pc = 0x828BF158; continue 'dispatch;
	}
	// 828BF154: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BF158: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF160: 419A0010  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF164: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BF168: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BF16C: 4BFFFDD8  b 0x828bef44
	pc = 0x828BEF44; continue 'dispatch;
	// 828BF170: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BF174: 483EA2CC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF178 size=360
    let mut pc: u32 = 0x828BF178;
    'dispatch: loop {
        match pc {
            0x828BF178 => {
    //   block [0x828BF178..0x828BF2E0)
	// 828BF178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF17C: 483EA289  bl 0x82ca9404
	ctx.lr = 0x828BF180;
	sub_82CA93D0(ctx, base);
	// 828BF180: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF184: 83C30034  lwz r30, 0x34(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF188: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BF18C: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF190: 3BA30028  addi r29, r3, 0x28
	ctx.r[29].s64 = ctx.r[3].s64 + 40;
	// 828BF194: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BF198: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF19C: 40990008  ble cr6, 0x828bf1a4
	if !ctx.cr[6].gt {
	pc = 0x828BF1A4; continue 'dispatch;
	}
	// 828BF1A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF1A4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828BF1A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BF1AC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF1B0: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF1B4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF1B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF1BC: 40990008  ble cr6, 0x828bf1c4
	if !ctx.cr[6].gt {
	pc = 0x828BF1C4; continue 'dispatch;
	}
	// 828BF1C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF1C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF1C8: 419A000C  beq cr6, 0x828bf1d4
	if ctx.cr[6].eq {
	pc = 0x828BF1D4; continue 'dispatch;
	}
	// 828BF1CC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF1D0: 419A0008  beq cr6, 0x828bf1d8
	if ctx.cr[6].eq {
	pc = 0x828BF1D8; continue 'dispatch;
	}
	// 828BF1D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF1D8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF1DC: 419A00FC  beq cr6, 0x828bf2d8
	if ctx.cr[6].eq {
	pc = 0x828BF2D8; continue 'dispatch;
	}
	// 828BF1E0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BF1E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF1E8: 409A0008  bne cr6, 0x828bf1f0
	if !ctx.cr[6].eq {
	pc = 0x828BF1F0; continue 'dispatch;
	}
	// 828BF1EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF1F0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF1F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF1F8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF1FC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF200: 41980008  blt cr6, 0x828bf208
	if ctx.cr[6].lt {
	pc = 0x828BF208; continue 'dispatch;
	}
	// 828BF204: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF208: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF20C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BF210: 41990008  bgt cr6, 0x828bf218
	if ctx.cr[6].gt {
	pc = 0x828BF218; continue 'dispatch;
	}
	// 828BF214: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 828BF218: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF21C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF220: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF224: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF22C: 419A001C  beq cr6, 0x828bf248
	if ctx.cr[6].eq {
	pc = 0x828BF248; continue 'dispatch;
	}
	// 828BF230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF238: 419A000C  beq cr6, 0x828bf244
	if ctx.cr[6].eq {
	pc = 0x828BF244; continue 'dispatch;
	}
	// 828BF23C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF240: 4800000C  b 0x828bf24c
	pc = 0x828BF24C; continue 'dispatch;
	// 828BF244: 4B8D4BF5  bl 0x82193e38
	ctx.lr = 0x828BF248;
	sub_82193E38(ctx, base);
	// 828BF248: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828BF24C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BF250: 409A0068  bne cr6, 0x828bf2b8
	if !ctx.cr[6].eq {
	pc = 0x828BF2B8; continue 'dispatch;
	}
	// 828BF254: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF258: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 828BF25C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF260: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828BF264: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF268: 4199000C  bgt cr6, 0x828bf274
	if ctx.cr[6].gt {
	pc = 0x828BF274; continue 'dispatch;
	}
	// 828BF26C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF270: 40980008  bge cr6, 0x828bf278
	if !ctx.cr[6].lt {
	pc = 0x828BF278; continue 'dispatch;
	}
	// 828BF274: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF278: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828BF27C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828BF280: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BF284: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BF288: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BF28C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BF290: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828BF294: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BF298: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828BF29C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828BF2A0: 48001541  bl 0x828c07e0
	ctx.lr = 0x828BF2A4;
	sub_828C07E0(ctx, base);
	// 828BF2A4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BF2A8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828BF2AC: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BF2B0: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828BF2B4: 4BFFFEF8  b 0x828bf1ac
	pc = 0x828BF1AC; continue 'dispatch;
	// 828BF2B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF2BC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF2C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF2C4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF2C8: 41980008  blt cr6, 0x828bf2d0
	if ctx.cr[6].lt {
	pc = 0x828BF2D0; continue 'dispatch;
	}
	// 828BF2CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF2D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BF2D4: 4BFFFED8  b 0x828bf1ac
	pc = 0x828BF1AC; continue 'dispatch;
	// 828BF2D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BF2DC: 483EA178  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF2E0 size=588
    let mut pc: u32 = 0x828BF2E0;
    'dispatch: loop {
        match pc {
            0x828BF2E0 => {
    //   block [0x828BF2E0..0x828BF52C)
	// 828BF2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF2E4: 483EA11D  bl 0x82ca9400
	ctx.lr = 0x828BF2E8;
	sub_82CA93D0(ctx, base);
	// 828BF2E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF2EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BF2F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BF2F4: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 828BF2F8: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF2FC: 815C0038  lwz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF300: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF304: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF308: 40990008  ble cr6, 0x828bf310
	if !ctx.cr[6].gt {
	pc = 0x828BF310; continue 'dispatch;
	}
	// 828BF30C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF310: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BF314: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BF318: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF31C: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF320: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BF324: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF328: 40990008  ble cr6, 0x828bf330
	if !ctx.cr[6].gt {
	pc = 0x828BF330; continue 'dispatch;
	}
	// 828BF32C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF330: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BF334: 419A0008  beq cr6, 0x828bf33c
	if ctx.cr[6].eq {
	pc = 0x828BF33C; continue 'dispatch;
	}
	// 828BF338: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF33C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF340: 419A00B8  beq cr6, 0x828bf3f8
	if ctx.cr[6].eq {
	pc = 0x828BF3F8; continue 'dispatch;
	}
	// 828BF344: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF348: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF34C: 41980008  blt cr6, 0x828bf354
	if ctx.cr[6].lt {
	pc = 0x828BF354; continue 'dispatch;
	}
	// 828BF350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF354: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF358: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF35C: 41990008  bgt cr6, 0x828bf364
	if ctx.cr[6].gt {
	pc = 0x828BF364; continue 'dispatch;
	}
	// 828BF360: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BF364: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF368: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF36C: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF370: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF378: 419A0048  beq cr6, 0x828bf3c0
	if ctx.cr[6].eq {
	pc = 0x828BF3C0; continue 'dispatch;
	}
	// 828BF37C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF384: 419A000C  beq cr6, 0x828bf390
	if ctx.cr[6].eq {
	pc = 0x828BF390; continue 'dispatch;
	}
	// 828BF388: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF38C: 48000038  b 0x828bf3c4
	pc = 0x828BF3C4; continue 'dispatch;
	// 828BF390: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF394: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828BF398: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BF39C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3A0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BF3A8: 409A0014  bne cr6, 0x828bf3bc
	if !ctx.cr[6].eq {
	pc = 0x828BF3BC; continue 'dispatch;
	}
	// 828BF3AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF3B4: 409A0008  bne cr6, 0x828bf3bc
	if !ctx.cr[6].eq {
	pc = 0x828BF3BC; continue 'dispatch;
	}
	// 828BF3B8: 4B95C981  bl 0x8221bd38
	ctx.lr = 0x828BF3BC;
	sub_8221BD38(ctx, base);
	// 828BF3BC: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828BF3C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BF3C4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BF3C8: 419A0024  beq cr6, 0x828bf3ec
	if ctx.cr[6].eq {
	pc = 0x828BF3EC; continue 'dispatch;
	}
	// 828BF3CC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF3D0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF3D4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF3D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF3DC: 41980008  blt cr6, 0x828bf3e4
	if ctx.cr[6].lt {
	pc = 0x828BF3E4; continue 'dispatch;
	}
	// 828BF3E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF3E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BF3E8: 4BFFFF30  b 0x828bf318
	pc = 0x828BF318; continue 'dispatch;
	// 828BF3EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BF3F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF3F4: 483EA05C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828BF3F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF400: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BF404: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828BF408: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BF40C: 419A00F4  beq cr6, 0x828bf500
	if ctx.cr[6].eq {
	pc = 0x828BF500; continue 'dispatch;
	}
	// 828BF410: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BF414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF418: 419A0024  beq cr6, 0x828bf43c
	if ctx.cr[6].eq {
	pc = 0x828BF43C; continue 'dispatch;
	}
	// 828BF41C: 892A0022  lbz r9, 0x22(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 828BF420: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF424: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828BF428: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF42C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF430: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF438: 480000CC  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
	// 828BF43C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF440: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BF444: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828BF448: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BF44C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BF450: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF454: 40810054  ble 0x828bf4a8
	if !ctx.cr[0].gt {
	pc = 0x828BF4A8; continue 'dispatch;
	}
	// 828BF458: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BF45C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BF460: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BF464: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF468: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 828BF46C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BF470: 41980008  blt cr6, 0x828bf478
	if ctx.cr[6].lt {
	pc = 0x828BF478; continue 'dispatch;
	}
	// 828BF474: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828BF478: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BF47C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BF480: 419A0014  beq cr6, 0x828bf494
	if ctx.cr[6].eq {
	pc = 0x828BF494; continue 'dispatch;
	}
	// 828BF484: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BF488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BF48C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BF490: 4800000C  b 0x828bf49c
	pc = 0x828BF49C; continue 'dispatch;
	// 828BF494: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BF498: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BF49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF4A0: 4199FFB8  bgt cr6, 0x828bf458
	if ctx.cr[6].gt {
	pc = 0x828BF458; continue 'dispatch;
	}
	// 828BF4A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BF4A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BF4AC: 419A0040  beq cr6, 0x828bf4ec
	if ctx.cr[6].eq {
	pc = 0x828BF4EC; continue 'dispatch;
	}
	// 828BF4B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF4B4: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 828BF4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4BC: 41990008  bgt cr6, 0x828bf4c4
	if ctx.cr[6].gt {
	pc = 0x828BF4C4; continue 'dispatch;
	}
	// 828BF4C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BF4C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF4CC: 409A0020  bne cr6, 0x828bf4ec
	if !ctx.cr[6].eq {
	pc = 0x828BF4EC; continue 'dispatch;
	}
	// 828BF4D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF4D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828BF4D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BF4DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF4E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF4E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4E8: 4800001C  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
	// 828BF4EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BF4F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF4F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF4F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4FC: 48000008  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
	// 828BF500: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828BF504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF50C: 419A0014  beq cr6, 0x828bf520
	if ctx.cr[6].eq {
	pc = 0x828BF520; continue 'dispatch;
	}
	// 828BF510: 4BEBCE09  bl 0x8277c318
	ctx.lr = 0x828BF514;
	sub_8277C318(ctx, base);
	// 828BF514: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BF518: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BF51C: 419A0008  beq cr6, 0x828bf524
	if ctx.cr[6].eq {
	pc = 0x828BF524; continue 'dispatch;
	}
	// 828BF520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BF524: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF528: 483E9F28  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF530 size=652
    let mut pc: u32 = 0x828BF530;
    'dispatch: loop {
        match pc {
            0x828BF530 => {
    //   block [0x828BF530..0x828BF7BC)
	// 828BF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF534: 483E9EC9  bl 0x82ca93fc
	ctx.lr = 0x828BF538;
	sub_82CA93D0(ctx, base);
	// 828BF538: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF53C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BF540: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BF544: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BF548: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828BF54C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BF550: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF554: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF558: 812A0078  lwz r9, 0x78(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828BF55C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF560: 83C80000  lwz r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF568: 4B922641  bl 0x821e1ba8
	ctx.lr = 0x828BF56C;
	sub_821E1BA8(ctx, base);
	// 828BF56C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 828BF570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BF574: 38A7B278  addi r5, r7, -0x4d88
	ctx.r[5].s64 = ctx.r[7].s64 + -19848;
	// 828BF578: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF57C: 4B9FA275  bl 0x822b97f0
	ctx.lr = 0x828BF580;
	sub_822B97F0(ctx, base);
	// 828BF580: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 828BF584: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF588: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF58C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF594: 40990008  ble cr6, 0x828bf59c
	if !ctx.cr[6].gt {
	pc = 0x828BF59C; continue 'dispatch;
	}
	// 828BF598: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF59C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BF5A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BF5A4: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	// 828BF5A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF5AC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF5B0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BF5B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF5B8: 40990008  ble cr6, 0x828bf5c0
	if !ctx.cr[6].gt {
	pc = 0x828BF5C0; continue 'dispatch;
	}
	// 828BF5BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF5C0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF5C4: 419A0008  beq cr6, 0x828bf5cc
	if ctx.cr[6].eq {
	pc = 0x828BF5CC; continue 'dispatch;
	}
	// 828BF5C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF5CC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF5D0: 419A01E0  beq cr6, 0x828bf7b0
	if ctx.cr[6].eq {
	pc = 0x828BF7B0; continue 'dispatch;
	}
	// 828BF5D4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF5D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF5DC: 41980008  blt cr6, 0x828bf5e4
	if ctx.cr[6].lt {
	pc = 0x828BF5E4; continue 'dispatch;
	}
	// 828BF5E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF5E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF5E8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF5EC: 41990008  bgt cr6, 0x828bf5f4
	if ctx.cr[6].gt {
	pc = 0x828BF5F4; continue 'dispatch;
	}
	// 828BF5F0: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BF5F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF5F8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF5FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF600: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF608: 419A0030  beq cr6, 0x828bf638
	if ctx.cr[6].eq {
	pc = 0x828BF638; continue 'dispatch;
	}
	// 828BF60C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF614: 419A008C  beq cr6, 0x828bf6a0
	if ctx.cr[6].eq {
	pc = 0x828BF6A0; continue 'dispatch;
	}
	// 828BF618: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF620: 419A0018  beq cr6, 0x828bf638
	if ctx.cr[6].eq {
	pc = 0x828BF638; continue 'dispatch;
	}
	// 828BF624: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF628: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF62C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF630: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF634: 409A0008  bne cr6, 0x828bf63c
	if !ctx.cr[6].eq {
	pc = 0x828BF63C; continue 'dispatch;
	}
	// 828BF638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BF63C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF644: 419A014C  beq cr6, 0x828bf790
	if ctx.cr[6].eq {
	pc = 0x828BF790; continue 'dispatch;
	}
	// 828BF648: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF64C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF650: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF654: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF658: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF65C: 41980008  blt cr6, 0x828bf664
	if ctx.cr[6].lt {
	pc = 0x828BF664; continue 'dispatch;
	}
	// 828BF660: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF664: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF668: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF66C: 41990008  bgt cr6, 0x828bf674
	if ctx.cr[6].gt {
	pc = 0x828BF674; continue 'dispatch;
	}
	// 828BF670: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BF674: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF678: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF67C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF680: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF688: 419A0024  beq cr6, 0x828bf6ac
	if ctx.cr[6].eq {
	pc = 0x828BF6AC; continue 'dispatch;
	}
	// 828BF68C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF690: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF694: 419A0014  beq cr6, 0x828bf6a8
	if ctx.cr[6].eq {
	pc = 0x828BF6A8; continue 'dispatch;
	}
	// 828BF698: 555C003E  slwi r28, r10, 0
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 828BF69C: 48000014  b 0x828bf6b0
	pc = 0x828BF6B0; continue 'dispatch;
	// 828BF6A0: 4B8D4799  bl 0x82193e38
	ctx.lr = 0x828BF6A4;
	sub_82193E38(ctx, base);
	// 828BF6A4: 4BFFFF94  b 0x828bf638
	pc = 0x828BF638; continue 'dispatch;
	// 828BF6A8: 4B8D4791  bl 0x82193e38
	ctx.lr = 0x828BF6AC;
	sub_82193E38(ctx, base);
	// 828BF6AC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BF6B0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF6B4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF6B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF6BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF6C0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF6C4: 41980008  blt cr6, 0x828bf6cc
	if ctx.cr[6].lt {
	pc = 0x828BF6CC; continue 'dispatch;
	}
	// 828BF6C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF6CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF6D0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF6D4: 41990008  bgt cr6, 0x828bf6dc
	if ctx.cr[6].gt {
	pc = 0x828BF6DC; continue 'dispatch;
	}
	// 828BF6D8: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BF6DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF6E0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF6E4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF6E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF6F0: 419A001C  beq cr6, 0x828bf70c
	if ctx.cr[6].eq {
	pc = 0x828BF70C; continue 'dispatch;
	}
	// 828BF6F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF6F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF6FC: 419A000C  beq cr6, 0x828bf708
	if ctx.cr[6].eq {
	pc = 0x828BF708; continue 'dispatch;
	}
	// 828BF700: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF704: 4800000C  b 0x828bf710
	pc = 0x828BF710; continue 'dispatch;
	// 828BF708: 4B8D4731  bl 0x82193e38
	ctx.lr = 0x828BF70C;
	sub_82193E38(ctx, base);
	// 828BF70C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BF710: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BF714: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828BF718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF71C: 419A0008  beq cr6, 0x828bf724
	if ctx.cr[6].eq {
	pc = 0x828BF724; continue 'dispatch;
	}
	// 828BF720: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF724: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF72C: 419A0064  beq cr6, 0x828bf790
	if ctx.cr[6].eq {
	pc = 0x828BF790; continue 'dispatch;
	}
	// 828BF730: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF734: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF738: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF73C: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BF740: 4B969A21  bl 0x82229160
	ctx.lr = 0x828BF744;
	sub_82229160(ctx, base);
	// 828BF744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BF748: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF74C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF750: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF754: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF758: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BF75C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF760: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828BF764: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF768: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 828BF76C: 90F90008  stw r7, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BF770: 4BAE3851  bl 0x823a2fc0
	ctx.lr = 0x828BF774;
	sub_823A2FC0(ctx, base);
	// 828BF774: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BF778: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BF77C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF780: 48164F49  bl 0x82a246c8
	ctx.lr = 0x828BF784;
	sub_82A246C8(ctx, base);
	// 828BF784: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF788: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 828BF78C: 90D90008  stw r6, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 828BF790: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF794: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF798: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF79C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF7A0: 41980008  blt cr6, 0x828bf7a8
	if ctx.cr[6].lt {
	pc = 0x828BF7A8; continue 'dispatch;
	}
	// 828BF7A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF7A8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BF7AC: 4BFFFDFC  b 0x828bf5a8
	pc = 0x828BF5A8; continue 'dispatch;
	// 828BF7B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF7B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF7B8: 483E9C94  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF7C0 size=344
    let mut pc: u32 = 0x828BF7C0;
    'dispatch: loop {
        match pc {
            0x828BF7C0 => {
    //   block [0x828BF7C0..0x828BF918)
	// 828BF7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BF7C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BF7CC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828BF7D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF7D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF7D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828BF7DC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BF7E0: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BF7E4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BF7E8: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 828BF7EC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828BF7F0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF7F4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF7F8: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828BF7FC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF800: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828BF804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF808: 409900EC  ble cr6, 0x828bf8f4
	if !ctx.cr[6].gt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF80C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF810: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF814: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828BF818: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF81C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF820: 40990008  ble cr6, 0x828bf828
	if !ctx.cr[6].gt {
	pc = 0x828BF828; continue 'dispatch;
	}
	// 828BF824: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF828: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 828BF82C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF830: 4199000C  bgt cr6, 0x828bf83c
	if ctx.cr[6].gt {
	pc = 0x828BF83C; continue 'dispatch;
	}
	// 828BF834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF838: 40980008  bge cr6, 0x828bf840
	if !ctx.cr[6].lt {
	pc = 0x828BF840; continue 'dispatch;
	}
	// 828BF83C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF840: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF844: 41980008  blt cr6, 0x828bf84c
	if ctx.cr[6].lt {
	pc = 0x828BF84C; continue 'dispatch;
	}
	// 828BF848: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF84C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF850: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF854: 41990008  bgt cr6, 0x828bf85c
	if ctx.cr[6].gt {
	pc = 0x828BF85C; continue 'dispatch;
	}
	// 828BF858: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BF85C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF860: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF864: 7CE9502E  lwzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF868: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF86C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BF870: 40990084  ble cr6, 0x828bf8f4
	if !ctx.cr[6].gt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF874: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF878: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF87C: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BF880: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF884: 40990008  ble cr6, 0x828bf88c
	if !ctx.cr[6].gt {
	pc = 0x828BF88C; continue 'dispatch;
	}
	// 828BF888: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF88C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 828BF890: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF894: 4199000C  bgt cr6, 0x828bf8a0
	if ctx.cr[6].gt {
	pc = 0x828BF8A0; continue 'dispatch;
	}
	// 828BF898: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF89C: 40980008  bge cr6, 0x828bf8a4
	if !ctx.cr[6].lt {
	pc = 0x828BF8A4; continue 'dispatch;
	}
	// 828BF8A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF8A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF8A8: 41980008  blt cr6, 0x828bf8b0
	if ctx.cr[6].lt {
	pc = 0x828BF8B0; continue 'dispatch;
	}
	// 828BF8AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BF8B0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF8B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF8B8: 41990008  bgt cr6, 0x828bf8c0
	if ctx.cr[6].gt {
	pc = 0x828BF8C0; continue 'dispatch;
	}
	// 828BF8BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BF8C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF8C4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF8C8: 7CE9502E  lwzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF8CC: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF8D0: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 828BF8D4: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 828BF8D8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF8DC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF8E0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828BF8E4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 828BF8E8: 4098000C  bge cr6, 0x828bf8f4
	if !ctx.cr[6].lt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF8EC: 48000E5D  bl 0x828c0748
	ctx.lr = 0x828BF8F0;
	sub_828C0748(ctx, base);
	// 828BF8F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828BF8F4: 550B063E  clrlwi r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828BF8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF8FC: 419AFF00  beq cr6, 0x828bf7fc
	if ctx.cr[6].eq {
	pc = 0x828BF7FC; continue 'dispatch;
	}
	// 828BF900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BF904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BF908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BF90C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BF910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BF914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828BF918 size=8
    let mut pc: u32 = 0x828BF918;
    'dispatch: loop {
        match pc {
            0x828BF918 => {
    //   block [0x828BF918..0x828BF920)
	// 828BF918: C0230018  lfs f1, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BF91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828BF920 size=16
    let mut pc: u32 = 0x828BF920;
    'dispatch: loop {
        match pc {
            0x828BF920 => {
    //   block [0x828BF920..0x828BF930)
	// 828BF920: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BF924: C0230024  lfs f1, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BF928: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 828BF92C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BF930 size=8
    let mut pc: u32 = 0x828BF930;
    'dispatch: loop {
        match pc {
            0x828BF930 => {
    //   block [0x828BF930..0x828BF938)
	// 828BF930: FC200090  fmr f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[0].f64;
	// 828BF934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BF938 size=28
    let mut pc: u32 = 0x828BF938;
    'dispatch: loop {
        match pc {
            0x828BF938 => {
    //   block [0x828BF938..0x828BF954)
	// 828BF938: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BF93C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 828BF940: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BF944: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BF948: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF94C: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828BF950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF958 size=1472
    let mut pc: u32 = 0x828BF958;
    'dispatch: loop {
        match pc {
            0x828BF958 => {
    //   block [0x828BF958..0x828BFF18)
	// 828BF958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF95C: 483E9AA5  bl 0x82ca9400
	ctx.lr = 0x828BF960;
	sub_82CA93D0(ctx, base);
	// 828BF960: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828BF964: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828BF968: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF96C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BF970: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BF974: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828BF978: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 828BF97C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF980: C3FA0024  lfs f31, 0x24(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BF984: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BF988: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF98C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BF990: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BF994: 4E800421  bctrl
	ctx.lr = 0x828BF998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BF998: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF99C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828BF9A0: 810B0034  lwz r8, 0x34(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF9A4: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828BF9A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BF9AC: 419A00D8  beq cr6, 0x828bfa84
	if ctx.cr[6].eq {
	pc = 0x828BFA84; continue 'dispatch;
	}
	// 828BF9B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BF9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF9B8: 419A001C  beq cr6, 0x828bf9d4
	if ctx.cr[6].eq {
	pc = 0x828BF9D4; continue 'dispatch;
	}
	// 828BF9BC: 894A0085  lbz r10, 0x85(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 828BF9C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF9C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BF9C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF9CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF9D0: 480000B0  b 0x828bfa80
	pc = 0x828BFA80; continue 'dispatch;
	// 828BF9D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF9D8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BF9DC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BF9E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BF9E4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BF9E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF9EC: 40810054  ble 0x828bfa40
	if !ctx.cr[0].gt {
	pc = 0x828BFA40; continue 'dispatch;
	}
	// 828BF9F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BF9F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BF9F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BF9FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFA00: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828BFA04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BFA08: 41980008  blt cr6, 0x828bfa10
	if ctx.cr[6].lt {
	pc = 0x828BFA10; continue 'dispatch;
	}
	// 828BFA0C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828BFA10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BFA14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BFA18: 419A0014  beq cr6, 0x828bfa2c
	if ctx.cr[6].eq {
	pc = 0x828BFA2C; continue 'dispatch;
	}
	// 828BFA1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BFA20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BFA24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BFA28: 4800000C  b 0x828bfa34
	pc = 0x828BFA34; continue 'dispatch;
	// 828BFA2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BFA30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BFA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFA38: 4199FFB8  bgt cr6, 0x828bf9f0
	if ctx.cr[6].gt {
	pc = 0x828BF9F0; continue 'dispatch;
	}
	// 828BFA3C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BFA40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BFA44: 419A0034  beq cr6, 0x828bfa78
	if ctx.cr[6].eq {
	pc = 0x828BFA78; continue 'dispatch;
	}
	// 828BFA48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFA4C: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828BFA50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BFA54: 41990008  bgt cr6, 0x828bfa5c
	if ctx.cr[6].gt {
	pc = 0x828BFA5C; continue 'dispatch;
	}
	// 828BFA58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828BFA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BFA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFA64: 409A0014  bne cr6, 0x828bfa78
	if !ctx.cr[6].eq {
	pc = 0x828BFA78; continue 'dispatch;
	}
	// 828BFA68: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BFA6C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BFA70: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BFA74: 48000008  b 0x828bfa7c
	pc = 0x828BFA7C; continue 'dispatch;
	// 828BFA78: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BFA7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFA80: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BFA84: 817A0034  lwz r11, 0x34(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BFA88: 3BFA0028  addi r31, r26, 0x28
	ctx.r[31].s64 = ctx.r[26].s64 + 40;
	// 828BFA8C: 815A0038  lwz r10, 0x38(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BFA90: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BFA94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BFA98: 40990008  ble cr6, 0x828bfaa0
	if !ctx.cr[6].gt {
	pc = 0x828BFAA0; continue 'dispatch;
	}
	// 828BFA9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFAA0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828BFAA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BFAA8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BFAAC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BFAB0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BFAB4: 40990008  ble cr6, 0x828bfabc
	if !ctx.cr[6].gt {
	pc = 0x828BFABC; continue 'dispatch;
	}
	// 828BFAB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFABC: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BFAC0: 419A0008  beq cr6, 0x828bfac8
	if ctx.cr[6].eq {
	pc = 0x828BFAC8; continue 'dispatch;
	}
	// 828BFAC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFAC8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BFACC: 419A0228  beq cr6, 0x828bfcf4
	if ctx.cr[6].eq {
	pc = 0x828BFCF4; continue 'dispatch;
	}
	// 828BFAD0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BFAD4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BFAD8: 41980008  blt cr6, 0x828bfae0
	if ctx.cr[6].lt {
	pc = 0x828BFAE0; continue 'dispatch;
	}
	// 828BFADC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFAE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BFAE4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BFAE8: 41990008  bgt cr6, 0x828bfaf0
	if ctx.cr[6].gt {
	pc = 0x828BFAF0; continue 'dispatch;
	}
	// 828BFAEC: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 828BFAF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFAF4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BFAF8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BFAFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB04: 419A0030  beq cr6, 0x828bfb34
	if ctx.cr[6].eq {
	pc = 0x828BFB34; continue 'dispatch;
	}
	// 828BFB08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFB0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB10: 419A008C  beq cr6, 0x828bfb9c
	if ctx.cr[6].eq {
	pc = 0x828BFB9C; continue 'dispatch;
	}
	// 828BFB14: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BFB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB1C: 419A0018  beq cr6, 0x828bfb34
	if ctx.cr[6].eq {
	pc = 0x828BFB34; continue 'dispatch;
	}
	// 828BFB20: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BFB24: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BFB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BFB2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB30: 409A0008  bne cr6, 0x828bfb38
	if !ctx.cr[6].eq {
	pc = 0x828BFB38; continue 'dispatch;
	}
	// 828BFB34: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828BFB38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BFB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB40: 419A0194  beq cr6, 0x828bfcd4
	if ctx.cr[6].eq {
	pc = 0x828BFCD4; continue 'dispatch;
	}
	// 828BFB44: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BFB48: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BFB4C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BFB50: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BFB54: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BFB58: 41980008  blt cr6, 0x828bfb60
	if ctx.cr[6].lt {
	pc = 0x828BFB60; continue 'dispatch;
	}
	// 828BFB5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFB60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BFB64: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BFB68: 41990008  bgt cr6, 0x828bfb70
	if ctx.cr[6].gt {
	pc = 0x828BFB70; continue 'dispatch;
	}
	// 828BFB6C: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 828BFB70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB74: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BFB78: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BFB7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB84: 419A0024  beq cr6, 0x828bfba8
	if ctx.cr[6].eq {
	pc = 0x828BFBA8; continue 'dispatch;
	}
	// 828BFB88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB90: 419A0014  beq cr6, 0x828bfba4
	if ctx.cr[6].eq {
	pc = 0x828BFBA4; continue 'dispatch;
	}
	// 828BFB94: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BFB98: 48000014  b 0x828bfbac
	pc = 0x828BFBAC; continue 'dispatch;
	// 828BFB9C: 4B8D429D  bl 0x82193e38
	ctx.lr = 0x828BFBA0;
	sub_82193E38(ctx, base);
	// 828BFBA0: 4BFFFF94  b 0x828bfb34
	pc = 0x828BFB34; continue 'dispatch;
	// 828BFBA4: 4B8D4295  bl 0x82193e38
	ctx.lr = 0x828BFBA8;
	sub_82193E38(ctx, base);
	// 828BFBA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828BFBAC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BFBB0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828BFBB4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFBB8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BFBBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BFBC0: 4E800421  bctrl
	ctx.lr = 0x828BFBC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BFBC4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 828BFBC8: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 828BFBCC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFF18 size=700
    let mut pc: u32 = 0x828BFF18;
    'dispatch: loop {
        match pc {
            0x828BFF18 => {
    //   block [0x828BFF18..0x828C01D4)
	// 828BFF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFF1C: 483E94ED  bl 0x82ca9408
	ctx.lr = 0x828BFF20;
	sub_82CA93D0(ctx, base);
	// 828BFF20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFF24: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 828BFF28: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828BFF2C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828BFF30: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BFF34: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C01D8 size=1080
    let mut pc: u32 = 0x828C01D8;
    'dispatch: loop {
        match pc {
            0x828C01D8 => {
    //   block [0x828C01D8..0x828C0610)
	// 828C01D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C01DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C01E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C01E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C01E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C01EC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C01F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C01F4: 3BCB2FA8  addi r30, r11, 0x2fa8
	ctx.r[30].s64 = ctx.r[11].s64 + 12200;
	// 828C01F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C01FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0204: 4B96CCCD  bl 0x8222ced0
	ctx.lr = 0x828C0208;
	sub_8222CED0(ctx, base);
	// 828C0208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C020C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0210: 48000A39  bl 0x828c0c48
	ctx.lr = 0x828C0214;
	sub_828C0C48(ctx, base);
	// 828C0214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0218: 4B954BC1  bl 0x82214dd8
	ctx.lr = 0x828C021C;
	sub_82214DD8(ctx, base);
	// 828C021C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0220: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0224: 388A2FB4  addi r4, r10, 0x2fb4
	ctx.r[4].s64 = ctx.r[10].s64 + 12212;
	// 828C0228: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C022C: 4B96CCA5  bl 0x8222ced0
	ctx.lr = 0x828C0230;
	sub_8222CED0(ctx, base);
	// 828C0230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0234: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C023C: 4B96CC95  bl 0x8222ced0
	ctx.lr = 0x828C0240;
	sub_8222CED0(ctx, base);
	// 828C0240: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C0244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0248: 38C9E650  addi r6, r9, -0x19b0
	ctx.r[6].s64 = ctx.r[9].s64 + -6576;
	// 828C024C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C0250: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0254: 48000C3D  bl 0x828c0e90
	ctx.lr = 0x828C0258;
	sub_828C0E90(ctx, base);
	// 828C0258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C025C: 4B954B7D  bl 0x82214dd8
	ctx.lr = 0x828C0260;
	sub_82214DD8(ctx, base);
	// 828C0260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0264: 4B954B75  bl 0x82214dd8
	ctx.lr = 0x828C0268;
	sub_82214DD8(ctx, base);
	// 828C0268: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C026C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0270: 38882FC4  addi r4, r8, 0x2fc4
	ctx.r[4].s64 = ctx.r[8].s64 + 12228;
	// 828C0274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0278: 4B96CC59  bl 0x8222ced0
	ctx.lr = 0x828C027C;
	sub_8222CED0(ctx, base);
	// 828C027C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0280: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0284: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0288: 4B96CC49  bl 0x8222ced0
	ctx.lr = 0x828C028C;
	sub_8222CED0(ctx, base);
	// 828C028C: 3CE0821A  lis r7, -0x7de6
	ctx.r[7].s64 = -2112225280;
	// 828C0290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0294: 38C79BB8  addi r6, r7, -0x6448
	ctx.r[6].s64 = ctx.r[7].s64 + -25672;
	// 828C0298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C029C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C02A0: 48000DB1  bl 0x828c1050
	ctx.lr = 0x828C02A4;
	sub_828C1050(ctx, base);
	// 828C02A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02A8: 4B954B31  bl 0x82214dd8
	ctx.lr = 0x828C02AC;
	sub_82214DD8(ctx, base);
	// 828C02AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02B0: 4B954B29  bl 0x82214dd8
	ctx.lr = 0x828C02B4;
	sub_82214DD8(ctx, base);
	// 828C02B4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C02B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C02BC: 38862FD0  addi r4, r6, 0x2fd0
	ctx.r[4].s64 = ctx.r[6].s64 + 12240;
	// 828C02C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02C4: 4B96CC0D  bl 0x8222ced0
	ctx.lr = 0x828C02C8;
	sub_8222CED0(ctx, base);
	// 828C02C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C02CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C02D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02D4: 4B96CBFD  bl 0x8222ced0
	ctx.lr = 0x828C02D8;
	sub_8222CED0(ctx, base);
	// 828C02D8: 3C80828C  lis r4, -0x7d74
	ctx.r[4].s64 = -2104754176;
	// 828C02DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C02E0: 38C4E270  addi r6, r4, -0x1d90
	ctx.r[6].s64 = ctx.r[4].s64 + -7568;
	// 828C02E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C02E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C02EC: 48000BA5  bl 0x828c0e90
	ctx.lr = 0x828C02F0;
	sub_828C0E90(ctx, base);
	// 828C02F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02F4: 4B954AE5  bl 0x82214dd8
	ctx.lr = 0x828C02F8;
	sub_82214DD8(ctx, base);
	// 828C02F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02FC: 4B954ADD  bl 0x82214dd8
	ctx.lr = 0x828C0300;
	sub_82214DD8(ctx, base);
	// 828C0300: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0304: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0308: 38832FE0  addi r4, r3, 0x2fe0
	ctx.r[4].s64 = ctx.r[3].s64 + 12256;
	// 828C030C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0310: 4B96CBC1  bl 0x8222ced0
	ctx.lr = 0x828C0314;
	sub_8222CED0(ctx, base);
	// 828C0314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0318: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C031C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0320: 4B96CBB1  bl 0x8222ced0
	ctx.lr = 0x828C0324;
	sub_8222CED0(ctx, base);
	// 828C0324: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C032C: 38CBF918  addi r6, r11, -0x6e8
	ctx.r[6].s64 = ctx.r[11].s64 + -1768;
	// 828C0330: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0334: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0338: 48000ED9  bl 0x828c1210
	ctx.lr = 0x828C033C;
	sub_828C1210(ctx, base);
	// 828C033C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0340: 4B954A99  bl 0x82214dd8
	ctx.lr = 0x828C0344;
	sub_82214DD8(ctx, base);
	// 828C0344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0348: 4B954A91  bl 0x82214dd8
	ctx.lr = 0x828C034C;
	sub_82214DD8(ctx, base);
	// 828C034C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0350: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0354: 388A2FF8  addi r4, r10, 0x2ff8
	ctx.r[4].s64 = ctx.r[10].s64 + 12280;
	// 828C0358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C035C: 4B96CB75  bl 0x8222ced0
	ctx.lr = 0x828C0360;
	sub_8222CED0(ctx, base);
	// 828C0360: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0364: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0368: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C036C: 4B96CB65  bl 0x8222ced0
	ctx.lr = 0x828C0370;
	sub_8222CED0(ctx, base);
	// 828C0370: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0378: 38C9F920  addi r6, r9, -0x6e0
	ctx.r[6].s64 = ctx.r[9].s64 + -1760;
	// 828C037C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0380: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0384: 48000E8D  bl 0x828c1210
	ctx.lr = 0x828C0388;
	sub_828C1210(ctx, base);
	// 828C0388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C038C: 4B954A4D  bl 0x82214dd8
	ctx.lr = 0x828C0390;
	sub_82214DD8(ctx, base);
	// 828C0390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0394: 4B954A45  bl 0x82214dd8
	ctx.lr = 0x828C0398;
	sub_82214DD8(ctx, base);
	// 828C0398: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C039C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03A0: 38883010  addi r4, r8, 0x3010
	ctx.r[4].s64 = ctx.r[8].s64 + 12304;
	// 828C03A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03A8: 4B96CB29  bl 0x8222ced0
	ctx.lr = 0x828C03AC;
	sub_8222CED0(ctx, base);
	// 828C03AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C03B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C03B8: 4B96CB19  bl 0x8222ced0
	ctx.lr = 0x828C03BC;
	sub_8222CED0(ctx, base);
	// 828C03BC: 3CE08270  lis r7, -0x7d90
	ctx.r[7].s64 = -2106589184;
	// 828C03C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C03C4: 38C7FED8  addi r6, r7, -0x128
	ctx.r[6].s64 = ctx.r[7].s64 + -296;
	// 828C03C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C03CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C03D0: 48001041  bl 0x828c1410
	ctx.lr = 0x828C03D4;
	sub_828C1410(ctx, base);
	// 828C03D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C03D8: 4B954A01  bl 0x82214dd8
	ctx.lr = 0x828C03DC;
	sub_82214DD8(ctx, base);
	// 828C03DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03E0: 4B9549F9  bl 0x82214dd8
	ctx.lr = 0x828C03E4;
	sub_82214DD8(ctx, base);
	// 828C03E4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C03E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03EC: 3886301C  addi r4, r6, 0x301c
	ctx.r[4].s64 = ctx.r[6].s64 + 12316;
	// 828C03F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03F4: 4B96CADD  bl 0x8222ced0
	ctx.lr = 0x828C03F8;
	sub_8222CED0(ctx, base);
	// 828C03F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C03FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0400: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0404: 4B96CACD  bl 0x8222ced0
	ctx.lr = 0x828C0408;
	sub_8222CED0(ctx, base);
	// 828C0408: 3C808272  lis r4, -0x7d8e
	ctx.r[4].s64 = -2106458112;
	// 828C040C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0410: 38C425D0  addi r6, r4, 0x25d0
	ctx.r[6].s64 = ctx.r[4].s64 + 9680;
	// 828C0414: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0418: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C041C: 48000FF5  bl 0x828c1410
	ctx.lr = 0x828C0420;
	sub_828C1410(ctx, base);
	// 828C0420: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0424: 4B9549B5  bl 0x82214dd8
	ctx.lr = 0x828C0428;
	sub_82214DD8(ctx, base);
	// 828C0428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C042C: 4B9549AD  bl 0x82214dd8
	ctx.lr = 0x828C0430;
	sub_82214DD8(ctx, base);
	// 828C0430: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0434: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0438: 38833034  addi r4, r3, 0x3034
	ctx.r[4].s64 = ctx.r[3].s64 + 12340;
	// 828C043C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0440: 4B96CA91  bl 0x8222ced0
	ctx.lr = 0x828C0444;
	sub_8222CED0(ctx, base);
	// 828C0444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0448: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C044C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0450: 4B96CA81  bl 0x8222ced0
	ctx.lr = 0x828C0454;
	sub_8222CED0(ctx, base);
	// 828C0454: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C045C: 38CBF178  addi r6, r11, -0xe88
	ctx.r[6].s64 = ctx.r[11].s64 + -3720;
	// 828C0460: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0464: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0468: 48000FA9  bl 0x828c1410
	ctx.lr = 0x828C046C;
	sub_828C1410(ctx, base);
	// 828C046C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0470: 4B954969  bl 0x82214dd8
	ctx.lr = 0x828C0474;
	sub_82214DD8(ctx, base);
	// 828C0474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0478: 4B954961  bl 0x82214dd8
	ctx.lr = 0x828C047C;
	sub_82214DD8(ctx, base);
	// 828C047C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0480: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0484: 388A3044  addi r4, r10, 0x3044
	ctx.r[4].s64 = ctx.r[10].s64 + 12356;
	// 828C0488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C048C: 4B96CA45  bl 0x8222ced0
	ctx.lr = 0x828C0490;
	sub_8222CED0(ctx, base);
	// 828C0490: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0494: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C049C: 4B96CA35  bl 0x8222ced0
	ctx.lr = 0x828C04A0;
	sub_8222CED0(ctx, base);
	// 828C04A0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C04A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C04A8: 38C9F938  addi r6, r9, -0x6c8
	ctx.r[6].s64 = ctx.r[9].s64 + -1736;
	// 828C04AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C04B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C04B4: 48000D5D  bl 0x828c1210
	ctx.lr = 0x828C04B8;
	sub_828C1210(ctx, base);
	// 828C04B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C04BC: 4B95491D  bl 0x82214dd8
	ctx.lr = 0x828C04C0;
	sub_82214DD8(ctx, base);
	// 828C04C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C04C4: 4B954915  bl 0x82214dd8
	ctx.lr = 0x828C04C8;
	sub_82214DD8(ctx, base);
	// 828C04C8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C04CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C04D0: 38883058  addi r4, r8, 0x3058
	ctx.r[4].s64 = ctx.r[8].s64 + 12376;
	// 828C04D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C04D8: 4B96C9F9  bl 0x8222ced0
	ctx.lr = 0x828C04DC;
	sub_8222CED0(ctx, base);
	// 828C04DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C04E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C04E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C04E8: 4B96C9E9  bl 0x8222ced0
	ctx.lr = 0x828C04EC;
	sub_8222CED0(ctx, base);
	// 828C04EC: 3CE0828C  lis r7, -0x7d74
	ctx.r[7].s64 = -2104754176;
	// 828C04F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C04F4: 38C7F2E0  addi r6, r7, -0xd20
	ctx.r[6].s64 = ctx.r[7].s64 + -3360;
	// 828C04F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C04FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0500: 48000991  bl 0x828c0e90
	ctx.lr = 0x828C0504;
	sub_828C0E90(ctx, base);
	// 828C0504: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0508: 4B9548D1  bl 0x82214dd8
	ctx.lr = 0x828C050C;
	sub_82214DD8(ctx, base);
	// 828C050C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0510: 4B9548C9  bl 0x82214dd8
	ctx.lr = 0x828C0514;
	sub_82214DD8(ctx, base);
	// 828C0514: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C0518: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C051C: 38863064  addi r4, r6, 0x3064
	ctx.r[4].s64 = ctx.r[6].s64 + 12388;
	// 828C0520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0524: 4B96C9AD  bl 0x8222ced0
	ctx.lr = 0x828C0528;
	sub_8222CED0(ctx, base);
	// 828C0528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C052C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0530: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0534: 4B96C99D  bl 0x8222ced0
	ctx.lr = 0x828C0538;
	sub_8222CED0(ctx, base);
	// 828C0538: 3C80828C  lis r4, -0x7d74
	ctx.r[4].s64 = -2104754176;
	// 828C053C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0540: 38C4F530  addi r6, r4, -0xad0
	ctx.r[6].s64 = ctx.r[4].s64 + -2768;
	// 828C0544: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0548: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C054C: 480010C5  bl 0x828c1610
	ctx.lr = 0x828C0550;
	sub_828C1610(ctx, base);
	// 828C0550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0554: 4B954885  bl 0x82214dd8
	ctx.lr = 0x828C0558;
	sub_82214DD8(ctx, base);
	// 828C0558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C055C: 4B95487D  bl 0x82214dd8
	ctx.lr = 0x828C0560;
	sub_82214DD8(ctx, base);
	// 828C0560: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0564: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0568: 38833078  addi r4, r3, 0x3078
	ctx.r[4].s64 = ctx.r[3].s64 + 12408;
	// 828C056C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0570: 4B96C961  bl 0x8222ced0
	ctx.lr = 0x828C0574;
	sub_8222CED0(ctx, base);
	// 828C0574: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0578: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C057C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0580: 4B96C951  bl 0x8222ced0
	ctx.lr = 0x828C0584;
	sub_8222CED0(ctx, base);
	// 828C0584: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0588: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C058C: 38CBEBD0  addi r6, r11, -0x1430
	ctx.r[6].s64 = ctx.r[11].s64 + -5168;
	// 828C0590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0594: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0598: 48000AB9  bl 0x828c1050
	ctx.lr = 0x828C059C;
	sub_828C1050(ctx, base);
	// 828C059C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05A0: 4B954839  bl 0x82214dd8
	ctx.lr = 0x828C05A4;
	sub_82214DD8(ctx, base);
	// 828C05A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05A8: 4B954831  bl 0x82214dd8
	ctx.lr = 0x828C05AC;
	sub_82214DD8(ctx, base);
	// 828C05AC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C05B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C05B4: 388A3080  addi r4, r10, 0x3080
	ctx.r[4].s64 = ctx.r[10].s64 + 12416;
	// 828C05B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05BC: 4B96C915  bl 0x8222ced0
	ctx.lr = 0x828C05C0;
	sub_8222CED0(ctx, base);
	// 828C05C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C05C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C05C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05CC: 4B96C905  bl 0x8222ced0
	ctx.lr = 0x828C05D0;
	sub_8222CED0(ctx, base);
	// 828C05D0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C05D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C05D8: 38C9F958  addi r6, r9, -0x6a8
	ctx.r[6].s64 = ctx.r[9].s64 + -1704;
	// 828C05DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C05E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C05E4: 48001235  bl 0x828c1818
	ctx.lr = 0x828C05E8;
	sub_828C1818(ctx, base);
	// 828C05E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05EC: 4B9547ED  bl 0x82214dd8
	ctx.lr = 0x828C05F0;
	sub_82214DD8(ctx, base);
	// 828C05F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05F4: 4B9547E5  bl 0x82214dd8
	ctx.lr = 0x828C05F8;
	sub_82214DD8(ctx, base);
	// 828C05F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C05FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C0600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C0604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C0608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C060C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0610 size=140
    let mut pc: u32 = 0x828C0610;
    'dispatch: loop {
        match pc {
            0x828C0610 => {
    //   block [0x828C0610..0x828C069C)
	// 828C0610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0614: 483E8DF9  bl 0x82ca940c
	ctx.lr = 0x828C0618;
	sub_82CA93D0(ctx, base);
	// 828C0618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C061C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C0620: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0628: 419A0018  beq cr6, 0x828c0640
	if ctx.cr[6].eq {
	pc = 0x828C0640; continue 'dispatch;
	}
	// 828C062C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C0630: 48000119  bl 0x828c0748
	ctx.lr = 0x828C0634;
	sub_828C0748(ctx, base);
	// 828C0634: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C063C: 409AFFF0  bne cr6, 0x828c062c
	if !ctx.cr[6].eq {
	pc = 0x828C062C; continue 'dispatch;
	}
	// 828C0640: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0644: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0648: 419A0030  beq cr6, 0x828c0678
	if ctx.cr[6].eq {
	pc = 0x828C0678; continue 'dispatch;
	}
	// 828C064C: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828C0650: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0654: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 828C0658: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 828C065C: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828C0660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C0664: 419A000C  beq cr6, 0x828c0670
	if ctx.cr[6].eq {
	pc = 0x828C0670; continue 'dispatch;
	}
	// 828C0668: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828C066C: 4B95B6CD  bl 0x8221bd38
	ctx.lr = 0x828C0670;
	sub_8221BD38(ctx, base);
	// 828C0670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0674: 409AFFDC  bne cr6, 0x828c0650
	if !ctx.cr[6].eq {
	pc = 0x828C0650; continue 'dispatch;
	}
	// 828C0678: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C067C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0680: 419A0008  beq cr6, 0x828c0688
	if ctx.cr[6].eq {
	pc = 0x828C0688; continue 'dispatch;
	}
	// 828C0684: 4B95B6B5  bl 0x8221bd38
	ctx.lr = 0x828C0688;
	sub_8221BD38(ctx, base);
	// 828C0688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C068C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C0690: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C0694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C0698: 483E8DC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C06A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C06A0 size=164
    let mut pc: u32 = 0x828C06A0;
    'dispatch: loop {
        match pc {
            0x828C06A0 => {
    //   block [0x828C06A0..0x828C0744)
	// 828C06A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C06A4: 483E8D65  bl 0x82ca9408
	ctx.lr = 0x828C06A8;
	sub_82CA93D0(ctx, base);
	// 828C06A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C06AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C06B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C06B4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C06B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C06BC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 828C06C0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C06C4: 4199000C  bgt cr6, 0x828c06d0
	if ctx.cr[6].gt {
	pc = 0x828C06D0; continue 'dispatch;
	}
	// 828C06C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C06CC: 4800031D  bl 0x828c09e8
	ctx.lr = 0x828C06D0;
	sub_828C09E8(ctx, base);
	// 828C06D0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C06D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C06D8: 409A0008  bne cr6, 0x828c06e0
	if !ctx.cr[6].eq {
	pc = 0x828C06E0; continue 'dispatch;
	}
	// 828C06DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C06E0: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 828C06E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C06E8: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828C06EC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C06F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C06F4: 409A0014  bne cr6, 0x828c0708
	if !ctx.cr[6].eq {
	pc = 0x828C0708; continue 'dispatch;
	}
	// 828C06F8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C06FC: 4B95EB5D  bl 0x8221f258
	ctx.lr = 0x828C0700;
	sub_8221F258(ctx, base);
	// 828C0700: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0704: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 828C0708: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C070C: 7FCBF02E  lwzx r30, r11, r30
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C0710: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0714: 419A0018  beq cr6, 0x828c072c
	if ctx.cr[6].eq {
	pc = 0x828C072C; continue 'dispatch;
	}
	// 828C0718: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C071C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0720: 4B8D6651  bl 0x82196d70
	ctx.lr = 0x828C0724;
	sub_82196D70(ctx, base);
	// 828C0724: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0728: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C072C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0730: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828C0734: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C0738: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C073C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C0740: 483E8D18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0748 size=148
    let mut pc: u32 = 0x828C0748;
    'dispatch: loop {
        match pc {
            0x828C0748 => {
    //   block [0x828C0748..0x828C07DC)
	// 828C0748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C074C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C0750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C0754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C0758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C075C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0760: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0764: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C0768: 419A005C  beq cr6, 0x828c07c4
	if ctx.cr[6].eq {
	pc = 0x828C07C4; continue 'dispatch;
	}
	// 828C076C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0770: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0774: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828C0778: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C077C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0780: 41990008  bgt cr6, 0x828c0788
	if ctx.cr[6].gt {
	pc = 0x828C0788; continue 'dispatch;
	}
	// 828C0784: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C0788: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C078C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C0790: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828C0794: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828C0798: 7FC9502E  lwzx r30, r9, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C079C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C07A0: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828C07A4: 4B8D3695  bl 0x82193e38
	ctx.lr = 0x828C07A8;
	sub_82193E38(ctx, base);
	// 828C07A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C07AC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C07B0: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C07B4: 3566FFFF  addic. r11, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C07B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C07BC: 40820008  bne 0x828c07c4
	if !ctx.cr[0].eq {
	pc = 0x828C07C4; continue 'dispatch;
	}
	// 828C07C0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828C07C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C07C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C07CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C07D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C07D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C07D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C07E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C07E0 size=516
    let mut pc: u32 = 0x828C07E0;
    'dispatch: loop {
        match pc {
            0x828C07E0 => {
    //   block [0x828C07E0..0x828C09E4)
	// 828C07E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C07E4: 483E8C19  bl 0x82ca93fc
	ctx.lr = 0x828C07E8;
	sub_82CA93D0(ctx, base);
	// 828C07E8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C07EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C07F0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C07F4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C07F8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C07FC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0800: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0804: 40990008  ble cr6, 0x828c080c
	if !ctx.cr[6].gt {
	pc = 0x828C080C; continue 'dispatch;
	}
	// 828C0808: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C080C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0814: 419A000C  beq cr6, 0x828c0820
	if ctx.cr[6].eq {
	pc = 0x828C0820; continue 'dispatch;
	}
	// 828C0818: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C081C: 419A0008  beq cr6, 0x828c0824
	if ctx.cr[6].eq {
	pc = 0x828C0824; continue 'dispatch;
	}
	// 828C0820: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C0824: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0828: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C082C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C0830: 7F6A4850  subf r27, r10, r9
	ctx.r[27].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828C0834: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C0838: 419A000C  beq cr6, 0x828c0844
	if ctx.cr[6].eq {
	pc = 0x828C0844; continue 'dispatch;
	}
	// 828C083C: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828C0840: 419A0008  beq cr6, 0x828c0848
	if ctx.cr[6].eq {
	pc = 0x828C0848; continue 'dispatch;
	}
	// 828C0844: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C0848: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C084C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0850: 7F895850  subf r28, r9, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C0854: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0858: 40990008  ble cr6, 0x828c0860
	if !ctx.cr[6].gt {
	pc = 0x828C0860; continue 'dispatch;
	}
	// 828C085C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C0860: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828C0864: 419A0008  beq cr6, 0x828c086c
	if ctx.cr[6].eq {
	pc = 0x828C086C; continue 'dispatch;
	}
	// 828C0868: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C086C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C0870: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828C0874: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0878: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828C087C: 7F1B3840  cmplw cr6, r27, r7
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828C0880: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828C0884: 409800B8  bge cr6, 0x828c093c
	if !ctx.cr[6].lt {
	pc = 0x828C093C; continue 'dispatch;
	}
	// 828C0888: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828C088C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0890: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C0894: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C0898: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 828C089C: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C08A0: 40990008  ble cr6, 0x828c08a8
	if !ctx.cr[6].gt {
	pc = 0x828C08A8; continue 'dispatch;
	}
	// 828C08A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C08A8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828C08AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C08B0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828C08B4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C08B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828C08BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C08C0: 48001161  bl 0x828c1a20
	ctx.lr = 0x828C08C4;
	sub_828C1A20(ctx, base);
	// 828C08C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C08C8: 419A00C8  beq cr6, 0x828c0990
	if ctx.cr[6].eq {
	pc = 0x828C0990; continue 'dispatch;
	}
	// 828C08CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C08D0: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 828C08D4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C08D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C08DC: 419A0054  beq cr6, 0x828c0930
	if ctx.cr[6].eq {
	pc = 0x828C0930; continue 'dispatch;
	}
	// 828C08E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C08E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C08E8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C08EC: 7F2A482E  lwzx r25, r10, r9
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828C08F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C08F4: 93B90000  stw r29, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C08F8: 4B8D3541  bl 0x82193e38
	ctx.lr = 0x828C08FC;
	sub_82193E38(ctx, base);
	// 828C08FC: 93D90004  stw r30, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0900: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0904: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0908: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C090C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0910: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828C0914: 41990008  bgt cr6, 0x828c091c
	if ctx.cr[6].gt {
	pc = 0x828C091C; continue 'dispatch;
	}
	// 828C0918: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828C091C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0920: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0924: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C0928: 40820008  bne 0x828c0930
	if !ctx.cr[0].eq {
	pc = 0x828C0930; continue 'dispatch;
	}
	// 828C092C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828C0930: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C0934: 4082FFA0  bne 0x828c08d4
	if !ctx.cr[0].eq {
	pc = 0x828C08D4; continue 'dispatch;
	}
	// 828C0938: 48000058  b 0x828c0990
	pc = 0x828C0990; continue 'dispatch;
	// 828C093C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 828C0940: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0944: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 828C0948: 40990008  ble cr6, 0x828c0950
	if !ctx.cr[6].gt {
	pc = 0x828C0950; continue 'dispatch;
	}
	// 828C094C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C0950: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828C0954: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828C0958: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828C095C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C0960: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 828C0964: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0968: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C096C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0970: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C0974: 4800118D  bl 0x828c1b00
	ctx.lr = 0x828C0978;
	sub_828C1B00(ctx, base);
	// 828C0978: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C097C: 419A0014  beq cr6, 0x828c0990
	if ctx.cr[6].eq {
	pc = 0x828C0990; continue 'dispatch;
	}
	// 828C0980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0984: 4BFFFDC5  bl 0x828c0748
	ctx.lr = 0x828C0988;
	sub_828C0748(ctx, base);
	// 828C0988: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C098C: 4082FFF4  bne 0x828c0980
	if !ctx.cr[0].eq {
	pc = 0x828C0980; continue 'dispatch;
	}
	// 828C0990: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0994: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0998: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C099C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C09A0: 40990008  ble cr6, 0x828c09a8
	if !ctx.cr[6].gt {
	pc = 0x828C09A8; continue 'dispatch;
	}
	// 828C09A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C09A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C09AC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828C09B0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C09B4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828C09B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C09BC: 4199000C  bgt cr6, 0x828c09c8
	if ctx.cr[6].gt {
	pc = 0x828C09C8; continue 'dispatch;
	}
	// 828C09C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C09C4: 40980008  bge cr6, 0x828c09cc
	if !ctx.cr[6].lt {
	pc = 0x828C09CC; continue 'dispatch;
	}
	// 828C09C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C09CC: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C09D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C09D4: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C09D8: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C09DC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828C09E0: 483E8A6C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C09E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C09E8 size=608
    let mut pc: u32 = 0x828C09E8;
    'dispatch: loop {
        match pc {
            0x828C09E8 => {
    //   block [0x828C09E8..0x828C0C48)
	// 828C09E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C09EC: 483E8A11  bl 0x82ca93fc
	ctx.lr = 0x828C09F0;
	sub_82CA93D0(ctx, base);
	// 828C09F0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C09F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C09F8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 828C09FC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C0A00: 617F5555  ori r31, r11, 0x5555
	ctx.r[31].u64 = ctx.r[11].u64 | 21845;
	// 828C0A04: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828C0A08: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0A0C: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828C0A10: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828C0A14: 40980064  bge cr6, 0x828c0a78
	if !ctx.cr[6].lt {
	pc = 0x828C0A78; continue 'dispatch;
	}
	// 828C0A18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C0A1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0A20: 388B2DA8  addi r4, r11, 0x2da8
	ctx.r[4].s64 = ctx.r[11].s64 + 11688;
	// 828C0A24: 4BA3151D  bl 0x822f1f40
	ctx.lr = 0x828C0A28;
	sub_822F1F40(ctx, base);
	// 828C0A28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C0A2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A30: 4BA31381  bl 0x822f1db0
	ctx.lr = 0x828C0A34;
	sub_822F1DB0(ctx, base);
	// 828C0A34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828C0A38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A3C: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828C0A40: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828C0A44: 4BA313DD  bl 0x822f1e20
	ctx.lr = 0x828C0A48;
	sub_822F1E20(ctx, base);
	// 828C0A48: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828C0A4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A50: 4BDBAD91  bl 0x8267b7e0
	ctx.lr = 0x828C0A54;
	sub_8267B7E0(ctx, base);
	// 828C0A54: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C0A58: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 828C0A5C: 4198000C  blt cr6, 0x828c0a68
	if ctx.cr[6].lt {
	pc = 0x828C0A68; continue 'dispatch;
	}
	// 828C0A60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C0A64: 4B95B2D5  bl 0x8221bd38
	ctx.lr = 0x828C0A68;
	sub_8221BD38(ctx, base);
	// 828C0A68: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 828C0A6C: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 828C0A70: 9B210064  stb r25, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u8 ) };
	// 828C0A74: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C0A78: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0A7C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C0A80: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 828C0A84: 4098000C  bge cr6, 0x828c0a90
	if !ctx.cr[6].lt {
	pc = 0x828C0A90; continue 'dispatch;
	}
	// 828C0A88: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828C0A8C: 4800000C  b 0x828c0a98
	pc = 0x828C0A98; continue 'dispatch;
	// 828C0A90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C0A94: 40990014  ble cr6, 0x828c0aa8
	if !ctx.cr[6].gt {
	pc = 0x828C0AA8; continue 'dispatch;
	}
	// 828C0A98: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828C0A9C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C0AA0: 41990008  bgt cr6, 0x828c0aa8
	if ctx.cr[6].gt {
	pc = 0x828C0AA8; continue 'dispatch;
	}
	// 828C0AA4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 828C0AA8: 83DD000C  lwz r30, 0xc(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0AAC: 7FEAD215  add. r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C0AB0: 4082000C  bne 0x828c0abc
	if !ctx.cr[0].eq {
	pc = 0x828C0ABC; continue 'dispatch;
	}
	// 828C0AB4: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828C0AB8: 48000038  b 0x828c0af0
	pc = 0x828C0AF0; continue 'dispatch;
	// 828C0ABC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828C0AC0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 828C0AC4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 828C0AC8: 40980028  bge cr6, 0x828c0af0
	if !ctx.cr[6].lt {
	pc = 0x828C0AF0; continue 'dispatch;
	}
	// 828C0ACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C0AD0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828C0AD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0AD8: 394B1714  addi r10, r11, 0x1714
	ctx.r[10].s64 = ctx.r[11].s64 + 5908;
	// 828C0ADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C0AE0: 4BA31341  bl 0x822f1e20
	ctx.lr = 0x828C0AE4;
	sub_822F1E20(ctx, base);
	// 828C0AE4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C0AE8: 39091708  addi r8, r9, 0x1708
	ctx.r[8].s64 = ctx.r[9].s64 + 5896;
	// 828C0AEC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828C0AF0: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828C0AF4: 4B95E765  bl 0x8221f258
	ctx.lr = 0x828C0AF8;
	sub_8221F258(ctx, base);
	// 828C0AF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0AFC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0B00: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828C0B04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0B08: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828C0B0C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C0B10: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 828C0B14: 7D454850  subf r10, r5, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 828C0B18: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0B1C: 7D0B1671  srawi. r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0B20: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0B24: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 828C0B28: 4182000C  beq 0x828c0b34
	if ctx.cr[0].eq {
	pc = 0x828C0B34; continue 'dispatch;
	}
	// 828C0B2C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0B30: 483E94F9  bl 0x82caa028
	ctx.lr = 0x828C0B34;
	sub_82CAA028(ctx, base);
	// 828C0B34: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0B38: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828C0B3C: 41990074  bgt cr6, 0x828c0bb0
	if ctx.cr[6].gt {
	pc = 0x828C0BB0; continue 'dispatch;
	}
	// 828C0B40: 7D65F850  subf r11, r5, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 828C0B44: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 828C0B48: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0B4C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0B50: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 828C0B54: 41820010  beq 0x828c0b64
	if ctx.cr[0].eq {
	pc = 0x828C0B64; continue 'dispatch;
	}
	// 828C0B58: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0B5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0B60: 483E94C9  bl 0x82caa028
	ctx.lr = 0x828C0B64;
	sub_82CAA028(ctx, base);
	// 828C0B64: 7D5ED051  subf. r10, r30, r26
	ctx.r[10].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C0B68: 41820024  beq 0x828c0b8c
	if ctx.cr[0].eq {
	pc = 0x828C0B8C; continue 'dispatch;
	}
	// 828C0B6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C0B70: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 828C0B74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C0B78: 419A0014  beq cr6, 0x828c0b8c
	if ctx.cr[6].eq {
	pc = 0x828C0B8C; continue 'dispatch;
	}
	// 828C0B7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C0B80: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C0B84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0B88: 4200FFF8  bdnz 0x828c0b80
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0B80; continue 'dispatch;
	}
	// 828C0B8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0B90: 419A0090  beq cr6, 0x828c0c20
	if ctx.cr[6].eq {
	pc = 0x828C0C20; continue 'dispatch;
	}
	// 828C0B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828C0B98: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C0B9C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 828C0BA0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0BA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0BA8: 4200FFF8  bdnz 0x828c0ba0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0BA0; continue 'dispatch;
	}
	// 828C0BAC: 48000074  b 0x828c0c20
	pc = 0x828C0C20; continue 'dispatch;
	// 828C0BB0: 575E103A  slwi r30, r26, 2
	ctx.r[30].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828C0BB4: 7D65F050  subf r11, r5, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 828C0BB8: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 828C0BBC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0BC0: 41820014  beq 0x828c0bd4
	if ctx.cr[0].eq {
	pc = 0x828C0BD4; continue 'dispatch;
	}
	// 828C0BC4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C0BC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0BCC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C0BD0: 483E9459  bl 0x82caa028
	ctx.lr = 0x828C0BD4;
	sub_82CAA028(ctx, base);
	// 828C0BD4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0BD8: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828C0BDC: 7D45F850  subf r10, r5, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 828C0BE0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0BE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0BE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0BEC: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 828C0BF0: 41820010  beq 0x828c0c00
	if ctx.cr[0].eq {
	pc = 0x828C0C00; continue 'dispatch;
	}
	// 828C0BF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0BF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0BFC: 483E942D  bl 0x82caa028
	ctx.lr = 0x828C0C00;
	sub_82CAA028(ctx, base);
	// 828C0C00: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828C0C04: 419A001C  beq cr6, 0x828c0c20
	if ctx.cr[6].eq {
	pc = 0x828C0C20; continue 'dispatch;
	}
	// 828C0C08: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C0C0C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C0C10: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 828C0C14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0C18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0C1C: 4200FFF8  bdnz 0x828c0c14
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0C14; continue 'dispatch;
	}
	// 828C0C20: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0C24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0C28: 419A0008  beq cr6, 0x828c0c30
	if ctx.cr[6].eq {
	pc = 0x828C0C30; continue 'dispatch;
	}
	// 828C0C2C: 4B95B10D  bl 0x8221bd38
	ctx.lr = 0x828C0C30;
	sub_8221BD38(ctx, base);
	// 828C0C30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0C34: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828C0C38: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828C0C3C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C0C40: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828C0C44: 483E8808  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0C48 size=584
    let mut pc: u32 = 0x828C0C48;
    'dispatch: loop {
        match pc {
            0x828C0C48 => {
    //   block [0x828C0C48..0x828C0E90)
	// 828C0C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0C4C: 483E87B5  bl 0x82ca9400
	ctx.lr = 0x828C0C50;
	sub_82CA93D0(ctx, base);
	// 828C0C50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0C54: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0C58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0C60: 409A0010  bne cr6, 0x828c0c70
	if !ctx.cr[6].eq {
	pc = 0x828C0C70; continue 'dispatch;
	}
	// 828C0C64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C0C68: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C0C6C: 48000008  b 0x828c0c74
	pc = 0x828C0C74; continue 'dispatch;
	// 828C0C70: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0C74: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0C78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0C7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0C80: 4BB0D941  bl 0x823ce5c0
	ctx.lr = 0x828C0C84;
	sub_823CE5C0(ctx, base);
	// 828C0C84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C0C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0C8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0C90: 4BB0D571  bl 0x823ce200
	ctx.lr = 0x828C0C94;
	sub_823CE200(ctx, base);
	// 828C0C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0C98: 4B8F6E81  bl 0x821b7b18
	ctx.lr = 0x828C0C9C;
	sub_821B7B18(ctx, base);
	// 828C0C9C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C0CA0: 4B95E5B9  bl 0x8221f258
	ctx.lr = 0x828C0CA4;
	sub_8221F258(ctx, base);
	// 828C0CA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C0CA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C0CAC: 419A0040  beq cr6, 0x828c0cec
	if ctx.cr[6].eq {
	pc = 0x828C0CEC; continue 'dispatch;
	}
	// 828C0CB0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C0CB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C0CB8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C0CBC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0CC0: 4B95E599  bl 0x8221f258
	ctx.lr = 0x828C0CC4;
	sub_8221F258(ctx, base);
	// 828C0CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0CC8: 419A0028  beq cr6, 0x828c0cf0
	if ctx.cr[6].eq {
	pc = 0x828C0CF0; continue 'dispatch;
	}
	// 828C0CCC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C0CD0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C0CD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C0CD8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C0CDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0CE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C0CE4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C0CE8: 4800000C  b 0x828c0cf4
	pc = 0x828C0CF4; continue 'dispatch;
	// 828C0CEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C0CF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C0CF4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0CF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0CFC: 419A00FC  beq cr6, 0x828c0df8
	if ctx.cr[6].eq {
	pc = 0x828C0DF8; continue 'dispatch;
	}
	// 828C0D00: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0D04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0D08: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0D0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D10: 4B9683F9  bl 0x82229108
	ctx.lr = 0x828C0D14;
	sub_82229108(ctx, base);
	// 828C0D14: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0D18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0D1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D20: 3BCB1BD8  addi r30, r11, 0x1bd8
	ctx.r[30].s64 = ctx.r[11].s64 + 7128;
	// 828C0D24: 4B966B5D  bl 0x82227880
	ctx.lr = 0x828C0D28;
	sub_82227880(ctx, base);
	// 828C0D28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C0D2C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C0D30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0D34: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C0D38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D3C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0D40: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0D44: 4B8D9D3D  bl 0x8219aa80
	ctx.lr = 0x828C0D48;
	sub_8219AA80(ctx, base);
	// 828C0D48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C0D4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C0D50: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C0D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0D58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C0D5C: 4BB0D6C5  bl 0x823ce420
	ctx.lr = 0x828C0D60;
	sub_823CE420(ctx, base);
	// 828C0D60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C0D64: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0D68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D6C: 4816395D  bl 0x82a246c8
	ctx.lr = 0x828C0D70;
	sub_82A246C8(ctx, base);
	// 828C0D70: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0D74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0D78: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C0D7C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C0D80: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0D84: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0D88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0D8C: 4B96837D  bl 0x82229108
	ctx.lr = 0x828C0D90;
	sub_82229108(ctx, base);
	// 828C0D90: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828C0D94: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0D9C: 3BEB6D48  addi r31, r11, 0x6d48
	ctx.r[31].s64 = ctx.r[11].s64 + 27976;
	// 828C0DA0: 4B966AE1  bl 0x82227880
	ctx.lr = 0x828C0DA4;
	sub_82227880(ctx, base);
	// 828C0DA4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C0DA8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C0DAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0DB0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C0DB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0DB8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0DBC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C0DC0: 4B8D9CC1  bl 0x8219aa80
	ctx.lr = 0x828C0DC4;
	sub_8219AA80(ctx, base);
	// 828C0DC4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C0DC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0DCC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C0DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0DD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0DD8: 4BB0D649  bl 0x823ce420
	ctx.lr = 0x828C0DDC;
	sub_823CE420(ctx, base);
	// 828C0DDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0DE0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0DE8: 481638E1  bl 0x82a246c8
	ctx.lr = 0x828C0DEC;
	sub_82A246C8(ctx, base);
	// 828C0DEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0DF0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C0DF4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828C0DF8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C0DFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0E00: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C0E04: 419A0020  beq cr6, 0x828c0e24
	if ctx.cr[6].eq {
	pc = 0x828C0E24; continue 'dispatch;
	}
	// 828C0E08: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C0E0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E10: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C0E14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C0E18: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0E1C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E20: 4082FFE8  bne 0x828c0e08
	if !ctx.cr[0].eq {
	pc = 0x828C0E08; continue 'dispatch;
	}
	// 828C0E24: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0E28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C0E2C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C0E30: 4BA34B19  bl 0x822f5948
	ctx.lr = 0x828C0E34;
	sub_822F5948(ctx, base);
	// 828C0E34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C0E38: 4B8F6CE1  bl 0x821b7b18
	ctx.lr = 0x828C0E3C;
	sub_821B7B18(ctx, base);
	// 828C0E3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0E40: 419A0040  beq cr6, 0x828c0e80
	if ctx.cr[6].eq {
	pc = 0x828C0E80; continue 'dispatch;
	}
	// 828C0E44: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C0E48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E4C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C0E50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C0E54: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0E58: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E5C: 4082FFE8  bne 0x828c0e44
	if !ctx.cr[0].eq {
	pc = 0x828C0E44; continue 'dispatch;
	}
	// 828C0E60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0E64: 409A001C  bne cr6, 0x828c0e80
	if !ctx.cr[6].eq {
	pc = 0x828C0E80; continue 'dispatch;
	}
	// 828C0E68: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0E6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C0E74: 4E800421  bctrl
	ctx.lr = 0x828C0E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C0E78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0E7C: 4B95AEBD  bl 0x8221bd38
	ctx.lr = 0x828C0E80;
	sub_8221BD38(ctx, base);
	// 828C0E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0E84: 4B8F6C95  bl 0x821b7b18
	ctx.lr = 0x828C0E88;
	sub_821B7B18(ctx, base);
	// 828C0E88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C0E8C: 483E85C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0E90 size=444
    let mut pc: u32 = 0x828C0E90;
    'dispatch: loop {
        match pc {
            0x828C0E90 => {
    //   block [0x828C0E90..0x828C104C)
	// 828C0E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0E94: 483E8569  bl 0x82ca93fc
	ctx.lr = 0x828C0E98;
	sub_82CA93D0(ctx, base);
	// 828C0E98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C0EA0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C0EA4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C0EA8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C0EAC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C0EB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0EB4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C0EB8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C0EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0EC0: 419A0008  beq cr6, 0x828c0ec8
	if ctx.cr[6].eq {
	pc = 0x828C0EC8; continue 'dispatch;
	}
	// 828C0EC4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0EC8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0ECC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C0ED0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0ED4: 4BB0D6ED  bl 0x823ce5c0
	ctx.lr = 0x828C0ED8;
	sub_823CE5C0(ctx, base);
	// 828C0ED8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C0EDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0EE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0EE4: 4BB0D22D  bl 0x823ce110
	ctx.lr = 0x828C0EE8;
	sub_823CE110(ctx, base);
	// 828C0EE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C0EEC: 4B8F6C2D  bl 0x821b7b18
	ctx.lr = 0x828C0EF0;
	sub_821B7B18(ctx, base);
	// 828C0EF0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C0EF4: 4B95E365  bl 0x8221f258
	ctx.lr = 0x828C0EF8;
	sub_8221F258(ctx, base);
	// 828C0EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0EFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0F00: 419A002C  beq cr6, 0x828c0f2c
	if ctx.cr[6].eq {
	pc = 0x828C0F2C; continue 'dispatch;
	}
	// 828C0F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C0F08: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C0F0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C0F10: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C0F14: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C0F18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0F1C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C0F20: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C0F24: 4B92F31D  bl 0x821f0240
	ctx.lr = 0x828C0F28;
	sub_821F0240(ctx, base);
	// 828C0F28: 48000008  b 0x828c0f30
	pc = 0x828C0F30; continue 'dispatch;
	// 828C0F2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C0F30: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C0F34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0F38: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C0F3C: 419A0018  beq cr6, 0x828c0f54
	if ctx.cr[6].eq {
	pc = 0x828C0F54; continue 'dispatch;
	}
	// 828C0F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0F44: 48143D7D  bl 0x82a04cc0
	ctx.lr = 0x828C0F48;
	sub_82A04CC0(ctx, base);
	// 828C0F48: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C0F4C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0F50: 4800000C  b 0x828c0f5c
	pc = 0x828C0F5C; continue 'dispatch;
	// 828C0F54: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C0F58: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C0F5C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0F60: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C0F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0F68: 419A0008  beq cr6, 0x828c0f70
	if ctx.cr[6].eq {
	pc = 0x828C0F70; continue 'dispatch;
	}
	// 828C0F6C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0F70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C0F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0F78: 419A0078  beq cr6, 0x828c0ff0
	if ctx.cr[6].eq {
	pc = 0x828C0FF0; continue 'dispatch;
	}
	// 828C0F7C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0F80: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0F84: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0F88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0F8C: 4B96817D  bl 0x82229108
	ctx.lr = 0x828C0F90;
	sub_82229108(ctx, base);
	// 828C0F90: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0F94: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0F98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0F9C: 3BCB1DA8  addi r30, r11, 0x1da8
	ctx.r[30].s64 = ctx.r[11].s64 + 7592;
	// 828C0FA0: 4B9668E1  bl 0x82227880
	ctx.lr = 0x828C0FA4;
	sub_82227880(ctx, base);
	// 828C0FA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C0FA8: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828C0FAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0FB0: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828C0FB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0FB8: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0FBC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0FC0: 4B8D9AC1  bl 0x8219aa80
	ctx.lr = 0x828C0FC4;
	sub_8219AA80(ctx, base);
	// 828C0FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0FC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C0FCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0FD0: 4BB0D451  bl 0x823ce420
	ctx.lr = 0x828C0FD4;
	sub_823CE420(ctx, base);
	// 828C0FD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0FD8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0FDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0FE0: 481636E9  bl 0x82a246c8
	ctx.lr = 0x828C0FE4;
	sub_82A246C8(ctx, base);
	// 828C0FE4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0FE8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C0FEC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C0FF0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C0FF4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0FF8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C0FFC: 419A0020  beq cr6, 0x828c101c
	if ctx.cr[6].eq {
	pc = 0x828C101C; continue 'dispatch;
	}
	// 828C1000: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1004: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1008: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C100C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1010: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C1014: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1018: 4082FFE8  bne 0x828c1000
	if !ctx.cr[0].eq {
	pc = 0x828C1000; continue 'dispatch;
	}
	// 828C101C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1020: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C1024: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C1028: 4BA34921  bl 0x822f5948
	ctx.lr = 0x828C102C;
	sub_822F5948(ctx, base);
	// 828C102C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1030: 4B8F6AE9  bl 0x821b7b18
	ctx.lr = 0x828C1034;
	sub_821B7B18(ctx, base);
	// 828C1034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C1038: 4B8F6AE1  bl 0x821b7b18
	ctx.lr = 0x828C103C;
	sub_821B7B18(ctx, base);
	// 828C103C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1040: 4B8F6AD9  bl 0x821b7b18
	ctx.lr = 0x828C1044;
	sub_821B7B18(ctx, base);
	// 828C1044: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1048: 483E8404  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1050 size=444
    let mut pc: u32 = 0x828C1050;
    'dispatch: loop {
        match pc {
            0x828C1050 => {
    //   block [0x828C1050..0x828C120C)
	// 828C1050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1054: 483E83A9  bl 0x82ca93fc
	ctx.lr = 0x828C1058;
	sub_82CA93D0(ctx, base);
	// 828C1058: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C105C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1060: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1064: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1068: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C106C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1070: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1074: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1078: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C107C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1080: 419A0008  beq cr6, 0x828c1088
	if ctx.cr[6].eq {
	pc = 0x828C1088; continue 'dispatch;
	}
	// 828C1084: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1088: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C108C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C1090: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1094: 4BB0D52D  bl 0x823ce5c0
	ctx.lr = 0x828C1098;
	sub_823CE5C0(ctx, base);
	// 828C1098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C109C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C10A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C10A4: 4BB0D06D  bl 0x823ce110
	ctx.lr = 0x828C10A8;
	sub_823CE110(ctx, base);
	// 828C10A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C10AC: 4B8F6A6D  bl 0x821b7b18
	ctx.lr = 0x828C10B0;
	sub_821B7B18(ctx, base);
	// 828C10B0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C10B4: 4B95E1A5  bl 0x8221f258
	ctx.lr = 0x828C10B8;
	sub_8221F258(ctx, base);
	// 828C10B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C10BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C10C0: 419A002C  beq cr6, 0x828c10ec
	if ctx.cr[6].eq {
	pc = 0x828C10EC; continue 'dispatch;
	}
	// 828C10C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C10C8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C10CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C10D0: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C10D4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C10D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C10DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C10E0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C10E4: 4B92F15D  bl 0x821f0240
	ctx.lr = 0x828C10E8;
	sub_821F0240(ctx, base);
	// 828C10E8: 48000008  b 0x828c10f0
	pc = 0x828C10F0; continue 'dispatch;
	// 828C10EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C10F0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C10F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C10F8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C10FC: 419A0018  beq cr6, 0x828c1114
	if ctx.cr[6].eq {
	pc = 0x828C1114; continue 'dispatch;
	}
	// 828C1100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C1104: 48143BBD  bl 0x82a04cc0
	ctx.lr = 0x828C1108;
	sub_82A04CC0(ctx, base);
	// 828C1108: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C110C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1110: 4800000C  b 0x828c111c
	pc = 0x828C111C; continue 'dispatch;
	// 828C1114: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C1118: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C111C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1120: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C1124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1128: 419A0008  beq cr6, 0x828c1130
	if ctx.cr[6].eq {
	pc = 0x828C1130; continue 'dispatch;
	}
	// 828C112C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1130: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C1134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1138: 419A0078  beq cr6, 0x828c11b0
	if ctx.cr[6].eq {
	pc = 0x828C11B0; continue 'dispatch;
	}
	// 828C113C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1140: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1144: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C114C: 4B967FBD  bl 0x82229108
	ctx.lr = 0x828C1150;
	sub_82229108(ctx, base);
	// 828C1150: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1154: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C115C: 3BCB1C18  addi r30, r11, 0x1c18
	ctx.r[30].s64 = ctx.r[11].s64 + 7192;
	// 828C1160: 4B966721  bl 0x82227880
	ctx.lr = 0x828C1164;
	sub_82227880(ctx, base);
	// 828C1164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1168: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828C116C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1170: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828C1174: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1178: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C117C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1180: 4B8D9901  bl 0x8219aa80
	ctx.lr = 0x828C1184;
	sub_8219AA80(ctx, base);
	// 828C1184: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1188: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C118C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1190: 4BB0D291  bl 0x823ce420
	ctx.lr = 0x828C1194;
	sub_823CE420(ctx, base);
	// 828C1194: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1198: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C119C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C11A0: 48163529  bl 0x82a246c8
	ctx.lr = 0x828C11A4;
	sub_82A246C8(ctx, base);
	// 828C11A4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C11A8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C11AC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C11B0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C11B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C11B8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C11BC: 419A0020  beq cr6, 0x828c11dc
	if ctx.cr[6].eq {
	pc = 0x828C11DC; continue 'dispatch;
	}
	// 828C11C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C11C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C11C8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C11CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C11D0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C11D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C11D8: 4082FFE8  bne 0x828c11c0
	if !ctx.cr[0].eq {
	pc = 0x828C11C0; continue 'dispatch;
	}
	// 828C11DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C11E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C11E4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C11E8: 4BA34761  bl 0x822f5948
	ctx.lr = 0x828C11EC;
	sub_822F5948(ctx, base);
	// 828C11EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C11F0: 4B8F6929  bl 0x821b7b18
	ctx.lr = 0x828C11F4;
	sub_821B7B18(ctx, base);
	// 828C11F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C11F8: 4B8F6921  bl 0x821b7b18
	ctx.lr = 0x828C11FC;
	sub_821B7B18(ctx, base);
	// 828C11FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1200: 4B8F6919  bl 0x821b7b18
	ctx.lr = 0x828C1204;
	sub_821B7B18(ctx, base);
	// 828C1204: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1208: 483E8244  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1210 size=512
    let mut pc: u32 = 0x828C1210;
    'dispatch: loop {
        match pc {
            0x828C1210 => {
    //   block [0x828C1210..0x828C1410)
	// 828C1210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1214: 483E81E9  bl 0x82ca93fc
	ctx.lr = 0x828C1218;
	sub_82CA93D0(ctx, base);
	// 828C1218: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C121C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1220: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1224: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1228: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C122C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1230: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1234: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1238: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C123C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1240: 419A0008  beq cr6, 0x828c1248
	if ctx.cr[6].eq {
	pc = 0x828C1248; continue 'dispatch;
	}
	// 828C1244: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1248: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C124C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1250: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1254: 4BB0D36D  bl 0x823ce5c0
	ctx.lr = 0x828C1258;
	sub_823CE5C0(ctx, base);
	// 828C1258: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C125C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1260: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1264: 4BB0CEAD  bl 0x823ce110
	ctx.lr = 0x828C1268;
	sub_823CE110(ctx, base);
	// 828C1268: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C126C: 4B8F68AD  bl 0x821b7b18
	ctx.lr = 0x828C1270;
	sub_821B7B18(ctx, base);
	// 828C1270: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1274: 4B95DFE5  bl 0x8221f258
	ctx.lr = 0x828C1278;
	sub_8221F258(ctx, base);
	// 828C1278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C127C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1280: 419A005C  beq cr6, 0x828c12dc
	if ctx.cr[6].eq {
	pc = 0x828C12DC; continue 'dispatch;
	}
	// 828C1284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1288: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C128C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1290: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1294: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C129C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C12A0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C12A4: 4B92EF9D  bl 0x821f0240
	ctx.lr = 0x828C12A8;
	sub_821F0240(ctx, base);
	// 828C12A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C12AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C12B0: 4B95DFA9  bl 0x8221f258
	ctx.lr = 0x828C12B4;
	sub_8221F258(ctx, base);
	// 828C12B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C12B8: 419A0028  beq cr6, 0x828c12e0
	if ctx.cr[6].eq {
	pc = 0x828C12E0; continue 'dispatch;
	}
	// 828C12BC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C12C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C12C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C12C8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C12CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C12D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C12D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C12D8: 4800000C  b 0x828c12e4
	pc = 0x828C12E4; continue 'dispatch;
	// 828C12DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C12E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C12E4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C12E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C12EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C12F0: 419A0008  beq cr6, 0x828c12f8
	if ctx.cr[6].eq {
	pc = 0x828C12F8; continue 'dispatch;
	}
	// 828C12F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C12F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C12FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1300: 419A0078  beq cr6, 0x828c1378
	if ctx.cr[6].eq {
	pc = 0x828C1378; continue 'dispatch;
	}
	// 828C1304: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1308: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C130C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1310: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1314: 4B967DF5  bl 0x82229108
	ctx.lr = 0x828C1318;
	sub_82229108(ctx, base);
	// 828C1318: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C131C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1320: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1324: 3BCB1F38  addi r30, r11, 0x1f38
	ctx.r[30].s64 = ctx.r[11].s64 + 7992;
	// 828C1328: 4B966559  bl 0x82227880
	ctx.lr = 0x828C132C;
	sub_82227880(ctx, base);
	// 828C132C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1330: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828C1334: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1338: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828C133C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1340: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1344: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1348: 4B8D9739  bl 0x8219aa80
	ctx.lr = 0x828C134C;
	sub_8219AA80(ctx, base);
	// 828C134C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1350: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1354: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1358: 4BB0D0C9  bl 0x823ce420
	ctx.lr = 0x828C135C;
	sub_823CE420(ctx, base);
	// 828C135C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1360: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1364: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1368: 48163361  bl 0x82a246c8
	ctx.lr = 0x828C136C;
	sub_82A246C8(ctx, base);
	// 828C136C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1370: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1374: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1378: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C137C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1380: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1384: 419A0020  beq cr6, 0x828c13a4
	if ctx.cr[6].eq {
	pc = 0x828C13A4; continue 'dispatch;
	}
	// 828C1388: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C138C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1390: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1394: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1398: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C139C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13A0: 4082FFE8  bne 0x828c1388
	if !ctx.cr[0].eq {
	pc = 0x828C1388; continue 'dispatch;
	}
	// 828C13A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C13A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C13AC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C13B0: 4BA34599  bl 0x822f5948
	ctx.lr = 0x828C13B4;
	sub_822F5948(ctx, base);
	// 828C13B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C13B8: 4B8F6761  bl 0x821b7b18
	ctx.lr = 0x828C13BC;
	sub_821B7B18(ctx, base);
	// 828C13BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C13C0: 419A0040  beq cr6, 0x828c1400
	if ctx.cr[6].eq {
	pc = 0x828C1400; continue 'dispatch;
	}
	// 828C13C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C13C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13CC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C13D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C13D4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C13D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13DC: 4082FFE8  bne 0x828c13c4
	if !ctx.cr[0].eq {
	pc = 0x828C13C4; continue 'dispatch;
	}
	// 828C13E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C13E4: 409A001C  bne cr6, 0x828c1400
	if !ctx.cr[6].eq {
	pc = 0x828C1400; continue 'dispatch;
	}
	// 828C13E8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C13EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C13F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C13F4: 4E800421  bctrl
	ctx.lr = 0x828C13F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C13F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C13FC: 4B95A93D  bl 0x8221bd38
	ctx.lr = 0x828C1400;
	sub_8221BD38(ctx, base);
	// 828C1400: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1404: 4B8F6715  bl 0x821b7b18
	ctx.lr = 0x828C1408;
	sub_821B7B18(ctx, base);
	// 828C1408: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C140C: 483E8040  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1410 size=512
    let mut pc: u32 = 0x828C1410;
    'dispatch: loop {
        match pc {
            0x828C1410 => {
    //   block [0x828C1410..0x828C1610)
	// 828C1410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1414: 483E7FE9  bl 0x82ca93fc
	ctx.lr = 0x828C1418;
	sub_82CA93D0(ctx, base);
	// 828C1418: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C141C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1420: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1424: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1428: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C142C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1430: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1434: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1438: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C143C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1440: 419A0008  beq cr6, 0x828c1448
	if ctx.cr[6].eq {
	pc = 0x828C1448; continue 'dispatch;
	}
	// 828C1444: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1448: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C144C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1450: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1454: 4BB0D16D  bl 0x823ce5c0
	ctx.lr = 0x828C1458;
	sub_823CE5C0(ctx, base);
	// 828C1458: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C145C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1460: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1464: 4BB0CCAD  bl 0x823ce110
	ctx.lr = 0x828C1468;
	sub_823CE110(ctx, base);
	// 828C1468: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C146C: 4B8F66AD  bl 0x821b7b18
	ctx.lr = 0x828C1470;
	sub_821B7B18(ctx, base);
	// 828C1470: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1474: 4B95DDE5  bl 0x8221f258
	ctx.lr = 0x828C1478;
	sub_8221F258(ctx, base);
	// 828C1478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C147C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1480: 419A005C  beq cr6, 0x828c14dc
	if ctx.cr[6].eq {
	pc = 0x828C14DC; continue 'dispatch;
	}
	// 828C1484: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1488: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C148C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1490: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1494: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C1498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C149C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C14A0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C14A4: 4B92ED9D  bl 0x821f0240
	ctx.lr = 0x828C14A8;
	sub_821F0240(ctx, base);
	// 828C14A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C14AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C14B0: 4B95DDA9  bl 0x8221f258
	ctx.lr = 0x828C14B4;
	sub_8221F258(ctx, base);
	// 828C14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C14B8: 419A0028  beq cr6, 0x828c14e0
	if ctx.cr[6].eq {
	pc = 0x828C14E0; continue 'dispatch;
	}
	// 828C14BC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C14C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C14C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C14C8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C14CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C14D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C14D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C14D8: 4800000C  b 0x828c14e4
	pc = 0x828C14E4; continue 'dispatch;
	// 828C14DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C14E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C14E4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C14E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C14EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C14F0: 419A0008  beq cr6, 0x828c14f8
	if ctx.cr[6].eq {
	pc = 0x828C14F8; continue 'dispatch;
	}
	// 828C14F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C14F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C14FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1500: 419A0078  beq cr6, 0x828c1578
	if ctx.cr[6].eq {
	pc = 0x828C1578; continue 'dispatch;
	}
	// 828C1504: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1508: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C150C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1510: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1514: 4B967BF5  bl 0x82229108
	ctx.lr = 0x828C1518;
	sub_82229108(ctx, base);
	// 828C1518: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C151C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1520: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1524: 3BCB20B8  addi r30, r11, 0x20b8
	ctx.r[30].s64 = ctx.r[11].s64 + 8376;
	// 828C1528: 4B966359  bl 0x82227880
	ctx.lr = 0x828C152C;
	sub_82227880(ctx, base);
	// 828C152C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1530: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828C1534: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1538: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828C153C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1540: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1544: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1548: 4B8D9539  bl 0x8219aa80
	ctx.lr = 0x828C154C;
	sub_8219AA80(ctx, base);
	// 828C154C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1550: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1554: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1558: 4BB0CEC9  bl 0x823ce420
	ctx.lr = 0x828C155C;
	sub_823CE420(ctx, base);
	// 828C155C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1560: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1564: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1568: 48163161  bl 0x82a246c8
	ctx.lr = 0x828C156C;
	sub_82A246C8(ctx, base);
	// 828C156C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1570: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1574: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1578: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C157C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1580: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1584: 419A0020  beq cr6, 0x828c15a4
	if ctx.cr[6].eq {
	pc = 0x828C15A4; continue 'dispatch;
	}
	// 828C1588: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C158C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1590: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1594: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1598: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C159C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15A0: 4082FFE8  bne 0x828c1588
	if !ctx.cr[0].eq {
	pc = 0x828C1588; continue 'dispatch;
	}
	// 828C15A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C15A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C15AC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C15B0: 4BA34399  bl 0x822f5948
	ctx.lr = 0x828C15B4;
	sub_822F5948(ctx, base);
	// 828C15B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C15B8: 4B8F6561  bl 0x821b7b18
	ctx.lr = 0x828C15BC;
	sub_821B7B18(ctx, base);
	// 828C15BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C15C0: 419A0040  beq cr6, 0x828c1600
	if ctx.cr[6].eq {
	pc = 0x828C1600; continue 'dispatch;
	}
	// 828C15C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C15C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15CC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C15D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C15D4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C15D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15DC: 4082FFE8  bne 0x828c15c4
	if !ctx.cr[0].eq {
	pc = 0x828C15C4; continue 'dispatch;
	}
	// 828C15E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C15E4: 409A001C  bne cr6, 0x828c1600
	if !ctx.cr[6].eq {
	pc = 0x828C1600; continue 'dispatch;
	}
	// 828C15E8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C15EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C15F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C15F4: 4E800421  bctrl
	ctx.lr = 0x828C15F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C15F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C15FC: 4B95A73D  bl 0x8221bd38
	ctx.lr = 0x828C1600;
	sub_8221BD38(ctx, base);
	// 828C1600: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1604: 4B8F6515  bl 0x821b7b18
	ctx.lr = 0x828C1608;
	sub_821B7B18(ctx, base);
	// 828C1608: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C160C: 483E7E40  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1610 size=516
    let mut pc: u32 = 0x828C1610;
    'dispatch: loop {
        match pc {
            0x828C1610 => {
    //   block [0x828C1610..0x828C1814)
	// 828C1610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1614: 483E7DE9  bl 0x82ca93fc
	ctx.lr = 0x828C1618;
	sub_82CA93D0(ctx, base);
	// 828C1618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C161C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1620: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C1624: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C1628: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C162C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1630: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1634: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1638: 3BAAF530  addi r29, r10, -0xad0
	ctx.r[29].s64 = ctx.r[10].s64 + -2768;
	// 828C163C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1640: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C1644: 419A0008  beq cr6, 0x828c164c
	if ctx.cr[6].eq {
	pc = 0x828C164C; continue 'dispatch;
	}
	// 828C1648: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C164C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1650: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1654: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1658: 4BB0CF69  bl 0x823ce5c0
	ctx.lr = 0x828C165C;
	sub_823CE5C0(ctx, base);
	// 828C165C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C1660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1664: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1668: 4BB0CAA9  bl 0x823ce110
	ctx.lr = 0x828C166C;
	sub_823CE110(ctx, base);
	// 828C166C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1670: 4B8F64A9  bl 0x821b7b18
	ctx.lr = 0x828C1674;
	sub_821B7B18(ctx, base);
	// 828C1674: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1678: 4B95DBE1  bl 0x8221f258
	ctx.lr = 0x828C167C;
	sub_8221F258(ctx, base);
	// 828C167C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1680: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1684: 419A005C  beq cr6, 0x828c16e0
	if ctx.cr[6].eq {
	pc = 0x828C16E0; continue 'dispatch;
	}
	// 828C1688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C168C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C1690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1694: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1698: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C169C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C16A0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C16A4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C16A8: 4B92EB99  bl 0x821f0240
	ctx.lr = 0x828C16AC;
	sub_821F0240(ctx, base);
	// 828C16AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C16B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C16B4: 4B95DBA5  bl 0x8221f258
	ctx.lr = 0x828C16B8;
	sub_8221F258(ctx, base);
	// 828C16B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C16BC: 419A0028  beq cr6, 0x828c16e4
	if ctx.cr[6].eq {
	pc = 0x828C16E4; continue 'dispatch;
	}
	// 828C16C0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C16C4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C16C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C16CC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C16D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C16D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C16D8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C16DC: 4800000C  b 0x828c16e8
	pc = 0x828C16E8; continue 'dispatch;
	// 828C16E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C16E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C16E8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C16EC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C16F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C16F4: 419A0008  beq cr6, 0x828c16fc
	if ctx.cr[6].eq {
	pc = 0x828C16FC; continue 'dispatch;
	}
	// 828C16F8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C16FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C1700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1704: 419A0078  beq cr6, 0x828c177c
	if ctx.cr[6].eq {
	pc = 0x828C177C; continue 'dispatch;
	}
	// 828C1708: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C170C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1710: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1718: 4B9679F1  bl 0x82229108
	ctx.lr = 0x828C171C;
	sub_82229108(ctx, base);
	// 828C171C: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1720: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1724: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1728: 3BCB2230  addi r30, r11, 0x2230
	ctx.r[30].s64 = ctx.r[11].s64 + 8752;
	// 828C172C: 4B966155  bl 0x82227880
	ctx.lr = 0x828C1730;
	sub_82227880(ctx, base);
	// 828C1730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1734: 3D408296  lis r10, -0x7d6a
	ctx.r[10].s64 = -2104098816;
	// 828C1738: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C173C: 388A7468  addi r4, r10, 0x7468
	ctx.r[4].s64 = ctx.r[10].s64 + 29800;
	// 828C1740: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1744: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1748: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C174C: 4B8D9335  bl 0x8219aa80
	ctx.lr = 0x828C1750;
	sub_8219AA80(ctx, base);
	// 828C1750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1754: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1758: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C175C: 4BB0CCC5  bl 0x823ce420
	ctx.lr = 0x828C1760;
	sub_823CE420(ctx, base);
	// 828C1760: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1764: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1768: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C176C: 48162F5D  bl 0x82a246c8
	ctx.lr = 0x828C1770;
	sub_82A246C8(ctx, base);
	// 828C1770: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1774: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1778: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C177C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C1780: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1784: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1788: 419A0020  beq cr6, 0x828c17a8
	if ctx.cr[6].eq {
	pc = 0x828C17A8; continue 'dispatch;
	}
	// 828C178C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1794: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1798: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C179C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C17A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17A4: 4082FFE8  bne 0x828c178c
	if !ctx.cr[0].eq {
	pc = 0x828C178C; continue 'dispatch;
	}
	// 828C17A8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C17AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C17B0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C17B4: 4BA34195  bl 0x822f5948
	ctx.lr = 0x828C17B8;
	sub_822F5948(ctx, base);
	// 828C17B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C17BC: 4B8F635D  bl 0x821b7b18
	ctx.lr = 0x828C17C0;
	sub_821B7B18(ctx, base);
	// 828C17C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C17C4: 419A0040  beq cr6, 0x828c1804
	if ctx.cr[6].eq {
	pc = 0x828C1804; continue 'dispatch;
	}
	// 828C17C8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C17CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17D0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C17D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C17D8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C17DC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17E0: 4082FFE8  bne 0x828c17c8
	if !ctx.cr[0].eq {
	pc = 0x828C17C8; continue 'dispatch;
	}
	// 828C17E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C17E8: 409A001C  bne cr6, 0x828c1804
	if !ctx.cr[6].eq {
	pc = 0x828C1804; continue 'dispatch;
	}
	// 828C17EC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C17F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C17F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C17F8: 4E800421  bctrl
	ctx.lr = 0x828C17FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C17FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C1800: 4B95A539  bl 0x8221bd38
	ctx.lr = 0x828C1804;
	sub_8221BD38(ctx, base);
	// 828C1804: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1808: 4B8F6311  bl 0x821b7b18
	ctx.lr = 0x828C180C;
	sub_821B7B18(ctx, base);
	// 828C180C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1810: 483E7C3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1818 size=516
    let mut pc: u32 = 0x828C1818;
    'dispatch: loop {
        match pc {
            0x828C1818 => {
    //   block [0x828C1818..0x828C1A1C)
	// 828C1818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C181C: 483E7BE1  bl 0x82ca93fc
	ctx.lr = 0x828C1820;
	sub_82CA93D0(ctx, base);
	// 828C1820: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1828: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C182C: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C1830: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C1834: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1838: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C183C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1840: 3BAAF958  addi r29, r10, -0x6a8
	ctx.r[29].s64 = ctx.r[10].s64 + -1704;
	// 828C1844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1848: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C184C: 419A0008  beq cr6, 0x828c1854
	if ctx.cr[6].eq {
	pc = 0x828C1854; continue 'dispatch;
	}
	// 828C1850: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1854: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1858: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C185C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1860: 4BB0CD61  bl 0x823ce5c0
	ctx.lr = 0x828C1864;
	sub_823CE5C0(ctx, base);
	// 828C1864: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C1868: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C186C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1870: 4BB0C8A1  bl 0x823ce110
	ctx.lr = 0x828C1874;
	sub_823CE110(ctx, base);
	// 828C1874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1878: 4B8F62A1  bl 0x821b7b18
	ctx.lr = 0x828C187C;
	sub_821B7B18(ctx, base);
	// 828C187C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1880: 4B95D9D9  bl 0x8221f258
	ctx.lr = 0x828C1884;
	sub_8221F258(ctx, base);
	// 828C1884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1888: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C188C: 419A005C  beq cr6, 0x828c18e8
	if ctx.cr[6].eq {
	pc = 0x828C18E8; continue 'dispatch;
	}
	// 828C1890: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1894: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C1898: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C189C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C18A0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C18A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C18A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C18AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C18B0: 4B92E991  bl 0x821f0240
	ctx.lr = 0x828C18B4;
	sub_821F0240(ctx, base);
	// 828C18B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C18B8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C18BC: 4B95D99D  bl 0x8221f258
	ctx.lr = 0x828C18C0;
	sub_8221F258(ctx, base);
	// 828C18C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C18C4: 419A0028  beq cr6, 0x828c18ec
	if ctx.cr[6].eq {
	pc = 0x828C18EC; continue 'dispatch;
	}
	// 828C18C8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C18CC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C18D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C18D4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C18D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C18DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C18E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C18E4: 4800000C  b 0x828c18f0
	pc = 0x828C18F0; continue 'dispatch;
	// 828C18E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C18EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C18F0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C18F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C18F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C18FC: 419A0008  beq cr6, 0x828c1904
	if ctx.cr[6].eq {
	pc = 0x828C1904; continue 'dispatch;
	}
	// 828C1900: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1904: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C1908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C190C: 419A0078  beq cr6, 0x828c1984
	if ctx.cr[6].eq {
	pc = 0x828C1984; continue 'dispatch;
	}
	// 828C1910: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1914: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1918: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C191C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1920: 4B9677E9  bl 0x82229108
	ctx.lr = 0x828C1924;
	sub_82229108(ctx, base);
	// 828C1924: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1928: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C192C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1930: 3BCB23F8  addi r30, r11, 0x23f8
	ctx.r[30].s64 = ctx.r[11].s64 + 9208;
	// 828C1934: 4B965F4D  bl 0x82227880
	ctx.lr = 0x828C1938;
	sub_82227880(ctx, base);
	// 828C1938: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C193C: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828C1940: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1944: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828C1948: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C194C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1950: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1954: 4B8D912D  bl 0x8219aa80
	ctx.lr = 0x828C1958;
	sub_8219AA80(ctx, base);
	// 828C1958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C195C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1960: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1964: 4BB0CABD  bl 0x823ce420
	ctx.lr = 0x828C1968;
	sub_823CE420(ctx, base);
	// 828C1968: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C196C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1970: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1974: 48162D55  bl 0x82a246c8
	ctx.lr = 0x828C1978;
	sub_82A246C8(ctx, base);
	// 828C1978: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C197C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1980: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1984: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C1988: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C198C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1990: 419A0020  beq cr6, 0x828c19b0
	if ctx.cr[6].eq {
	pc = 0x828C19B0; continue 'dispatch;
	}
	// 828C1994: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1998: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C199C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C19A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C19A4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C19A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19AC: 4082FFE8  bne 0x828c1994
	if !ctx.cr[0].eq {
	pc = 0x828C1994; continue 'dispatch;
	}
	// 828C19B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C19B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C19B8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C19BC: 4BA33F8D  bl 0x822f5948
	ctx.lr = 0x828C19C0;
	sub_822F5948(ctx, base);
	// 828C19C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C19C4: 4B8F6155  bl 0x821b7b18
	ctx.lr = 0x828C19C8;
	sub_821B7B18(ctx, base);
	// 828C19C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C19CC: 419A0040  beq cr6, 0x828c1a0c
	if ctx.cr[6].eq {
	pc = 0x828C1A0C; continue 'dispatch;
	}
	// 828C19D0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C19D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19D8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C19DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C19E0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C19E4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19E8: 4082FFE8  bne 0x828c19d0
	if !ctx.cr[0].eq {
	pc = 0x828C19D0; continue 'dispatch;
	}
	// 828C19EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C19F0: 409A001C  bne cr6, 0x828c1a0c
	if !ctx.cr[6].eq {
	pc = 0x828C1A0C; continue 'dispatch;
	}
	// 828C19F4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C19F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C19FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1A00: 4E800421  bctrl
	ctx.lr = 0x828C1A04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1A04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C1A08: 4B95A331  bl 0x8221bd38
	ctx.lr = 0x828C1A0C;
	sub_8221BD38(ctx, base);
	// 828C1A0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1A10: 4B8F6109  bl 0x821b7b18
	ctx.lr = 0x828C1A14;
	sub_821B7B18(ctx, base);
	// 828C1A14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1A18: 483E7A34  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1A20 size=220
    let mut pc: u32 = 0x828C1A20;
    'dispatch: loop {
        match pc {
            0x828C1A20 => {
    //   block [0x828C1A20..0x828C1AFC)
	// 828C1A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1A24: 483E79E9  bl 0x82ca940c
	ctx.lr = 0x828C1A28;
	sub_82CA93D0(ctx, base);
	// 828C1A28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1A2C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1A30: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A34: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 828C1A38: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1A40: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A44: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A48: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A4C: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C1A50: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A54: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C1A58: 7D2B00D0  neg r9, r11
	ctx.r[9].s64 = -ctx.r[11].s64;
	// 828C1A5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1A60: 409A0008  bne cr6, 0x828c1a68
	if !ctx.cr[6].eq {
	pc = 0x828C1A68; continue 'dispatch;
	}
	// 828C1A64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C1A68: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C1A6C: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 828C1A70: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C1A74: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828C1A78: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1A7C: 4199000C  bgt cr6, 0x828c1a88
	if ctx.cr[6].gt {
	pc = 0x828C1A88; continue 'dispatch;
	}
	// 828C1A80: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C1A84: 40980008  bge cr6, 0x828c1a8c
	if !ctx.cr[6].lt {
	pc = 0x828C1A8C; continue 'dispatch;
	}
	// 828C1A88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C1A8C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828C1A90: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 828C1A94: 3BA10051  addi r29, r1, 0x51
	ctx.r[29].s64 = ctx.r[1].s64 + 81;
	// 828C1A98: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828C1A9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1AA0: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 828C1AA4: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 828C1AA8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828C1AAC: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C1AB0: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C1AB4: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1AB8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1ABC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1AC0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828C1AC4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1AC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C1ACC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C1AD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C1AD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C1AD8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C1ADC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C1AE0: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1AE4: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1AE8: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1AEC: 48000EED  bl 0x828c29d8
	ctx.lr = 0x828C1AF0;
	sub_828C29D8(ctx, base);
	// 828C1AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C1AF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C1AF8: 483E7964  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1B00 size=212
    let mut pc: u32 = 0x828C1B00;
    'dispatch: loop {
        match pc {
            0x828C1B00 => {
    //   block [0x828C1B00..0x828C1BD4)
	// 828C1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1B04: 483E7909  bl 0x82ca940c
	ctx.lr = 0x828C1B08;
	sub_82CA93D0(ctx, base);
	// 828C1B08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1B0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1B10: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B14: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1B1C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B20: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B24: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B28: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B2C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C1B30: 7D274050  subf r9, r7, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C1B34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1B38: 409A0008  bne cr6, 0x828c1b40
	if !ctx.cr[6].eq {
	pc = 0x828C1B40; continue 'dispatch;
	}
	// 828C1B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C1B40: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C1B44: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 828C1B48: 80AA0010  lwz r5, 0x10(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C1B4C: 7CA55A14  add r5, r5, r11
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 828C1B50: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C1B54: 4199000C  bgt cr6, 0x828c1b60
	if ctx.cr[6].gt {
	pc = 0x828C1B60; continue 'dispatch;
	}
	// 828C1B58: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C1B5C: 40980008  bge cr6, 0x828c1b64
	if !ctx.cr[6].lt {
	pc = 0x828C1B64; continue 'dispatch;
	}
	// 828C1B60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C1B64: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828C1B68: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 828C1B6C: 3BA10051  addi r29, r1, 0x51
	ctx.r[29].s64 = ctx.r[1].s64 + 81;
	// 828C1B70: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828C1B74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1B78: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 828C1B7C: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 828C1B80: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828C1B84: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C1B88: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C1B8C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1B90: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1B94: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1B98: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828C1B9C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1BA0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C1BA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C1BA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C1BAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C1BB0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C1BB4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C1BB8: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1BBC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1BC0: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1BC4: 48000F55  bl 0x828c2b18
	ctx.lr = 0x828C1BC8;
	sub_828C2B18(ctx, base);
	// 828C1BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C1BCC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C1BD0: 483E788C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C1BD8 size=56
    let mut pc: u32 = 0x828C1BD8;
    'dispatch: loop {
        match pc {
            0x828C1BD8 => {
    //   block [0x828C1BD8..0x828C1C10)
	// 828C1BD8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C1BDC: 419A0018  beq cr6, 0x828c1bf4
	if ctx.cr[6].eq {
	pc = 0x828C1BF4; continue 'dispatch;
	}
	// 828C1BE0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1BE4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1BE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1BEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1BF0: 409A0008  bne cr6, 0x828c1bf8
	if !ctx.cr[6].eq {
	pc = 0x828C1BF8; continue 'dispatch;
	}
	// 828C1BF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1BF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1C00: 419A0010  beq cr6, 0x828c1c10
	if ctx.cr[6].eq {
		sub_828C1C10(ctx, base);
		return;
	}
	// 828C1C04: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1C08: 55631FFE  rlwinm r3, r11, 3, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C1C10 size=8
    let mut pc: u32 = 0x828C1C10;
    'dispatch: loop {
        match pc {
            0x828C1C10 => {
    //   block [0x828C1C10..0x828C1C18)
	// 828C1C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1C18 size=396
    let mut pc: u32 = 0x828C1C18;
    'dispatch: loop {
        match pc {
            0x828C1C18 => {
    //   block [0x828C1C18..0x828C1DA4)
	// 828C1C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1C20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1C24: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1C2C: 419A0018  beq cr6, 0x828c1c44
	if ctx.cr[6].eq {
	pc = 0x828C1C44; continue 'dispatch;
	}
	// 828C1C30: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1C34: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1C38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1C3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1C40: 409A0008  bne cr6, 0x828c1c48
	if !ctx.cr[6].eq {
	pc = 0x828C1C48; continue 'dispatch;
	}
	// 828C1C44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1C48: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C1C4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1C50: 419A0140  beq cr6, 0x828c1d90
	if ctx.cr[6].eq {
	pc = 0x828C1D90; continue 'dispatch;
	}
	// 828C1C54: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1C58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1C5C: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1C60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C1C64: 419A00F8  beq cr6, 0x828c1d5c
	if ctx.cr[6].eq {
	pc = 0x828C1D5C; continue 'dispatch;
	}
	// 828C1C68: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1C6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1C70: 419A0024  beq cr6, 0x828c1c94
	if ctx.cr[6].eq {
	pc = 0x828C1C94; continue 'dispatch;
	}
	// 828C1C74: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1C78: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1C7C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C1C80: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C1C84: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1C88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1C8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1C90: 480000D0  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
	// 828C1C94: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1C98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C1C9C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1CA0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C1CA4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1CA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1CAC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1CB0: 40810054  ble 0x828c1d04
	if !ctx.cr[0].gt {
	pc = 0x828C1D04; continue 'dispatch;
	}
	// 828C1CB4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1CB8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1CBC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1CC0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1CC4: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1CC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1CCC: 41980008  blt cr6, 0x828c1cd4
	if ctx.cr[6].lt {
	pc = 0x828C1CD4; continue 'dispatch;
	}
	// 828C1CD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C1CD4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1CD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1CDC: 419A0014  beq cr6, 0x828c1cf0
	if ctx.cr[6].eq {
	pc = 0x828C1CF0; continue 'dispatch;
	}
	// 828C1CE0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1CE4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C1CE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C1CEC: 4800000C  b 0x828c1cf8
	pc = 0x828C1CF8; continue 'dispatch;
	// 828C1CF0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C1CF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C1CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1CFC: 4199FFB8  bgt cr6, 0x828c1cb4
	if ctx.cr[6].gt {
	pc = 0x828C1CB4; continue 'dispatch;
	}
	// 828C1D00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1D04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1D08: 419A0040  beq cr6, 0x828c1d48
	if ctx.cr[6].eq {
	pc = 0x828C1D48; continue 'dispatch;
	}
	// 828C1D0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1D10: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C1D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D18: 41990008  bgt cr6, 0x828c1d20
	if ctx.cr[6].gt {
	pc = 0x828C1D20; continue 'dispatch;
	}
	// 828C1D1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1D28: 409A0020  bne cr6, 0x828c1d48
	if !ctx.cr[6].eq {
	pc = 0x828C1D48; continue 'dispatch;
	}
	// 828C1D2C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C1D30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C1D34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C1D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D3C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D44: 4800001C  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
	// 828C1D48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C1D4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D58: 48000008  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
	// 828C1D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1D68: 419A0028  beq cr6, 0x828c1d90
	if ctx.cr[6].eq {
	pc = 0x828C1D90; continue 'dispatch;
	}
	// 828C1D6C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D70: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C1D74: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C1D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1D7C: 4E800421  bctrl
	ctx.lr = 0x828C1D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1D80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1D84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1D88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1D8C: 4E800020  blr
	return;
	// 828C1D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1D94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1D98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1D9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1DA8 size=396
    let mut pc: u32 = 0x828C1DA8;
    'dispatch: loop {
        match pc {
            0x828C1DA8 => {
    //   block [0x828C1DA8..0x828C1F34)
	// 828C1DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1DB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1DB4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1DBC: 419A0018  beq cr6, 0x828c1dd4
	if ctx.cr[6].eq {
	pc = 0x828C1DD4; continue 'dispatch;
	}
	// 828C1DC0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1DC4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1DC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1DCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1DD0: 409A0008  bne cr6, 0x828c1dd8
	if !ctx.cr[6].eq {
	pc = 0x828C1DD8; continue 'dispatch;
	}
	// 828C1DD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1DD8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C1DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1DE0: 419A0140  beq cr6, 0x828c1f20
	if ctx.cr[6].eq {
	pc = 0x828C1F20; continue 'dispatch;
	}
	// 828C1DE4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1DE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1DEC: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1DF0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C1DF4: 419A00F8  beq cr6, 0x828c1eec
	if ctx.cr[6].eq {
	pc = 0x828C1EEC; continue 'dispatch;
	}
	// 828C1DF8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1DFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1E00: 419A0024  beq cr6, 0x828c1e24
	if ctx.cr[6].eq {
	pc = 0x828C1E24; continue 'dispatch;
	}
	// 828C1E04: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1E08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1E0C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C1E10: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C1E14: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1E18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1E1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1E20: 480000D0  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
	// 828C1E24: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1E28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C1E2C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1E30: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C1E34: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1E38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1E3C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1E40: 40810054  ble 0x828c1e94
	if !ctx.cr[0].gt {
	pc = 0x828C1E94; continue 'dispatch;
	}
	// 828C1E44: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1E48: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1E4C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1E50: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1E54: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1E58: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1E5C: 41980008  blt cr6, 0x828c1e64
	if ctx.cr[6].lt {
	pc = 0x828C1E64; continue 'dispatch;
	}
	// 828C1E60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C1E64: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1E68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1E6C: 419A0014  beq cr6, 0x828c1e80
	if ctx.cr[6].eq {
	pc = 0x828C1E80; continue 'dispatch;
	}
	// 828C1E70: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1E74: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C1E78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C1E7C: 4800000C  b 0x828c1e88
	pc = 0x828C1E88; continue 'dispatch;
	// 828C1E80: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C1E84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C1E88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1E8C: 4199FFB8  bgt cr6, 0x828c1e44
	if ctx.cr[6].gt {
	pc = 0x828C1E44; continue 'dispatch;
	}
	// 828C1E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1E94: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1E98: 419A0040  beq cr6, 0x828c1ed8
	if ctx.cr[6].eq {
	pc = 0x828C1ED8; continue 'dispatch;
	}
	// 828C1E9C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1EA0: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C1EA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1EA8: 41990008  bgt cr6, 0x828c1eb0
	if ctx.cr[6].gt {
	pc = 0x828C1EB0; continue 'dispatch;
	}
	// 828C1EAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1EB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1EB8: 409A0020  bne cr6, 0x828c1ed8
	if !ctx.cr[6].eq {
	pc = 0x828C1ED8; continue 'dispatch;
	}
	// 828C1EBC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C1EC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C1EC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C1EC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1ECC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1ED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1ED4: 4800001C  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
	// 828C1ED8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C1EDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1EE0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1EE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1EE8: 48000008  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
	// 828C1EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1EF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1EF8: 419A0028  beq cr6, 0x828c1f20
	if ctx.cr[6].eq {
	pc = 0x828C1F20; continue 'dispatch;
	}
	// 828C1EFC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1F00: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C1F04: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C1F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1F0C: 4E800421  bctrl
	ctx.lr = 0x828C1F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1F10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1F14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1F18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1F1C: 4E800020  blr
	return;
	// 828C1F20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C1F38 size=380
    let mut pc: u32 = 0x828C1F38;
    'dispatch: loop {
        match pc {
            0x828C1F38 => {
    //   block [0x828C1F38..0x828C20B4)
	// 828C1F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1F44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C1F48: 419A0018  beq cr6, 0x828c1f60
	if ctx.cr[6].eq {
	pc = 0x828C1F60; continue 'dispatch;
	}
	// 828C1F4C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1F50: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1F54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1F58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1F5C: 409A0008  bne cr6, 0x828c1f64
	if !ctx.cr[6].eq {
	pc = 0x828C1F64; continue 'dispatch;
	}
	// 828C1F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1F64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1F6C: 419A0130  beq cr6, 0x828c209c
	if ctx.cr[6].eq {
	pc = 0x828C209C; continue 'dispatch;
	}
	// 828C1F70: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1F78: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1F7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1F80: 419A00EC  beq cr6, 0x828c206c
	if ctx.cr[6].eq {
	pc = 0x828C206C; continue 'dispatch;
	}
	// 828C1F84: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1F8C: 419A0020  beq cr6, 0x828c1fac
	if ctx.cr[6].eq {
	pc = 0x828C1FAC; continue 'dispatch;
	}
	// 828C1F90: 894B003D  lbz r10, 0x3d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1F94: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1F98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C1F9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C1FA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1FA4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1FA8: 480000C8  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
	// 828C1FAC: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1FB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1FB4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1FB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C1FBC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1FC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1FC4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1FC8: 40810054  ble 0x828c201c
	if !ctx.cr[0].gt {
	pc = 0x828C201C; continue 'dispatch;
	}
	// 828C1FCC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1FD0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1FD4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1FD8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1FDC: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1FE0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1FE4: 41980008  blt cr6, 0x828c1fec
	if ctx.cr[6].lt {
	pc = 0x828C1FEC; continue 'dispatch;
	}
	// 828C1FE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C1FEC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1FF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1FF4: 419A0014  beq cr6, 0x828c2008
	if ctx.cr[6].eq {
	pc = 0x828C2008; continue 'dispatch;
	}
	// 828C1FF8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1FFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2000: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C2004: 4800000C  b 0x828c2010
	pc = 0x828C2010; continue 'dispatch;
	// 828C2008: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C200C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C2010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2014: 4199FFB8  bgt cr6, 0x828c1fcc
	if ctx.cr[6].gt {
	pc = 0x828C1FCC; continue 'dispatch;
	}
	// 828C2018: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C201C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C2020: 419A003C  beq cr6, 0x828c205c
	if ctx.cr[6].eq {
	pc = 0x828C205C; continue 'dispatch;
	}
	// 828C2024: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2028: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C202C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2030: 41990008  bgt cr6, 0x828c2038
	if ctx.cr[6].gt {
	pc = 0x828C2038; continue 'dispatch;
	}
	// 828C2034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C203C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2040: 409A001C  bne cr6, 0x828c205c
	if !ctx.cr[6].eq {
	pc = 0x828C205C; continue 'dispatch;
	}
	// 828C2044: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C2048: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C204C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C2050: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2054: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2058: 48000018  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
	// 828C205C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C2060: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2068: 48000008  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
	// 828C206C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2070: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2074: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2078: 419A0024  beq cr6, 0x828c209c
	if ctx.cr[6].eq {
	pc = 0x828C209C; continue 'dispatch;
	}
	// 828C207C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2080: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C2084: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2088: 4E800421  bctrl
	ctx.lr = 0x828C208C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C208C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2098: 4E800020  blr
	return;
	// 828C209C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C20A0: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C20A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C20A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C20AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C20B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C20B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C20B8 size=376
    let mut pc: u32 = 0x828C20B8;
    'dispatch: loop {
        match pc {
            0x828C20B8 => {
    //   block [0x828C20B8..0x828C2230)
	// 828C20B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C20BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C20C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C20C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C20C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C20CC: 419A0018  beq cr6, 0x828c20e4
	if ctx.cr[6].eq {
	pc = 0x828C20E4; continue 'dispatch;
	}
	// 828C20D0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C20D4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C20D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C20DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C20E0: 409A0008  bne cr6, 0x828c20e8
	if !ctx.cr[6].eq {
	pc = 0x828C20E8; continue 'dispatch;
	}
	// 828C20E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C20E8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C20EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C20F0: 419A0130  beq cr6, 0x828c2220
	if ctx.cr[6].eq {
	pc = 0x828C2220; continue 'dispatch;
	}
	// 828C20F4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C20F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C20FC: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C2100: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C2104: 419A00F8  beq cr6, 0x828c21fc
	if ctx.cr[6].eq {
	pc = 0x828C21FC; continue 'dispatch;
	}
	// 828C2108: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C210C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2110: 419A0024  beq cr6, 0x828c2134
	if ctx.cr[6].eq {
	pc = 0x828C2134; continue 'dispatch;
	}
	// 828C2114: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C2118: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C211C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C2120: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2124: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2128: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C212C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2130: 480000D0  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
	// 828C2134: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C2138: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C213C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2140: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C2144: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C2148: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C214C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2150: 40810054  ble 0x828c21a4
	if !ctx.cr[0].gt {
	pc = 0x828C21A4; continue 'dispatch;
	}
	// 828C2154: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C2158: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C215C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C2160: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2164: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C2168: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C216C: 41980008  blt cr6, 0x828c2174
	if ctx.cr[6].lt {
	pc = 0x828C2174; continue 'dispatch;
	}
	// 828C2170: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C2174: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C2178: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C217C: 419A0014  beq cr6, 0x828c2190
	if ctx.cr[6].eq {
	pc = 0x828C2190; continue 'dispatch;
	}
	// 828C2180: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C2184: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2188: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C218C: 4800000C  b 0x828c2198
	pc = 0x828C2198; continue 'dispatch;
	// 828C2190: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C2194: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C2198: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C219C: 4199FFB8  bgt cr6, 0x828c2154
	if ctx.cr[6].gt {
	pc = 0x828C2154; continue 'dispatch;
	}
	// 828C21A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C21A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C21A8: 419A0040  beq cr6, 0x828c21e8
	if ctx.cr[6].eq {
	pc = 0x828C21E8; continue 'dispatch;
	}
	// 828C21AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C21B0: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C21B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21B8: 41990008  bgt cr6, 0x828c21c0
	if ctx.cr[6].gt {
	pc = 0x828C21C0; continue 'dispatch;
	}
	// 828C21BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C21C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C21C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C21C8: 409A0020  bne cr6, 0x828c21e8
	if !ctx.cr[6].eq {
	pc = 0x828C21E8; continue 'dispatch;
	}
	// 828C21CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C21D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C21D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C21D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C21DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C21E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21E4: 4800001C  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
	// 828C21E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C21EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C21F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C21F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21F8: 48000008  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
	// 828C21FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2208: 419A0018  beq cr6, 0x828c2220
	if ctx.cr[6].eq {
	pc = 0x828C2220; continue 'dispatch;
	}
	// 828C220C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2210: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C2214: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C2218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C221C: 4E800421  bctrl
	ctx.lr = 0x828C2220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2220: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C222C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2230 size=456
    let mut pc: u32 = 0x828C2230;
    'dispatch: loop {
        match pc {
            0x828C2230 => {
    //   block [0x828C2230..0x828C23F8)
	// 828C2230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C223C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C2248: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C224C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828C2250: 419A0018  beq cr6, 0x828c2268
	if ctx.cr[6].eq {
	pc = 0x828C2268; continue 'dispatch;
	}
	// 828C2254: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C2258: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C225C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2264: 409A0008  bne cr6, 0x828c226c
	if !ctx.cr[6].eq {
	pc = 0x828C226C; continue 'dispatch;
	}
	// 828C2268: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C226C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2274: 419A0160  beq cr6, 0x828c23d4
	if ctx.cr[6].eq {
	pc = 0x828C23D4; continue 'dispatch;
	}
	// 828C2278: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C227C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C2280: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C2284: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2288: 419A00E8  beq cr6, 0x828c2370
	if ctx.cr[6].eq {
	pc = 0x828C2370; continue 'dispatch;
	}
	// 828C228C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C2290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2294: 419A0020  beq cr6, 0x828c22b4
	if ctx.cr[6].eq {
	pc = 0x828C22B4; continue 'dispatch;
	}
	// 828C2298: 894B003D  lbz r10, 0x3d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C229C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C22A0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C22A4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C22A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C22AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C22B0: 480000C4  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
	// 828C22B4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C22B8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C22BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C22C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C22C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C22C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C22CC: 40810054  ble 0x828c2320
	if !ctx.cr[0].gt {
	pc = 0x828C2320; continue 'dispatch;
	}
	// 828C22D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C22D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C22D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C22DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C22E0: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C22E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C22E8: 41980008  blt cr6, 0x828c22f0
	if ctx.cr[6].lt {
	pc = 0x828C22F0; continue 'dispatch;
	}
	// 828C22EC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828C22F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C22F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C22F8: 419A0014  beq cr6, 0x828c230c
	if ctx.cr[6].eq {
	pc = 0x828C230C; continue 'dispatch;
	}
	// 828C22FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C2300: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2304: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C2308: 4800000C  b 0x828c2314
	pc = 0x828C2314; continue 'dispatch;
	// 828C230C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C2310: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C2314: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2318: 4199FFB8  bgt cr6, 0x828c22d0
	if ctx.cr[6].gt {
	pc = 0x828C22D0; continue 'dispatch;
	}
	// 828C231C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C2320: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C2324: 419A003C  beq cr6, 0x828c2360
	if ctx.cr[6].eq {
	pc = 0x828C2360; continue 'dispatch;
	}
	// 828C2328: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C232C: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C2330: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2334: 41990008  bgt cr6, 0x828c233c
	if ctx.cr[6].gt {
	pc = 0x828C233C; continue 'dispatch;
	}
	// 828C2338: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C233C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2344: 409A001C  bne cr6, 0x828c2360
	if !ctx.cr[6].eq {
	pc = 0x828C2360; continue 'dispatch;
	}
	// 828C2348: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C234C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2350: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C2354: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2358: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C235C: 48000018  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
	// 828C2360: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C2364: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2368: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C236C: 48000008  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
	// 828C2370: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C2374: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C237C: 419A0058  beq cr6, 0x828c23d4
	if ctx.cr[6].eq {
	pc = 0x828C23D4; continue 'dispatch;
	}
	// 828C2380: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2384: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828C2388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C238C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2390: 4E800421  bctrl
	ctx.lr = 0x828C2394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2394: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2398: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C239C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C23A0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C23A4: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C23A8: 419A0020  beq cr6, 0x828c23c8
	if ctx.cr[6].eq {
	pc = 0x828C23C8; continue 'dispatch;
	}
	// 828C23AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C23B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C23B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C23B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C23BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C23C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C23C4: 4082FFE8  bne 0x828c23ac
	if !ctx.cr[0].eq {
	pc = 0x828C23AC; continue 'dispatch;
	}
	// 828C23C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C23CC: 4B8F574D  bl 0x821b7b18
	ctx.lr = 0x828C23D0;
	sub_821B7B18(ctx, base);
	// 828C23D0: 4800000C  b 0x828c23dc
	pc = 0x828C23DC; continue 'dispatch;
	// 828C23D4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C23D8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C23DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C23E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C23E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C23E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C23EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C23F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C23F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C23F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C23F8 size=372
    let mut pc: u32 = 0x828C23F8;
    'dispatch: loop {
        match pc {
            0x828C23F8 => {
    //   block [0x828C23F8..0x828C256C)
	// 828C23F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C23FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2400: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2404: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C2408: 419A0018  beq cr6, 0x828c2420
	if ctx.cr[6].eq {
	pc = 0x828C2420; continue 'dispatch;
	}
	// 828C240C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C2410: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C2414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C241C: 409A0008  bne cr6, 0x828c2424
	if !ctx.cr[6].eq {
	pc = 0x828C2424; continue 'dispatch;
	}
	// 828C2420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2424: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C242C: 419A012C  beq cr6, 0x828c2558
	if ctx.cr[6].eq {
	pc = 0x828C2558; continue 'dispatch;
	}
	// 828C2430: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C2434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2438: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C243C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2440: 419A00E8  beq cr6, 0x828c2528
	if ctx.cr[6].eq {
	pc = 0x828C2528; continue 'dispatch;
	}
	// 828C2444: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C2448: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C244C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2450: 419A001C  beq cr6, 0x828c246c
	if ctx.cr[6].eq {
	pc = 0x828C246C; continue 'dispatch;
	}
	// 828C2454: 896B003D  lbz r11, 0x3d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C2458: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C245C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2460: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2464: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2468: 480000C4  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
	// 828C246C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2474: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C2478: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C247C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C2480: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2484: 40810054  ble 0x828c24d8
	if !ctx.cr[0].gt {
	pc = 0x828C24D8; continue 'dispatch;
	}
	// 828C2488: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C248C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2490: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C2494: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2498: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C249C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C24A0: 41980008  blt cr6, 0x828c24a8
	if ctx.cr[6].lt {
	pc = 0x828C24A8; continue 'dispatch;
	}
	// 828C24A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C24A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C24AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C24B0: 419A0014  beq cr6, 0x828c24c4
	if ctx.cr[6].eq {
	pc = 0x828C24C4; continue 'dispatch;
	}
	// 828C24B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C24B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C24BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C24C0: 4800000C  b 0x828c24cc
	pc = 0x828C24CC; continue 'dispatch;
	// 828C24C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C24C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C24CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C24D0: 4199FFB8  bgt cr6, 0x828c2488
	if ctx.cr[6].gt {
	pc = 0x828C2488; continue 'dispatch;
	}
	// 828C24D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C24D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C24DC: 419A003C  beq cr6, 0x828c2518
	if ctx.cr[6].eq {
	pc = 0x828C2518; continue 'dispatch;
	}
	// 828C24E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C24E4: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C24E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C24EC: 41990008  bgt cr6, 0x828c24f4
	if ctx.cr[6].gt {
	pc = 0x828C24F4; continue 'dispatch;
	}
	// 828C24F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C24F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C24F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C24FC: 409A001C  bne cr6, 0x828c2518
	if !ctx.cr[6].eq {
	pc = 0x828C2518; continue 'dispatch;
	}
	// 828C2500: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C2504: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2508: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C250C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2514: 48000018  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
	// 828C2518: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C251C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2520: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2524: 48000008  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
	// 828C2528: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C252C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2530: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2534: 419A0024  beq cr6, 0x828c2558
	if ctx.cr[6].eq {
	pc = 0x828C2558; continue 'dispatch;
	}
	// 828C2538: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C253C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C2540: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2544: 4E800421  bctrl
	ctx.lr = 0x828C2548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C254C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2554: 4E800020  blr
	return;
	// 828C2558: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C255C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2570 size=396
    let mut pc: u32 = 0x828C2570;
    'dispatch: loop {
        match pc {
            0x828C2570 => {
    //   block [0x828C2570..0x828C26FC)
	// 828C2570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2574: 483E6E85  bl 0x82ca93f8
	ctx.lr = 0x828C2578;
	sub_82CA93D0(ctx, base);
	// 828C2578: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828C257C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C2588: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828C258C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C2590: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 828C2594: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2598: 485C6AE9  bl 0x82e89080
	ctx.lr = 0x828C259C;
	sub_82E89080(ctx, base);
	// 828C259C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C25A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C25A4: 485C4DAD  bl 0x82e87350
	ctx.lr = 0x828C25A8;
	sub_82E87350(ctx, base);
	// 828C25A8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C25AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C25B0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828C25B4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C25B8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 828C25BC: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C25C0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828C25C4: 419A0010  beq cr6, 0x828c25d4
	if ctx.cr[6].eq {
	pc = 0x828C25D4; continue 'dispatch;
	}
	// 828C25C8: 4B99E3F1  bl 0x822609b8
	ctx.lr = 0x828C25CC;
	sub_822609B8(ctx, base);
	// 828C25CC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C25D0: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 828C25D4: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C25D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828C25DC: 4098000C  bge cr6, 0x828c25e8
	if !ctx.cr[6].lt {
	pc = 0x828C25E8; continue 'dispatch;
	}
	// 828C25E0: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 828C25E4: 4800002C  b 0x828c2610
	pc = 0x828C2610; continue 'dispatch;
	// 828C25E8: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C25EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828C25F0: 40980014  bge cr6, 0x828c2604
	if !ctx.cr[6].lt {
	pc = 0x828C2604; continue 'dispatch;
	}
	// 828C25F4: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 828C25F8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 828C25FC: 409A0014  bne cr6, 0x828c2610
	if !ctx.cr[6].eq {
	pc = 0x828C2610; continue 'dispatch;
	}
	// 828C2600: 4800000C  b 0x828c260c
	pc = 0x828C260C; continue 'dispatch;
	// 828C2604: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C2608: 40990008  ble cr6, 0x828c2610
	if !ctx.cr[6].gt {
	pc = 0x828C2610; continue 'dispatch;
	}
	// 828C260C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C2610: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C2614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2618: 409A00AC  bne cr6, 0x828c26c4
	if !ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C261C: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828C2620: 409A0060  bne cr6, 0x828c2680
	if !ctx.cr[6].eq {
	pc = 0x828C2680; continue 'dispatch;
	}
	// 828C2624: 4B99E395  bl 0x822609b8
	ctx.lr = 0x828C2628;
	sub_822609B8(ctx, base);
	// 828C2628: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C262C: 485BF025  bl 0x82e81650
	ctx.lr = 0x828C2630;
	sub_82E81650(ctx, base);
	// 828C2630: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2634: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C2638: 419A008C  beq cr6, 0x828c26c4
	if ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C263C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2640: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C2644: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C2648: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C264C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2650: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C2654: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2658: 4E800421  bctrl
	ctx.lr = 0x828C265C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C265C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C2660: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C2664: 409A0050  bne cr6, 0x828c26b4
	if !ctx.cr[6].eq {
	pc = 0x828C26B4; continue 'dispatch;
	}
	// 828C2668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C266C: 485BEFE5  bl 0x82e81650
	ctx.lr = 0x828C2670;
	sub_82E81650(ctx, base);
	// 828C2670: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2674: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C2678: 409AFFC4  bne cr6, 0x828c263c
	if !ctx.cr[6].eq {
	pc = 0x828C263C; continue 'dispatch;
	}
	// 828C267C: 48000048  b 0x828c26c4
	pc = 0x828C26C4; continue 'dispatch;
	// 828C2680: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 828C2684: 409A0040  bne cr6, 0x828c26c4
	if !ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C2688: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C268C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C2690: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C2694: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C2698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C269C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C26A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C26A4: 4E800421  bctrl
	ctx.lr = 0x828C26A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C26A8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C26AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C26B0: 419AFFD8  beq cr6, 0x828c2688
	if ctx.cr[6].eq {
	pc = 0x828C2688; continue 'dispatch;
	}
	// 828C26B4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C26B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C26BC: 419A0008  beq cr6, 0x828c26c4
	if ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C26C0: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 828C26C4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C26C8: 57CAE8FE  srwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C26CC: 57C9077E  clrlwi r9, r30, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 828C26D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C26D4: 7F684830  slw r8, r27, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[27].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 828C26D8: 7CEA58AE  lbzx r7, r10, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C26DC: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 828C26E0: 7CC50034  cntlzw r5, r6
	ctx.r[5].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 828C26E4: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 828C26E8: 688B0001  xori r11, r4, 1
	ctx.r[11].u64 = ctx.r[4].u64 ^ 1;
	// 828C26EC: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C26F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C26F4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C26F8: 483E6D50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2700 size=84
    let mut pc: u32 = 0x828C2700;
    'dispatch: loop {
        match pc {
            0x828C2700 => {
    //   block [0x828C2700..0x828C2754)
	// 828C2700: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2704: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2708: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828C270C: 409A0040  bne cr6, 0x828c274c
	if !ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C2710: 81050064  lwz r8, 0x64(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2714: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C2718: 419A0034  beq cr6, 0x828c274c
	if ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C271C: 81230080  lwz r9, 0x80(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C2720: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2724: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2728: 419A0024  beq cr6, 0x828c274c
	if ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C272C: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C2730: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2734: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C2738: 419A001C  beq cr6, 0x828c2754
	if ctx.cr[6].eq {
		sub_828C2754(ctx, base);
		return;
	}
	// 828C273C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C2740: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C2744: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2748: 4198FFE8  blt cr6, 0x828c2730
	if ctx.cr[6].lt {
	pc = 0x828C2730; continue 'dispatch;
	}
	// 828C274C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2754(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2754 size=8
    let mut pc: u32 = 0x828C2754;
    'dispatch: loop {
        match pc {
            0x828C2754 => {
    //   block [0x828C2754..0x828C275C)
	// 828C2754: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C2758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2760 size=172
    let mut pc: u32 = 0x828C2760;
    'dispatch: loop {
        match pc {
            0x828C2760 => {
    //   block [0x828C2760..0x828C280C)
	// 828C2760: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 828C2764: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2768: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C276C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C2770: 409A004C  bne cr6, 0x828c27bc
	if !ctx.cr[6].eq {
	pc = 0x828C27BC; continue 'dispatch;
	}
	// 828C2774: 80E30080  lwz r7, 0x80(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C2778: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C277C: 80C50064  lwz r6, 0x64(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2780: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2784: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C2788: 419A0034  beq cr6, 0x828c27bc
	if ctx.cr[6].eq {
	pc = 0x828C27BC; continue 'dispatch;
	}
	// 828C278C: 81030078  lwz r8, 0x78(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C2790: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2798: 419A0014  beq cr6, 0x828c27ac
	if ctx.cr[6].eq {
	pc = 0x828C27AC; continue 'dispatch;
	}
	// 828C279C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C27A0: 419A0028  beq cr6, 0x828c27c8
	if ctx.cr[6].eq {
	pc = 0x828C27C8; continue 'dispatch;
	}
	// 828C27A4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C27A8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C27AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C27B0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 828C27B4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828C27B8: 4198FFD8  blt cr6, 0x828c2790
	if ctx.cr[6].lt {
	pc = 0x828C2790; continue 'dispatch;
	}
	// 828C27BC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 828C27C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828C27C4: 4E800020  blr
	return;
	// 828C27C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C27CC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 828C27D0: 81060008  lwz r8, 8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C27D4: 80E4006C  lwz r7, 0x6c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C27D8: 80C5006C  lwz r6, 0x6c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C27DC: 80A30070  lwz r5, 0x70(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C27E0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C27E4: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C27E8: 7D443850  subf r10, r4, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 828C27EC: 7D033050  subf r8, r3, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[3].s64;
	// 828C27F0: 7CEA5B96  divwu r7, r10, r11
	ctx.r[7].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 828C27F4: 7D485B96  divwu r10, r8, r11
	ctx.r[10].u32 = ctx.r[8].u32 / ctx.r[11].u32;
	// 828C27F8: 7D6729D6  mullw r11, r7, r5
	ctx.r[11].s64 = (ctx.r[7].s32 as i64) * (ctx.r[5].s32 as i64);
	// 828C27FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2800: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C2804: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828C2808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2810 size=456
    let mut pc: u32 = 0x828C2810;
    'dispatch: loop {
        match pc {
            0x828C2810 => {
    //   block [0x828C2810..0x828C29D8)
	// 828C2810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2814: 483E6BBD  bl 0x82ca93d0
	ctx.lr = 0x828C2818;
	sub_82CA93D0(ctx, base);
	// 828C2818: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C281C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2820: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C2824: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828C2828: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828C282C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828C2830: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828C2834: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2838: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828C283C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828C2840: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C2844: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C2848: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828C284C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2850: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C2854: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828C2858: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828C285C: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828C2860: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C2864: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2868: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828C286C: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2870: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828C2874: 4B9A31B5  bl 0x82265a28
	ctx.lr = 0x828C2878;
	sub_82265A28(ctx, base);
	// 828C2878: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C287C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828C2880: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828C2884: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C2888: 40990148  ble cr6, 0x828c29d0
	if !ctx.cr[6].gt {
	pc = 0x828C29D0; continue 'dispatch;
	}
	// 828C288C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C2890: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828C2894: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2898: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828C289C: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C28A0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C28A4: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828C28A8: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	// 828C28AC: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828C28B0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C28B4: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C28B8: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828C28BC: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828C28C0: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828C28C4: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828C28C8: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828C28CC: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828C28D0: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828C28D4: 418200E0  beq 0x828c29b4
	if ctx.cr[0].eq {
	pc = 0x828C29B4; continue 'dispatch;
	}
	// 828C28D8: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C28DC: 418200D8  beq 0x828c29b4
	if ctx.cr[0].eq {
	pc = 0x828C29B4; continue 'dispatch;
	}
	// 828C28E0: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828C28E4: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828C28E8: 409800CC  bge cr6, 0x828c29b4
	if !ctx.cr[6].lt {
	pc = 0x828C29B4; continue 'dispatch;
	}
	// 828C28EC: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C28F0: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828C28F4: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C28F8: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828C28FC: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828C2900: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2904: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2908: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[23].s32 as i64);
	// 828C290C: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828C2910: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C2914: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2918: 40980088  bge cr6, 0x828c29a0
	if !ctx.cr[6].lt {
	pc = 0x828C29A0; continue 'dispatch;
	}
	// 828C291C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 828C2920: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2924: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C2928: 419A006C  beq cr6, 0x828c2994
	if ctx.cr[6].eq {
	pc = 0x828C2994; continue 'dispatch;
	}
	// 828C292C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2930: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2934: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C2938: 40980050  bge cr6, 0x828c2988
	if !ctx.cr[6].lt {
	pc = 0x828C2988; continue 'dispatch;
	}
	// 828C293C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828C2940: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2944: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C294C: 4B940C95  bl 0x822035e0
	ctx.lr = 0x828C2950;
	sub_822035E0(ctx, base);
	// 828C2950: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C2954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2958: 419A002C  beq cr6, 0x828c2984
	if ctx.cr[6].eq {
	pc = 0x828C2984; continue 'dispatch;
	}
	// 828C295C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C2960: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2964: 4BC4DAC5  bl 0x82510428
	ctx.lr = 0x828C2968;
	sub_82510428(ctx, base);
	// 828C2968: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C296C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2970: 419A0014  beq cr6, 0x828c2984
	if ctx.cr[6].eq {
	pc = 0x828C2984; continue 'dispatch;
	}
	// 828C2974: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828C2978: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C297C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2980: 48286DD1  bl 0x82b49750
	ctx.lr = 0x828C2984;
	sub_82B49750(ctx, base);
	// 828C2984: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828C2988: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C298C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C2990: 409AFF9C  bne cr6, 0x828c292c
	if !ctx.cr[6].eq {
	pc = 0x828C292C; continue 'dispatch;
	}
	// 828C2994: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828C2998: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828C299C: 4082FF84  bne 0x828c2920
	if !ctx.cr[0].eq {
	pc = 0x828C2920; continue 'dispatch;
	}
	// 828C29A0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828C29A4: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828C29A8: 4198FF44  blt cr6, 0x828c28ec
	if ctx.cr[6].lt {
	pc = 0x828C28EC; continue 'dispatch;
	}
	// 828C29AC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C29B0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828C29B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C29B8: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828C29BC: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828C29C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C29C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C29C8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828C29CC: 4198FEE0  blt cr6, 0x828c28ac
	if ctx.cr[6].lt {
	pc = 0x828C28AC; continue 'dispatch;
	}
	// 828C29D0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828C29D4: 483E6A4C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C29D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C29D8 size=316
    let mut pc: u32 = 0x828C29D8;
    'dispatch: loop {
        match pc {
            0x828C29D8 => {
    //   block [0x828C29D8..0x828C2B14)
	// 828C29D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C29DC: 483E6A25  bl 0x82ca9400
	ctx.lr = 0x828C29E0;
	sub_82CA93D0(ctx, base);
	// 828C29E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C29E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C29E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C29EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828C29F0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C29F4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C29F8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C29FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A00: 419A00F0  beq cr6, 0x828c2af0
	if ctx.cr[6].eq {
	pc = 0x828C2AF0; continue 'dispatch;
	}
	// 828C2A04: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A08: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C2A0C: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2A14: 409A0008  bne cr6, 0x828c2a1c
	if !ctx.cr[6].eq {
	pc = 0x828C2A1C; continue 'dispatch;
	}
	// 828C2A18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2A1C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2A20: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2A24: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2A28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2A2C: 41980008  blt cr6, 0x828c2a34
	if ctx.cr[6].lt {
	pc = 0x828C2A34; continue 'dispatch;
	}
	// 828C2A30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2A34: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A38: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A3C: 41990008  bgt cr6, 0x828c2a44
	if ctx.cr[6].gt {
	pc = 0x828C2A44; continue 'dispatch;
	}
	// 828C2A40: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828C2A44: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A48: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C2A4C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A50: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C2A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2A5C: 7FE8482E  lwzx r31, r8, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828C2A60: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2A64: 409A0008  bne cr6, 0x828c2a6c
	if !ctx.cr[6].eq {
	pc = 0x828C2A6C; continue 'dispatch;
	}
	// 828C2A68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2A6C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2A70: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2A74: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2A78: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2A7C: 41980008  blt cr6, 0x828c2a84
	if ctx.cr[6].lt {
	pc = 0x828C2A84; continue 'dispatch;
	}
	// 828C2A80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2A84: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A88: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A8C: 41990008  bgt cr6, 0x828c2a94
	if ctx.cr[6].gt {
	pc = 0x828C2A94; continue 'dispatch;
	}
	// 828C2A90: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828C2A94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A98: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2A9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2AA4: 7FC9402E  lwzx r30, r9, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2AA8: 419A0030  beq cr6, 0x828c2ad8
	if ctx.cr[6].eq {
	pc = 0x828C2AD8; continue 'dispatch;
	}
	// 828C2AAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2AB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2AB4: 419A001C  beq cr6, 0x828c2ad0
	if ctx.cr[6].eq {
	pc = 0x828C2AD0; continue 'dispatch;
	}
	// 828C2AB8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C2ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2AC0: 4B951DD9  bl 0x82214898
	ctx.lr = 0x828C2AC4;
	sub_82214898(ctx, base);
	// 828C2AC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AC8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2ACC: 4BFFFF28  b 0x828c29f4
	pc = 0x828C29F4; continue 'dispatch;
	// 828C2AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2AD4: 4B8D1365  bl 0x82193e38
	ctx.lr = 0x828C2AD8;
	sub_82193E38(ctx, base);
	// 828C2AD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C2ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2AE0: 4B951DB9  bl 0x82214898
	ctx.lr = 0x828C2AE4;
	sub_82214898(ctx, base);
	// 828C2AE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AE8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2AEC: 4BFFFF08  b 0x828c29f4
	pc = 0x828C29F4; continue 'dispatch;
	// 828C2AF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2AF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2AF8: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C2B00: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C2B04: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C2B08: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2B0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C2B10: 483E6940  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2B18 size=308
    let mut pc: u32 = 0x828C2B18;
    'dispatch: loop {
        match pc {
            0x828C2B18 => {
    //   block [0x828C2B18..0x828C2C4C)
	// 828C2B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2B1C: 483E68E5  bl 0x82ca9400
	ctx.lr = 0x828C2B20;
	sub_82CA93D0(ctx, base);
	// 828C2B20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2B24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C2B28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C2B2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C2B30: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C2B34: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B38: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B3C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C2B40: 419A00E8  beq cr6, 0x828c2c28
	if ctx.cr[6].eq {
	pc = 0x828C2C28; continue 'dispatch;
	}
	// 828C2B44: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2B4C: 409A0008  bne cr6, 0x828c2b54
	if !ctx.cr[6].eq {
	pc = 0x828C2B54; continue 'dispatch;
	}
	// 828C2B50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2B54: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2B58: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2B5C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2B60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2B64: 41980008  blt cr6, 0x828c2b6c
	if ctx.cr[6].lt {
	pc = 0x828C2B6C; continue 'dispatch;
	}
	// 828C2B68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2B6C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2B74: 41990008  bgt cr6, 0x828c2b7c
	if ctx.cr[6].gt {
	pc = 0x828C2B7C; continue 'dispatch;
	}
	// 828C2B78: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828C2B7C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B80: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2B84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B88: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2B90: 7FC9402E  lwzx r30, r9, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2B94: 409A0008  bne cr6, 0x828c2b9c
	if !ctx.cr[6].eq {
	pc = 0x828C2B9C; continue 'dispatch;
	}
	// 828C2B98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2B9C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2BA0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2BA4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2BA8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2BAC: 41980008  blt cr6, 0x828c2bb4
	if ctx.cr[6].lt {
	pc = 0x828C2BB4; continue 'dispatch;
	}
	// 828C2BB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2BB4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2BB8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2BBC: 41990008  bgt cr6, 0x828c2bc4
	if ctx.cr[6].gt {
	pc = 0x828C2BC4; continue 'dispatch;
	}
	// 828C2BC0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828C2BC4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2BC8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2BCC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2BD4: 7FE9402E  lwzx r31, r9, r8
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2BD8: 419A0020  beq cr6, 0x828c2bf8
	if ctx.cr[6].eq {
	pc = 0x828C2BF8; continue 'dispatch;
	}
	// 828C2BDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2BE4: 419A000C  beq cr6, 0x828c2bf0
	if ctx.cr[6].eq {
	pc = 0x828C2BF0; continue 'dispatch;
	}
	// 828C2BE8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C2BEC: 48000010  b 0x828c2bfc
	pc = 0x828C2BFC; continue 'dispatch;
	// 828C2BF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2BF4: 4B8D1245  bl 0x82193e38
	ctx.lr = 0x828C2BF8;
	sub_82193E38(ctx, base);
	// 828C2BF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C2BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2C00: 4B951C99  bl 0x82214898
	ctx.lr = 0x828C2C04;
	sub_82214898(ctx, base);
	// 828C2C04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C08: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2C0C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C10: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C2C14: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2C18: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C1C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 828C2C20: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2C24: 4BFFFF10  b 0x828c2b34
	pc = 0x828C2B34; continue 'dispatch;
	// 828C2C28: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2C2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2C30: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C2C38: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C2C3C: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C2C40: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2C44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C2C48: 483E6808  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2C50 size=168
    let mut pc: u32 = 0x828C2C50;
    'dispatch: loop {
        match pc {
            0x828C2C50 => {
    //   block [0x828C2C50..0x828C2CF8)
	// 828C2C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2C5C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C2C60: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2CF8 size=84
    let mut pc: u32 = 0x828C2CF8;
    'dispatch: loop {
        match pc {
            0x828C2CF8 => {
    //   block [0x828C2CF8..0x828C2D4C)
	// 828C2CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2D0C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C2D10: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828C2D14: 392B39E0  addi r9, r11, 0x39e0
	ctx.r[9].s64 = ctx.r[11].s64 + 14816;
	// 828C2D18: 390A279C  addi r8, r10, 0x279c
	ctx.r[8].s64 = ctx.r[10].s64 + 10140;
	// 828C2D1C: 548707FE  clrlwi r7, r4, 0x1f
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 828C2D20: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 828C2D24: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C2D28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C2D2C: 419A000C  beq cr6, 0x828c2d38
	if ctx.cr[6].eq {
	pc = 0x828C2D38; continue 'dispatch;
	}
	// 828C2D30: 4B959009  bl 0x8221bd38
	ctx.lr = 0x828C2D34;
	sub_8221BD38(ctx, base);
	// 828C2D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2D38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2D50 size=172
    let mut pc: u32 = 0x828C2D50;
    'dispatch: loop {
        match pc {
            0x828C2D50 => {
    //   block [0x828C2D50..0x828C2DFC)
	// 828C2D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2D58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2D5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2D60: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 828C2D64: C0040090  lfs f0, 0x90(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2D68: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 828C2D6C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C2D70: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C2D74: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 828C2D78: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2E00 size=176
    let mut pc: u32 = 0x828C2E00;
    'dispatch: loop {
        match pc {
            0x828C2E00 => {
    //   block [0x828C2E00..0x828C2EB0)
	// 828C2E00: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 828C2E04: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 828C2E08: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 828C2E0C: 38A1FFF0  addi r5, r1, -0x10
	ctx.r[5].s64 = ctx.r[1].s64 + -16;
	// 828C2E10: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2EB0 size=8
    let mut pc: u32 = 0x828C2EB0;
    'dispatch: loop {
        match pc {
            0x828C2EB0 => {
    //   block [0x828C2EB0..0x828C2EB8)
	// 828C2EB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2EB8 size=8
    let mut pc: u32 = 0x828C2EB8;
    'dispatch: loop {
        match pc {
            0x828C2EB8 => {
    //   block [0x828C2EB8..0x828C2EC0)
	// 828C2EB8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828C2EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2EC0 size=116
    let mut pc: u32 = 0x828C2EC0;
    'dispatch: loop {
        match pc {
            0x828C2EC0 => {
    //   block [0x828C2EC0..0x828C2F34)
	// 828C2EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2EC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2ECC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2ED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2ED4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C2ED8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2EDC: 392B0DE4  addi r9, r11, 0xde4
	ctx.r[9].s64 = ctx.r[11].s64 + 3556;
	// 828C2EE0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C2EE4: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 828C2EE8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C2EEC: 4B95C36D  bl 0x8221f258
	ctx.lr = 0x828C2EF0;
	sub_8221F258(ctx, base);
	// 828C2EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2EF4: 419A0008  beq cr6, 0x828c2efc
	if ctx.cr[6].eq {
	pc = 0x828C2EFC; continue 'dispatch;
	}
	// 828C2EF8: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828C2EFC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2F00: 41820008  beq 0x828c2f08
	if ctx.cr[0].eq {
	pc = 0x828C2F08; continue 'dispatch;
	}
	// 828C2F04: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828C2F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2F0C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828C2F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2F14: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C2F18: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828C2F1C: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828C2F20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2F38 size=88
    let mut pc: u32 = 0x828C2F38;
    'dispatch: loop {
        match pc {
            0x828C2F38 => {
    //   block [0x828C2F38..0x828C2F90)
	// 828C2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2F50: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2F54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2F58: 4E800421  bctrl
	ctx.lr = 0x828C2F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2F5C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828C2F60: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C2F64: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C2F68: 4BB19C79  bl 0x823dcbe0
	ctx.lr = 0x828C2F6C;
	sub_823DCBE0(ctx, base);
	// 828C2F6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2F70: 419A000C  beq cr6, 0x828c2f7c
	if ctx.cr[6].eq {
	pc = 0x828C2F7C; continue 'dispatch;
	}
	// 828C2F74: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828C2F78: 4812B039  bl 0x829edfb0
	ctx.lr = 0x828C2F7C;
	sub_829EDFB0(ctx, base);
	// 828C2F7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2F90 size=8
    let mut pc: u32 = 0x828C2F90;
    'dispatch: loop {
        match pc {
            0x828C2F90 => {
    //   block [0x828C2F90..0x828C2F98)
	// 828C2F90: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 828C2F94: 4BEDDE84  b 0x827a0e18
	sub_827A0E18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2F98 size=268
    let mut pc: u32 = 0x828C2F98;
    'dispatch: loop {
        match pc {
            0x828C2F98 => {
    //   block [0x828C2F98..0x828C30A4)
	// 828C2F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2F9C: 483E6465  bl 0x82ca9400
	ctx.lr = 0x828C2FA0;
	sub_82CA93D0(ctx, base);
	// 828C2FA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2FA4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C2FA8: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828C2FAC: 3BBA0008  addi r29, r26, 8
	ctx.r[29].s64 = ctx.r[26].s64 + 8;
	// 828C2FB0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C2FB4: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2FB8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2FBC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FC0: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C2FC4: 419A0008  beq cr6, 0x828c2fcc
	if ctx.cr[6].eq {
	pc = 0x828C2FCC; continue 'dispatch;
	}
	// 828C2FC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2FCC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C2FD0: 419A0064  beq cr6, 0x828c3034
	if ctx.cr[6].eq {
	pc = 0x828C3034; continue 'dispatch;
	}
	// 828C2FD4: 817C6B08  lwz r11, 0x6b08(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C2FD8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FDC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2FE0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C2FE4: 409A0008  bne cr6, 0x828c2fec
	if !ctx.cr[6].eq {
	pc = 0x828C2FEC; continue 'dispatch;
	}
	// 828C2FE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C2FEC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2FF0: 4BB19BF1  bl 0x823dcbe0
	ctx.lr = 0x828C2FF4;
	sub_823DCBE0(ctx, base);
	// 828C2FF4: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C2FF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C2FFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3000: 419A001C  beq cr6, 0x828c301c
	if ctx.cr[6].eq {
	pc = 0x828C301C; continue 'dispatch;
	}
	// 828C3004: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3008: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 828C300C: 41810010  bgt 0x828c301c
	if ctx.cr[0].gt {
	pc = 0x828C301C; continue 'dispatch;
	}
	// 828C3010: 937F0040  stw r27, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[27].u32 ) };
	// 828C3014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3018: 4812A661  bl 0x829ed678
	ctx.lr = 0x828C301C;
	sub_829ED678(ctx, base);
	// 828C301C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3020: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C3024: 409A0008  bne cr6, 0x828c302c
	if !ctx.cr[6].eq {
	pc = 0x828C302C; continue 'dispatch;
	}
	// 828C3028: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C302C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3030: 4BFFFF8C  b 0x828c2fbc
	pc = 0x828C2FBC; continue 'dispatch;
	// 828C3034: 897A0018  lbz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C3038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C303C: 419A0060  beq cr6, 0x828c309c
	if ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3040: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C3044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3048: 419A0050  beq cr6, 0x828c3098
	if ctx.cr[6].eq {
	pc = 0x828C3098; continue 'dispatch;
	}
	// 828C304C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3050: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C3054: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3058: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C305C: 409A0008  bne cr6, 0x828c3064
	if !ctx.cr[6].eq {
	pc = 0x828C3064; continue 'dispatch;
	}
	// 828C3060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C3064: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C306C: 419A0030  beq cr6, 0x828c309c
	if ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3070: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C3074: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C307C: 41990008  bgt cr6, 0x828c3084
	if ctx.cr[6].gt {
	pc = 0x828C3084; continue 'dispatch;
	}
	// 828C3080: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828C3084: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C308C: 409A0010  bne cr6, 0x828c309c
	if !ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3090: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C3094: 480003F5  bl 0x828c3488
	ctx.lr = 0x828C3098;
	sub_828C3488(ctx, base);
	// 828C3098: 9B7A0018  stb r27, 0x18(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 828C309C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C30A0: 483E63B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C30A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C30A8 size=420
    let mut pc: u32 = 0x828C30A8;
    'dispatch: loop {
        match pc {
            0x828C30A8 => {
    //   block [0x828C30A8..0x828C324C)
	// 828C30A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C30AC: 483E6349  bl 0x82ca93f4
	ctx.lr = 0x828C30B0;
	sub_82CA93D0(ctx, base);
	// 828C30B0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 828C30B4: 483EAC25  bl 0x82cadcd8
	ctx.lr = 0x828C30B8;
	sub_82CADCA0(ctx, base);
	// 828C30B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C30BC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828C30C0: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828C30C4: 2F04001B  cmpwi cr6, r4, 0x1b
	ctx.cr[6].compare_i32(ctx.r[4].s32, 27, &mut ctx.xer);
	// 828C30C8: 409A0174  bne cr6, 0x828c323c
	if !ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C30CC: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C30D0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828C30D4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C30D8: 3BB70008  addi r29, r23, 8
	ctx.r[29].s64 = ctx.r[23].s64 + 8;
	// 828C30DC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C30E0: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828C30E4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C30E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C30EC: C38A0FF0  lfs f28, 0xff0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4080 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828C30F0: 3B6B9484  addi r27, r11, -0x6b7c
	ctx.r[27].s64 = ctx.r[11].s64 + -27516;
	// 828C30F4: CBA90DF0  lfd f29, 0xdf0(r9)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3568 as u32) ) };
	// 828C30F8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 828C30FC: 3B4B0E68  addi r26, r11, 0xe68
	ctx.r[26].s64 = ctx.r[11].s64 + 3688;
	// 828C3100: C3DB0000  lfs f30, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C3104: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3108: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C310C: 419A0008  beq cr6, 0x828c3114
	if ctx.cr[6].eq {
	pc = 0x828C3114; continue 'dispatch;
	}
	// 828C3110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C3114: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C3118: 419A00DC  beq cr6, 0x828c31f4
	if ctx.cr[6].eq {
	pc = 0x828C31F4; continue 'dispatch;
	}
	// 828C311C: 817C6B08  lwz r11, 0x6b08(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3120: 2B180002  cmplwi cr6, r24, 2
	ctx.cr[6].compare_u32(ctx.r[24].u32, 2 as u32, &mut ctx.xer);
	// 828C3124: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3128: 409A000C  bne cr6, 0x828c3134
	if !ctx.cr[6].eq {
	pc = 0x828C3134; continue 'dispatch;
	}
	// 828C312C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C3130: 48000008  b 0x828c3138
	pc = 0x828C3138; continue 'dispatch;
	// 828C3134: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3138: E96B0018  ld r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 828C313C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828C3140: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C3144: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3148: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C314C: 4B93B35D  bl 0x821fe4a8
	ctx.lr = 0x828C3150;
	sub_821FE4A8(ctx, base);
	// 828C3150: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3154: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3158: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828C315C: FC206850  fneg f1, f13
	ctx.f[1].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C3160: 4B93B349  bl 0x821fe4a8
	ctx.lr = 0x828C3164;
	sub_821FE4A8(ctx, base);
	// 828C3164: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3168: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828C316C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3170: 4099000C  ble cr6, 0x828c317c
	if !ctx.cr[6].gt {
	pc = 0x828C317C; continue 'dispatch;
	}
	// 828C3174: C01B2324  lfs f0, 0x2324(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8996 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3178: 48000020  b 0x828c3198
	pc = 0x828C3198; continue 'dispatch;
	// 828C317C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3180: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828C3184: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C3188: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828C318C: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 828C3190: 7C1A442E  lfsx f0, r26, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3194: FC00E7AE  fsel f0, f0, f30, f28
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[28].f64 };
	// 828C3198: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C319C: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828C31A0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828C31A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C31A8: 409A0008  bne cr6, 0x828c31b0
	if !ctx.cr[6].eq {
	pc = 0x828C31B0; continue 'dispatch;
	}
	// 828C31AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C31B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C31B4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C31B8: 4BB19A29  bl 0x823dcbe0
	ctx.lr = 0x828C31BC;
	sub_823DCBE0(ctx, base);
	// 828C31BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C31C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C31C4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C31C8: 4812A5C1  bl 0x829ed788
	ctx.lr = 0x828C31CC;
	sub_829ED788(ctx, base);
	// 828C31CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C31D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C31D4: 419A0008  beq cr6, 0x828c31dc
	if ctx.cr[6].eq {
	pc = 0x828C31DC; continue 'dispatch;
	}
	// 828C31D8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 828C31DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C31E0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C31E4: 409A0008  bne cr6, 0x828c31ec
	if !ctx.cr[6].eq {
	pc = 0x828C31EC; continue 'dispatch;
	}
	// 828C31E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C31EC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C31F0: 4BFFFF14  b 0x828c3104
	pc = 0x828C3104; continue 'dispatch;
	// 828C31F4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C31F8: 48000291  bl 0x828c3488
	ctx.lr = 0x828C31FC;
	sub_828C3488(ctx, base);
	// 828C31FC: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828C3200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3204: 419A0038  beq cr6, 0x828c323c
	if ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C3208: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C320C: 809C6B08  lwz r4, 0x6b08(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3210: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C3214: 38AB7E20  addi r5, r11, 0x7e20
	ctx.r[5].s64 = ctx.r[11].s64 + 32288;
	// 828C3218: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C321C: 4BAAEC65  bl 0x82371e80
	ctx.lr = 0x828C3220;
	sub_82371E80(ctx, base);
	// 828C3220: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C3224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3228: 419A0014  beq cr6, 0x828c323c
	if ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C322C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3230: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C3238: 4E800421  bctrl
	ctx.lr = 0x828C323C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C323C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828C3240: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 828C3244: 483EAAE1  bl 0x82cadd24
	ctx.lr = 0x828C3248;
	sub_82CADCEC(ctx, base);
	// 828C3248: 483E61FC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3250 size=264
    let mut pc: u32 = 0x828C3250;
    'dispatch: loop {
        match pc {
            0x828C3250 => {
    //   block [0x828C3250..0x828C3358)
	// 828C3250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3254: 483E61B5  bl 0x82ca9408
	ctx.lr = 0x828C3258;
	sub_82CA93D0(ctx, base);
	// 828C3258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C325C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3260: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C3264: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3268: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C326C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3270: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3274: 4BB1996D  bl 0x823dcbe0
	ctx.lr = 0x828C3278;
	sub_823DCBE0(ctx, base);
	// 828C3278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C327C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3280: 419A00C8  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C3284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C328C: 4B92CFB5  bl 0x821f0240
	ctx.lr = 0x828C3290;
	sub_821F0240(ctx, base);
	// 828C3290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3294: 4BB63505  bl 0x82426798
	ctx.lr = 0x828C3298;
	sub_82426798(ctx, base);
	// 828C3298: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C329C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C32A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C32A4: 4B92CF9D  bl 0x821f0240
	ctx.lr = 0x828C32A8;
	sub_821F0240(ctx, base);
	// 828C32A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C32AC: 4BB634ED  bl 0x82426798
	ctx.lr = 0x828C32B0;
	sub_82426798(ctx, base);
	// 828C32B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C32B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C32B8: 419A0090  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C32BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C32C0: 419A0088  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C32C4: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 828C32C8: 4B95BF91  bl 0x8221f258
	ctx.lr = 0x828C32CC;
	sub_8221F258(ctx, base);
	// 828C32CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C32D0: 419A0010  beq cr6, 0x828c32e0
	if ctx.cr[6].eq {
	pc = 0x828C32E0; continue 'dispatch;
	}
	// 828C32D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C32D8: 4812A299  bl 0x829ed570
	ctx.lr = 0x828C32DC;
	sub_829ED570(ctx, base);
	// 828C32DC: 48000008  b 0x828c32e4
	pc = 0x828C32E4; continue 'dispatch;
	// 828C32E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C32E4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828C32E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C32EC: 419A0010  beq cr6, 0x828c32fc
	if ctx.cr[6].eq {
	pc = 0x828C32FC; continue 'dispatch;
	}
	// 828C32F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C32F4: 481419CD  bl 0x82a04cc0
	ctx.lr = 0x828C32F8;
	sub_82A04CC0(ctx, base);
	// 828C32F8: 4800000C  b 0x828c3304
	pc = 0x828C3304; continue 'dispatch;
	// 828C32FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3300: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C3304: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3308: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C330C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3310: 4812AAD9  bl 0x829edde8
	ctx.lr = 0x828C3314;
	sub_829EDDE8(ctx, base);
	// 828C3314: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C3318: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 828C331C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C3320: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C3324: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C3328: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C332C: 4BD5A7BD  bl 0x8261dae8
	ctx.lr = 0x828C3330;
	sub_8261DAE8(ctx, base);
	// 828C3330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3334: 4B8F47E5  bl 0x821b7b18
	ctx.lr = 0x828C3338;
	sub_821B7B18(ctx, base);
	// 828C3338: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C333C: 995C0018  stb r10, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 828C3340: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C3344: 483E6114  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828C3348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C334C: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828C3350: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C3354: 483E6104  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3358 size=148
    let mut pc: u32 = 0x828C3358;
    'dispatch: loop {
        match pc {
            0x828C3358 => {
    //   block [0x828C3358..0x828C33EC)
	// 828C3358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C335C: 483E60AD  bl 0x82ca9408
	ctx.lr = 0x828C3360;
	sub_82CA93D0(ctx, base);
	// 828C3360: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3364: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3368: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C336C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3370: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3374: 4BB1986D  bl 0x823dcbe0
	ctx.lr = 0x828C3378;
	sub_823DCBE0(ctx, base);
	// 828C3378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C337C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C3380: 419A0064  beq cr6, 0x828c33e4
	if ctx.cr[6].eq {
	pc = 0x828C33E4; continue 'dispatch;
	}
	// 828C3384: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C3388: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 828C338C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3390: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3394: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828C3398: 419A0008  beq cr6, 0x828c33a0
	if ctx.cr[6].eq {
	pc = 0x828C33A0; continue 'dispatch;
	}
	// 828C339C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C33A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33A4: 419A0038  beq cr6, 0x828c33dc
	if ctx.cr[6].eq {
	pc = 0x828C33DC; continue 'dispatch;
	}
	// 828C33A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C33AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33B0: 409A0008  bne cr6, 0x828c33b8
	if !ctx.cr[6].eq {
	pc = 0x828C33B8; continue 'dispatch;
	}
	// 828C33B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C33B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C33BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C33C0: 4812AB11  bl 0x829eded0
	ctx.lr = 0x828C33C4;
	sub_829EDED0(ctx, base);
	// 828C33C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C33C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33CC: 409A0008  bne cr6, 0x828c33d4
	if !ctx.cr[6].eq {
	pc = 0x828C33D4; continue 'dispatch;
	}
	// 828C33D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C33D4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C33D8: 4BFFFFB8  b 0x828c3390
	pc = 0x828C3390; continue 'dispatch;
	// 828C33DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C33E0: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828C33E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C33E8: 483E6070  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C33F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C33F0 size=148
    let mut pc: u32 = 0x828C33F0;
    'dispatch: loop {
        match pc {
            0x828C33F0 => {
    //   block [0x828C33F0..0x828C3484)
	// 828C33F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C33F4: 483E6019  bl 0x82ca940c
	ctx.lr = 0x828C33F8;
	sub_82CA93D0(ctx, base);
	// 828C33F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C33FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C3400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3404: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C340C: 419A0010  beq cr6, 0x828c341c
	if ctx.cr[6].eq {
	pc = 0x828C341C; continue 'dispatch;
	}
	// 828C3410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3414: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3418: 409A0014  bne cr6, 0x828c342c
	if !ctx.cr[6].eq {
	pc = 0x828C342C; continue 'dispatch;
	}
	// 828C341C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3420: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828C3424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3428: 483E6034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828C342C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3430: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3434: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3438: 4BB197A9  bl 0x823dcbe0
	ctx.lr = 0x828C343C;
	sub_823DCBE0(ctx, base);
	// 828C343C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3444: 419A0038  beq cr6, 0x828c347c
	if ctx.cr[6].eq {
	pc = 0x828C347C; continue 'dispatch;
	}
	// 828C3448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C344C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3450: 4B92CDF1  bl 0x821f0240
	ctx.lr = 0x828C3454;
	sub_821F0240(ctx, base);
	// 828C3454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3458: 4BB63341  bl 0x82426798
	ctx.lr = 0x828C345C;
	sub_82426798(ctx, base);
	// 828C345C: 907E0014  stw r3, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 828C3460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3464: 419A0018  beq cr6, 0x828c347c
	if ctx.cr[6].eq {
	pc = 0x828C347C; continue 'dispatch;
	}
	// 828C3468: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C346C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3470: 4BB62DF1  bl 0x82426260
	ctx.lr = 0x828C3474;
	sub_82426260(ctx, base);
	// 828C3474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3478: 4BFFFEE1  bl 0x828c3358
	ctx.lr = 0x828C347C;
	sub_828C3358(ctx, base);
	// 828C347C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3480: 483E5FDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3488 size=580
    let mut pc: u32 = 0x828C3488;
    'dispatch: loop {
        match pc {
            0x828C3488 => {
    //   block [0x828C3488..0x828C36CC)
	// 828C3488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C348C: 483E5F71  bl 0x82ca93fc
	ctx.lr = 0x828C3490;
	sub_82CA93D0(ctx, base);
	// 828C3490: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828C3494: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828C3498: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828C349C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C34A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C34A4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C34A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34AC: 419A020C  beq cr6, 0x828c36b8
	if ctx.cr[6].eq {
	pc = 0x828C36B8; continue 'dispatch;
	}
	// 828C34B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C34B4: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C34B8: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C34BC: 4BB19725  bl 0x823dcbe0
	ctx.lr = 0x828C34C0;
	sub_823DCBE0(ctx, base);
	// 828C34C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C34C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C34C8: 419A01F0  beq cr6, 0x828c36b8
	if ctx.cr[6].eq {
	pc = 0x828C36B8; continue 'dispatch;
	}
	// 828C34CC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C34D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34D4: 40990034  ble cr6, 0x828c3508
	if !ctx.cr[6].gt {
	pc = 0x828C3508; continue 'dispatch;
	}
	// 828C34D8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C34DC: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828C34E0: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C34E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C34E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C34EC: 409A0008  bne cr6, 0x828c34f4
	if !ctx.cr[6].eq {
	pc = 0x828C34F4; continue 'dispatch;
	}
	// 828C34F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C34F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C34F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34FC: 419A000C  beq cr6, 0x828c3508
	if ctx.cr[6].eq {
	pc = 0x828C3508; continue 'dispatch;
	}
	// 828C3500: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C3504: 48000008  b 0x828c350c
	pc = 0x828C350C; continue 'dispatch;
	// 828C3508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C350C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3514: 419A0180  beq cr6, 0x828c3694
	if ctx.cr[6].eq {
	pc = 0x828C3694; continue 'dispatch;
	}
	// 828C3518: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C351C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3520: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3524: 388B30AC  addi r4, r11, 0x30ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12460;
	// 828C3528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C352C: 4B9699A5  bl 0x8222ced0
	ctx.lr = 0x828C3530;
	sub_8222CED0(ctx, base);
	// 828C3530: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3534: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3538: 4BB63069  bl 0x824265a0
	ctx.lr = 0x828C353C;
	sub_824265A0(ctx, base);
	// 828C353C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C3540: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C3544: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3548: 388A30B4  addi r4, r10, 0x30b4
	ctx.r[4].s64 = ctx.r[10].s64 + 12468;
	// 828C354C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3554: 4B96997D  bl 0x8222ced0
	ctx.lr = 0x828C3558;
	sub_8222CED0(ctx, base);
	// 828C3558: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C355C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3560: 4BB63041  bl 0x824265a0
	ctx.lr = 0x828C3564;
	sub_824265A0(ctx, base);
	// 828C3564: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C3568: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C356C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3570: 388930C0  addi r4, r9, 0x30c0
	ctx.r[4].s64 = ctx.r[9].s64 + 12480;
	// 828C3574: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3578: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C357C: 4B969955  bl 0x8222ced0
	ctx.lr = 0x828C3580;
	sub_8222CED0(ctx, base);
	// 828C3580: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3584: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3588: 4BB63019  bl 0x824265a0
	ctx.lr = 0x828C358C;
	sub_824265A0(ctx, base);
	// 828C358C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3590: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C3594: 3B2BBE08  addi r25, r11, -0x41f8
	ctx.r[25].s64 = ctx.r[11].s64 + -16888;
	// 828C3598: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C359C: C3B9D67C  lfs f29, -0x2984(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-10628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C35A0: 40990034  ble cr6, 0x828c35d4
	if !ctx.cr[6].gt {
	pc = 0x828C35D4; continue 'dispatch;
	}
	// 828C35A4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C35A8: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828C35AC: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C35B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C35B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C35B8: 409A0008  bne cr6, 0x828c35c0
	if !ctx.cr[6].eq {
	pc = 0x828C35C0; continue 'dispatch;
	}
	// 828C35BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C35C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C35C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C35C8: 419A000C  beq cr6, 0x828c35d4
	if ctx.cr[6].eq {
	pc = 0x828C35D4; continue 'dispatch;
	}
	// 828C35CC: C3EB0020  lfs f31, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C35D0: 48000008  b 0x828c35d8
	pc = 0x828C35D8; continue 'dispatch;
	// 828C35D4: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 828C35D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C35DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C35E0: 4BB637A1  bl 0x82426d80
	ctx.lr = 0x828C35E4;
	sub_82426D80(ctx, base);
	// 828C35E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C35E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C35EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C35F0: 4BB63791  bl 0x82426d80
	ctx.lr = 0x828C35F4;
	sub_82426D80(ctx, base);
	// 828C35F4: C3D9D688  lfs f30, -0x2978(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-10616 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C35F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C35FC: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 828C3600: 409A0014  bne cr6, 0x828c3614
	if !ctx.cr[6].eq {
	pc = 0x828C3614; continue 'dispatch;
	}
	// 828C3604: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 828C3608: 419A0054  beq cr6, 0x828c365c
	if ctx.cr[6].eq {
	pc = 0x828C365C; continue 'dispatch;
	}
	// 828C360C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3610: 48000040  b 0x828c3650
	pc = 0x828C3650; continue 'dispatch;
	// 828C3614: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3618: 409A002C  bne cr6, 0x828c3644
	if !ctx.cr[6].eq {
	pc = 0x828C3644; continue 'dispatch;
	}
	// 828C361C: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 828C3620: 419A0014  beq cr6, 0x828c3634
	if ctx.cr[6].eq {
	pc = 0x828C3634; continue 'dispatch;
	}
	// 828C3624: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C362C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3630: 4BB63579  bl 0x82426ba8
	ctx.lr = 0x828C3634;
	sub_82426BA8(ctx, base);
	// 828C3634: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 828C3638: 419A003C  beq cr6, 0x828c3674
	if ctx.cr[6].eq {
	pc = 0x828C3674; continue 'dispatch;
	}
	// 828C363C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3640: 48000028  b 0x828c3668
	pc = 0x828C3668; continue 'dispatch;
	// 828C3644: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 828C3648: 419A0014  beq cr6, 0x828c365c
	if ctx.cr[6].eq {
	pc = 0x828C365C; continue 'dispatch;
	}
	// 828C364C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3654: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3658: 4BB63551  bl 0x82426ba8
	ctx.lr = 0x828C365C;
	sub_82426BA8(ctx, base);
	// 828C365C: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 828C3660: 419A0014  beq cr6, 0x828c3674
	if ctx.cr[6].eq {
	pc = 0x828C3674; continue 'dispatch;
	}
	// 828C3664: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C366C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C3670: 4BB63539  bl 0x82426ba8
	ctx.lr = 0x828C3674;
	sub_82426BA8(ctx, base);
	// 828C3674: EDBEF828  fsubs f13, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 828C3678: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C367C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3680: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3684: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C3688: 4BB63799  bl 0x82426e20
	ctx.lr = 0x828C368C;
	sub_82426E20(ctx, base);
	// 828C368C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3690: 4800001C  b 0x828c36ac
	pc = 0x828C36AC; continue 'dispatch;
	// 828C3694: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3698: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C369C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C36A0: C02BBE08  lfs f1, -0x41f8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16888 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C36A4: 4BB6377D  bl 0x82426e20
	ctx.lr = 0x828C36A8;
	sub_82426E20(ctx, base);
	// 828C36A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C36B0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C36B4: 4BB62BAD  bl 0x82426260
	ctx.lr = 0x828C36B8;
	sub_82426260(ctx, base);
	// 828C36B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C36BC: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828C36C0: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C36C4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828C36C8: 483E5D84  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C36D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C36D0 size=120
    let mut pc: u32 = 0x828C36D0;
    'dispatch: loop {
        match pc {
            0x828C36D0 => {
    //   block [0x828C36D0..0x828C3748)
	// 828C36D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C36D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C36D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C36DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C36E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C36E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C36E8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C36EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C36F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C36F4: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C36F8: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 828C36FC: 4B95B32D  bl 0x8221ea28
	ctx.lr = 0x828C3700;
	sub_8221EA28(ctx, base);
	// 828C3700: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C3704: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 828C3708: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C370C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C3710: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 828C3714: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 828C3718: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 828C371C: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 828C3720: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 828C3724: D11F0004  stfs f8, 4(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C3728: ECE8F82A  fadds f7, f8, f31
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[31].f64) as f32) as f64;
	// 828C372C: D0FF0008  stfs f7, 8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828C3730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C373C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C3740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3748 size=128
    let mut pc: u32 = 0x828C3748;
    'dispatch: loop {
        match pc {
            0x828C3748 => {
    //   block [0x828C3748..0x828C37C8)
	// 828C3748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C374C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3754: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C375C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 828C3760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3764: 419A004C  beq cr6, 0x828c37b0
	if ctx.cr[6].eq {
	pc = 0x828C37B0; continue 'dispatch;
	}
	// 828C3768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C376C: 4B95B2BD  bl 0x8221ea28
	ctx.lr = 0x828C3770;
	sub_8221EA28(ctx, base);
	// 828C3770: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C3774: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 828C3778: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C377C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C3780: C13F0008  lfs f9, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828C3784: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C3788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C378C: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 828C3790: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 828C3794: C1899484  lfs f12, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3798: FD0A0028  fsub f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 - ctx.f[0].f64;
	// 828C379C: FCE86824  fdiv f7, f8, f13
	ctx.f[7].f64 = ctx.f[8].f64 / ctx.f[13].f64;
	// 828C37A0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 828C37A4: ECA93028  fsubs f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 828C37A8: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 828C37AC: 40990008  ble cr6, 0x828c37b4
	if !ctx.cr[6].gt {
	pc = 0x828C37B4; continue 'dispatch;
	}
	// 828C37B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C37B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C37B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C37BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C37C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C37C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C37C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C37C8 size=328
    let mut pc: u32 = 0x828C37C8;
    'dispatch: loop {
        match pc {
            0x828C37C8 => {
    //   block [0x828C37C8..0x828C3910)
	// 828C37C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C37CC: 483E5C41  bl 0x82ca940c
	ctx.lr = 0x828C37D0;
	sub_82CA93D0(ctx, base);
	// 828C37D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C37D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C37D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C37DC: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 828C37E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C37E4: 419A0030  beq cr6, 0x828c3814
	if ctx.cr[6].eq {
	pc = 0x828C3814; continue 'dispatch;
	}
	// 828C37E8: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C37EC: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C37F0: C19F002C  lfs f12, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C37F4: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C37F8: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C37FC: ED2C6AFA  fmadds f9, f12, f11, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 828C3800: C11F0014  lfs f8, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C3804: ECEA023A  fmadds f7, f10, f8, f0
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 828C3808: D13F0018  stfs f9, 0x18(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C380C: D0FF001C  stfs f7, 0x1c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828C3810: 4800002C  b 0x828c383c
	pc = 0x828C383C; continue 'dispatch;
	// 828C3814: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 828C3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C381C: 4BFFFF2D  bl 0x828c3748
	ctx.lr = 0x828C3820;
	sub_828C3748(ctx, base);
	// 828C3820: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C3824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3828: 419A0014  beq cr6, 0x828c383c
	if ctx.cr[6].eq {
	pc = 0x828C383C; continue 'dispatch;
	}
	// 828C382C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3830: 9BBE0000  stb r29, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C3834: 9BBE0001  stb r29, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[29].u8 ) };
	// 828C3838: 997F0029  stb r11, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[11].u8 ) };
	// 828C383C: E93F0018  ld r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C3840: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3844: E91F0020  ld r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828C3848: 394BB46C  addi r10, r11, -0x4b94
	ctx.r[10].s64 = ctx.r[11].s64 + -19348;
	// 828C384C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828C3850: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3854: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828C3858: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C385C: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3860: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C3864: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 828C3868: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 828C386C: C00AE060  lfs f0, -0x1fa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3870: FD005210  fabs f8, f10
	ctx.f[8].u64 = ctx.f[10].u64 & !0x8000_0000_0000_0000u64;
	// 828C3874: FDA04A10  fabs f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 & !0x8000_0000_0000_0000u64;
	// 828C3878: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 828C387C: 40980010  bge cr6, 0x828c388c
	if !ctx.cr[6].lt {
	pc = 0x828C388C; continue 'dispatch;
	}
	// 828C3880: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C3884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3888: 41980008  blt cr6, 0x828c3890
	if ctx.cr[6].lt {
	pc = 0x828C3890; continue 'dispatch;
	}
	// 828C388C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828C3890: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3898: 409A0070  bne cr6, 0x828c3908
	if !ctx.cr[6].eq {
	pc = 0x828C3908; continue 'dispatch;
	}
	// 828C389C: E97F0020  ld r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828C38A0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828C38A4: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C38A8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C38AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828C38B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C38B4: C1210054  lfs f9, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828C38B8: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 828C38BC: C0C10064  lfs f6, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828C38C0: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828C38C4: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C38C8: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C38CC: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C38D0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C38D4: C10B0080  lfs f8, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C38D8: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C38DC: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C38E0: EC8C6828  fsubs f4, f12, f13
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 828C38E4: ECA64828  fsubs f5, f6, f9
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 828C38E8: EC4401F2  fmuls f2, f4, f7
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[7].f64) as f32) as f64);
	// 828C38EC: EC6501F2  fmuls f3, f5, f7
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[7].f64) as f32) as f64);
	// 828C38F0: EC0B102A  fadds f0, f11, f2
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[2].f64) as f32) as f64;
	// 828C38F4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C38F8: EC23502A  fadds f1, f3, f10
	ctx.f[1].f64 = ((ctx.f[3].f64 + ctx.f[10].f64) as f32) as f64;
	// 828C38FC: D0210064  stfs f1, 0x64(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C3900: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C3904: F8DF0020  std r6, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[6].u64 ) };
	// 828C3908: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C390C: 483E5B50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3910 size=220
    let mut pc: u32 = 0x828C3910;
    'dispatch: loop {
        match pc {
            0x828C3910 => {
    //   block [0x828C3910..0x828C39EC)
	// 828C3910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C391C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C3920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3924: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C392C: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 828C3930: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3934: 409A000C  bne cr6, 0x828c3940
	if !ctx.cr[6].eq {
	pc = 0x828C3940; continue 'dispatch;
	}
	// 828C3938: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C393C: 48000008  b 0x828c3944
	pc = 0x828C3944; continue 'dispatch;
	// 828C3940: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3944: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C3948: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 828C394C: CBEA0DF0  lfd f31, 0xdf0(r10)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3568 as u32) ) };
	// 828C3950: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828C3954: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C3958: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828C395C: 4B93AB4D  bl 0x821fe4a8
	ctx.lr = 0x828C3960;
	sub_821FE4A8(ctx, base);
	// 828C3960: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3964: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3968: FD800818  frsp f12, f1
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C396C: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828C3970: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C3974: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828C3978: EFEB0332  fmuls f31, f11, f12
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 828C397C: 4B93AB2D  bl 0x821fe4a8
	ctx.lr = 0x828C3980;
	sub_821FE4A8(ctx, base);
	// 828C3980: C15F000C  lfs f10, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C3984: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3988: C11F0004  lfs f8, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C398C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3990: ECEA0232  fmuls f7, f10, f8
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[8].f64) as f32) as f64);
	// 828C3994: C0DF0018  lfs f6, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828C3998: 396BD5C8  addi r11, r11, -0x2a38
	ctx.r[11].s64 = ctx.r[11].s64 + -10808;
	// 828C399C: C0BF001C  lfs f5, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828C39A0: 891F0028  lbz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C39A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C39A8: 98FF0029  stb r7, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[7].u8 ) };
	// 828C39AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C39B0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C39B4: EC9F303A  fmadds f4, f31, f0, f6
	ctx.f[4].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 828C39B8: D09F0018  stfs f4, 0x18(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C39BC: EC672A7A  fmadds f3, f7, f9, f5
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828C39C0: D07F001C  stfs f3, 0x1c(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828C39C4: 419A0010  beq cr6, 0x828c39d4
	if ctx.cr[6].eq {
	pc = 0x828C39D4; continue 'dispatch;
	}
	// 828C39C8: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828C39CC: C02BE1DC  lfs f1, -0x1e24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C39D0: 4BFFFD01  bl 0x828c36d0
	ctx.lr = 0x828C39D4;
	sub_828C36D0(ctx, base);
	// 828C39D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C39D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C39DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C39E0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C39E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C39E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C39F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C39F0 size=320
    let mut pc: u32 = 0x828C39F0;
    'dispatch: loop {
        match pc {
            0x828C39F0 => {
    //   block [0x828C39F0..0x828C3B30)
	// 828C39F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C39F4: 483E5A15  bl 0x82ca9408
	ctx.lr = 0x828C39F8;
	sub_82CA93D0(ctx, base);
	// 828C39F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C39FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3A00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3A04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C3A08: 419A0120  beq cr6, 0x828c3b28
	if ctx.cr[6].eq {
	pc = 0x828C3B28; continue 'dispatch;
	}
	// 828C3A0C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828C3A10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3A14: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 828C3A18: 816AC844  lwz r11, -0x37bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14268 as u32) ) } as u64;
	// 828C3A1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C3A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A24: 419A0008  beq cr6, 0x828c3a2c
	if ctx.cr[6].eq {
	pc = 0x828C3A2C; continue 'dispatch;
	}
	// 828C3A28: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3A34: 4BEBF9E5  bl 0x82783418
	ctx.lr = 0x828C3A38;
	sub_82783418(ctx, base);
	// 828C3A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3A3C: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3A40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C3A48: 419A0014  beq cr6, 0x828c3a5c
	if ctx.cr[6].eq {
	pc = 0x828C3A5C; continue 'dispatch;
	}
	// 828C3A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3A50: 48000589  bl 0x828c3fd8
	ctx.lr = 0x828C3A54;
	sub_828C3FD8(ctx, base);
	// 828C3A54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A58: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828C3A5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3A60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3A64: 816BC848  lwz r11, -0x37b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14264 as u32) ) } as u64;
	// 828C3A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A6C: 419A0008  beq cr6, 0x828c3a74
	if ctx.cr[6].eq {
	pc = 0x828C3A74; continue 'dispatch;
	}
	// 828C3A70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A74: 38BD0050  addi r5, r29, 0x50
	ctx.r[5].s64 = ctx.r[29].s64 + 80;
	// 828C3A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3A7C: 4BBF8955  bl 0x824bc3d0
	ctx.lr = 0x828C3A80;
	sub_824BC3D0(ctx, base);
	// 828C3A80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3A84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3A88: 816BC84C  lwz r11, -0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14260 as u32) ) } as u64;
	// 828C3A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A90: 419A0008  beq cr6, 0x828c3a98
	if ctx.cr[6].eq {
	pc = 0x828C3A98; continue 'dispatch;
	}
	// 828C3A94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A98: 38BD0060  addi r5, r29, 0x60
	ctx.r[5].s64 = ctx.r[29].s64 + 96;
	// 828C3A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AA0: 4BBF8931  bl 0x824bc3d0
	ctx.lr = 0x828C3AA4;
	sub_824BC3D0(ctx, base);
	// 828C3AA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3AA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3AAC: 816BC850  lwz r11, -0x37b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 828C3AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3AB4: 419A0008  beq cr6, 0x828c3abc
	if ctx.cr[6].eq {
	pc = 0x828C3ABC; continue 'dispatch;
	}
	// 828C3AB8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3ABC: 38BD0070  addi r5, r29, 0x70
	ctx.r[5].s64 = ctx.r[29].s64 + 112;
	// 828C3AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AC4: 4BAE992D  bl 0x823ad3f0
	ctx.lr = 0x828C3AC8;
	sub_823AD3F0(ctx, base);
	// 828C3AC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3ACC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3AD0: 816BC854  lwz r11, -0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14252 as u32) ) } as u64;
	// 828C3AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3AD8: 419A0008  beq cr6, 0x828c3ae0
	if ctx.cr[6].eq {
	pc = 0x828C3AE0; continue 'dispatch;
	}
	// 828C3ADC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3AE0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C3AE4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C3AE8: 4B930271  bl 0x821f3d58
	ctx.lr = 0x828C3AEC;
	sub_821F3D58(ctx, base);
	// 828C3AEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AF4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3AF8: 4813CBD1  bl 0x82a006c8
	ctx.lr = 0x828C3AFC;
	sub_82A006C8(ctx, base);
	// 828C3AFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3B00: 419A0010  beq cr6, 0x828c3b10
	if ctx.cr[6].eq {
	pc = 0x828C3B10; continue 'dispatch;
	}
	// 828C3B04: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3B0C: 4800000C  b 0x828c3b18
	pc = 0x828C3B18; continue 'dispatch;
	// 828C3B10: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C3B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3B18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3B20: 419A0008  beq cr6, 0x828c3b28
	if ctx.cr[6].eq {
	pc = 0x828C3B28; continue 'dispatch;
	}
	// 828C3B24: 915D0078  stw r10, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828C3B28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3B2C: 483E592C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3B30 size=324
    let mut pc: u32 = 0x828C3B30;
    'dispatch: loop {
        match pc {
            0x828C3B30 => {
    //   block [0x828C3B30..0x828C3C74)
	// 828C3B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3B34: 483E58D9  bl 0x82ca940c
	ctx.lr = 0x828C3B38;
	sub_82CA93D0(ctx, base);
	// 828C3B38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3B3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3B40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3B44: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828C3B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3B4C: 38EAF11C  addi r7, r10, -0xee4
	ctx.r[7].s64 = ctx.r[10].s64 + -3812;
	// 828C3B50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B54: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3B58: 4B8EE9A1  bl 0x821b24f8
	ctx.lr = 0x828C3B5C;
	sub_821B24F8(ctx, base);
	// 828C3B5C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3B60: 4B9E5E89  bl 0x822a99e8
	ctx.lr = 0x828C3B64;
	sub_822A99E8(ctx, base);
	// 828C3B64: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 828C3B68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C3B6C: 39267088  addi r9, r6, 0x7088
	ctx.r[9].s64 = ctx.r[6].s64 + 28808;
	// 828C3B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3B74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C3B78: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 828C3B7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3B80: 7CA04828  lwarx r5, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828C3B84: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828C3B88: 7CA0492D  stwcx. r5, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C3B8C: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3B90: 4082FFE8  bne 0x828c3b78
	if !ctx.cr[0].eq {
	pc = 0x828C3B78; continue 'dispatch;
	}
	// 828C3B94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3B98: 419A000C  beq cr6, 0x828c3ba4
	if ctx.cr[6].eq {
	pc = 0x828C3BA4; continue 'dispatch;
	}
	// 828C3B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3BA0: 4BFFFE51  bl 0x828c39f0
	ctx.lr = 0x828C3BA4;
	sub_828C39F0(ctx, base);
	// 828C3BA4: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BAC: 419900B8  bgt cr6, 0x828c3c64
	if ctx.cr[6].gt {
	pc = 0x828C3C64; continue 'dispatch;
	}
	// 828C3BB0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828C3BB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3BB8: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 828C3BBC: 816AC858  lwz r11, -0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14248 as u32) ) } as u64;
	// 828C3BC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828C3BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BC8: 419A0008  beq cr6, 0x828c3bd0
	if ctx.cr[6].eq {
	pc = 0x828C3BD0; continue 'dispatch;
	}
	// 828C3BCC: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3BD4: 4B8EE925  bl 0x821b24f8
	ctx.lr = 0x828C3BD8;
	sub_821B24F8(ctx, base);
	// 828C3BD8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3BDC: 4B9E5E0D  bl 0x822a99e8
	ctx.lr = 0x828C3BE0;
	sub_822A99E8(ctx, base);
	// 828C3BE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3BE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3BE8: 409A0038  bne cr6, 0x828c3c20
	if !ctx.cr[6].eq {
	pc = 0x828C3C20; continue 'dispatch;
	}
	// 828C3BEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3BF0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828C3BF4: 816BC85C  lwz r11, -0x37a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14244 as u32) ) } as u64;
	// 828C3BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BFC: 419A0008  beq cr6, 0x828c3c04
	if ctx.cr[6].eq {
	pc = 0x828C3C04; continue 'dispatch;
	}
	// 828C3C00: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3C08: 4B8EE8F1  bl 0x821b24f8
	ctx.lr = 0x828C3C0C;
	sub_821B24F8(ctx, base);
	// 828C3C0C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3C10: 4B9E5DD9  bl 0x822a99e8
	ctx.lr = 0x828C3C14;
	sub_822A99E8(ctx, base);
	// 828C3C14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3C18: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3C1C: 419A0048  beq cr6, 0x828c3c64
	if ctx.cr[6].eq {
	pc = 0x828C3C64; continue 'dispatch;
	}
	// 828C3C20: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3C24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3C28: 816BC860  lwz r11, -0x37a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14240 as u32) ) } as u64;
	// 828C3C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3C30: 419A0008  beq cr6, 0x828c3c38
	if ctx.cr[6].eq {
	pc = 0x828C3C38; continue 'dispatch;
	}
	// 828C3C34: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3C3C: 4BEBF7DD  bl 0x82783418
	ctx.lr = 0x828C3C40;
	sub_82783418(ctx, base);
	// 828C3C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3C44: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3C48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C3C50: 419A0014  beq cr6, 0x828c3c64
	if ctx.cr[6].eq {
	pc = 0x828C3C64; continue 'dispatch;
	}
	// 828C3C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3C58: 48000381  bl 0x828c3fd8
	ctx.lr = 0x828C3C5C;
	sub_828C3FD8(ctx, base);
	// 828C3C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C60: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828C3C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3C68: 4B951171  bl 0x82214dd8
	ctx.lr = 0x828C3C6C;
	sub_82214DD8(ctx, base);
	// 828C3C6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3C70: 483E57EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3C78 size=860
    let mut pc: u32 = 0x828C3C78;
    'dispatch: loop {
        match pc {
            0x828C3C78 => {
    //   block [0x828C3C78..0x828C3D58)
	// 828C3C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3C7C: 483E578D  bl 0x82ca9408
	ctx.lr = 0x828C3C80;
	sub_82CA93D0(ctx, base);
	// 828C3C80: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828C3C84: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C3C88: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3C8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3C90: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C3C94: 3B9D007C  addi r28, r29, 0x7c
	ctx.r[28].s64 = ctx.r[29].s64 + 124;
	// 828C3C98: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3CA0: 40990324  ble cr6, 0x828c3fc4
	if !ctx.cr[6].gt {
	pc = 0x828C3FC4; continue 'dispatch;
	}
	// 828C3CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3CA8: 4B92C599  bl 0x821f0240
	ctx.lr = 0x828C3CAC;
	sub_821F0240(ctx, base);
	// 828C3CAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3CB0: 4BB62AE9  bl 0x82426798
	ctx.lr = 0x828C3CB4;
	sub_82426798(ctx, base);
	// 828C3CB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3CB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3CBC: 419A0308  beq cr6, 0x828c3fc4
	if ctx.cr[6].eq {
	pc = 0x828C3FC4; continue 'dispatch;
	}
	// 828C3CC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3CC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3CC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C3CCC: 4BB616D5  bl 0x824253a0
	ctx.lr = 0x828C3CD0;
	sub_824253A0(ctx, base);
	// 828C3CD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3CD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3CD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C3CDC: 4BB618FD  bl 0x824255d8
	ctx.lr = 0x828C3CE0;
	sub_824255D8(ctx, base);
	// 828C3CE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3CE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3CE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C3CEC: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 828C3CF0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3CF4: C3CB9490  lfs f30, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C3CF8: C3EAFFF4  lfs f31, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C3CFC: 419A0144  beq cr6, 0x828c3e40
	if ctx.cr[6].eq {
	pc = 0x828C3E40; continue 'dispatch;
	}
	// 828C3D00: 817D0078  lwz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3D04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3D08: 40990010  ble cr6, 0x828c3d18
	if !ctx.cr[6].gt {
	pc = 0x828C3D18; continue 'dispatch;
	}
	// 828C3D0C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C3D10: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C3D14: 40990008  ble cr6, 0x828c3d1c
	if !ctx.cr[6].gt {
	pc = 0x828C3D1C; continue 'dispatch;
	}
	// 828C3D18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C3D1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C3D20: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 828C3D24: 419900C8  bgt cr6, 0x828c3dec
	if ctx.cr[6].gt {
	pc = 0x828C3DEC; continue 'dispatch;
	}
	// 828C3D28: 3D80828C  lis r12, -0x7d74
	ctx.r[12].s64 = -2104754176;
	// 828C3D2C: 398C3D40  addi r12, r12, 0x3d40
	ctx.r[12].s64 = ctx.r[12].s64 + 15680;
	// 828C3D30: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828C3D34: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828C3D38: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828C3D3C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x828C3D58; continue 'dispatch;
		},
		1 => {
	pc = 0x828C3D8C; continue 'dispatch;
		},
		2 => {
	pc = 0x828C3DB8; continue 'dispatch;
		},
		3 => {
	pc = 0x828C3D58; continue 'dispatch;
		},
		4 => {
	pc = 0x828C3D8C; continue 'dispatch;
		},
		5 => {
	pc = 0x828C3DB8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 828C3D40: 828C3D58  lwz r20, 0x3d58(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15704 as u32) ) } as u64;
	// 828C3D44: 828C3D8C  lwz r20, 0x3d8c(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15756 as u32) ) } as u64;
	// 828C3D48: 828C3DB8  lwz r20, 0x3db8(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15800 as u32) ) } as u64;
	// 828C3D4C: 828C3D58  lwz r20, 0x3d58(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15704 as u32) ) } as u64;
	// 828C3D50: 828C3D8C  lwz r20, 0x3d8c(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15756 as u32) ) } as u64;
	// 828C3D54: 828C3DB8  lwz r20, 0x3db8(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15800 as u32) ) } as u64;
            }
            0x828C3D58 => {
    //   block [0x828C3D58..0x828C3D8C)
	// 828C3D58: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3D5C: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3D60: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3D64: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3D68: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3D6C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3D70: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3D74: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3D78: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3D7C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C3D80: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828C3D84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828C3D88: 48000088  b 0x828c3e10
	pc = 0x828C3E10; continue 'dispatch;
            }
            0x828C3D8C => {
    //   block [0x828C3D8C..0x828C3DB8)
	// 828C3D8C: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3D90: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3D94: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3D98: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3D9C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DA0: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3DA4: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3DA8: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C3DAC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DB0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828C3DB4: 48000054  b 0x828c3e08
	pc = 0x828C3E08; continue 'dispatch;
            }
            0x828C3DB8 => {
    //   block [0x828C3DB8..0x828C3FD4)
	// 828C3DB8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3DBC: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3DC0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3DC4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DC8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3DCC: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DD0: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3DD4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C3DD8: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3DDC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3DE0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828C3DE4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828C3DE8: 48000028  b 0x828c3e10
	pc = 0x828C3E10; continue 'dispatch;
	// 828C3DEC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DF0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3DF4: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3DF8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DFC: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 828C3E00: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3E04: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828C3E08: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3E0C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828C3E10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C3E14: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828C3E18: 4815FC49  bl 0x82a23a60
	ctx.lr = 0x828C3E1C;
	sub_82A23A60(ctx, base);
	// 828C3E1C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828C3E20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C3E24: 4B8EC245  bl 0x821b0068
	ctx.lr = 0x828C3E28;
	sub_821B0068(ctx, base);
	// 828C3E28: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C3E2C: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 828C3E30: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 828C3E34: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828C3E38: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828C3E3C: 4800002C  b 0x828c3e68
	pc = 0x828C3E68; continue 'dispatch;
	// 828C3E40: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C3E44: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C3E48: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828C3E4C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828C3E50: 390A9160  addi r8, r10, -0x6ea0
	ctx.r[8].s64 = ctx.r[10].s64 + -28320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3FD8 size=120
    let mut pc: u32 = 0x828C3FD8;
    'dispatch: loop {
        match pc {
            0x828C3FD8 => {
    //   block [0x828C3FD8..0x828C4050)
	// 828C3FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3FE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3FE8: 89630040  lbz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C3FEC: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828C3FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3FF4: 419A0048  beq cr6, 0x828c403c
	if ctx.cr[6].eq {
	pc = 0x828C403C; continue 'dispatch;
	}
	// 828C3FF8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C3FFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4000: 995F0030  stb r10, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 828C4004: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828C4008: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C400C: 419A0028  beq cr6, 0x828c4034
	if ctx.cr[6].eq {
	pc = 0x828C4034; continue 'dispatch;
	}
	// 828C4010: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C4014: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C4018: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C401C: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 828C4020: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C4024: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C4028: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C402C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4030: 481D3339  bl 0x82a97368
	ctx.lr = 0x828C4034;
	sub_82A97368(ctx, base);
	// 828C4034: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828C4038: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 828C403C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4048: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C404C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C4050 size=12
    let mut pc: u32 = 0x828C4050;
    'dispatch: loop {
        match pc {
            0x828C4050 => {
    //   block [0x828C4050..0x828C405C)
	// 828C4050: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C4054: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828C4058: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C405C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C405C size=8
    let mut pc: u32 = 0x828C405C;
    'dispatch: loop {
        match pc {
            0x828C405C => {
    //   block [0x828C405C..0x828C4064)
	// 828C405C: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 828C4060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4068 size=424
    let mut pc: u32 = 0x828C4068;
    'dispatch: loop {
        match pc {
            0x828C4068 => {
    //   block [0x828C4068..0x828C4210)
	// 828C4068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C406C: 483E53A1  bl 0x82ca940c
	ctx.lr = 0x828C4070;
	sub_82CA93D0(ctx, base);
	// 828C4070: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4074: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C4078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C407C: 3BABA1F0  addi r29, r11, -0x5e10
	ctx.r[29].s64 = ctx.r[11].s64 + -24080;
	// 828C4080: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4088: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C408C: 4B968E45  bl 0x8222ced0
	ctx.lr = 0x828C4090;
	sub_8222CED0(ctx, base);
	// 828C4090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4094: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4098: 48000861  bl 0x828c48f8
	ctx.lr = 0x828C409C;
	sub_828C48F8(ctx, base);
	// 828C409C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40A0: 4B950D39  bl 0x82214dd8
	ctx.lr = 0x828C40A4;
	sub_82214DD8(ctx, base);
	// 828C40A4: 3D40822D  lis r10, -0x7dd3
	ctx.r[10].s64 = -2110980096;
	// 828C40A8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C40AC: 390A1A30  addi r8, r10, 0x1a30
	ctx.r[8].s64 = ctx.r[10].s64 + 6704;
	// 828C40B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C40B4: 38893140  addi r4, r9, 0x3140
	ctx.r[4].s64 = ctx.r[9].s64 + 12608;
	// 828C40B8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C40BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C40C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C40C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C40C8: 4B968E09  bl 0x8222ced0
	ctx.lr = 0x828C40CC;
	sub_8222CED0(ctx, base);
	// 828C40CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C40D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C40D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40D8: 4B968DF9  bl 0x8222ced0
	ctx.lr = 0x828C40DC;
	sub_8222CED0(ctx, base);
	// 828C40DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C40E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C40E4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C40E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C40EC: 48000A55  bl 0x828c4b40
	ctx.lr = 0x828C40F0;
	sub_828C4B40(ctx, base);
	// 828C40F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40F4: 4B950CE5  bl 0x82214dd8
	ctx.lr = 0x828C40F8;
	sub_82214DD8(ctx, base);
	// 828C40F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C40FC: 4B950CDD  bl 0x82214dd8
	ctx.lr = 0x828C4100;
	sub_82214DD8(ctx, base);
	// 828C4100: 3CE0828C  lis r7, -0x7d74
	ctx.r[7].s64 = -2104754176;
	// 828C4104: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C4108: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C410C: 386748E0  addi r3, r7, 0x48e0
	ctx.r[3].s64 = ctx.r[7].s64 + 18656;
	// 828C4110: 38863150  addi r4, r6, 0x3150
	ctx.r[4].s64 = ctx.r[6].s64 + 12624;
	// 828C4114: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C4118: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C411C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4120: 4B968DB1  bl 0x8222ced0
	ctx.lr = 0x828C4124;
	sub_8222CED0(ctx, base);
	// 828C4124: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C4128: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C412C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C4130: 4B968DA1  bl 0x8222ced0
	ctx.lr = 0x828C4134;
	sub_8222CED0(ctx, base);
	// 828C4134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4138: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C413C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4140: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C4144: 480009FD  bl 0x828c4b40
	ctx.lr = 0x828C4148;
	sub_828C4B40(ctx, base);
	// 828C4148: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C414C: 4B950C8D  bl 0x82214dd8
	ctx.lr = 0x828C4150;
	sub_82214DD8(ctx, base);
	// 828C4150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4154: 4B950C85  bl 0x82214dd8
	ctx.lr = 0x828C4158;
	sub_82214DD8(ctx, base);
	// 828C4158: 3D60831C  lis r11, -0x7ce4
	ctx.r[11].s64 = -2095316992;
	// 828C415C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C4160: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C4164: 392BC060  addi r9, r11, -0x3fa0
	ctx.r[9].s64 = ctx.r[11].s64 + -16288;
	// 828C4168: 388A3158  addi r4, r10, 0x3158
	ctx.r[4].s64 = ctx.r[10].s64 + 12632;
	// 828C416C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4170: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828C4174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4178: 4B968D59  bl 0x8222ced0
	ctx.lr = 0x828C417C;
	sub_8222CED0(ctx, base);
	// 828C417C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C4180: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4184: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C4188: 4B968D49  bl 0x8222ced0
	ctx.lr = 0x828C418C;
	sub_8222CED0(ctx, base);
	// 828C418C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C4190: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C4194: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C419C: 48000BB5  bl 0x828c4d50
	ctx.lr = 0x828C41A0;
	sub_828C4D50(ctx, base);
	// 828C41A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41A4: 4B950C35  bl 0x82214dd8
	ctx.lr = 0x828C41A8;
	sub_82214DD8(ctx, base);
	// 828C41A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C41AC: 4B950C2D  bl 0x82214dd8
	ctx.lr = 0x828C41B0;
	sub_82214DD8(ctx, base);
	// 828C41B0: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C41B4: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828C41B8: 38C84050  addi r6, r8, 0x4050
	ctx.r[6].s64 = ctx.r[8].s64 + 16464;
	// 828C41BC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C41C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C41C4: 38873164  addi r4, r7, 0x3164
	ctx.r[4].s64 = ctx.r[7].s64 + 12644;
	// 828C41C8: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 828C41CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C41D0: 4B968D01  bl 0x8222ced0
	ctx.lr = 0x828C41D4;
	sub_8222CED0(ctx, base);
	// 828C41D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C41D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C41DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41E0: 4B968CF1  bl 0x8222ced0
	ctx.lr = 0x828C41E4;
	sub_8222CED0(ctx, base);
	// 828C41E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C41E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C41EC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C41F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C41F4: 48000D6D  bl 0x828c4f60
	ctx.lr = 0x828C41F8;
	sub_828C4F60(ctx, base);
	// 828C41F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41FC: 4B950BDD  bl 0x82214dd8
	ctx.lr = 0x828C4200;
	sub_82214DD8(ctx, base);
	// 828C4200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4204: 4B950BD5  bl 0x82214dd8
	ctx.lr = 0x828C4208;
	sub_82214DD8(ctx, base);
	// 828C4208: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C420C: 483E5250  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4210 size=432
    let mut pc: u32 = 0x828C4210;
    'dispatch: loop {
        match pc {
            0x828C4210 => {
    //   block [0x828C4210..0x828C43C0)
	// 828C4210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C421C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4228: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C422C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C4230: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828C4234: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C4238: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 828C423C: 5507063E  clrlwi r7, r8, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828C4240: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C4244: 419A0154  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4248: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C424C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C4250: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 828C4254: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C4258: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 828C425C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C4260: 419A00F4  beq cr6, 0x828c4354
	if ctx.cr[6].eq {
	pc = 0x828C4354; continue 'dispatch;
	}
	// 828C4264: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C4268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C426C: 419A0024  beq cr6, 0x828c4290
	if ctx.cr[6].eq {
	pc = 0x828C4290; continue 'dispatch;
	}
	// 828C4270: 894A0084  lbz r10, 0x84(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C4274: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4278: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C427C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C4280: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4284: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C4288: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C428C: 480000CC  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
	// 828C4290: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4294: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C4298: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828C429C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C42A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C42A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C42A8: 40810054  ble 0x828c42fc
	if !ctx.cr[0].gt {
	pc = 0x828C42FC; continue 'dispatch;
	}
	// 828C42AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C42B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C42B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C42B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C42BC: 2F070084  cmpwi cr6, r7, 0x84
	ctx.cr[6].compare_i32(ctx.r[7].s32, 132, &mut ctx.xer);
	// 828C42C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C42C4: 41980008  blt cr6, 0x828c42cc
	if ctx.cr[6].lt {
	pc = 0x828C42CC; continue 'dispatch;
	}
	// 828C42C8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828C42CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C42D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C42D4: 419A0014  beq cr6, 0x828c42e8
	if ctx.cr[6].eq {
	pc = 0x828C42E8; continue 'dispatch;
	}
	// 828C42D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C42DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C42E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C42E4: 4800000C  b 0x828c42f0
	pc = 0x828C42F0; continue 'dispatch;
	// 828C42E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C42EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C42F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C42F4: 4199FFB8  bgt cr6, 0x828c42ac
	if ctx.cr[6].gt {
	pc = 0x828C42AC; continue 'dispatch;
	}
	// 828C42F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C42FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C4300: 419A0040  beq cr6, 0x828c4340
	if ctx.cr[6].eq {
	pc = 0x828C4340; continue 'dispatch;
	}
	// 828C4304: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4308: 2F0B0084  cmpwi cr6, r11, 0x84
	ctx.cr[6].compare_i32(ctx.r[11].s32, 132, &mut ctx.xer);
	// 828C430C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4310: 41990008  bgt cr6, 0x828c4318
	if ctx.cr[6].gt {
	pc = 0x828C4318; continue 'dispatch;
	}
	// 828C4314: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828C4318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C431C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4320: 409A0020  bne cr6, 0x828c4340
	if !ctx.cr[6].eq {
	pc = 0x828C4340; continue 'dispatch;
	}
	// 828C4324: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4328: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C432C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C4330: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4334: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C4338: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C433C: 4800001C  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
	// 828C4340: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C4344: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4348: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C434C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4350: 48000008  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
	// 828C4354: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828C4358: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C435C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4360: 419A0038  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4364: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4368: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 828C436C: 4802A6CD  bl 0x828eea38
	ctx.lr = 0x828C4370;
	sub_828EEA38(ctx, base);
	// 828C4370: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C4374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4378: 419A0020  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C437C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C4380: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 828C4384: 4802A6B5  bl 0x828eea38
	ctx.lr = 0x828C4388;
	sub_828EEA38(ctx, base);
	// 828C4388: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C438C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4390: 409A0008  bne cr6, 0x828c4398
	if !ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4394: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 828C4398: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C439C: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 828C43A0: 419A0008  beq cr6, 0x828c43a8
	if ctx.cr[6].eq {
	pc = 0x828C43A8; continue 'dispatch;
	}
	// 828C43A4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828C43A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C43AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C43B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C43B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C43B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C43BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C43C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C43C0 size=392
    let mut pc: u32 = 0x828C43C0;
    'dispatch: loop {
        match pc {
            0x828C43C0 => {
    //   block [0x828C43C0..0x828C4548)
	// 828C43C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C43C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C43C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C43CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C43D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C43D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C43D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C43DC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C43E0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828C43E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C43E8: 419A00F8  beq cr6, 0x828c44e0
	if ctx.cr[6].eq {
	pc = 0x828C44E0; continue 'dispatch;
	}
	// 828C43EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C43F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C43F4: 419A0024  beq cr6, 0x828c4418
	if ctx.cr[6].eq {
	pc = 0x828C4418; continue 'dispatch;
	}
	// 828C43F8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828C43FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4400: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C4404: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C4408: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C440C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C4410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4414: 480000D4  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
	// 828C4418: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C441C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4420: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C4424: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C4428: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C442C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C4430: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4434: 40810054  ble 0x828c4488
	if !ctx.cr[0].gt {
	pc = 0x828C4488; continue 'dispatch;
	}
	// 828C4438: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C443C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C4440: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C4444: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4448: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828C444C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C4450: 41980008  blt cr6, 0x828c4458
	if ctx.cr[6].lt {
	pc = 0x828C4458; continue 'dispatch;
	}
	// 828C4454: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C4458: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C445C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C4460: 419A0014  beq cr6, 0x828c4474
	if ctx.cr[6].eq {
	pc = 0x828C4474; continue 'dispatch;
	}
	// 828C4464: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C4468: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C446C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4470: 4800000C  b 0x828c447c
	pc = 0x828C447C; continue 'dispatch;
	// 828C4474: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C4478: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C447C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4480: 4199FFB8  bgt cr6, 0x828c4438
	if ctx.cr[6].gt {
	pc = 0x828C4438; continue 'dispatch;
	}
	// 828C4484: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C4488: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C448C: 419A0040  beq cr6, 0x828c44cc
	if ctx.cr[6].eq {
	pc = 0x828C44CC; continue 'dispatch;
	}
	// 828C4490: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4494: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828C4498: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C449C: 41990008  bgt cr6, 0x828c44a4
	if ctx.cr[6].gt {
	pc = 0x828C44A4; continue 'dispatch;
	}
	// 828C44A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C44A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C44A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C44AC: 409A0020  bne cr6, 0x828c44cc
	if !ctx.cr[6].eq {
	pc = 0x828C44CC; continue 'dispatch;
	}
	// 828C44B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C44B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C44B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C44BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C44C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C44C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C44C8: 48000020  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
	// 828C44CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C44D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C44D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C44D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C44DC: 4800000C  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
	// 828C44E0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C44E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C44E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C44EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C44F0: 419A0034  beq cr6, 0x828c4524
	if ctx.cr[6].eq {
	pc = 0x828C4524; continue 'dispatch;
	}
	// 828C44F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C44F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C44FC: 388B2EEC  addi r4, r11, 0x2eec
	ctx.r[4].s64 = ctx.r[11].s64 + 12012;
	// 828C4500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4504: 4B9689CD  bl 0x8222ced0
	ctx.lr = 0x828C4508;
	sub_8222CED0(ctx, base);
	// 828C4508: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C450C: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 828C4510: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 828C4514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4518: 4B979F11  bl 0x8223e428
	ctx.lr = 0x828C451C;
	sub_8223E428(ctx, base);
	// 828C451C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4520: 4B9508B9  bl 0x82214dd8
	ctx.lr = 0x828C4524;
	sub_82214DD8(ctx, base);
	// 828C4524: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4528: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C452C: 4BAC8F8D  bl 0x8238d4b8
	ctx.lr = 0x828C4530;
	sub_8238D4B8(ctx, base);
	// 828C4530: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C453C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4548 size=312
    let mut pc: u32 = 0x828C4548;
    'dispatch: loop {
        match pc {
            0x828C4548 => {
    //   block [0x828C4548..0x828C4680)
	// 828C4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C454C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4550: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4554: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4558: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C455C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828C4560: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C4564: 419A00EC  beq cr6, 0x828c4650
	if ctx.cr[6].eq {
	pc = 0x828C4650; continue 'dispatch;
	}
	// 828C4568: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C456C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C4570: 419A0020  beq cr6, 0x828c4590
	if ctx.cr[6].eq {
	pc = 0x828C4590; continue 'dispatch;
	}
	// 828C4574: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828C4578: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C457C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C4580: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C4584: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4588: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C458C: 480000CC  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
	// 828C4590: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4594: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4598: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C459C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C45A0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C45A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C45A8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C45AC: 40810054  ble 0x828c4600
	if !ctx.cr[0].gt {
	pc = 0x828C4600; continue 'dispatch;
	}
	// 828C45B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C45B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C45B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C45BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C45C0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828C45C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C45C8: 41980008  blt cr6, 0x828c45d0
	if ctx.cr[6].lt {
	pc = 0x828C45D0; continue 'dispatch;
	}
	// 828C45CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C45D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C45D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C45D8: 419A0014  beq cr6, 0x828c45ec
	if ctx.cr[6].eq {
	pc = 0x828C45EC; continue 'dispatch;
	}
	// 828C45DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C45E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C45E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C45E8: 4800000C  b 0x828c45f4
	pc = 0x828C45F4; continue 'dispatch;
	// 828C45EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C45F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C45F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C45F8: 4199FFB8  bgt cr6, 0x828c45b0
	if ctx.cr[6].gt {
	pc = 0x828C45B0; continue 'dispatch;
	}
	// 828C45FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C4600: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C4604: 419A003C  beq cr6, 0x828c4640
	if ctx.cr[6].eq {
	pc = 0x828C4640; continue 'dispatch;
	}
	// 828C4608: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C460C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828C4610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4614: 41990008  bgt cr6, 0x828c461c
	if ctx.cr[6].gt {
	pc = 0x828C461C; continue 'dispatch;
	}
	// 828C4618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C461C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C4620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4624: 409A001C  bne cr6, 0x828c4640
	if !ctx.cr[6].eq {
	pc = 0x828C4640; continue 'dispatch;
	}
	// 828C4628: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C462C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4630: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C4634: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C4638: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C463C: 4800001C  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
	// 828C4640: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C4644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4648: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C464C: 4800000C  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
	// 828C4650: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C4654: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4658: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C465C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C4660: 419A0010  beq cr6, 0x828c4670
	if ctx.cr[6].eq {
	pc = 0x828C4670; continue 'dispatch;
	}
	// 828C4664: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 828C4668: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C466C: 4BC9FA15  bl 0x82564080
	ctx.lr = 0x828C4670;
	sub_82564080(ctx, base);
	// 828C4670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C4674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C467C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4680 size=424
    let mut pc: u32 = 0x828C4680;
    'dispatch: loop {
        match pc {
            0x828C4680 => {
    //   block [0x828C4680..0x828C4828)
	// 828C4680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4684: 483E4D89  bl 0x82ca940c
	ctx.lr = 0x828C4688;
	sub_82CA93D0(ctx, base);
	// 828C4688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C468C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4690: 83C60000  lwz r30, 0(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4694: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4698: 3BEB0CA0  addi r31, r11, 0xca0
	ctx.r[31].s64 = ctx.r[11].s64 + 3232;
	// 828C469C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C46A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C46A4: 409A003C  bne cr6, 0x828c46e0
	if !ctx.cr[6].eq {
	pc = 0x828C46E0; continue 'dispatch;
	}
	// 828C46A8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C46AC: 396BA3E4  addi r11, r11, -0x5c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -23580;
	// 828C46B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46B4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46B8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C46BC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C46C0: 419A0014  beq cr6, 0x828c46d4
	if ctx.cr[6].eq {
	pc = 0x828C46D4; continue 'dispatch;
	}
	// 828C46C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C46C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C46CC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C46D0: 419AFFE0  beq cr6, 0x828c46b0
	if ctx.cr[6].eq {
	pc = 0x828C46B0; continue 'dispatch;
	}
	// 828C46D4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C46D8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C46DC: 48000018  b 0x828c46f4
	pc = 0x828C46F4; continue 'dispatch;
	// 828C46E0: 388BA3E4  addi r4, r11, -0x5c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -23580;
	// 828C46E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46E8: 4B9A9111  bl 0x8226d7f8
	ctx.lr = 0x828C46EC;
	sub_8226D7F8(ctx, base);
	// 828C46EC: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C46F0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C46F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C46F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C46FC: 419A0024  beq cr6, 0x828c4720
	if ctx.cr[6].eq {
	pc = 0x828C4720; continue 'dispatch;
	}
	// 828C4700: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4704: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C4708: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 828C470C: 419A0114  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4710: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 828C4714: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C4718: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C471C: 483E4D40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828C4720: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C4724: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C4728: 409A003C  bne cr6, 0x828c4764
	if !ctx.cr[6].eq {
	pc = 0x828C4764; continue 'dispatch;
	}
	// 828C472C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C4730: 396BA3EC  addi r11, r11, -0x5c14
	ctx.r[11].s64 = ctx.r[11].s64 + -23572;
	// 828C4734: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4738: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C473C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C4740: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C4744: 419A0014  beq cr6, 0x828c4758
	if ctx.cr[6].eq {
	pc = 0x828C4758; continue 'dispatch;
	}
	// 828C4748: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C474C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C4750: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C4754: 419AFFE0  beq cr6, 0x828c4734
	if ctx.cr[6].eq {
	pc = 0x828C4734; continue 'dispatch;
	}
	// 828C4758: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C475C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C4760: 48000018  b 0x828c4778
	pc = 0x828C4778; continue 'dispatch;
	// 828C4764: 388BA3EC  addi r4, r11, -0x5c14
	ctx.r[4].s64 = ctx.r[11].s64 + -23572;
	// 828C4768: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C476C: 4B9A908D  bl 0x8226d7f8
	ctx.lr = 0x828C4770;
	sub_8226D7F8(ctx, base);
	// 828C4770: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C4774: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C4778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C477C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4780: 419A0024  beq cr6, 0x828c47a4
	if ctx.cr[6].eq {
	pc = 0x828C47A4; continue 'dispatch;
	}
	// 828C4784: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4788: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C478C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 828C4790: 419A0090  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4794: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 828C4798: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C479C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C47A0: 483E4CBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828C47A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C47A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C47AC: 409A003C  bne cr6, 0x828c47e8
	if !ctx.cr[6].eq {
	pc = 0x828C47E8; continue 'dispatch;
	}
	// 828C47B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C47B4: 396BA3F4  addi r11, r11, -0x5c0c
	ctx.r[11].s64 = ctx.r[11].s64 + -23564;
	// 828C47B8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47BC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C47C4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C47C8: 419A0014  beq cr6, 0x828c47dc
	if ctx.cr[6].eq {
	pc = 0x828C47DC; continue 'dispatch;
	}
	// 828C47CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C47D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C47D4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C47D8: 419AFFE0  beq cr6, 0x828c47b8
	if ctx.cr[6].eq {
	pc = 0x828C47B8; continue 'dispatch;
	}
	// 828C47DC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C47E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C47E4: 48000018  b 0x828c47fc
	pc = 0x828C47FC; continue 'dispatch;
	// 828C47E8: 388BA3F4  addi r4, r11, -0x5c0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23564;
	// 828C47EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47F0: 4B9A9009  bl 0x8226d7f8
	ctx.lr = 0x828C47F4;
	sub_8226D7F8(ctx, base);
	// 828C47F4: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C47F8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C47FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C4800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4804: 419A001C  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4808: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C480C: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C4810: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828C4814: 419A000C  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4818: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C481C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C4820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4824: 483E4C38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4828 size=184
    let mut pc: u32 = 0x828C4828;
    'dispatch: loop {
        match pc {
            0x828C4828 => {
    //   block [0x828C4828..0x828C48E0)
	// 828C4828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C482C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4838: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C483C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4840: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4844: 390B0B7C  addi r8, r11, 0xb7c
	ctx.r[8].s64 = ctx.r[11].s64 + 2940;
	// 828C4848: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C484C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4850: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828C4854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4858: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 828C485C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C4860: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C4864: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C4868: 4B950031  bl 0x82214898
	ctx.lr = 0x828C486C;
	sub_82214898(ctx, base);
	// 828C486C: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C4870: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C4874: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C4878: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 828C487C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828C4880: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C4884: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 828C4888: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C488C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4890: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828C4894: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C4898: 4BE68EB9  bl 0x8272d750
	ctx.lr = 0x828C489C;
	sub_8272D750(ctx, base);
	// 828C489C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C48A0: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C48A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C48A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C48AC: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828C48B0: 4BE68891  bl 0x8272d140
	ctx.lr = 0x828C48B4;
	sub_8272D140(ctx, base);
	// 828C48B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C48B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C48BC: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 828C48C0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C48C4: 4B8CF575  bl 0x82193e38
	ctx.lr = 0x828C48C8;
	sub_82193E38(ctx, base);
	// 828C48C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C48CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C48D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C48D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C48D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C48DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C48E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C48E0 size=20
    let mut pc: u32 = 0x828C48E0;
    'dispatch: loop {
        match pc {
            0x828C48E0 => {
    //   block [0x828C48E0..0x828C48F4)
	// 828C48E0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C48E4: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 828C48E8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828C48EC: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C48F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C48F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C48F8 size=584
    let mut pc: u32 = 0x828C48F8;
    'dispatch: loop {
        match pc {
            0x828C48F8 => {
    //   block [0x828C48F8..0x828C4B40)
	// 828C48F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C48FC: 483E4B05  bl 0x82ca9400
	ctx.lr = 0x828C4900;
	sub_82CA93D0(ctx, base);
	// 828C4900: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4904: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4908: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C490C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4910: 409A0010  bne cr6, 0x828c4920
	if !ctx.cr[6].eq {
	pc = 0x828C4920; continue 'dispatch;
	}
	// 828C4914: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4918: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C491C: 48000008  b 0x828c4924
	pc = 0x828C4924; continue 'dispatch;
	// 828C4920: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4924: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4928: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C492C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4930: 4BB09C91  bl 0x823ce5c0
	ctx.lr = 0x828C4934;
	sub_823CE5C0(ctx, base);
	// 828C4934: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C493C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4940: 4BB098C1  bl 0x823ce200
	ctx.lr = 0x828C4944;
	sub_823CE200(ctx, base);
	// 828C4944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4948: 4B8F31D1  bl 0x821b7b18
	ctx.lr = 0x828C494C;
	sub_821B7B18(ctx, base);
	// 828C494C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C4950: 4B95A909  bl 0x8221f258
	ctx.lr = 0x828C4954;
	sub_8221F258(ctx, base);
	// 828C4954: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4958: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C495C: 419A0040  beq cr6, 0x828c499c
	if ctx.cr[6].eq {
	pc = 0x828C499C; continue 'dispatch;
	}
	// 828C4960: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C4964: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4968: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C496C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4970: 4B95A8E9  bl 0x8221f258
	ctx.lr = 0x828C4974;
	sub_8221F258(ctx, base);
	// 828C4974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4978: 419A0028  beq cr6, 0x828c49a0
	if ctx.cr[6].eq {
	pc = 0x828C49A0; continue 'dispatch;
	}
	// 828C497C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4980: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C4984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4988: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C498C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4990: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C4994: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4998: 4800000C  b 0x828c49a4
	pc = 0x828C49A4; continue 'dispatch;
	// 828C499C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C49A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C49A4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C49A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C49AC: 419A00FC  beq cr6, 0x828c4aa8
	if ctx.cr[6].eq {
	pc = 0x828C4AA8; continue 'dispatch;
	}
	// 828C49B0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C49B4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C49B8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C49BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49C0: 4B964749  bl 0x82229108
	ctx.lr = 0x828C49C4;
	sub_82229108(ctx, base);
	// 828C49C4: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C49C8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C49CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49D0: 3BCB5170  addi r30, r11, 0x5170
	ctx.r[30].s64 = ctx.r[11].s64 + 20848;
	// 828C49D4: 4B962EAD  bl 0x82227880
	ctx.lr = 0x828C49D8;
	sub_82227880(ctx, base);
	// 828C49D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C49DC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C49E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C49E4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C49E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49EC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C49F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C49F4: 4B8D608D  bl 0x8219aa80
	ctx.lr = 0x828C49F8;
	sub_8219AA80(ctx, base);
	// 828C49F8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C49FC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C4A00: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C4A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4A08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C4A0C: 4BB09A15  bl 0x823ce420
	ctx.lr = 0x828C4A10;
	sub_823CE420(ctx, base);
	// 828C4A10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C4A14: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4A18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C4A1C: 4815FCAD  bl 0x82a246c8
	ctx.lr = 0x828C4A20;
	sub_82A246C8(ctx, base);
	// 828C4A20: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4A24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4A28: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C4A2C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C4A30: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4A34: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A3C: 4B9646CD  bl 0x82229108
	ctx.lr = 0x828C4A40;
	sub_82229108(ctx, base);
	// 828C4A40: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828C4A44: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A4C: 3BEB6B58  addi r31, r11, 0x6b58
	ctx.r[31].s64 = ctx.r[11].s64 + 27480;
	// 828C4A50: 4B962E31  bl 0x82227880
	ctx.lr = 0x828C4A54;
	sub_82227880(ctx, base);
	// 828C4A54: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C4A58: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C4A5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4A60: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C4A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A68: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C4A6C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C4A70: 4B8D6011  bl 0x8219aa80
	ctx.lr = 0x828C4A74;
	sub_8219AA80(ctx, base);
	// 828C4A74: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C4A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4A7C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C4A80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4A84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4A88: 4BB09999  bl 0x823ce420
	ctx.lr = 0x828C4A8C;
	sub_823CE420(ctx, base);
	// 828C4A8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4A90: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A98: 4815FC31  bl 0x82a246c8
	ctx.lr = 0x828C4A9C;
	sub_82A246C8(ctx, base);
	// 828C4A9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4AA0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C4AA4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828C4AA8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C4AAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C4AB0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C4AB4: 419A0020  beq cr6, 0x828c4ad4
	if ctx.cr[6].eq {
	pc = 0x828C4AD4; continue 'dispatch;
	}
	// 828C4AB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4ABC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AC0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4AC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4AC8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4ACC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AD0: 4082FFE8  bne 0x828c4ab8
	if !ctx.cr[0].eq {
	pc = 0x828C4AB8; continue 'dispatch;
	}
	// 828C4AD4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4AD8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C4ADC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4AE0: 4BA30E69  bl 0x822f5948
	ctx.lr = 0x828C4AE4;
	sub_822F5948(ctx, base);
	// 828C4AE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4AE8: 4B8F3031  bl 0x821b7b18
	ctx.lr = 0x828C4AEC;
	sub_821B7B18(ctx, base);
	// 828C4AEC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C4AF0: 419A0040  beq cr6, 0x828c4b30
	if ctx.cr[6].eq {
	pc = 0x828C4B30; continue 'dispatch;
	}
	// 828C4AF4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4AF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AFC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4B00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4B04: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4B08: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4B0C: 4082FFE8  bne 0x828c4af4
	if !ctx.cr[0].eq {
	pc = 0x828C4AF4; continue 'dispatch;
	}
	// 828C4B10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4B14: 409A001C  bne cr6, 0x828c4b30
	if !ctx.cr[6].eq {
	pc = 0x828C4B30; continue 'dispatch;
	}
	// 828C4B18: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4B1C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4B24: 4E800421  bctrl
	ctx.lr = 0x828C4B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4B28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C4B2C: 4B95720D  bl 0x8221bd38
	ctx.lr = 0x828C4B30;
	sub_8221BD38(ctx, base);
	// 828C4B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4B34: 4B8F2FE5  bl 0x821b7b18
	ctx.lr = 0x828C4B38;
	sub_821B7B18(ctx, base);
	// 828C4B38: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C4B3C: 483E4914  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4B40 size=528
    let mut pc: u32 = 0x828C4B40;
    'dispatch: loop {
        match pc {
            0x828C4B40 => {
    //   block [0x828C4B40..0x828C4D50)
	// 828C4B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4B44: 483E48B9  bl 0x82ca93fc
	ctx.lr = 0x828C4B48;
	sub_82CA93D0(ctx, base);
	// 828C4B48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4B4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4B50: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4B54: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4B58: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4B5C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4B60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B64: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4B68: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4B70: 419A0008  beq cr6, 0x828c4b78
	if ctx.cr[6].eq {
	pc = 0x828C4B78; continue 'dispatch;
	}
	// 828C4B74: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B78: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4B7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4B80: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B84: 4BB09A3D  bl 0x823ce5c0
	ctx.lr = 0x828C4B88;
	sub_823CE5C0(ctx, base);
	// 828C4B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4B90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4B94: 4BB0957D  bl 0x823ce110
	ctx.lr = 0x828C4B98;
	sub_823CE110(ctx, base);
	// 828C4B98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4B9C: 4B8F2F7D  bl 0x821b7b18
	ctx.lr = 0x828C4BA0;
	sub_821B7B18(ctx, base);
	// 828C4BA0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4BA4: 4B95A6B5  bl 0x8221f258
	ctx.lr = 0x828C4BA8;
	sub_8221F258(ctx, base);
	// 828C4BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4BAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4BB0: 419A006C  beq cr6, 0x828c4c1c
	if ctx.cr[6].eq {
	pc = 0x828C4C1C; continue 'dispatch;
	}
	// 828C4BB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4BB8: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 828C4BBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4BC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4BC4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4BC8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4BCC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4BD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4BD4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4BD8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4BDC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C4BE0: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 828C4BE4: 4B92B65D  bl 0x821f0240
	ctx.lr = 0x828C4BE8;
	sub_821F0240(ctx, base);
	// 828C4BE8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4BEC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C4BF0: 4B95A669  bl 0x8221f258
	ctx.lr = 0x828C4BF4;
	sub_8221F258(ctx, base);
	// 828C4BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4BF8: 419A0028  beq cr6, 0x828c4c20
	if ctx.cr[6].eq {
	pc = 0x828C4C20; continue 'dispatch;
	}
	// 828C4BFC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4C00: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C4C04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4C08: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C4C0C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4C10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4C14: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4C18: 4800000C  b 0x828c4c24
	pc = 0x828C4C24; continue 'dispatch;
	// 828C4C1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C4C20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C4C24: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C28: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4C30: 419A0008  beq cr6, 0x828c4c38
	if ctx.cr[6].eq {
	pc = 0x828C4C38; continue 'dispatch;
	}
	// 828C4C34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C38: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C4C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4C40: 419A0078  beq cr6, 0x828c4cb8
	if ctx.cr[6].eq {
	pc = 0x828C4CB8; continue 'dispatch;
	}
	// 828C4C44: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C48: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4C4C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4C50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C54: 4B9644B5  bl 0x82229108
	ctx.lr = 0x828C4C58;
	sub_82229108(ctx, base);
	// 828C4C58: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C4C5C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4C60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C64: 3BCB51B0  addi r30, r11, 0x51b0
	ctx.r[30].s64 = ctx.r[11].s64 + 20912;
	// 828C4C68: 4B962C19  bl 0x82227880
	ctx.lr = 0x828C4C6C;
	sub_82227880(ctx, base);
	// 828C4C6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4C70: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C4C74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4C78: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C4C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C80: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C4C84: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C4C88: 4B8D5DF9  bl 0x8219aa80
	ctx.lr = 0x828C4C8C;
	sub_8219AA80(ctx, base);
	// 828C4C8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4C90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C4C94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4C98: 4BB09789  bl 0x823ce420
	ctx.lr = 0x828C4C9C;
	sub_823CE420(ctx, base);
	// 828C4C9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4CA0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4CA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4CA8: 4815FA21  bl 0x82a246c8
	ctx.lr = 0x828C4CAC;
	sub_82A246C8(ctx, base);
	// 828C4CAC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4CB0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C4CB4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C4CB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C4CBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4CC0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C4CC4: 419A0020  beq cr6, 0x828c4ce4
	if ctx.cr[6].eq {
	pc = 0x828C4CE4; continue 'dispatch;
	}
	// 828C4CC8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4CCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4CD0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4CD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4CD8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4CDC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4CE0: 4082FFE8  bne 0x828c4cc8
	if !ctx.cr[0].eq {
	pc = 0x828C4CC8; continue 'dispatch;
	}
	// 828C4CE4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4CE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4CEC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4CF0: 4BA30C59  bl 0x822f5948
	ctx.lr = 0x828C4CF4;
	sub_822F5948(ctx, base);
	// 828C4CF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4CF8: 4B8F2E21  bl 0x821b7b18
	ctx.lr = 0x828C4CFC;
	sub_821B7B18(ctx, base);
	// 828C4CFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4D00: 419A0040  beq cr6, 0x828c4d40
	if ctx.cr[6].eq {
	pc = 0x828C4D40; continue 'dispatch;
	}
	// 828C4D04: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4D08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4D0C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4D10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4D14: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4D18: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4D1C: 4082FFE8  bne 0x828c4d04
	if !ctx.cr[0].eq {
	pc = 0x828C4D04; continue 'dispatch;
	}
	// 828C4D20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4D24: 409A001C  bne cr6, 0x828c4d40
	if !ctx.cr[6].eq {
	pc = 0x828C4D40; continue 'dispatch;
	}
	// 828C4D28: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4D2C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4D30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4D34: 4E800421  bctrl
	ctx.lr = 0x828C4D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4D38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C4D3C: 4B956FFD  bl 0x8221bd38
	ctx.lr = 0x828C4D40;
	sub_8221BD38(ctx, base);
	// 828C4D40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4D44: 4B8F2DD5  bl 0x821b7b18
	ctx.lr = 0x828C4D48;
	sub_821B7B18(ctx, base);
	// 828C4D48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C4D4C: 483E4700  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4D50 size=528
    let mut pc: u32 = 0x828C4D50;
    'dispatch: loop {
        match pc {
            0x828C4D50 => {
    //   block [0x828C4D50..0x828C4F60)
	// 828C4D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4D54: 483E46A9  bl 0x82ca93fc
	ctx.lr = 0x828C4D58;
	sub_82CA93D0(ctx, base);
	// 828C4D58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4D5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4D60: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4D64: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4D68: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4D6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4D70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D74: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4D78: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4D80: 419A0008  beq cr6, 0x828c4d88
	if ctx.cr[6].eq {
	pc = 0x828C4D88; continue 'dispatch;
	}
	// 828C4D84: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D88: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4D8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4D90: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D94: 4BB0982D  bl 0x823ce5c0
	ctx.lr = 0x828C4D98;
	sub_823CE5C0(ctx, base);
	// 828C4D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4DA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4DA4: 4BB0936D  bl 0x823ce110
	ctx.lr = 0x828C4DA8;
	sub_823CE110(ctx, base);
	// 828C4DA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4DAC: 4B8F2D6D  bl 0x821b7b18
	ctx.lr = 0x828C4DB0;
	sub_821B7B18(ctx, base);
	// 828C4DB0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4DB4: 4B95A4A5  bl 0x8221f258
	ctx.lr = 0x828C4DB8;
	sub_8221F258(ctx, base);
	// 828C4DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4DC0: 419A006C  beq cr6, 0x828c4e2c
	if ctx.cr[6].eq {
	pc = 0x828C4E2C; continue 'dispatch;
	}
	// 828C4DC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4DC8: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 828C4DCC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4DD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4DD4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4DD8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4DDC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4DE4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4DE8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4DEC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C4DF0: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 828C4DF4: 4B92B44D  bl 0x821f0240
	ctx.lr = 0x828C4DF8;
	sub_821F0240(ctx, base);
	// 828C4DF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4DFC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C4E00: 4B95A459  bl 0x8221f258
	ctx.lr = 0x828C4E04;
	sub_8221F258(ctx, base);
	// 828C4E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4E08: 419A0028  beq cr6, 0x828c4e30
	if ctx.cr[6].eq {
	pc = 0x828C4E30; continue 'dispatch;
	}
	// 828C4E0C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4E10: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C4E14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4E18: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C4E1C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4E20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4E24: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4E28: 4800000C  b 0x828c4e34
	pc = 0x828C4E34; continue 'dispatch;
	// 828C4E2C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C4E30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C4E34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4E38: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4E40: 419A0008  beq cr6, 0x828c4e48
	if ctx.cr[6].eq {
	pc = 0x828C4E48; continue 'dispatch;
	}
	// 828C4E44: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4E48: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C4E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4E50: 419A0078  beq cr6, 0x828c4ec8
	if ctx.cr[6].eq {
	pc = 0x828C4EC8; continue 'dispatch;
	}
	// 828C4E54: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4E58: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4E5C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4E60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E64: 4B9642A5  bl 0x82229108
	ctx.lr = 0x828C4E68;
	sub_82229108(ctx, base);
	// 828C4E68: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C4E6C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4E70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E74: 3BCB51B0  addi r30, r11, 0x51b0
	ctx.r[30].s64 = ctx.r[11].s64 + 20912;
	// 828C4E78: 4B962A09  bl 0x82227880
	ctx.lr = 0x828C4E7C;
	sub_82227880(ctx, base);
	// 828C4E7C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4E80: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828C4E84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4E88: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 828C4E8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E90: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C4E94: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C4E98: 4B8D5BE9  bl 0x8219aa80
	ctx.lr = 0x828C4E9C;
	sub_8219AA80(ctx, base);
	// 828C4E9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4EA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C4EA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4EA8: 4BB09579  bl 0x823ce420
	ctx.lr = 0x828C4EAC;
	sub_823CE420(ctx, base);
	// 828C4EAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4EB0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4EB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4EB8: 4815F811  bl 0x82a246c8
	ctx.lr = 0x828C4EBC;
	sub_82A246C8(ctx, base);
	// 828C4EBC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4EC0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C4EC4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C4EC8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C4ECC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4ED0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C4ED4: 419A0020  beq cr6, 0x828c4ef4
	if ctx.cr[6].eq {
	pc = 0x828C4EF4; continue 'dispatch;
	}
	// 828C4ED8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4EDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4EE0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4EE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4EE8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4EEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4EF0: 4082FFE8  bne 0x828c4ed8
	if !ctx.cr[0].eq {
	pc = 0x828C4ED8; continue 'dispatch;
	}
	// 828C4EF4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4EFC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4F00: 4BA30A49  bl 0x822f5948
	ctx.lr = 0x828C4F04;
	sub_822F5948(ctx, base);
	// 828C4F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4F08: 4B8F2C11  bl 0x821b7b18
	ctx.lr = 0x828C4F0C;
	sub_821B7B18(ctx, base);
	// 828C4F0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4F10: 419A0040  beq cr6, 0x828c4f50
	if ctx.cr[6].eq {
	pc = 0x828C4F50; continue 'dispatch;
	}
	// 828C4F14: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4F1C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4F20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4F24: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4F28: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4F2C: 4082FFE8  bne 0x828c4f14
	if !ctx.cr[0].eq {
	pc = 0x828C4F14; continue 'dispatch;
	}
	// 828C4F30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4F34: 409A001C  bne cr6, 0x828c4f50
	if !ctx.cr[6].eq {
	pc = 0x828C4F50; continue 'dispatch;
	}
	// 828C4F38: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4F3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4F44: 4E800421  bctrl
	ctx.lr = 0x828C4F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4F48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C4F4C: 4B956DED  bl 0x8221bd38
	ctx.lr = 0x828C4F50;
	sub_8221BD38(ctx, base);
	// 828C4F50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4F54: 4B8F2BC5  bl 0x821b7b18
	ctx.lr = 0x828C4F58;
	sub_821B7B18(ctx, base);
	// 828C4F58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C4F5C: 483E44F0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4F60 size=528
    let mut pc: u32 = 0x828C4F60;
    'dispatch: loop {
        match pc {
            0x828C4F60 => {
    //   block [0x828C4F60..0x828C5170)
	// 828C4F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4F64: 483E4499  bl 0x82ca93fc
	ctx.lr = 0x828C4F68;
	sub_82CA93D0(ctx, base);
	// 828C4F68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4F6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4F70: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4F74: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4F78: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4F7C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4F80: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4F84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4F88: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4F90: 419A0008  beq cr6, 0x828c4f98
	if ctx.cr[6].eq {
	pc = 0x828C4F98; continue 'dispatch;
	}
	// 828C4F94: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4F98: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4F9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4FA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4FA4: 4BB0961D  bl 0x823ce5c0
	ctx.lr = 0x828C4FA8;
	sub_823CE5C0(ctx, base);
	// 828C4FA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4FAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4FB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4FB4: 4BB0915D  bl 0x823ce110
	ctx.lr = 0x828C4FB8;
	sub_823CE110(ctx, base);
	// 828C4FB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4FBC: 4B8F2B5D  bl 0x821b7b18
	ctx.lr = 0x828C4FC0;
	sub_821B7B18(ctx, base);
	// 828C4FC0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4FC4: 4B95A295  bl 0x8221f258
	ctx.lr = 0x828C4FC8;
	sub_8221F258(ctx, base);
	// 828C4FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4FD0: 419A006C  beq cr6, 0x828c503c
	if ctx.cr[6].eq {
	pc = 0x828C503C; continue 'dispatch;
	}
	// 828C4FD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4FD8: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 828C4FDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4FE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4FE4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4FE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4FEC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4FF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4FF4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4FF8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4FFC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C5000: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 828C5004: 4B92B23D  bl 0x821f0240
	ctx.lr = 0x828C5008;
	sub_821F0240(ctx, base);
	// 828C5008: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C500C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C5010: 4B95A249  bl 0x8221f258
	ctx.lr = 0x828C5014;
	sub_8221F258(ctx, base);
	// 828C5014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5018: 419A0028  beq cr6, 0x828c5040
	if ctx.cr[6].eq {
	pc = 0x828C5040; continue 'dispatch;
	}
	// 828C501C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C5020: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C5024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C5028: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C502C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C5030: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C5034: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C5038: 4800000C  b 0x828c5044
	pc = 0x828C5044; continue 'dispatch;
	// 828C503C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C5040: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C5044: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5048: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C504C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5050: 419A0008  beq cr6, 0x828c5058
	if ctx.cr[6].eq {
	pc = 0x828C5058; continue 'dispatch;
	}
	// 828C5054: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5058: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C505C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5060: 419A0078  beq cr6, 0x828c50d8
	if ctx.cr[6].eq {
	pc = 0x828C50D8; continue 'dispatch;
	}
	// 828C5064: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5068: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C506C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5070: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C5074: 4B964095  bl 0x82229108
	ctx.lr = 0x828C5078;
	sub_82229108(ctx, base);
	// 828C5078: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C507C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C5080: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C5084: 3BCB5328  addi r30, r11, 0x5328
	ctx.r[30].s64 = ctx.r[11].s64 + 21288;
	// 828C5088: 4B9627F9  bl 0x82227880
	ctx.lr = 0x828C508C;
	sub_82227880(ctx, base);
	// 828C508C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C5090: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 828C5094: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C5098: 388A8BA8  addi r4, r10, -0x7458
	ctx.r[4].s64 = ctx.r[10].s64 + -29784;
	// 828C509C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C50A0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C50A4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C50A8: 4B8D59D9  bl 0x8219aa80
	ctx.lr = 0x828C50AC;
	sub_8219AA80(ctx, base);
	// 828C50AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C50B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C50B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C50B8: 4BB09369  bl 0x823ce420
	ctx.lr = 0x828C50BC;
	sub_823CE420(ctx, base);
	// 828C50BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C50C0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C50C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C50C8: 4815F601  bl 0x82a246c8
	ctx.lr = 0x828C50CC;
	sub_82A246C8(ctx, base);
	// 828C50CC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C50D0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C50D4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C50D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C50DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C50E0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C50E4: 419A0020  beq cr6, 0x828c5104
	if ctx.cr[6].eq {
	pc = 0x828C5104; continue 'dispatch;
	}
	// 828C50E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C50EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C50F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C50F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C50F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C50FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5100: 4082FFE8  bne 0x828c50e8
	if !ctx.cr[0].eq {
	pc = 0x828C50E8; continue 'dispatch;
	}
	// 828C5104: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5108: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C510C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C5110: 4BA30839  bl 0x822f5948
	ctx.lr = 0x828C5114;
	sub_822F5948(ctx, base);
	// 828C5114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5118: 4B8F2A01  bl 0x821b7b18
	ctx.lr = 0x828C511C;
	sub_821B7B18(ctx, base);
	// 828C511C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C5120: 419A0040  beq cr6, 0x828c5160
	if ctx.cr[6].eq {
	pc = 0x828C5160; continue 'dispatch;
	}
	// 828C5124: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C5128: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C512C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C5130: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C5134: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C5138: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C513C: 4082FFE8  bne 0x828c5124
	if !ctx.cr[0].eq {
	pc = 0x828C5124; continue 'dispatch;
	}
	// 828C5140: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5144: 409A001C  bne cr6, 0x828c5160
	if !ctx.cr[6].eq {
	pc = 0x828C5160; continue 'dispatch;
	}
	// 828C5148: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C514C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5150: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5154: 4E800421  bctrl
	ctx.lr = 0x828C5158;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5158: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C515C: 4B956BDD  bl 0x8221bd38
	ctx.lr = 0x828C5160;
	sub_8221BD38(ctx, base);
	// 828C5160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C5164: 4B8F29B5  bl 0x821b7b18
	ctx.lr = 0x828C5168;
	sub_821B7B18(ctx, base);
	// 828C5168: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C516C: 483E42E0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5170 size=56
    let mut pc: u32 = 0x828C5170;
    'dispatch: loop {
        match pc {
            0x828C5170 => {
    //   block [0x828C5170..0x828C51A8)
	// 828C5170: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5174: 419A0018  beq cr6, 0x828c518c
	if ctx.cr[6].eq {
	pc = 0x828C518C; continue 'dispatch;
	}
	// 828C5178: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C517C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5188: 409A0008  bne cr6, 0x828c5190
	if !ctx.cr[6].eq {
	pc = 0x828C5190; continue 'dispatch;
	}
	// 828C518C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5190: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5198: 419A0010  beq cr6, 0x828c51a8
	if ctx.cr[6].eq {
		sub_828C51A8(ctx, base);
		return;
	}
	// 828C519C: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C51A0: 5563EFFE  rlwinm r3, r11, 0x1d, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828C51A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C51A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C51A8 size=8
    let mut pc: u32 = 0x828C51A8;
    'dispatch: loop {
        match pc {
            0x828C51A8 => {
    //   block [0x828C51A8..0x828C51B0)
	// 828C51A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C51AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C51B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C51B0 size=376
    let mut pc: u32 = 0x828C51B0;
    'dispatch: loop {
        match pc {
            0x828C51B0 => {
    //   block [0x828C51B0..0x828C5328)
	// 828C51B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C51B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C51B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C51BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C51C0: 419A0018  beq cr6, 0x828c51d8
	if ctx.cr[6].eq {
	pc = 0x828C51D8; continue 'dispatch;
	}
	// 828C51C4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C51C8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C51CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C51D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C51D4: 409A0008  bne cr6, 0x828c51dc
	if !ctx.cr[6].eq {
	pc = 0x828C51DC; continue 'dispatch;
	}
	// 828C51D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C51DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C51E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C51E4: 419A0130  beq cr6, 0x828c5314
	if ctx.cr[6].eq {
	pc = 0x828C5314; continue 'dispatch;
	}
	// 828C51E8: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C51EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C51F0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828C51F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C51F8: 419A00E8  beq cr6, 0x828c52e0
	if ctx.cr[6].eq {
	pc = 0x828C52E0; continue 'dispatch;
	}
	// 828C51FC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C5200: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C5204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5208: 419A001C  beq cr6, 0x828c5224
	if ctx.cr[6].eq {
	pc = 0x828C5224; continue 'dispatch;
	}
	// 828C520C: 896B0063  lbz r11, 0x63(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(99 as u32) ) } as u64;
	// 828C5210: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C5214: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C5218: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C521C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C5220: 480000C4  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
	// 828C5224: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C5228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C522C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C5230: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C5234: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C5238: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C523C: 40810054  ble 0x828c5290
	if !ctx.cr[0].gt {
	pc = 0x828C5290; continue 'dispatch;
	}
	// 828C5240: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C5244: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C5248: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C524C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5250: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828C5254: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C5258: 41980008  blt cr6, 0x828c5260
	if ctx.cr[6].lt {
	pc = 0x828C5260; continue 'dispatch;
	}
	// 828C525C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C5260: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C5264: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C5268: 419A0014  beq cr6, 0x828c527c
	if ctx.cr[6].eq {
	pc = 0x828C527C; continue 'dispatch;
	}
	// 828C526C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C5270: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C5274: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C5278: 4800000C  b 0x828c5284
	pc = 0x828C5284; continue 'dispatch;
	// 828C527C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C5280: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C5284: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5288: 4199FFB8  bgt cr6, 0x828c5240
	if ctx.cr[6].gt {
	pc = 0x828C5240; continue 'dispatch;
	}
	// 828C528C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C5290: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C5294: 419A003C  beq cr6, 0x828c52d0
	if ctx.cr[6].eq {
	pc = 0x828C52D0; continue 'dispatch;
	}
	// 828C5298: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C529C: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828C52A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C52A4: 41990008  bgt cr6, 0x828c52ac
	if ctx.cr[6].gt {
	pc = 0x828C52AC; continue 'dispatch;
	}
	// 828C52A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C52AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C52B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C52B4: 409A001C  bne cr6, 0x828c52d0
	if !ctx.cr[6].eq {
	pc = 0x828C52D0; continue 'dispatch;
	}
	// 828C52B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C52BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C52C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C52C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C52C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C52CC: 48000018  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
	// 828C52D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C52D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C52D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C52DC: 48000008  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
	// 828C52E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C52E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C52E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C52EC: 419A0028  beq cr6, 0x828c5314
	if ctx.cr[6].eq {
	pc = 0x828C5314; continue 'dispatch;
	}
	// 828C52F0: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C52F4: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C52F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C52FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C5300: 4E800421  bctrl
	ctx.lr = 0x828C5304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C5308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C530C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5310: 4E800020  blr
	return;
	// 828C5314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C5318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C531C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5328 size=380
    let mut pc: u32 = 0x828C5328;
    'dispatch: loop {
        match pc {
            0x828C5328 => {
    //   block [0x828C5328..0x828C54A4)
	// 828C5328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C532C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5334: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C5338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C533C: 419A0018  beq cr6, 0x828c5354
	if ctx.cr[6].eq {
	pc = 0x828C5354; continue 'dispatch;
	}
	// 828C5340: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C5344: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5348: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C534C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C5350: 409A0008  bne cr6, 0x828c5358
	if !ctx.cr[6].eq {
	pc = 0x828C5358; continue 'dispatch;
	}
	// 828C5354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C5358: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C535C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5360: 419A0134  beq cr6, 0x828c5494
	if ctx.cr[6].eq {
	pc = 0x828C5494; continue 'dispatch;
	}
	// 828C5364: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C5368: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C536C: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 828C5370: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C5374: 419A00F8  beq cr6, 0x828c546c
	if ctx.cr[6].eq {
	pc = 0x828C546C; continue 'dispatch;
	}
	// 828C5378: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C537C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5380: 419A0024  beq cr6, 0x828c53a4
	if ctx.cr[6].eq {
	pc = 0x828C53A4; continue 'dispatch;
	}
	// 828C5384: 892A0063  lbz r9, 0x63(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 828C5388: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C538C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C5390: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C5394: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5398: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C539C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C53A0: 480000D0  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
	// 828C53A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C53A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C53AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C53B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C53B4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C53B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C53BC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C53C0: 40810054  ble 0x828c5414
	if !ctx.cr[0].gt {
	pc = 0x828C5414; continue 'dispatch;
	}
	// 828C53C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C53C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C53CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C53D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C53D4: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828C53D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C53DC: 41980008  blt cr6, 0x828c53e4
	if ctx.cr[6].lt {
	pc = 0x828C53E4; continue 'dispatch;
	}
	// 828C53E0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C53E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C53E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C53EC: 419A0014  beq cr6, 0x828c5400
	if ctx.cr[6].eq {
	pc = 0x828C5400; continue 'dispatch;
	}
	// 828C53F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C53F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C53F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C53FC: 4800000C  b 0x828c5408
	pc = 0x828C5408; continue 'dispatch;
	// 828C5400: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C5404: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C5408: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C540C: 4199FFB8  bgt cr6, 0x828c53c4
	if ctx.cr[6].gt {
	pc = 0x828C53C4; continue 'dispatch;
	}
	// 828C5410: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C5414: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C5418: 419A0040  beq cr6, 0x828c5458
	if ctx.cr[6].eq {
	pc = 0x828C5458; continue 'dispatch;
	}
	// 828C541C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5420: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828C5424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5428: 41990008  bgt cr6, 0x828c5430
	if ctx.cr[6].gt {
	pc = 0x828C5430; continue 'dispatch;
	}
	// 828C542C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5430: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5438: 409A0020  bne cr6, 0x828c5458
	if !ctx.cr[6].eq {
	pc = 0x828C5458; continue 'dispatch;
	}
	// 828C543C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C5440: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C5444: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C5448: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C544C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C5450: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5454: 4800001C  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
	// 828C5458: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C545C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5460: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C5464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5468: 48000008  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
	// 828C546C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5470: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5478: 419A001C  beq cr6, 0x828c5494
	if ctx.cr[6].eq {
	pc = 0x828C5494; continue 'dispatch;
	}
	// 828C547C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C5480: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C5484: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5488: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C548C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C5490: 4E800421  bctrl
	ctx.lr = 0x828C5494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5494: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C5498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C549C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C54A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C54A8 size=384
    let mut pc: u32 = 0x828C54A8;
    'dispatch: loop {
        match pc {
            0x828C54A8 => {
    //   block [0x828C54A8..0x828C5628)
	// 828C54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C54AC: 483E3F61  bl 0x82ca940c
	ctx.lr = 0x828C54B0;
	sub_82CA93D0(ctx, base);
	// 828C54B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C54B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C54B8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5628 size=296
    let mut pc: u32 = 0x828C5628;
    'dispatch: loop {
        match pc {
            0x828C5628 => {
    //   block [0x828C5628..0x828C5750)
	// 828C5628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C562C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5630: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 828C5634: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 828C5638: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C563C: 8083007C  lwz r4, 0x7c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C5640: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C5644: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 828C5648: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C564C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5650: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5654: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5658: 4E800421  bctrl
	ctx.lr = 0x828C565C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C565C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828C5660: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 828C5664: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 828C5668: 4B9304F1  bl 0x821f5b58
	ctx.lr = 0x828C566C;
	sub_821F5B58(ctx, base);
	// 828C566C: FDA0F050  fneg f13, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C5670: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C5674: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 828C5678: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 828C567C: 38E80E68  addi r7, r8, 0xe68
	ctx.r[7].s64 = ctx.r[8].s64 + 3688;
	// 828C5680: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C5684: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 828C5688: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5750 size=336
    let mut pc: u32 = 0x828C5750;
    'dispatch: loop {
        match pc {
            0x828C5750 => {
    //   block [0x828C5750..0x828C58A0)
	// 828C5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C575C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5760: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828C5764: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C58A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C58A0 size=376
    let mut pc: u32 = 0x828C58A0;
    'dispatch: loop {
        match pc {
            0x828C58A0 => {
    //   block [0x828C58A0..0x828C5A18)
	// 828C58A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C58A4: 483E3B65  bl 0x82ca9408
	ctx.lr = 0x828C58A8;
	sub_82CA93D0(ctx, base);
	// 828C58A8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C58AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C58B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C58B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C58B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C58BC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C58C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C58C4: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C58C8: 388A3194  addi r4, r10, 0x3194
	ctx.r[4].s64 = ctx.r[10].s64 + 12692;
	// 828C58CC: D3FF0184  stfs f31, 0x184(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 828C58D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C58D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C58D8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C58DC: 4BBEA6C5  bl 0x824affa0
	ctx.lr = 0x828C58E0;
	sub_824AFFA0(ctx, base);
	// 828C58E0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C58E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C58E8: 419A0048  beq cr6, 0x828c5930
	if ctx.cr[6].eq {
	pc = 0x828C5930; continue 'dispatch;
	}
	// 828C58EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C58F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C58F4: 419A003C  beq cr6, 0x828c5930
	if ctx.cr[6].eq {
	pc = 0x828C5930; continue 'dispatch;
	}
	// 828C58F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828C58FC: 419A002C  beq cr6, 0x828c5928
	if ctx.cr[6].eq {
	pc = 0x828C5928; continue 'dispatch;
	}
	// 828C5900: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828C5904: 419A001C  beq cr6, 0x828c5920
	if ctx.cr[6].eq {
	pc = 0x828C5920; continue 'dispatch;
	}
	// 828C5908: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C590C: 419A000C  beq cr6, 0x828c5918
	if ctx.cr[6].eq {
	pc = 0x828C5918; continue 'dispatch;
	}
	// 828C5910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5914: 48000018  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
	// 828C5918: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828C591C: 48000010  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
	// 828C5920: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C5924: 48000008  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
	// 828C5928: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828C592C: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	// 828C5930: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C5934: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828C5938: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 828C593C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5944: C00B94D4  lfs f0, -0x6b2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5948: C1AA94D8  lfs f13, -0x6b28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C594C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 828C5950: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C5954: 4BC9A9BD  bl 0x82560310
	ctx.lr = 0x828C5958;
	sub_82560310(ctx, base);
	// 828C5958: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828C595C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5960: 387F018D  addi r3, r31, 0x18d
	ctx.r[3].s64 = ctx.r[31].s64 + 397;
	// 828C5964: C00994DC  lfs f0, -0x6b24(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5968: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C596C: 4BC9A9A5  bl 0x82560310
	ctx.lr = 0x828C5970;
	sub_82560310(ctx, base);
	// 828C5970: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828C5974: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C5978: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C597C: 388847E0  addi r4, r8, 0x47e0
	ctx.r[4].s64 = ctx.r[8].s64 + 18400;
	// 828C5980: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5984: 4BAE7A6D  bl 0x823ad3f0
	ctx.lr = 0x828C5988;
	sub_823AD3F0(ctx, base);
	// 828C5988: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C598C: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 828C5990: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C5994: 419A0024  beq cr6, 0x828c59b8
	if ctx.cr[6].eq {
	pc = 0x828C59B8; continue 'dispatch;
	}
	// 828C5998: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C599C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C59A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C59A4: 40990014  ble cr6, 0x828c59b8
	if !ctx.cr[6].gt {
	pc = 0x828C59B8; continue 'dispatch;
	}
	// 828C59A8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C59AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C59B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C59B4: 4BC9A95D  bl 0x82560310
	ctx.lr = 0x828C59B8;
	sub_82560310(ctx, base);
	// 828C59B8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C59BC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C59C0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828C59C4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C59C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C59CC: 388931A8  addi r4, r9, 0x31a8
	ctx.r[4].s64 = ctx.r[9].s64 + 12712;
	// 828C59D0: C00B6B7C  lfs f0, 0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C59D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C59D8: C1AA94D0  lfs f13, -0x6b30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C59DC: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 828C59E0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828C59E4: D1BF0084  stfs f13, 0x84(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828C59E8: 4BAE7A09  bl 0x823ad3f0
	ctx.lr = 0x828C59EC;
	sub_823AD3F0(ctx, base);
	// 828C59EC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C59F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C59F4: 419A0018  beq cr6, 0x828c5a0c
	if ctx.cr[6].eq {
	pc = 0x828C5A0C; continue 'dispatch;
	}
	// 828C59F8: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C59FC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C5A00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C5A04: 40990008  ble cr6, 0x828c5a0c
	if !ctx.cr[6].gt {
	pc = 0x828C5A0C; continue 'dispatch;
	}
	// 828C5A08: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C5A0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C5A10: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C5A14: 483E3A44  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5A18 size=1168
    let mut pc: u32 = 0x828C5A18;
    'dispatch: loop {
        match pc {
            0x828C5A18 => {
    //   block [0x828C5A18..0x828C5EA8)
	// 828C5A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5A1C: 483E39C1  bl 0x82ca93dc
	ctx.lr = 0x828C5A20;
	sub_82CA93D0(ctx, base);
	// 828C5A20: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5EA8 size=164
    let mut pc: u32 = 0x828C5EA8;
    'dispatch: loop {
        match pc {
            0x828C5EA8 => {
    //   block [0x828C5EA8..0x828C5F4C)
	// 828C5EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5EB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5EB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5EB8: 80840038  lwz r4, 0x38(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C5EC0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5EC4: 419A002C  beq cr6, 0x828c5ef0
	if ctx.cr[6].eq {
	pc = 0x828C5EF0; continue 'dispatch;
	}
	// 828C5EC8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5ECC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C5ED0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5ED4: 4E800421  bctrl
	ctx.lr = 0x828C5ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C5EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5EE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C5EEC: 4E800020  blr
	return;
	// 828C5EF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C5EF4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828C5EF8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 828C5EFC: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828C5F00: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828C5F04: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5F08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F50 size=12
    let mut pc: u32 = 0x828C5F50;
    'dispatch: loop {
        match pc {
            0x828C5F50 => {
    //   block [0x828C5F50..0x828C5F5C)
	// 828C5F50: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5F58: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F5C size=16
    let mut pc: u32 = 0x828C5F5C;
    'dispatch: loop {
        match pc {
            0x828C5F5C => {
    //   block [0x828C5F5C..0x828C5F6C)
	// 828C5F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F60: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C5F64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5F68: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F6C size=4
    let mut pc: u32 = 0x828C5F6C;
    'dispatch: loop {
        match pc {
            0x828C5F6C => {
    //   block [0x828C5F6C..0x828C5F70)
	// 828C5F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F70 size=12
    let mut pc: u32 = 0x828C5F70;
    'dispatch: loop {
        match pc {
            0x828C5F70 => {
    //   block [0x828C5F70..0x828C5F7C)
	// 828C5F70: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5F78: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F7C size=16
    let mut pc: u32 = 0x828C5F7C;
    'dispatch: loop {
        match pc {
            0x828C5F7C => {
    //   block [0x828C5F7C..0x828C5F8C)
	// 828C5F7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F80: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5F84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5F88: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F8C size=4
    let mut pc: u32 = 0x828C5F8C;
    'dispatch: loop {
        match pc {
            0x828C5F8C => {
    //   block [0x828C5F8C..0x828C5F90)
	// 828C5F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5F90 size=228
    let mut pc: u32 = 0x828C5F90;
    'dispatch: loop {
        match pc {
            0x828C5F90 => {
    //   block [0x828C5F90..0x828C6074)
	// 828C5F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5F94: 483E3475  bl 0x82ca9408
	ctx.lr = 0x828C5F98;
	sub_82CA93D0(ctx, base);
	// 828C5F98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C5FA0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C5FA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828C5FA8: 419A00BC  beq cr6, 0x828c6064
	if ctx.cr[6].eq {
	pc = 0x828C6064; continue 'dispatch;
	}
	// 828C5FAC: 809E0038  lwz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5FB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5FB4: 419A0014  beq cr6, 0x828c5fc8
	if ctx.cr[6].eq {
	pc = 0x828C5FC8; continue 'dispatch;
	}
	// 828C5FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FBC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C5FC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5FC4: 4E800421  bctrl
	ctx.lr = 0x828C5FC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5FC8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C5FCC: 3BBE0040  addi r29, r30, 0x40
	ctx.r[29].s64 = ctx.r[30].s64 + 64;
	// 828C5FD0: 815E0044  lwz r10, 0x44(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5FD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C5FD8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C5FDC: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5FE0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C5FE4: 419A0080  beq cr6, 0x828c6064
	if ctx.cr[6].eq {
	pc = 0x828C6064; continue 'dispatch;
	}
	// 828C5FE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C5FEC: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5FF0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828C5FF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FF8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6000: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C6004: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C6008: 419A0020  beq cr6, 0x828c6028
	if ctx.cr[6].eq {
	pc = 0x828C6028; continue 'dispatch;
	}
	// 828C600C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C6010: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6014: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C6018: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C601C: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C6020: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6024: 4082FFE8  bne 0x828c600c
	if !ctx.cr[0].eq {
	pc = 0x828C600C; continue 'dispatch;
	}
	// 828C6028: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C602C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6030: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C6034: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6038: 4E800421  bctrl
	ctx.lr = 0x828C603C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C603C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6040: 4B8F1AD9  bl 0x821b7b18
	ctx.lr = 0x828C6044;
	sub_821B7B18(ctx, base);
	// 828C6044: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C6048: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C604C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828C6050: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828C6054: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C6058: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C605C: 7F1C3040  cmplw cr6, r28, r6
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C6060: 409AFF8C  bne cr6, 0x828c5fec
	if !ctx.cr[6].eq {
	pc = 0x828C5FEC; continue 'dispatch;
	}
	// 828C6064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6068: 4BD96321  bl 0x8265c388
	ctx.lr = 0x828C606C;
	sub_8265C388(ctx, base);
	// 828C606C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C6070: 483E33E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6078 size=240
    let mut pc: u32 = 0x828C6078;
    'dispatch: loop {
        match pc {
            0x828C6078 => {
    //   block [0x828C6078..0x828C6168)
	// 828C6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C607C: 483E3389  bl 0x82ca9404
	ctx.lr = 0x828C6080;
	sub_82CA93D0(ctx, base);
	// 828C6080: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6084: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C6088: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C608C: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C6090: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6094: 409A00C0  bne cr6, 0x828c6154
	if !ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C6098: 809B0038  lwz r4, 0x38(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C609C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C60A0: 419A00B4  beq cr6, 0x828c6154
	if ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C60A4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C60AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C60B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C60B4: 4E800421  bctrl
	ctx.lr = 0x828C60B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C60B8: 813B0048  lwz r9, 0x48(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C60BC: 811B0044  lwz r8, 0x44(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C60C0: 3BDB0040  addi r30, r27, 0x40
	ctx.r[30].s64 = ctx.r[27].s64 + 64;
	// 828C60C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C60C8: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C60CC: 54E60038  rlwinm r6, r7, 0, 0, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 828C60D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828C60D4: 419A0080  beq cr6, 0x828c6154
	if ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C60D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C60DC: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C60E0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828C60E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C60E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C60F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C60F4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C60F8: 419A0020  beq cr6, 0x828c6118
	if ctx.cr[6].eq {
	pc = 0x828C6118; continue 'dispatch;
	}
	// 828C60FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C6100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6104: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C6108: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C610C: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C6110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6114: 4082FFE8  bne 0x828c60fc
	if !ctx.cr[0].eq {
	pc = 0x828C60FC; continue 'dispatch;
	}
	// 828C6118: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C611C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C6120: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C6124: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6128: 4E800421  bctrl
	ctx.lr = 0x828C612C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C612C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6130: 4B8F19E9  bl 0x821b7b18
	ctx.lr = 0x828C6134;
	sub_821B7B18(ctx, base);
	// 828C6134: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C6138: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C613C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C6140: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828C6144: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C6148: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C614C: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C6150: 409AFF8C  bne cr6, 0x828c60dc
	if !ctx.cr[6].eq {
	pc = 0x828C60DC; continue 'dispatch;
	}
	// 828C6154: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C6158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C615C: 4BD96125  bl 0x8265c280
	ctx.lr = 0x828C6160;
	sub_8265C280(ctx, base);
	// 828C6160: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6164: 483E32F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6168 size=164
    let mut pc: u32 = 0x828C6168;
    'dispatch: loop {
        match pc {
            0x828C6168 => {
    //   block [0x828C6168..0x828C620C)
	// 828C6168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C616C: 483E3299  bl 0x82ca9404
	ctx.lr = 0x828C6170;
	sub_82CA93D0(ctx, base);
	// 828C6170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6174: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6178: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C617C: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6184: 419A0014  beq cr6, 0x828c6198
	if ctx.cr[6].eq {
	pc = 0x828C6198; continue 'dispatch;
	}
	// 828C6188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C618C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C6190: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6194: 4E800421  bctrl
	ctx.lr = 0x828C6198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6198: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C619C: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 828C61A0: 815C0044  lwz r10, 0x44(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C61A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C61A8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C61AC: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C61B0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C61B4: 419A0044  beq cr6, 0x828c61f8
	if ctx.cr[6].eq {
	pc = 0x828C61F8; continue 'dispatch;
	}
	// 828C61B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C61BC: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C61C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C61C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C61C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C61CC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C61D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C61D4: 4E800421  bctrl
	ctx.lr = 0x828C61D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C61D8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C61DC: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C61E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C61E4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C61E8: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C61EC: 7CC51E70  srawi r5, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828C61F0: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C61F4: 409AFFC8  bne cr6, 0x828c61bc
	if !ctx.cr[6].eq {
	pc = 0x828C61BC; continue 'dispatch;
	}
	// 828C61F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C61FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C6200: 4BD95CA1  bl 0x8265bea0
	ctx.lr = 0x828C6204;
	sub_8265BEA0(ctx, base);
	// 828C6204: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C6208: 483E324C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6210 size=152
    let mut pc: u32 = 0x828C6210;
    'dispatch: loop {
        match pc {
            0x828C6210 => {
    //   block [0x828C6210..0x828C62A8)
	// 828C6210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6214: 483E31F5  bl 0x82ca9408
	ctx.lr = 0x828C6218;
	sub_82CA93D0(ctx, base);
	// 828C6218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C621C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6220: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6228: 419A0014  beq cr6, 0x828c623c
	if ctx.cr[6].eq {
	pc = 0x828C623C; continue 'dispatch;
	}
	// 828C622C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6230: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6238: 4E800421  bctrl
	ctx.lr = 0x828C623C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C623C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6240: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 828C6244: 815C0044  lwz r10, 0x44(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C6248: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C624C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C6250: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C6254: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C6258: 419A0040  beq cr6, 0x828c6298
	if ctx.cr[6].eq {
	pc = 0x828C6298; continue 'dispatch;
	}
	// 828C625C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C6260: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C6264: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C6268: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C626C: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6270: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C6274: 4E800421  bctrl
	ctx.lr = 0x828C6278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6278: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C627C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6280: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C6284: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C6288: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C628C: 7CC51E70  srawi r5, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828C6290: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6294: 409AFFCC  bne cr6, 0x828c6260
	if !ctx.cr[6].eq {
	pc = 0x828C6260; continue 'dispatch;
	}
	// 828C6298: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C629C: 4BD95CD5  bl 0x8265bf70
	ctx.lr = 0x828C62A0;
	sub_8265BF70(ctx, base);
	// 828C62A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C62A4: 483E31B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C62A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C62A8 size=120
    let mut pc: u32 = 0x828C62A8;
    'dispatch: loop {
        match pc {
            0x828C62A8 => {
    //   block [0x828C62A8..0x828C6320)
	// 828C62A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C62AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C62B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C62B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C62B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C62BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C62C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C62C4: 4BD95E5D  bl 0x8265c120
	ctx.lr = 0x828C62C8;
	sub_8265C120(ctx, base);
	// 828C62C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C62CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C62D0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C62D4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C62D8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C62DC: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C62E0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C62E4: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C62E8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828C62EC: 4E800421  bctrl
	ctx.lr = 0x828C62F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C62F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C62F4: 80BF0038  lwz r5, 0x38(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C62F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C62FC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C6300: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6304: 4E800421  bctrl
	ctx.lr = 0x828C6308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C630C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C631C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6320 size=844
    let mut pc: u32 = 0x828C6320;
    'dispatch: loop {
        match pc {
            0x828C6320 => {
    //   block [0x828C6320..0x828C666C)
	// 828C6320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6324: 483E30C9  bl 0x82ca93ec
	ctx.lr = 0x828C6328;
	sub_82CA93D0(ctx, base);
	// 828C6328: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C632C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828C6330: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828C6334: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828C6338: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 828C633C: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C6340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6344: 419A0018  beq cr6, 0x828c635c
	if ctx.cr[6].eq {
	pc = 0x828C635C; continue 'dispatch;
	}
	// 828C6348: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C634C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828C6350: 812A0038  lwz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6354: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C6358: 4E800421  bctrl
	ctx.lr = 0x828C635C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C635C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 828C6360: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828C6364: B341005C  sth r26, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u16 ) };
	// 828C6368: 3B780038  addi r27, r24, 0x38
	ctx.r[27].s64 = ctx.r[24].s64 + 56;
	// 828C636C: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 828C6370: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828C6374: B3410054  sth r26, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u16 ) };
	// 828C6378: B161005E  sth r11, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[11].u16 ) };
	// 828C637C: B1610056  sth r11, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u16 ) };
	// 828C6380: 80780038  lwz r3, 0x38(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6384: 4BF8CECD  bl 0x82853250
	ctx.lr = 0x828C6388;
	sub_82853250(ctx, base);
	// 828C6388: 81580038  lwz r10, 0x38(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C638C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828C6390: 7F57D378  mr r23, r26
	ctx.r[23].u64 = ctx.r[26].u64;
	// 828C6394: 83EA002C  lwz r31, 0x2c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C639C: 419A0148  beq cr6, 0x828c64e4
	if ctx.cr[6].eq {
	pc = 0x828C64E4; continue 'dispatch;
	}
	// 828C63A0: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 828C63A4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828C63A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C63AC: 419A0068  beq cr6, 0x828c6414
	if ctx.cr[6].eq {
	pc = 0x828C6414; continue 'dispatch;
	}
	// 828C63B0: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C63B4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828C63B8: A141005E  lhz r10, 0x5e(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 828C63BC: 5569043E  clrlwi r9, r11, 0x10
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 828C63C0: 839F01F0  lwz r28, 0x1f0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 828C63C4: 554804BE  clrlwi r8, r10, 0x12
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 828C63C8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C63CC: 409A0014  bne cr6, 0x828c63e0
	if !ctx.cr[6].eq {
	pc = 0x828C63E0; continue 'dispatch;
	}
	// 828C63D0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C63D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C63D8: 48495041  bl 0x82d5b418
	ctx.lr = 0x828C63DC;
	sub_82D5B418(ctx, base);
	// 828C63DC: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C63E0: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828C63E4: 556913BA  rlwinm r9, r11, 2, 0xe, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C63E8: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C63EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C63F0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C63F4: 7D49412E  stwx r10, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 828C63F8: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C63FC: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 828C6400: 54CB043E  clrlwi r11, r6, 0x10
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 828C6404: B161005C  sth r11, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 828C6408: A0BF01F4  lhz r5, 0x1f4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 828C640C: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6410: 409AFFA8  bne cr6, 0x828c63b8
	if !ctx.cr[6].eq {
	pc = 0x828C63B8; continue 'dispatch;
	}
	// 828C6414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6418: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828C641C: 48000295  bl 0x828c66b0
	ctx.lr = 0x828C6420;
	sub_828C66B0(ctx, base);
	// 828C6420: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6428: 419A0070  beq cr6, 0x828c6498
	if ctx.cr[6].eq {
	pc = 0x828C6498; continue 'dispatch;
	}
	// 828C642C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828C6430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6434: 4800027D  bl 0x828c66b0
	ctx.lr = 0x828C6438;
	sub_828C66B0(ctx, base);
	// 828C6438: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 828C643C: A1010054  lhz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6440: 556904BE  clrlwi r9, r11, 0x12
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 828C6444: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6448: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C644C: 409A0010  bne cr6, 0x828c645c
	if !ctx.cr[6].eq {
	pc = 0x828C645C; continue 'dispatch;
	}
	// 828C6450: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C6454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6458: 48494FC1  bl 0x82d5b418
	ctx.lr = 0x828C645C;
	sub_82D5B418(ctx, base);
	// 828C645C: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6464: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828C6468: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C646C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6470: 5568103E  rotlwi r8, r11, 2
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 828C6474: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C6478: 7D48492E  stwx r10, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 828C647C: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6480: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 828C6484: B0C10054  sth r6, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u16 ) };
	// 828C6488: 48000229  bl 0x828c66b0
	ctx.lr = 0x828C648C;
	sub_828C66B0(ctx, base);
	// 828C648C: A0830004  lhz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6490: 7F1D2040  cmplw cr6, r29, r4
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828C6494: 409AFF9C  bne cr6, 0x828c6430
	if !ctx.cr[6].eq {
	pc = 0x828C6430; continue 'dispatch;
	}
	// 828C6498: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C649C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828C64A0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 828C64A4: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C64A8: 418201BC  beq 0x828c6664
	if ctx.cr[0].eq {
	pc = 0x828C6664; continue 'dispatch;
	}
	// 828C64AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C64B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C64B4: 419A01B0  beq cr6, 0x828c6664
	if ctx.cr[6].eq {
	pc = 0x828C6664; continue 'dispatch;
	}
	// 828C64B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C64BC: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C64C0: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C64C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C64C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C64CC: 409A0008  bne cr6, 0x828c64d4
	if !ctx.cr[6].eq {
	pc = 0x828C64D4; continue 'dispatch;
	}
	// 828C64D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828C64D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C64D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C64DC: 419A0008  beq cr6, 0x828c64e4
	if ctx.cr[6].eq {
	pc = 0x828C64E4; continue 'dispatch;
	}
	// 828C64E0: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828C64E4: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C64E8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C64EC: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C64F0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C64F4: 419A0028  beq cr6, 0x828c651c
	if ctx.cr[6].eq {
	pc = 0x828C651C; continue 'dispatch;
	}
	// 828C64F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C64FC: 4B8F161D  bl 0x821b7b18
	ctx.lr = 0x828C6500;
	sub_821B7B18(ctx, base);
	// 828C6500: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C6504: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6508: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C650C: 419A0010  beq cr6, 0x828c651c
	if ctx.cr[6].eq {
	pc = 0x828C651C; continue 'dispatch;
	}
	// 828C6510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6514: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C6518: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C651C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6520: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828C6524: A121005C  lhz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C6528: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C652C: 83AB002C  lwz r29, 0x2c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6530: 419A002C  beq cr6, 0x828c655c
	if ctx.cr[6].eq {
	pc = 0x828C655C; continue 'dispatch;
	}
	// 828C6534: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828C6538: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C653C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6540: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C6544: 484BF41D  bl 0x82d85960
	ctx.lr = 0x828C6548;
	sub_82D85960(ctx, base);
	// 828C6548: A121005C  lhz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C654C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C6550: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C6554: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C6558: 409AFFE0  bne cr6, 0x828c6538
	if !ctx.cr[6].eq {
	pc = 0x828C6538; continue 'dispatch;
	}
	// 828C655C: A1410054  lhz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6560: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828C6564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6568: 419A002C  beq cr6, 0x828c6594
	if ctx.cr[6].eq {
	pc = 0x828C6594; continue 'dispatch;
	}
	// 828C656C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828C6570: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6578: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C657C: 484BF97D  bl 0x82d85ef8
	ctx.lr = 0x828C6580;
	sub_82D85EF8(ctx, base);
	// 828C6580: A1210054  lhz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6584: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C6588: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C658C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C6590: 409AFFE0  bne cr6, 0x828c6570
	if !ctx.cr[6].eq {
	pc = 0x828C6570; continue 'dispatch;
	}
	// 828C6594: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C6598: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C659C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C65A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C65A4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C65A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C65AC: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C65B0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65B4: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C65B8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828C65BC: 4E800421  bctrl
	ctx.lr = 0x828C65C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C65C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C65C8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828C65CC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C65D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C65D4: 4E800421  bctrl
	ctx.lr = 0x828C65D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C65D8: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65DC: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 828C65E0: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C65E4: 92E8000C  stw r23, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 828C65E8: 419A001C  beq cr6, 0x828c6604
	if ctx.cr[6].eq {
	pc = 0x828C6604; continue 'dispatch;
	}
	// 828C65EC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65F0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828C65F4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828C65F8: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C65FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6600: 4E800421  bctrl
	ctx.lr = 0x828C6604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6604: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 828C6608: 556A0020  rlwinm r10, r11, 0, 0, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C660C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6610: 409A0020  bne cr6, 0x828c6630
	if !ctx.cr[6].eq {
	pc = 0x828C6630; continue 'dispatch;
	}
	// 828C6614: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6618: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828C661C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C6620: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6624: 5565143A  rlwinm r5, r11, 2, 0x10, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C6628: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C662C: 4848EC9D  bl 0x82d552c8
	ctx.lr = 0x828C6630;
	sub_82D552C8(ctx, base);
	// 828C6630: A161005E  lhz r11, 0x5e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 828C6634: 556A0020  rlwinm r10, r11, 0, 0, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C6638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C663C: 409A0020  bne cr6, 0x828c665c
	if !ctx.cr[6].eq {
	pc = 0x828C665C; continue 'dispatch;
	}
	// 828C6640: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6644: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828C6648: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C664C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C6650: 5565143A  rlwinm r5, r11, 2, 0x10, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C6654: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C6658: 4848EC71  bl 0x82d552c8
	ctx.lr = 0x828C665C;
	sub_82D552C8(ctx, base);
	// 828C665C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C6660: 483E2DDC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 828C6664: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828C6668: 4BFFFE68  b 0x828c64d0
	pc = 0x828C64D0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6670 size=12
    let mut pc: u32 = 0x828C6670;
    'dispatch: loop {
        match pc {
            0x828C6670 => {
    //   block [0x828C6670..0x828C667C)
	// 828C6670: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6678: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C667C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C667C size=16
    let mut pc: u32 = 0x828C667C;
    'dispatch: loop {
        match pc {
            0x828C667C => {
    //   block [0x828C667C..0x828C668C)
	// 828C667C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6680: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6684: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6688: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C668C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C668C size=4
    let mut pc: u32 = 0x828C668C;
    'dispatch: loop {
        match pc {
            0x828C668C => {
    //   block [0x828C668C..0x828C6690)
	// 828C668C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6690 size=12
    let mut pc: u32 = 0x828C6690;
    'dispatch: loop {
        match pc {
            0x828C6690 => {
    //   block [0x828C6690..0x828C669C)
	// 828C6690: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6698: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C669C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C669C size=16
    let mut pc: u32 = 0x828C669C;
    'dispatch: loop {
        match pc {
            0x828C669C => {
    //   block [0x828C669C..0x828C66AC)
	// 828C669C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66A0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C66A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C66A8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C66AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C66AC size=4
    let mut pc: u32 = 0x828C66AC;
    'dispatch: loop {
        match pc {
            0x828C66AC => {
    //   block [0x828C66AC..0x828C66B0)
	// 828C66AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C66B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C66B0 size=172
    let mut pc: u32 = 0x828C66B0;
    'dispatch: loop {
        match pc {
            0x828C66B0 => {
    //   block [0x828C66B0..0x828C675C)
	// 828C66B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C66B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C66B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C66BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C66C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C66C4: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 828C66C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C66CC: 409A0078  bne cr6, 0x828c6744
	if !ctx.cr[6].eq {
	pc = 0x828C6744; continue 'dispatch;
	}
	// 828C66D0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66D4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C66D8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C66DC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C66E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C66E4: 419A001C  beq cr6, 0x828c6700
	if ctx.cr[6].eq {
	pc = 0x828C6700; continue 'dispatch;
	}
	// 828C66E8: 8143004C  lwz r10, 0x4c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C66EC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C66F0: 9143004C  stw r10, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 828C66F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66F8: 91230048  stw r9, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 828C66FC: 48000010  b 0x828c670c
	pc = 0x828C670C; continue 'dispatch;
	// 828C6700: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C6704: 4848E94D  bl 0x82d55050
	ctx.lr = 0x828C6708;
	sub_82D55050(ctx, base);
	// 828C6708: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C670C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6710: 419A002C  beq cr6, 0x828c673c
	if ctx.cr[6].eq {
	pc = 0x828C673C; continue 'dispatch;
	}
	// 828C6714: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 828C6718: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C671C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 828C6720: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C6724: B12B0004  sth r9, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 828C6728: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 828C672C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C6730: B12B000C  sth r9, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u16 ) };
	// 828C6734: B14B000E  sth r10, 0xe(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[10].u16 ) };
	// 828C6738: 48000008  b 0x828c6740
	pc = 0x828C6740; continue 'dispatch;
	// 828C673C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6740: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 828C6744: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 828C6748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C674C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828C6760 size=20
    let mut pc: u32 = 0x828C6760;
    'dispatch: loop {
        match pc {
            0x828C6760 => {
    //   block [0x828C6760..0x828C6774)
	// 828C6760: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C6764: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6768: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828C676C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C6770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6778 size=420
    let mut pc: u32 = 0x828C6778;
    'dispatch: loop {
        match pc {
            0x828C6778 => {
    //   block [0x828C6778..0x828C691C)
	// 828C6778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C677C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6784: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 828C6788: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C678C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6920 size=356
    let mut pc: u32 = 0x828C6920;
    'dispatch: loop {
        match pc {
            0x828C6920 => {
    //   block [0x828C6920..0x828C6A84)
	// 828C6920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6924: 483E2AE9  bl 0x82ca940c
	ctx.lr = 0x828C6928;
	sub_82CA93D0(ctx, base);
	// 828C6928: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6A88 size=1136
    let mut pc: u32 = 0x828C6A88;
    'dispatch: loop {
        match pc {
            0x828C6A88 => {
    //   block [0x828C6A88..0x828C6EF8)
	// 828C6A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6A8C: 483E2975  bl 0x82ca9400
	ctx.lr = 0x828C6A90;
	sub_82CA93D0(ctx, base);
	// 828C6A90: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828C6A94: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6A98: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C6A9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6AA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6AA4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C6AA8: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 828C6AAC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C6AB0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C6AB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6AB8: 419A00F4  beq cr6, 0x828c6bac
	if ctx.cr[6].eq {
	pc = 0x828C6BAC; continue 'dispatch;
	}
	// 828C6ABC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C6AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6AC4: 419A0024  beq cr6, 0x828c6ae8
	if ctx.cr[6].eq {
	pc = 0x828C6AE8; continue 'dispatch;
	}
	// 828C6AC8: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C6ACC: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6AD0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C6AD4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C6AD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6ADC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6AE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6AE4: 480000CC  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
	// 828C6AE8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6AEC: 80A4004C  lwz r5, 0x4c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C6AF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C6AF4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828C6AF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C6AFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6B00: 40810054  ble 0x828c6b54
	if !ctx.cr[0].gt {
	pc = 0x828C6B54; continue 'dispatch;
	}
	// 828C6B04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C6B08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C6B0C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C6B10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6B14: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 828C6B18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C6B1C: 41980008  blt cr6, 0x828c6b24
	if ctx.cr[6].lt {
	pc = 0x828C6B24; continue 'dispatch;
	}
	// 828C6B20: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828C6B24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C6B28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C6B2C: 419A0014  beq cr6, 0x828c6b40
	if ctx.cr[6].eq {
	pc = 0x828C6B40; continue 'dispatch;
	}
	// 828C6B30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C6B34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C6B38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C6B3C: 4800000C  b 0x828c6b48
	pc = 0x828C6B48; continue 'dispatch;
	// 828C6B40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C6B44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C6B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6B4C: 4199FFB8  bgt cr6, 0x828c6b04
	if ctx.cr[6].gt {
	pc = 0x828C6B04; continue 'dispatch;
	}
	// 828C6B50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C6B54: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6B58: 419A0040  beq cr6, 0x828c6b98
	if ctx.cr[6].eq {
	pc = 0x828C6B98; continue 'dispatch;
	}
	// 828C6B5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6B60: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828C6B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6B68: 41990008  bgt cr6, 0x828c6b70
	if ctx.cr[6].gt {
	pc = 0x828C6B70; continue 'dispatch;
	}
	// 828C6B6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C6B70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C6B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6B78: 409A0020  bne cr6, 0x828c6b98
	if !ctx.cr[6].eq {
	pc = 0x828C6B98; continue 'dispatch;
	}
	// 828C6B7C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C6B80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C6B84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6B88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6B8C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6B90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6B94: 4800001C  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
	// 828C6B98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828C6B9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6BA0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6BA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6BA8: 48000008  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
	// 828C6BAC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C6BB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C6BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6BB8: 419A0330  beq cr6, 0x828c6ee8
	if ctx.cr[6].eq {
	pc = 0x828C6EE8; continue 'dispatch;
	}
	// 828C6BBC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6BC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C6BC4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828C6BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6BCC: 83DD0094  lwz r30, 0x94(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C6BD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C6BD4: 4B93970D  bl 0x822002e0
	ctx.lr = 0x828C6BD8;
	sub_822002E0(ctx, base);
	// 828C6BD8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C6BDC: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C6BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6BE4: 419A02BC  beq cr6, 0x828c6ea0
	if ctx.cr[6].eq {
	pc = 0x828C6EA0; continue 'dispatch;
	}
	// 828C6BE8: 39610088  addi r11, r1, 0x88
	ctx.r[11].s64 = ctx.r[1].s64 + 136;
	// 828C6BEC: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 828C6BF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C6BF4: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828C6BF8: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 828C6BFC: 39210098  addi r9, r1, 0x98
	ctx.r[9].s64 = ctx.r[1].s64 + 152;
	// 828C6C00: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 828C6C04: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828C6C08: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828C6C0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6C10: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6C14: 38E838C0  addi r7, r8, 0x38c0
	ctx.r[7].s64 = ctx.r[8].s64 + 14528;
	// 828C6C18: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6C1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C6C20: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C6C24: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C6C28: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6C2C: 93E90004  stw r31, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6C30: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C6C34: 93E9000C  stw r31, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C6C38: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C6C3C: 93E10110  stw r31, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	// 828C6C40: 93E10114  stw r31, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[31].u32 ) };
	// 828C6C44: 93E10118  stw r31, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[31].u32 ) };
	// 828C6C48: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 828C6C4C: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 828C6C50: 9BE100BA  stb r31, 0xba(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(186 as u32), ctx.r[31].u8 ) };
	// 828C6C54: 9BE100E8  stb r31, 0xe8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u8 ) };
	// 828C6C58: 9BE100E9  stb r31, 0xe9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(233 as u32), ctx.r[31].u8 ) };
	// 828C6C5C: 482B1265  bl 0x82b77ec0
	ctx.lr = 0x828C6C60;
	sub_82B77EC0(ctx, base);
	// 828C6C60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C6C64: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C6C68: 4B8EE8A1  bl 0x821b5508
	ctx.lr = 0x828C6C6C;
	sub_821B5508(ctx, base);
	// 828C6C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6C70: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 828C6C74: 419A0224  beq cr6, 0x828c6e98
	if ctx.cr[6].eq {
	pc = 0x828C6E98; continue 'dispatch;
	}
	// 828C6C78: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C6C7C: 81410110  lwz r10, 0x110(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 828C6C80: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828C6C84: 7D1F5A14  add r8, r31, r11
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828C6C88: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 828C6C8C: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C6C90: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 828C6C94: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6EF8 size=268
    let mut pc: u32 = 0x828C6EF8;
    'dispatch: loop {
        match pc {
            0x828C6EF8 => {
    //   block [0x828C6EF8..0x828C7004)
	// 828C6EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6EFC: 483E250D  bl 0x82ca9408
	ctx.lr = 0x828C6F00;
	sub_82CA93D0(ctx, base);
	// 828C6F00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C6F04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6F08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C6F0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C6F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6F14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C6F18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C6F1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6F20: 388B0F70  addi r4, r11, 0xf70
	ctx.r[4].s64 = ctx.r[11].s64 + 3952;
	// 828C6F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F28: 4B965FA9  bl 0x8222ced0
	ctx.lr = 0x828C6F2C;
	sub_8222CED0(ctx, base);
	// 828C6F2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6F30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6F34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6F38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6F3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F40: 4BFFFB49  bl 0x828c6a88
	ctx.lr = 0x828C6F44;
	sub_828C6A88(ctx, base);
	// 828C6F44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F4C: 4B94DE8D  bl 0x82214dd8
	ctx.lr = 0x828C6F50;
	sub_82214DD8(ctx, base);
	// 828C6F50: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C6F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6F58: 419A0014  beq cr6, 0x828c6f6c
	if ctx.cr[6].eq {
	pc = 0x828C6F6C; continue 'dispatch;
	}
	// 828C6F5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C6F60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6F64: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C6F68: 483E24F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 828C6F6C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C6F70: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6F74: 388B31CC  addi r4, r11, 0x31cc
	ctx.r[4].s64 = ctx.r[11].s64 + 12748;
	// 828C6F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F7C: 4B965F55  bl 0x8222ced0
	ctx.lr = 0x828C6F80;
	sub_8222CED0(ctx, base);
	// 828C6F80: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6F84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6F88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6F8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F94: 4BFFFAF5  bl 0x828c6a88
	ctx.lr = 0x828C6F98;
	sub_828C6A88(ctx, base);
	// 828C6F98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FA0: 4B94DE39  bl 0x82214dd8
	ctx.lr = 0x828C6FA4;
	sub_82214DD8(ctx, base);
	// 828C6FA4: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C6FA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6FAC: 409AFFB0  bne cr6, 0x828c6f5c
	if !ctx.cr[6].eq {
	pc = 0x828C6F5C; continue 'dispatch;
	}
	// 828C6FB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C6FB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6FB8: 388B7550  addi r4, r11, 0x7550
	ctx.r[4].s64 = ctx.r[11].s64 + 30032;
	// 828C6FBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FC0: 4B965F11  bl 0x8222ced0
	ctx.lr = 0x828C6FC4;
	sub_8222CED0(ctx, base);
	// 828C6FC4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6FC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6FCC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FD8: 4BFFFAB1  bl 0x828c6a88
	ctx.lr = 0x828C6FDC;
	sub_828C6A88(ctx, base);
	// 828C6FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FE4: 4B94DDF5  bl 0x82214dd8
	ctx.lr = 0x828C6FE8;
	sub_82214DD8(ctx, base);
	// 828C6FE8: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828C6FEC: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828C6FF0: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828C6FF4: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 828C6FF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6FFC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C7000: 483E2458  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7008 size=456
    let mut pc: u32 = 0x828C7008;
    'dispatch: loop {
        match pc {
            0x828C7008 => {
    //   block [0x828C7008..0x828C71D0)
	// 828C7008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C700C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7014: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C7018: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C701C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7020: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C7024: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7028: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C702C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C7030: 4E800421  bctrl
	ctx.lr = 0x828C7034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7034: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C7038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C703C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C7040: 419A0178  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7048: 4BE559A9  bl 0x8271c9f0
	ctx.lr = 0x828C704C;
	sub_8271C9F0(ctx, base);
	// 828C704C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C7050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7054: 419A0164  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7058: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C705C: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C7060: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C7064: 419A0154  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7068: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C706C: 4BCB5125  bl 0x8257c190
	ctx.lr = 0x828C7070;
	sub_8257C190(ctx, base);
	// 828C7070: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 828C7074: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828C7078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C71D0 size=60
    let mut pc: u32 = 0x828C71D0;
    'dispatch: loop {
        match pc {
            0x828C71D0 => {
    //   block [0x828C71D0..0x828C720C)
	// 828C71D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C71D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C71D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C71DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C71E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C71E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C71E8: 388B3C1C  addi r4, r11, 0x3c1c
	ctx.r[4].s64 = ctx.r[11].s64 + 15388;
	// 828C71EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C71F0: 4B965CE1  bl 0x8222ced0
	ctx.lr = 0x828C71F4;
	sub_8222CED0(ctx, base);
	// 828C71F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C71F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C71FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7210 size=892
    let mut pc: u32 = 0x828C7210;
    'dispatch: loop {
        match pc {
            0x828C7210 => {
    //   block [0x828C7210..0x828C758C)
	// 828C7210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7214: 483E21ED  bl 0x82ca9400
	ctx.lr = 0x828C7218;
	sub_82CA93D0(ctx, base);
	// 828C7218: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C721C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C7220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7224: 3B7A000C  addi r27, r26, 0xc
	ctx.r[27].s64 = ctx.r[26].s64 + 12;
	// 828C7228: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C722C: 4BAC3F6D  bl 0x8238b198
	ctx.lr = 0x828C7230;
	sub_8238B198(ctx, base);
	// 828C7230: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C7234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7238: 419A034C  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C723C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C7240: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7244: 4BA8418D  bl 0x8234b3d0
	ctx.lr = 0x828C7248;
	sub_8234B3D0(ctx, base);
	// 828C7248: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C724C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C7250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7254: 419A0100  beq cr6, 0x828c7354
	if ctx.cr[6].eq {
	pc = 0x828C7354; continue 'dispatch;
	}
	// 828C7258: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C725C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828C7260: 4B8ACBD9  bl 0x82173e38
	ctx.lr = 0x828C7264;
	sub_82173E38(ctx, base);
	// 828C7264: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C7268: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C726C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7270: 419A00D8  beq cr6, 0x828c7348
	if ctx.cr[6].eq {
	pc = 0x828C7348; continue 'dispatch;
	}
	// 828C7274: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C727C: 419A001C  beq cr6, 0x828c7298
	if ctx.cr[6].eq {
	pc = 0x828C7298; continue 'dispatch;
	}
	// 828C7280: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C7284: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7288: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C728C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C7290: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7294: 480000B0  b 0x828c7344
	pc = 0x828C7344; continue 'dispatch;
	// 828C7298: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C729C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C72A0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C72A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C72A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C72AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C72B0: 40810054  ble 0x828c7304
	if !ctx.cr[0].gt {
	pc = 0x828C7304; continue 'dispatch;
	}
	// 828C72B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C72B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C72BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C72C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C72C4: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C72C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C72CC: 41980008  blt cr6, 0x828c72d4
	if ctx.cr[6].lt {
	pc = 0x828C72D4; continue 'dispatch;
	}
	// 828C72D0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828C72D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C72D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C72DC: 419A0014  beq cr6, 0x828c72f0
	if ctx.cr[6].eq {
	pc = 0x828C72F0; continue 'dispatch;
	}
	// 828C72E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C72E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C72E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C72EC: 4800000C  b 0x828c72f8
	pc = 0x828C72F8; continue 'dispatch;
	// 828C72F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C72F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C72F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C72FC: 4199FFB8  bgt cr6, 0x828c72b4
	if ctx.cr[6].gt {
	pc = 0x828C72B4; continue 'dispatch;
	}
	// 828C7300: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C7304: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C7308: 419A0034  beq cr6, 0x828c733c
	if ctx.cr[6].eq {
	pc = 0x828C733C; continue 'dispatch;
	}
	// 828C730C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7310: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C7314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7318: 41990008  bgt cr6, 0x828c7320
	if ctx.cr[6].gt {
	pc = 0x828C7320; continue 'dispatch;
	}
	// 828C731C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828C7320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7328: 409A0014  bne cr6, 0x828c733c
	if !ctx.cr[6].eq {
	pc = 0x828C733C; continue 'dispatch;
	}
	// 828C732C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C7330: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828C7334: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C7338: 48000008  b 0x828c7340
	pc = 0x828C7340; continue 'dispatch;
	// 828C733C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C7340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7344: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C7348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C734C: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7350: 48020DA9  bl 0x828e80f8
	ctx.lr = 0x828C7354;
	sub_828E80F8(ctx, base);
	// 828C7354: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C7358: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828C735C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C7360: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7364: 394B3214  addi r10, r11, 0x3214
	ctx.r[10].s64 = ctx.r[11].s64 + 12820;
	// 828C7368: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828C736C: 4B93B9ED  bl 0x82202d58
	ctx.lr = 0x828C7370;
	sub_82202D58(ctx, base);
	// 828C7370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C7374: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 828C7378: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C737C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 828C7380: 39092B90  addi r8, r9, 0x2b90
	ctx.r[8].s64 = ctx.r[9].s64 + 11152;
	// 828C7384: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C7388: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C738C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C7390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7394: 4B94D505  bl 0x82214898
	ctx.lr = 0x828C7398;
	sub_82214898(ctx, base);
	// 828C7398: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C739C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C73A0: 4BC0AB29  bl 0x824d1ec8
	ctx.lr = 0x828C73A4;
	sub_824D1EC8(ctx, base);
	// 828C73A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C73A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C73AC: 3BCB0B7C  addi r30, r11, 0xb7c
	ctx.r[30].s64 = ctx.r[11].s64 + 2940;
	// 828C73B0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C73B4: 4B8CCA85  bl 0x82193e38
	ctx.lr = 0x828C73B8;
	sub_82193E38(ctx, base);
	// 828C73B8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C73BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C73C0: 419A0038  beq cr6, 0x828c73f8
	if ctx.cr[6].eq {
	pc = 0x828C73F8; continue 'dispatch;
	}
	// 828C73C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C73C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C73CC: 419A0080  beq cr6, 0x828c744c
	if ctx.cr[6].eq {
	pc = 0x828C744C; continue 'dispatch;
	}
	// 828C73D0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C73D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C73D8: 419A0020  beq cr6, 0x828c73f8
	if ctx.cr[6].eq {
	pc = 0x828C73F8; continue 'dispatch;
	}
	// 828C73DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C73E0: 4B8ACA59  bl 0x82173e38
	ctx.lr = 0x828C73E4;
	sub_82173E38(ctx, base);
	// 828C73E4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C73E8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C73EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C73F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C73F4: 409A0008  bne cr6, 0x828c73fc
	if !ctx.cr[6].eq {
	pc = 0x828C73FC; continue 'dispatch;
	}
	// 828C73F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828C73FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7404: 419A0180  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C7408: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C740C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828C7410: 4B8ACA29  bl 0x82173e38
	ctx.lr = 0x828C7414;
	sub_82173E38(ctx, base);
	// 828C7414: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C7418: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C741C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7420: 419A00F0  beq cr6, 0x828c7510
	if ctx.cr[6].eq {
	pc = 0x828C7510; continue 'dispatch;
	}
	// 828C7424: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7428: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C742C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7430: 419A0028  beq cr6, 0x828c7458
	if ctx.cr[6].eq {
	pc = 0x828C7458; continue 'dispatch;
	}
	// 828C7434: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C7438: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C743C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C7440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7444: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7448: 480000CC  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
	// 828C744C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7450: 4B8CC9E9  bl 0x82193e38
	ctx.lr = 0x828C7454;
	sub_82193E38(ctx, base);
	// 828C7454: 4BFFFFA4  b 0x828c73f8
	pc = 0x828C73F8; continue 'dispatch;
	// 828C7458: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C745C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7460: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C7464: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C7468: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C746C: 40810054  ble 0x828c74c0
	if !ctx.cr[0].gt {
	pc = 0x828C74C0; continue 'dispatch;
	}
	// 828C7470: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C7474: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C7478: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C747C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7480: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C7484: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C7488: 41980008  blt cr6, 0x828c7490
	if ctx.cr[6].lt {
	pc = 0x828C7490; continue 'dispatch;
	}
	// 828C748C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828C7490: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C7494: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C7498: 419A0014  beq cr6, 0x828c74ac
	if ctx.cr[6].eq {
	pc = 0x828C74AC; continue 'dispatch;
	}
	// 828C749C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C74A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C74A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C74A8: 4800000C  b 0x828c74b4
	pc = 0x828C74B4; continue 'dispatch;
	// 828C74AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C74B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C74B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C74B8: 4199FFB8  bgt cr6, 0x828c7470
	if ctx.cr[6].gt {
	pc = 0x828C7470; continue 'dispatch;
	}
	// 828C74BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C74C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C74C4: 419A003C  beq cr6, 0x828c7500
	if ctx.cr[6].eq {
	pc = 0x828C7500; continue 'dispatch;
	}
	// 828C74C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C74CC: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C74D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C74D4: 41990008  bgt cr6, 0x828c74dc
	if ctx.cr[6].gt {
	pc = 0x828C74DC; continue 'dispatch;
	}
	// 828C74D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828C74DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C74E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C74E4: 409A001C  bne cr6, 0x828c7500
	if !ctx.cr[6].eq {
	pc = 0x828C7500; continue 'dispatch;
	}
	// 828C74E8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C74EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828C74F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C74F4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C74FC: 48000018  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
	// 828C7500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C7504: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C750C: 48000008  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
	// 828C7510: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828C7514: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C751C: 409A0024  bne cr6, 0x828c7540
	if !ctx.cr[6].eq {
	pc = 0x828C7540; continue 'dispatch;
	}
	// 828C7520: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7524: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7528: 3BEB9510  addi r31, r11, -0x6af0
	ctx.r[31].s64 = ctx.r[11].s64 + -27376;
	// 828C752C: 4B8AC90D  bl 0x82173e38
	ctx.lr = 0x828C7530;
	sub_82173E38(ctx, base);
	// 828C7530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C7534: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C7538: 4BAC5831  bl 0x8238cd68
	ctx.lr = 0x828C753C;
	sub_8238CD68(ctx, base);
	// 828C753C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7540: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7544: 419A0040  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C7548: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C754C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7550: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C7554: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7558: 4B94D341  bl 0x82214898
	ctx.lr = 0x828C755C;
	sub_82214898(ctx, base);
	// 828C755C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C7560: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7564: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C7568: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 828C756C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828C7570: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C7574: 4BB8EBA5  bl 0x82456118
	ctx.lr = 0x828C7578;
	sub_82456118(ctx, base);
	// 828C7578: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C757C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7580: 4B8CC8B9  bl 0x82193e38
	ctx.lr = 0x828C7584;
	sub_82193E38(ctx, base);
	// 828C7584: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C7588: 483E1EC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C7590 size=4
    let mut pc: u32 = 0x828C7590;
    'dispatch: loop {
        match pc {
            0x828C7590 => {
    //   block [0x828C7590..0x828C7594)
	// 828C7590: 48000008  b 0x828c7598
	sub_828C7598(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7598 size=256
    let mut pc: u32 = 0x828C7598;
    'dispatch: loop {
        match pc {
            0x828C7598 => {
    //   block [0x828C7598..0x828C7698)
	// 828C7598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C759C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C75A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C75A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C75A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C75AC: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C75B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C75B4: 409A00D0  bne cr6, 0x828c7684
	if !ctx.cr[6].eq {
	pc = 0x828C7684; continue 'dispatch;
	}
	// 828C75B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C75BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C75C0: 4B912DF1  bl 0x821da3b0
	ctx.lr = 0x828C75C4;
	sub_821DA3B0(ctx, base);
	// 828C75C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C75C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C75CC: 419A00B8  beq cr6, 0x828c7684
	if ctx.cr[6].eq {
	pc = 0x828C7684; continue 'dispatch;
	}
	// 828C75D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C75D4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C75D8: 386B31F4  addi r3, r11, 0x31f4
	ctx.r[3].s64 = ctx.r[11].s64 + 12788;
	// 828C75DC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C75E0: 4B92C779  bl 0x821f3d58
	ctx.lr = 0x828C75E4;
	sub_821F3D58(ctx, base);
	// 828C75E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C75E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C75EC: 4B8EAF0D  bl 0x821b24f8
	ctx.lr = 0x828C75F0;
	sub_821B24F8(ctx, base);
	// 828C75F0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C75F4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828C75F8: 481390D1  bl 0x82a006c8
	ctx.lr = 0x828C75FC;
	sub_82A006C8(ctx, base);
	// 828C75FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7600: 419A000C  beq cr6, 0x828c760c
	if ctx.cr[6].eq {
	pc = 0x828C760C; continue 'dispatch;
	}
	// 828C7604: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7608: 48000008  b 0x828c7610
	pc = 0x828C7610; continue 'dispatch;
	// 828C760C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7614: 419A0068  beq cr6, 0x828c767c
	if ctx.cr[6].eq {
	pc = 0x828C767C; continue 'dispatch;
	}
	// 828C7618: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C761C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C7620: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C7624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7628: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C762C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C7630: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C7634: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7638: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C763C: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7640: 4B99CE49  bl 0x82264488
	ctx.lr = 0x828C7644;
	sub_82264488(ctx, base);
	// 828C7644: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7648: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C764C: 419A0018  beq cr6, 0x828c7664
	if ctx.cr[6].eq {
	pc = 0x828C7664; continue 'dispatch;
	}
	// 828C7650: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7654: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7658: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C765C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7660: 409A0008  bne cr6, 0x828c7668
	if !ctx.cr[6].eq {
	pc = 0x828C7668; continue 'dispatch;
	}
	// 828C7664: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7668: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C766C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7670: 419A000C  beq cr6, 0x828c767c
	if ctx.cr[6].eq {
	pc = 0x828C767C; continue 'dispatch;
	}
	// 828C7674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7678: 4BFFFB99  bl 0x828c7210
	ctx.lr = 0x828C767C;
	sub_828C7210(ctx, base);
	// 828C767C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7680: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 828C7684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C768C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7698 size=416
    let mut pc: u32 = 0x828C7698;
    'dispatch: loop {
        match pc {
            0x828C7698 => {
    //   block [0x828C7698..0x828C7838)
	// 828C7698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C769C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C76A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C76A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C76A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C76AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C76B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C76B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C76B8: 419A0084  beq cr6, 0x828c773c
	if ctx.cr[6].eq {
	pc = 0x828C773C; continue 'dispatch;
	}
	// 828C76BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C76C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C76C4: 419A0074  beq cr6, 0x828c7738
	if ctx.cr[6].eq {
	pc = 0x828C7738; continue 'dispatch;
	}
	// 828C76C8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C76CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C76D0: 419A0018  beq cr6, 0x828c76e8
	if ctx.cr[6].eq {
	pc = 0x828C76E8; continue 'dispatch;
	}
	// 828C76D4: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C76D8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C76DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C76E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C76E4: 409A0008  bne cr6, 0x828c76ec
	if !ctx.cr[6].eq {
	pc = 0x828C76EC; continue 'dispatch;
	}
	// 828C76E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C76EC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C76F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C76F4: 419A0130  beq cr6, 0x828c7824
	if ctx.cr[6].eq {
	pc = 0x828C7824; continue 'dispatch;
	}
	// 828C76F8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C76FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C7700: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C7704: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C7708: 419A0104  beq cr6, 0x828c780c
	if ctx.cr[6].eq {
	pc = 0x828C780C; continue 'dispatch;
	}
	// 828C770C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7714: 419A0030  beq cr6, 0x828c7744
	if ctx.cr[6].eq {
	pc = 0x828C7744; continue 'dispatch;
	}
	// 828C7718: 892A003F  lbz r9, 0x3f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C771C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7720: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C7724: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C7728: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C772C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C7730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7734: 480000DC  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
	// 828C7738: 4B8CC701  bl 0x82193e38
	ctx.lr = 0x828C773C;
	sub_82193E38(ctx, base);
	// 828C773C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7740: 4BFFFFA8  b 0x828c76e8
	pc = 0x828C76E8; continue 'dispatch;
	// 828C7744: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7748: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C774C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C7750: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C7754: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C7758: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C775C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7760: 40810054  ble 0x828c77b4
	if !ctx.cr[0].gt {
	pc = 0x828C77B4; continue 'dispatch;
	}
	// 828C7764: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C7768: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C776C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C7770: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7774: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C7778: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C777C: 41980008  blt cr6, 0x828c7784
	if ctx.cr[6].lt {
	pc = 0x828C7784; continue 'dispatch;
	}
	// 828C7780: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C7784: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C7788: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C778C: 419A0014  beq cr6, 0x828c77a0
	if ctx.cr[6].eq {
	pc = 0x828C77A0; continue 'dispatch;
	}
	// 828C7790: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C7794: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C7798: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C779C: 4800000C  b 0x828c77a8
	pc = 0x828C77A8; continue 'dispatch;
	// 828C77A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C77A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C77A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C77AC: 4199FFB8  bgt cr6, 0x828c7764
	if ctx.cr[6].gt {
	pc = 0x828C7764; continue 'dispatch;
	}
	// 828C77B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C77B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C77B8: 419A0040  beq cr6, 0x828c77f8
	if ctx.cr[6].eq {
	pc = 0x828C77F8; continue 'dispatch;
	}
	// 828C77BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C77C0: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C77C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C77C8: 41990008  bgt cr6, 0x828c77d0
	if ctx.cr[6].gt {
	pc = 0x828C77D0; continue 'dispatch;
	}
	// 828C77CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C77D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C77D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C77D8: 409A0020  bne cr6, 0x828c77f8
	if !ctx.cr[6].eq {
	pc = 0x828C77F8; continue 'dispatch;
	}
	// 828C77DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C77E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C77E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C77E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C77EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C77F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C77F4: 4800001C  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
	// 828C77F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C77FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7800: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C7804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7808: 48000008  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
	// 828C780C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7818: 419A000C  beq cr6, 0x828c7824
	if ctx.cr[6].eq {
	pc = 0x828C7824; continue 'dispatch;
	}
	// 828C781C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7820: 480208D9  bl 0x828e80f8
	ctx.lr = 0x828C7824;
	sub_828E80F8(ctx, base);
	// 828C7824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C782C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7838 size=244
    let mut pc: u32 = 0x828C7838;
    'dispatch: loop {
        match pc {
            0x828C7838 => {
    //   block [0x828C7838..0x828C792C)
	// 828C7838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C783C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C784C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C7850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7854: 3BCB31FC  addi r30, r11, 0x31fc
	ctx.r[30].s64 = ctx.r[11].s64 + 12796;
	// 828C7858: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C785C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7860: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7864: 4B96566D  bl 0x8222ced0
	ctx.lr = 0x828C7868;
	sub_8222CED0(ctx, base);
	// 828C7868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C786C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7870: 480000C1  bl 0x828c7930
	ctx.lr = 0x828C7874;
	sub_828C7930(ctx, base);
	// 828C7874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7878: 4B94D561  bl 0x82214dd8
	ctx.lr = 0x828C787C;
	sub_82214DD8(ctx, base);
	// 828C787C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C7880: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C7884: 388A3208  addi r4, r10, 0x3208
	ctx.r[4].s64 = ctx.r[10].s64 + 12808;
	// 828C7888: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C788C: 4B965645  bl 0x8222ced0
	ctx.lr = 0x828C7890;
	sub_8222CED0(ctx, base);
	// 828C7890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7894: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C7898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C789C: 4B965635  bl 0x8222ced0
	ctx.lr = 0x828C78A0;
	sub_8222CED0(ctx, base);
	// 828C78A0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C78A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C78A8: 38C97210  addi r6, r9, 0x7210
	ctx.r[6].s64 = ctx.r[9].s64 + 29200;
	// 828C78AC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C78B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C78B4: 480002C5  bl 0x828c7b78
	ctx.lr = 0x828C78B8;
	sub_828C7B78(ctx, base);
	// 828C78B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C78BC: 4B94D51D  bl 0x82214dd8
	ctx.lr = 0x828C78C0;
	sub_82214DD8(ctx, base);
	// 828C78C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C78C4: 4B94D515  bl 0x82214dd8
	ctx.lr = 0x828C78C8;
	sub_82214DD8(ctx, base);
	// 828C78C8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C78CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C78D0: 3888D16C  addi r4, r8, -0x2e94
	ctx.r[4].s64 = ctx.r[8].s64 + -11924;
	// 828C78D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C78D8: 4B9655F9  bl 0x8222ced0
	ctx.lr = 0x828C78DC;
	sub_8222CED0(ctx, base);
	// 828C78DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C78E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C78E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C78E8: 4B9655E9  bl 0x8222ced0
	ctx.lr = 0x828C78EC;
	sub_8222CED0(ctx, base);
	// 828C78EC: 3CE0822A  lis r7, -0x7dd6
	ctx.r[7].s64 = -2111176704;
	// 828C78F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C78F4: 38C7EE78  addi r6, r7, -0x1188
	ctx.r[6].s64 = ctx.r[7].s64 + -4488;
	// 828C78F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C78FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7900: 48000481  bl 0x828c7d80
	ctx.lr = 0x828C7904;
	sub_828C7D80(ctx, base);
	// 828C7904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C7908: 4B94D4D1  bl 0x82214dd8
	ctx.lr = 0x828C790C;
	sub_82214DD8(ctx, base);
	// 828C790C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7910: 4B94D4C9  bl 0x82214dd8
	ctx.lr = 0x828C7914;
	sub_82214DD8(ctx, base);
	// 828C7914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C791C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7920: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7930 size=584
    let mut pc: u32 = 0x828C7930;
    'dispatch: loop {
        match pc {
            0x828C7930 => {
    //   block [0x828C7930..0x828C7B78)
	// 828C7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7934: 483E1ACD  bl 0x82ca9400
	ctx.lr = 0x828C7938;
	sub_82CA93D0(ctx, base);
	// 828C7938: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C793C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7940: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C7944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7948: 409A0010  bne cr6, 0x828c7958
	if !ctx.cr[6].eq {
	pc = 0x828C7958; continue 'dispatch;
	}
	// 828C794C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7950: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C7954: 48000008  b 0x828c795c
	pc = 0x828C795C; continue 'dispatch;
	// 828C7958: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C795C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7960: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7964: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7968: 4BB06C59  bl 0x823ce5c0
	ctx.lr = 0x828C796C;
	sub_823CE5C0(ctx, base);
	// 828C796C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7974: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7978: 4BB06889  bl 0x823ce200
	ctx.lr = 0x828C797C;
	sub_823CE200(ctx, base);
	// 828C797C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7980: 4B8F0199  bl 0x821b7b18
	ctx.lr = 0x828C7984;
	sub_821B7B18(ctx, base);
	// 828C7984: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C7988: 4B9578D1  bl 0x8221f258
	ctx.lr = 0x828C798C;
	sub_8221F258(ctx, base);
	// 828C798C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7990: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7994: 419A0040  beq cr6, 0x828c79d4
	if ctx.cr[6].eq {
	pc = 0x828C79D4; continue 'dispatch;
	}
	// 828C7998: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C799C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C79A0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C79A4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C79A8: 4B9578B1  bl 0x8221f258
	ctx.lr = 0x828C79AC;
	sub_8221F258(ctx, base);
	// 828C79AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C79B0: 419A0028  beq cr6, 0x828c79d8
	if ctx.cr[6].eq {
	pc = 0x828C79D8; continue 'dispatch;
	}
	// 828C79B4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C79B8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C79BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C79C0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C79C4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C79C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C79CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C79D0: 4800000C  b 0x828c79dc
	pc = 0x828C79DC; continue 'dispatch;
	// 828C79D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C79D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C79DC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C79E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C79E4: 419A00FC  beq cr6, 0x828c7ae0
	if ctx.cr[6].eq {
	pc = 0x828C7AE0; continue 'dispatch;
	}
	// 828C79E8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C79EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C79F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C79F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C79F8: 4B961711  bl 0x82229108
	ctx.lr = 0x828C79FC;
	sub_82229108(ctx, base);
	// 828C79FC: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C7A00: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7A04: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A08: 3BCB7F88  addi r30, r11, 0x7f88
	ctx.r[30].s64 = ctx.r[11].s64 + 32648;
	// 828C7A0C: 4B95FE75  bl 0x82227880
	ctx.lr = 0x828C7A10;
	sub_82227880(ctx, base);
	// 828C7A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7A14: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C7A18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7A1C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C7A20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A24: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7A28: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7A2C: 4B8D3055  bl 0x8219aa80
	ctx.lr = 0x828C7A30;
	sub_8219AA80(ctx, base);
	// 828C7A30: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C7A34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C7A38: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C7A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7A40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C7A44: 4BB069DD  bl 0x823ce420
	ctx.lr = 0x828C7A48;
	sub_823CE420(ctx, base);
	// 828C7A48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C7A4C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7A50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A54: 4815CC75  bl 0x82a246c8
	ctx.lr = 0x828C7A58;
	sub_82A246C8(ctx, base);
	// 828C7A58: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7A5C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7A60: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C7A64: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C7A68: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7A6C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7A74: 4B961695  bl 0x82229108
	ctx.lr = 0x828C7A78;
	sub_82229108(ctx, base);
	// 828C7A78: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828C7A7C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7A84: 3BEB6548  addi r31, r11, 0x6548
	ctx.r[31].s64 = ctx.r[11].s64 + 25928;
	// 828C7A88: 4B95FDF9  bl 0x82227880
	ctx.lr = 0x828C7A8C;
	sub_82227880(ctx, base);
	// 828C7A8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C7A90: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C7A94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7A98: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C7A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7AA0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7AA4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C7AA8: 4B8D2FD9  bl 0x8219aa80
	ctx.lr = 0x828C7AAC;
	sub_8219AA80(ctx, base);
	// 828C7AAC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C7AB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7AB4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C7AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7ABC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7AC0: 4BB06961  bl 0x823ce420
	ctx.lr = 0x828C7AC4;
	sub_823CE420(ctx, base);
	// 828C7AC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7AC8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7AD0: 4815CBF9  bl 0x82a246c8
	ctx.lr = 0x828C7AD4;
	sub_82A246C8(ctx, base);
	// 828C7AD4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7AD8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C7ADC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828C7AE0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C7AE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C7AE8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C7AEC: 419A0020  beq cr6, 0x828c7b0c
	if ctx.cr[6].eq {
	pc = 0x828C7B0C; continue 'dispatch;
	}
	// 828C7AF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7AF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7AF8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7AFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7B00: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7B04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B08: 4082FFE8  bne 0x828c7af0
	if !ctx.cr[0].eq {
	pc = 0x828C7AF0; continue 'dispatch;
	}
	// 828C7B0C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7B10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C7B14: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7B18: 4BA2DE31  bl 0x822f5948
	ctx.lr = 0x828C7B1C;
	sub_822F5948(ctx, base);
	// 828C7B1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7B20: 4B8EFFF9  bl 0x821b7b18
	ctx.lr = 0x828C7B24;
	sub_821B7B18(ctx, base);
	// 828C7B24: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C7B28: 419A0040  beq cr6, 0x828c7b68
	if ctx.cr[6].eq {
	pc = 0x828C7B68; continue 'dispatch;
	}
	// 828C7B2C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7B30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B34: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7B38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7B3C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7B40: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B44: 4082FFE8  bne 0x828c7b2c
	if !ctx.cr[0].eq {
	pc = 0x828C7B2C; continue 'dispatch;
	}
	// 828C7B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7B4C: 409A001C  bne cr6, 0x828c7b68
	if !ctx.cr[6].eq {
	pc = 0x828C7B68; continue 'dispatch;
	}
	// 828C7B50: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7B54: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7B5C: 4E800421  bctrl
	ctx.lr = 0x828C7B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7B60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C7B64: 4B9541D5  bl 0x8221bd38
	ctx.lr = 0x828C7B68;
	sub_8221BD38(ctx, base);
	// 828C7B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7B6C: 4B8EFFAD  bl 0x821b7b18
	ctx.lr = 0x828C7B70;
	sub_821B7B18(ctx, base);
	// 828C7B70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C7B74: 483E18DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7B78 size=516
    let mut pc: u32 = 0x828C7B78;
    'dispatch: loop {
        match pc {
            0x828C7B78 => {
    //   block [0x828C7B78..0x828C7D7C)
	// 828C7B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7B7C: 483E1881  bl 0x82ca93fc
	ctx.lr = 0x828C7B80;
	sub_82CA93D0(ctx, base);
	// 828C7B80: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7B84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7B88: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C7B8C: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C7B90: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C7B94: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C7B98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7B9C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C7BA0: 3BAA7210  addi r29, r10, 0x7210
	ctx.r[29].s64 = ctx.r[10].s64 + 29200;
	// 828C7BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7BA8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7BAC: 419A0008  beq cr6, 0x828c7bb4
	if ctx.cr[6].eq {
	pc = 0x828C7BB4; continue 'dispatch;
	}
	// 828C7BB0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7BB4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7BB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7BBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7BC0: 4BB06A01  bl 0x823ce5c0
	ctx.lr = 0x828C7BC4;
	sub_823CE5C0(ctx, base);
	// 828C7BC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7BC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7BCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7BD0: 4BB06541  bl 0x823ce110
	ctx.lr = 0x828C7BD4;
	sub_823CE110(ctx, base);
	// 828C7BD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7BD8: 4B8EFF41  bl 0x821b7b18
	ctx.lr = 0x828C7BDC;
	sub_821B7B18(ctx, base);
	// 828C7BDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7BE0: 4B957679  bl 0x8221f258
	ctx.lr = 0x828C7BE4;
	sub_8221F258(ctx, base);
	// 828C7BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7BE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7BEC: 419A005C  beq cr6, 0x828c7c48
	if ctx.cr[6].eq {
	pc = 0x828C7C48; continue 'dispatch;
	}
	// 828C7BF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7BF4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C7BF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C7BFC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C7C00: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C7C04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7C08: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7C0C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7C10: 4B928631  bl 0x821f0240
	ctx.lr = 0x828C7C14;
	sub_821F0240(ctx, base);
	// 828C7C14: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C7C18: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C7C1C: 4B95763D  bl 0x8221f258
	ctx.lr = 0x828C7C20;
	sub_8221F258(ctx, base);
	// 828C7C20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7C24: 419A0028  beq cr6, 0x828c7c4c
	if ctx.cr[6].eq {
	pc = 0x828C7C4C; continue 'dispatch;
	}
	// 828C7C28: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C7C2C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C7C30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7C34: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C7C38: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C7C3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7C40: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C7C44: 4800000C  b 0x828c7c50
	pc = 0x828C7C50; continue 'dispatch;
	// 828C7C48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C7C4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C7C50: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7C54: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7C5C: 419A0008  beq cr6, 0x828c7c64
	if ctx.cr[6].eq {
	pc = 0x828C7C64; continue 'dispatch;
	}
	// 828C7C60: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7C64: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7C6C: 419A0078  beq cr6, 0x828c7ce4
	if ctx.cr[6].eq {
	pc = 0x828C7CE4; continue 'dispatch;
	}
	// 828C7C70: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7C74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7C78: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7C80: 4B961489  bl 0x82229108
	ctx.lr = 0x828C7C84;
	sub_82229108(ctx, base);
	// 828C7C84: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C7C88: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7C8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7C90: 3BCB7FC8  addi r30, r11, 0x7fc8
	ctx.r[30].s64 = ctx.r[11].s64 + 32712;
	// 828C7C94: 4B95FBED  bl 0x82227880
	ctx.lr = 0x828C7C98;
	sub_82227880(ctx, base);
	// 828C7C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7C9C: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828C7CA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7CA4: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828C7CA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7CAC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C7CB0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7CB4: 4B8D2DCD  bl 0x8219aa80
	ctx.lr = 0x828C7CB8;
	sub_8219AA80(ctx, base);
	// 828C7CB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7CBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C7CC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7CC4: 4BB0675D  bl 0x823ce420
	ctx.lr = 0x828C7CC8;
	sub_823CE420(ctx, base);
	// 828C7CC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7CCC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7CD0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7CD4: 4815C9F5  bl 0x82a246c8
	ctx.lr = 0x828C7CD8;
	sub_82A246C8(ctx, base);
	// 828C7CD8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7CDC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C7CE0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C7CE4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7CE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7CEC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C7CF0: 419A0020  beq cr6, 0x828c7d10
	if ctx.cr[6].eq {
	pc = 0x828C7D10; continue 'dispatch;
	}
	// 828C7CF4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7CF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7CFC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7D00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7D04: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7D08: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D0C: 4082FFE8  bne 0x828c7cf4
	if !ctx.cr[0].eq {
	pc = 0x828C7CF4; continue 'dispatch;
	}
	// 828C7D10: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7D18: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7D1C: 4BA2DC2D  bl 0x822f5948
	ctx.lr = 0x828C7D20;
	sub_822F5948(ctx, base);
	// 828C7D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7D24: 4B8EFDF5  bl 0x821b7b18
	ctx.lr = 0x828C7D28;
	sub_821B7B18(ctx, base);
	// 828C7D28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7D2C: 419A0040  beq cr6, 0x828c7d6c
	if ctx.cr[6].eq {
	pc = 0x828C7D6C; continue 'dispatch;
	}
	// 828C7D30: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7D34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D38: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7D3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7D40: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7D44: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D48: 4082FFE8  bne 0x828c7d30
	if !ctx.cr[0].eq {
	pc = 0x828C7D30; continue 'dispatch;
	}
	// 828C7D4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7D50: 409A001C  bne cr6, 0x828c7d6c
	if !ctx.cr[6].eq {
	pc = 0x828C7D6C; continue 'dispatch;
	}
	// 828C7D54: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7D58: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7D5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7D60: 4E800421  bctrl
	ctx.lr = 0x828C7D64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7D64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C7D68: 4B953FD1  bl 0x8221bd38
	ctx.lr = 0x828C7D6C;
	sub_8221BD38(ctx, base);
	// 828C7D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7D70: 4B8EFDA9  bl 0x821b7b18
	ctx.lr = 0x828C7D74;
	sub_821B7B18(ctx, base);
	// 828C7D74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C7D78: 483E16D4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7D80 size=516
    let mut pc: u32 = 0x828C7D80;
    'dispatch: loop {
        match pc {
            0x828C7D80 => {
    //   block [0x828C7D80..0x828C7F84)
	// 828C7D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7D84: 483E1679  bl 0x82ca93fc
	ctx.lr = 0x828C7D88;
	sub_82CA93D0(ctx, base);
	// 828C7D88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7D8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7D90: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C7D94: 3D40822A  lis r10, -0x7dd6
	ctx.r[10].s64 = -2111176704;
	// 828C7D98: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C7D9C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C7DA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7DA4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C7DA8: 3BAAEE78  addi r29, r10, -0x1188
	ctx.r[29].s64 = ctx.r[10].s64 + -4488;
	// 828C7DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7DB0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7DB4: 419A0008  beq cr6, 0x828c7dbc
	if ctx.cr[6].eq {
	pc = 0x828C7DBC; continue 'dispatch;
	}
	// 828C7DB8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7DBC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7DC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7DC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7DC8: 4BB067F9  bl 0x823ce5c0
	ctx.lr = 0x828C7DCC;
	sub_823CE5C0(ctx, base);
	// 828C7DCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7DD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7DD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7DD8: 4BB06339  bl 0x823ce110
	ctx.lr = 0x828C7DDC;
	sub_823CE110(ctx, base);
	// 828C7DDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7DE0: 4B8EFD39  bl 0x821b7b18
	ctx.lr = 0x828C7DE4;
	sub_821B7B18(ctx, base);
	// 828C7DE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7DE8: 4B957471  bl 0x8221f258
	ctx.lr = 0x828C7DEC;
	sub_8221F258(ctx, base);
	// 828C7DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7DF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7DF4: 419A005C  beq cr6, 0x828c7e50
	if ctx.cr[6].eq {
	pc = 0x828C7E50; continue 'dispatch;
	}
	// 828C7DF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7DFC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C7E00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C7E04: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C7E08: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7E0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7E10: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7E14: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7E18: 4B928429  bl 0x821f0240
	ctx.lr = 0x828C7E1C;
	sub_821F0240(ctx, base);
	// 828C7E1C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C7E20: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C7E24: 4B957435  bl 0x8221f258
	ctx.lr = 0x828C7E28;
	sub_8221F258(ctx, base);
	// 828C7E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7E2C: 419A0028  beq cr6, 0x828c7e54
	if ctx.cr[6].eq {
	pc = 0x828C7E54; continue 'dispatch;
	}
	// 828C7E30: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C7E34: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C7E38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7E3C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C7E40: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C7E44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7E48: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C7E4C: 4800000C  b 0x828c7e58
	pc = 0x828C7E58; continue 'dispatch;
	// 828C7E50: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C7E54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C7E58: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E5C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7E64: 419A0008  beq cr6, 0x828c7e6c
	if ctx.cr[6].eq {
	pc = 0x828C7E6C; continue 'dispatch;
	}
	// 828C7E68: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E6C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7E74: 419A0078  beq cr6, 0x828c7eec
	if ctx.cr[6].eq {
	pc = 0x828C7EEC; continue 'dispatch;
	}
	// 828C7E78: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E7C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7E80: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7E84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7E88: 4B961281  bl 0x82229108
	ctx.lr = 0x828C7E8C;
	sub_82229108(ctx, base);
	// 828C7E8C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828C7E90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7E94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7E98: 3BCB8140  addi r30, r11, -0x7ec0
	ctx.r[30].s64 = ctx.r[11].s64 + -32448;
	// 828C7E9C: 4B95F9E5  bl 0x82227880
	ctx.lr = 0x828C7EA0;
	sub_82227880(ctx, base);
	// 828C7EA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7EA4: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828C7EA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7EAC: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828C7EB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7EB4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C7EB8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7EBC: 4B8D2BC5  bl 0x8219aa80
	ctx.lr = 0x828C7EC0;
	sub_8219AA80(ctx, base);
	// 828C7EC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7EC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C7EC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7ECC: 4BB06555  bl 0x823ce420
	ctx.lr = 0x828C7ED0;
	sub_823CE420(ctx, base);
	// 828C7ED0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7ED4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7ED8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7EDC: 4815C7ED  bl 0x82a246c8
	ctx.lr = 0x828C7EE0;
	sub_82A246C8(ctx, base);
	// 828C7EE0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7EE4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C7EE8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C7EEC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7EF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7EF4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C7EF8: 419A0020  beq cr6, 0x828c7f18
	if ctx.cr[6].eq {
	pc = 0x828C7F18; continue 'dispatch;
	}
	// 828C7EFC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7F00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F04: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7F08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7F0C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7F10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F14: 4082FFE8  bne 0x828c7efc
	if !ctx.cr[0].eq {
	pc = 0x828C7EFC; continue 'dispatch;
	}
	// 828C7F18: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7F1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7F20: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7F24: 4BA2DA25  bl 0x822f5948
	ctx.lr = 0x828C7F28;
	sub_822F5948(ctx, base);
	// 828C7F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7F2C: 4B8EFBED  bl 0x821b7b18
	ctx.lr = 0x828C7F30;
	sub_821B7B18(ctx, base);
	// 828C7F30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7F34: 419A0040  beq cr6, 0x828c7f74
	if ctx.cr[6].eq {
	pc = 0x828C7F74; continue 'dispatch;
	}
	// 828C7F38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7F3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F40: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7F44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7F48: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7F4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F50: 4082FFE8  bne 0x828c7f38
	if !ctx.cr[0].eq {
	pc = 0x828C7F38; continue 'dispatch;
	}
	// 828C7F54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7F58: 409A001C  bne cr6, 0x828c7f74
	if !ctx.cr[6].eq {
	pc = 0x828C7F74; continue 'dispatch;
	}
	// 828C7F5C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7F60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7F64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7F68: 4E800421  bctrl
	ctx.lr = 0x828C7F6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7F6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C7F70: 4B953DC9  bl 0x8221bd38
	ctx.lr = 0x828C7F74;
	sub_8221BD38(ctx, base);
	// 828C7F74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7F78: 4B8EFBA1  bl 0x821b7b18
	ctx.lr = 0x828C7F7C;
	sub_821B7B18(ctx, base);
	// 828C7F7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C7F80: 483E14CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C7F88 size=56
    let mut pc: u32 = 0x828C7F88;
    'dispatch: loop {
        match pc {
            0x828C7F88 => {
    //   block [0x828C7F88..0x828C7FC0)
	// 828C7F88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C7F8C: 419A0018  beq cr6, 0x828c7fa4
	if ctx.cr[6].eq {
	pc = 0x828C7FA4; continue 'dispatch;
	}
	// 828C7F90: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7F94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7F98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7FA0: 409A0008  bne cr6, 0x828c7fa8
	if !ctx.cr[6].eq {
	pc = 0x828C7FA8; continue 'dispatch;
	}
	// 828C7FA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7FA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7FB0: 419A0010  beq cr6, 0x828c7fc0
	if ctx.cr[6].eq {
		sub_828C7FC0(ctx, base);
		return;
	}
	// 828C7FB4: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C7FB8: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828C7FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C7FC0 size=8
    let mut pc: u32 = 0x828C7FC0;
    'dispatch: loop {
        match pc {
            0x828C7FC0 => {
    //   block [0x828C7FC0..0x828C7FC8)
	// 828C7FC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C7FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7FC8 size=376
    let mut pc: u32 = 0x828C7FC8;
    'dispatch: loop {
        match pc {
            0x828C7FC8 => {
    //   block [0x828C7FC8..0x828C8140)
	// 828C7FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7FD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7FD4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C7FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7FDC: 419A0018  beq cr6, 0x828c7ff4
	if ctx.cr[6].eq {
	pc = 0x828C7FF4; continue 'dispatch;
	}
	// 828C7FE0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7FE4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7FE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7FEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C7FF0: 409A0008  bne cr6, 0x828c7ff8
	if !ctx.cr[6].eq {
	pc = 0x828C7FF8; continue 'dispatch;
	}
	// 828C7FF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C7FF8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C7FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8000: 419A0130  beq cr6, 0x828c8130
	if ctx.cr[6].eq {
	pc = 0x828C8130; continue 'dispatch;
	}
	// 828C8004: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C8008: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C800C: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 828C8010: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8014: 419A00F8  beq cr6, 0x828c810c
	if ctx.cr[6].eq {
	pc = 0x828C810C; continue 'dispatch;
	}
	// 828C8018: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C801C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8020: 419A0024  beq cr6, 0x828c8044
	if ctx.cr[6].eq {
	pc = 0x828C8044; continue 'dispatch;
	}
	// 828C8024: 892A0040  lbz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C8028: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C802C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C8030: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C8034: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8038: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C803C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8040: 480000D0  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
	// 828C8044: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C8048: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C804C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C8050: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C8054: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C8058: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C805C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8060: 40810054  ble 0x828c80b4
	if !ctx.cr[0].gt {
	pc = 0x828C80B4; continue 'dispatch;
	}
	// 828C8064: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C8068: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C806C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C8070: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8074: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 828C8078: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C807C: 41980008  blt cr6, 0x828c8084
	if ctx.cr[6].lt {
	pc = 0x828C8084; continue 'dispatch;
	}
	// 828C8080: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C8084: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C8088: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C808C: 419A0014  beq cr6, 0x828c80a0
	if ctx.cr[6].eq {
	pc = 0x828C80A0; continue 'dispatch;
	}
	// 828C8090: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C8094: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C8098: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C809C: 4800000C  b 0x828c80a8
	pc = 0x828C80A8; continue 'dispatch;
	// 828C80A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C80A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C80A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C80AC: 4199FFB8  bgt cr6, 0x828c8064
	if ctx.cr[6].gt {
	pc = 0x828C8064; continue 'dispatch;
	}
	// 828C80B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C80B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C80B8: 419A0040  beq cr6, 0x828c80f8
	if ctx.cr[6].eq {
	pc = 0x828C80F8; continue 'dispatch;
	}
	// 828C80BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C80C0: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 828C80C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C80C8: 41990008  bgt cr6, 0x828c80d0
	if ctx.cr[6].gt {
	pc = 0x828C80D0; continue 'dispatch;
	}
	// 828C80CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C80D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C80D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C80D8: 409A0020  bne cr6, 0x828c80f8
	if !ctx.cr[6].eq {
	pc = 0x828C80F8; continue 'dispatch;
	}
	// 828C80DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C80E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C80E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C80E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C80EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C80F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C80F4: 4800001C  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
	// 828C80F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C80FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8100: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C8104: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8108: 48000008  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
	// 828C810C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8118: 419A0018  beq cr6, 0x828c8130
	if ctx.cr[6].eq {
	pc = 0x828C8130; continue 'dispatch;
	}
	// 828C811C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8120: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C8124: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C812C: 4E800421  bctrl
	ctx.lr = 0x828C8130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8130: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C8134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C813C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8140 size=372
    let mut pc: u32 = 0x828C8140;
    'dispatch: loop {
        match pc {
            0x828C8140 => {
    //   block [0x828C8140..0x828C82B4)
	// 828C8140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8148: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C814C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C8150: 419A0018  beq cr6, 0x828c8168
	if ctx.cr[6].eq {
	pc = 0x828C8168; continue 'dispatch;
	}
	// 828C8154: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C8158: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C815C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8164: 409A0008  bne cr6, 0x828c816c
	if !ctx.cr[6].eq {
	pc = 0x828C816C; continue 'dispatch;
	}
	// 828C8168: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C816C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8174: 419A012C  beq cr6, 0x828c82a0
	if ctx.cr[6].eq {
	pc = 0x828C82A0; continue 'dispatch;
	}
	// 828C8178: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C817C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8180: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828C8184: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C8188: 419A00E8  beq cr6, 0x828c8270
	if ctx.cr[6].eq {
	pc = 0x828C8270; continue 'dispatch;
	}
	// 828C818C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C8190: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C8194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8198: 419A001C  beq cr6, 0x828c81b4
	if ctx.cr[6].eq {
	pc = 0x828C81B4; continue 'dispatch;
	}
	// 828C819C: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C81A0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C81A4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C81A8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C81AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C81B0: 480000C4  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
	// 828C81B4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C81B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C81BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C81C0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C81C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C81C8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C81CC: 40810054  ble 0x828c8220
	if !ctx.cr[0].gt {
	pc = 0x828C8220; continue 'dispatch;
	}
	// 828C81D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C81D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C81D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C81DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C81E0: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 828C81E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C81E8: 41980008  blt cr6, 0x828c81f0
	if ctx.cr[6].lt {
	pc = 0x828C81F0; continue 'dispatch;
	}
	// 828C81EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C81F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C81F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C81F8: 419A0014  beq cr6, 0x828c820c
	if ctx.cr[6].eq {
	pc = 0x828C820C; continue 'dispatch;
	}
	// 828C81FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C8200: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C8204: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C8208: 4800000C  b 0x828c8214
	pc = 0x828C8214; continue 'dispatch;
	// 828C820C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C8210: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828C8214: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8218: 4199FFB8  bgt cr6, 0x828c81d0
	if ctx.cr[6].gt {
	pc = 0x828C81D0; continue 'dispatch;
	}
	// 828C821C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C8220: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C8224: 419A003C  beq cr6, 0x828c8260
	if ctx.cr[6].eq {
	pc = 0x828C8260; continue 'dispatch;
	}
	// 828C8228: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C822C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 828C8230: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8234: 41990008  bgt cr6, 0x828c823c
	if ctx.cr[6].gt {
	pc = 0x828C823C; continue 'dispatch;
	}
	// 828C8238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C823C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8244: 409A001C  bne cr6, 0x828c8260
	if !ctx.cr[6].eq {
	pc = 0x828C8260; continue 'dispatch;
	}
	// 828C8248: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C824C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C8250: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C8254: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8258: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C825C: 48000018  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
	// 828C8260: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C8264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C8268: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C826C: 48000008  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
	// 828C8270: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C8274: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C8278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C827C: 419A0024  beq cr6, 0x828c82a0
	if ctx.cr[6].eq {
	pc = 0x828C82A0; continue 'dispatch;
	}
	// 828C8280: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8284: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8288: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C828C: 4E800421  bctrl
	ctx.lr = 0x828C8290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C8294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C829C: 4E800020  blr
	return;
	// 828C82A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C82A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C82A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C82AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C82B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C82B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C82B8 size=72
    let mut pc: u32 = 0x828C82B8;
    'dispatch: loop {
        match pc {
            0x828C82B8 => {
    //   block [0x828C82B8..0x828C8300)
	// 828C82B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C82BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C82C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C82C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C82C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C82CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C82D0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 828C82D4: 392B3268  addi r9, r11, 0x3268
	ctx.r[9].s64 = ctx.r[11].s64 + 12904;
	// 828C82D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C82DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C82E0: 419A000C  beq cr6, 0x828c82ec
	if ctx.cr[6].eq {
	pc = 0x828C82EC; continue 'dispatch;
	}
	// 828C82E4: 4B953A55  bl 0x8221bd38
	ctx.lr = 0x828C82E8;
	sub_8221BD38(ctx, base);
	// 828C82E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C82EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C82F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C82F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C82F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C82FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8300 size=308
    let mut pc: u32 = 0x828C8300;
    'dispatch: loop {
        match pc {
            0x828C8300 => {
    //   block [0x828C8300..0x828C8434)
	// 828C8300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8304: 483E10F1  bl 0x82ca93f4
	ctx.lr = 0x828C8308;
	sub_82CA93D0(ctx, base);
	// 828C8308: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C830C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C8310: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828C8314: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C8318: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828C831C: 419A0100  beq cr6, 0x828c841c
	if ctx.cr[6].eq {
	pc = 0x828C841C; continue 'dispatch;
	}
	// 828C8320: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C8324: 8317000C  lwz r24, 0xc(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C8328: 83990004  lwz r28, 4(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C832C: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8330: 3B6B0CA0  addi r27, r11, 0xca0
	ctx.r[27].s64 = ctx.r[11].s64 + 3232;
	// 828C8334: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828C8338: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C833C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8340: 7D4BC02E  lwzx r10, r11, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C8344: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8348: 4099000C  ble cr6, 0x828c8354
	if !ctx.cr[6].gt {
	pc = 0x828C8354; continue 'dispatch;
	}
	// 828C834C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C8350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C8354: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C8358: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828C835C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C8360: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8364: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828C8368: 419A007C  beq cr6, 0x828c83e4
	if ctx.cr[6].eq {
	pc = 0x828C83E4; continue 'dispatch;
	}
	// 828C836C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8374: 409A0038  bne cr6, 0x828c83ac
	if !ctx.cr[6].eq {
	pc = 0x828C83AC; continue 'dispatch;
	}
	// 828C8378: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828C837C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C8380: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8384: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8388: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C838C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C8390: 419A0014  beq cr6, 0x828c83a4
	if ctx.cr[6].eq {
	pc = 0x828C83A4; continue 'dispatch;
	}
	// 828C8394: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C8398: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C839C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C83A0: 419AFFE0  beq cr6, 0x828c8380
	if ctx.cr[6].eq {
	pc = 0x828C8380; continue 'dispatch;
	}
	// 828C83A4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C83A8: 48000014  b 0x828c83bc
	pc = 0x828C83BC; continue 'dispatch;
	// 828C83AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C83B0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C83B4: 4B9A5445  bl 0x8226d7f8
	ctx.lr = 0x828C83B8;
	sub_8226D7F8(ctx, base);
	// 828C83B8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C83BC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C83C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C83C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C83C8: 409A0010  bne cr6, 0x828c83d8
	if !ctx.cr[6].eq {
	pc = 0x828C83D8; continue 'dispatch;
	}
	// 828C83CC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C83D0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C83D4: 409AFF98  bne cr6, 0x828c836c
	if !ctx.cr[6].eq {
	pc = 0x828C836C; continue 'dispatch;
	}
	// 828C83D8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C83DC: 40990008  ble cr6, 0x828c83e4
	if !ctx.cr[6].gt {
	pc = 0x828C83E4; continue 'dispatch;
	}
	// 828C83E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C83E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C83E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C83EC: 419A000C  beq cr6, 0x828c83f8
	if ctx.cr[6].eq {
	pc = 0x828C83F8; continue 'dispatch;
	}
	// 828C83F0: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828C83F4: 419A0008  beq cr6, 0x828c83fc
	if ctx.cr[6].eq {
	pc = 0x828C83FC; continue 'dispatch;
	}
	// 828C83F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C83FC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8400: 409A0028  bne cr6, 0x828c8428
	if !ctx.cr[6].eq {
	pc = 0x828C8428; continue 'dispatch;
	}
	// 828C8404: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8408: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C840C: 7D2A5A2E  lhzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8410: 7D3A0734  extsh r26, r9
	ctx.r[26].s64 = ctx.r[9].s16 as i64;
	// 828C8414: 2F1AFFFF  cmpwi cr6, r26, -1
	ctx.cr[6].compare_i32(ctx.r[26].s32, -1, &mut ctx.xer);
	// 828C8418: 409AFF20  bne cr6, 0x828c8338
	if !ctx.cr[6].eq {
	pc = 0x828C8338; continue 'dispatch;
	}
	// 828C841C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C8420: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8424: 483E1020  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828C8428: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C842C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8430: 483E1014  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8438 size=320
    let mut pc: u32 = 0x828C8438;
    'dispatch: loop {
        match pc {
            0x828C8438 => {
    //   block [0x828C8438..0x828C8578)
	// 828C8438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C843C: 483E0FB9  bl 0x82ca93f4
	ctx.lr = 0x828C8440;
	sub_82CA93D0(ctx, base);
	// 828C8440: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8444: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C8448: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C844C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828C8450: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 828C8454: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C845C: 419A0104  beq cr6, 0x828c8560
	if ctx.cr[6].eq {
	pc = 0x828C8560; continue 'dispatch;
	}
	// 828C8460: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C8464: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8468: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828C846C: 3AEA7088  addi r23, r10, 0x7088
	ctx.r[23].s64 = ctx.r[10].s64 + 28808;
	// 828C8470: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	// 828C8474: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8478: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C847C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8480: 7FCBE82E  lwzx r30, r11, r29
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8484: 809E0070  lwz r4, 0x70(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C8488: 4B964A49  bl 0x8222ced0
	ctx.lr = 0x828C848C;
	sub_8222CED0(ctx, base);
	// 828C848C: 80F80000  lwz r7, 0(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8490: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C8494: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8498: 419A0008  beq cr6, 0x828c84a0
	if ctx.cr[6].eq {
	pc = 0x828C84A0; continue 'dispatch;
	}
	// 828C849C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C84A0: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C84A4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828C84A8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C84AC: 419A0008  beq cr6, 0x828c84b4
	if ctx.cr[6].eq {
	pc = 0x828C84B4; continue 'dispatch;
	}
	// 828C84B0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C84B4: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C84B8: 41800058  blt 0x828c8510
	if ctx.cr[0].lt {
	pc = 0x828C8510; continue 'dispatch;
	}
	// 828C84BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C84C0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828C84C4: 419A0008  beq cr6, 0x828c84cc
	if ctx.cr[6].eq {
	pc = 0x828C84CC; continue 'dispatch;
	}
	// 828C84C8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C84D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828C84D4: 419A0008  beq cr6, 0x828c84dc
	if ctx.cr[6].eq {
	pc = 0x828C84DC; continue 'dispatch;
	}
	// 828C84D8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84DC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C84E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C84EC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C84F0: 419A0014  beq cr6, 0x828c8504
	if ctx.cr[6].eq {
	pc = 0x828C8504; continue 'dispatch;
	}
	// 828C84F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C84F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C84FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8500: 419AFFE0  beq cr6, 0x828c84e0
	if ctx.cr[6].eq {
	pc = 0x828C84E0; continue 'dispatch;
	}
	// 828C8504: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C8508: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C850C: 48000008  b 0x828c8514
	pc = 0x828C8514; continue 'dispatch;
	// 828C8510: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828C8514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8518: 4B8FE251  bl 0x821c6768
	ctx.lr = 0x828C851C;
	sub_821C6768(ctx, base);
	// 828C851C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 828C8520: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C8524: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8528: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C852C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C8530: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8534: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8538: 4082FFE8  bne 0x828c8520
	if !ctx.cr[0].eq {
	pc = 0x828C8520; continue 'dispatch;
	}
	// 828C853C: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828C8540: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828C8544: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8548: 409A0024  bne cr6, 0x828c856c
	if !ctx.cr[6].eq {
	pc = 0x828C856C; continue 'dispatch;
	}
	// 828C854C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8550: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828C8554: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828C8558: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C855C: 409AFF18  bne cr6, 0x828c8474
	if !ctx.cr[6].eq {
	pc = 0x828C8474; continue 'dispatch;
	}
	// 828C8560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C8564: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8568: 483E0EDC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 828C856C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8570: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8574: 483E0ED0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8578 size=100
    let mut pc: u32 = 0x828C8578;
    'dispatch: loop {
        match pc {
            0x828C8578 => {
    //   block [0x828C8578..0x828C85DC)
	// 828C8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C857C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8584: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 828C8588: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C858C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828C8590: 388BC864  addi r4, r11, -0x379c
	ctx.r[4].s64 = ctx.r[11].s64 + -14236;
	// 828C8594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C8598: 4B9CA481  bl 0x82292a18
	ctx.lr = 0x828C859C;
	sub_82292A18(ctx, base);
	// 828C859C: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C85A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C85A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C85A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C85AC: 409A0008  bne cr6, 0x828c85b4
	if !ctx.cr[6].eq {
	pc = 0x828C85B4; continue 'dispatch;
	}
	// 828C85B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C85B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C85B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C85BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C85C0: 409A0008  bne cr6, 0x828c85c8
	if !ctx.cr[6].eq {
	pc = 0x828C85C8; continue 'dispatch;
	}
	// 828C85C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C85C8: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 828C85CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C85D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C85D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C85D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C85E0 size=308
    let mut pc: u32 = 0x828C85E0;
    'dispatch: loop {
        match pc {
            0x828C85E0 => {
    //   block [0x828C85E0..0x828C8714)
	// 828C85E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C85E4: 483E0E1D  bl 0x82ca9400
	ctx.lr = 0x828C85E8;
	sub_82CA93D0(ctx, base);
	// 828C85E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C85EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C85F0: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828C85F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C85F8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C85FC: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828C8600: 813C0014  lwz r9, 0x14(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8604: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C8608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C860C: 792907E6  rldicr r9, r9, 0x20, 0x3f
	ctx.r[9].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 828C8610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8614: 7FC95214  add r30, r9, r10
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828C8618: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 828C861C: 4B9CA3FD  bl 0x82292a18
	ctx.lr = 0x828C8620;
	sub_82292A18(ctx, base);
	// 828C8620: E9030000  ld r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C8624: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828C8628: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C862C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8630: 419A000C  beq cr6, 0x828c863c
	if ctx.cr[6].eq {
	pc = 0x828C863C; continue 'dispatch;
	}
	// 828C8634: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C8638: 419A0008  beq cr6, 0x828c8640
	if ctx.cr[6].eq {
	pc = 0x828C8640; continue 'dispatch;
	}
	// 828C863C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C8640: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8644: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8648: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C864C: 409A00BC  bne cr6, 0x828c8708
	if !ctx.cr[6].eq {
	pc = 0x828C8708; continue 'dispatch;
	}
	// 828C8650: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C8654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8658: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C865C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C8660: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C8664: 7D3F1E70  srawi r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C8668: 48002671  bl 0x828cacd8
	ctx.lr = 0x828C866C;
	sub_828CACD8(ctx, base);
	// 828C866C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C8670: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C8674: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C8678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C867C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C8680: 4B9E49F9  bl 0x822ad078
	ctx.lr = 0x828C8684;
	sub_822AD078(ctx, base);
	// 828C8684: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828C8688: 419A004C  beq cr6, 0x828c86d4
	if ctx.cr[6].eq {
	pc = 0x828C86D4; continue 'dispatch;
	}
	// 828C868C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8690: 419A0038  beq cr6, 0x828c86c8
	if ctx.cr[6].eq {
	pc = 0x828C86C8; continue 'dispatch;
	}
	// 828C8694: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828C8698: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C869C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C86A0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828C86A4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828C86A8: 48000071  bl 0x828c8718
	ctx.lr = 0x828C86AC;
	sub_828C8718(ctx, base);
	// 828C86AC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C86B0: 7C690734  extsh r9, r3
	ctx.r[9].s64 = ctx.r[3].s16 as i64;
	// 828C86B4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C86B8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C86BC: 7D2BE92E  stwx r9, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[9].u32) };
	// 828C86C0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828C86C4: 4082FFD4  bne 0x828c8698
	if !ctx.cr[0].eq {
	pc = 0x828C8698; continue 'dispatch;
	}
	// 828C86C8: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C86CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C86D0: 483E0D80  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828C86D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828C86D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C86DC: 419AFFEC  beq cr6, 0x828c86c8
	if ctx.cr[6].eq {
	pc = 0x828C86C8; continue 'dispatch;
	}
	// 828C86E0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828C86E4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C86E8: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 828C86EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C86F0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828C86F4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C86F8: 409AFFEC  bne cr6, 0x828c86e4
	if !ctx.cr[6].eq {
	pc = 0x828C86E4; continue 'dispatch;
	}
	// 828C86FC: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C8700: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8704: 483E0D4C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828C8708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C870C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8710: 483E0D40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8718 size=456
    let mut pc: u32 = 0x828C8718;
    'dispatch: loop {
        match pc {
            0x828C8718 => {
    //   block [0x828C8718..0x828C88E0)
	// 828C8718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C871C: 483E0CE9  bl 0x82ca9404
	ctx.lr = 0x828C8720;
	sub_82CA93D0(ctx, base);
	// 828C8720: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8724: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C8728: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C872C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C8730: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8738: 419A0164  beq cr6, 0x828c889c
	if ctx.cr[6].eq {
	pc = 0x828C889C; continue 'dispatch;
	}
	// 828C873C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8740: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C8744: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 828C8748: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C874C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C8750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8754: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8758: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C875C: 4B964775  bl 0x8222ced0
	ctx.lr = 0x828C8760;
	sub_8222CED0(ctx, base);
	// 828C8760: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8764: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C8768: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C876C: 419A0008  beq cr6, 0x828c8774
	if ctx.cr[6].eq {
	pc = 0x828C8774; continue 'dispatch;
	}
	// 828C8770: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8774: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C877C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8780: 419A0008  beq cr6, 0x828c8788
	if ctx.cr[6].eq {
	pc = 0x828C8788; continue 'dispatch;
	}
	// 828C8784: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8788: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C878C: 41800058  blt 0x828c87e4
	if ctx.cr[0].lt {
	pc = 0x828C87E4; continue 'dispatch;
	}
	// 828C8790: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8794: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828C8798: 419A0008  beq cr6, 0x828c87a0
	if ctx.cr[6].eq {
	pc = 0x828C87A0; continue 'dispatch;
	}
	// 828C879C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C87A4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828C87A8: 419A0008  beq cr6, 0x828c87b0
	if ctx.cr[6].eq {
	pc = 0x828C87B0; continue 'dispatch;
	}
	// 828C87AC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C87B4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87B8: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C87C0: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 828C87C4: 419A0014  beq cr6, 0x828c87d8
	if ctx.cr[6].eq {
	pc = 0x828C87D8; continue 'dispatch;
	}
	// 828C87C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C87CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C87D0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C87D4: 419AFFE0  beq cr6, 0x828c87b4
	if ctx.cr[6].eq {
	pc = 0x828C87B4; continue 'dispatch;
	}
	// 828C87D8: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C87DC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C87E0: 48000008  b 0x828c87e8
	pc = 0x828C87E8; continue 'dispatch;
	// 828C87E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C87E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C87EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C87F0: 409A00B8  bne cr6, 0x828c88a8
	if !ctx.cr[6].eq {
	pc = 0x828C88A8; continue 'dispatch;
	}
	// 828C87F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C87F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C87FC: 419A0008  beq cr6, 0x828c8804
	if ctx.cr[6].eq {
	pc = 0x828C8804; continue 'dispatch;
	}
	// 828C8800: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8804: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C880C: 419A0008  beq cr6, 0x828c8814
	if ctx.cr[6].eq {
	pc = 0x828C8814; continue 'dispatch;
	}
	// 828C8810: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8814: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8818: 41800058  blt 0x828c8870
	if ctx.cr[0].lt {
	pc = 0x828C8870; continue 'dispatch;
	}
	// 828C881C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8820: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828C8824: 419A0008  beq cr6, 0x828c882c
	if ctx.cr[6].eq {
	pc = 0x828C882C; continue 'dispatch;
	}
	// 828C8828: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C882C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8830: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828C8834: 419A0008  beq cr6, 0x828c883c
	if ctx.cr[6].eq {
	pc = 0x828C883C; continue 'dispatch;
	}
	// 828C8838: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C883C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C8840: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8844: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8848: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C884C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C8850: 419A0014  beq cr6, 0x828c8864
	if ctx.cr[6].eq {
	pc = 0x828C8864; continue 'dispatch;
	}
	// 828C8854: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C8858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C885C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8860: 419AFFE0  beq cr6, 0x828c8840
	if ctx.cr[6].eq {
	pc = 0x828C8840; continue 'dispatch;
	}
	// 828C8864: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C8868: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C886C: 48000008  b 0x828c8874
	pc = 0x828C8874; continue 'dispatch;
	// 828C8870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8874: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C887C: 409A002C  bne cr6, 0x828c88a8
	if !ctx.cr[6].eq {
	pc = 0x828C88A8; continue 'dispatch;
	}
	// 828C8880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8884: 4B94C555  bl 0x82214dd8
	ctx.lr = 0x828C8888;
	sub_82214DD8(ctx, base);
	// 828C8888: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C888C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828C8890: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C8894: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C8898: 409AFEB0  bne cr6, 0x828c8748
	if !ctx.cr[6].eq {
	pc = 0x828C8748; continue 'dispatch;
	}
	// 828C889C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 828C88A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C88A4: 483E0BB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828C88A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C88AC: 4B8FDEBD  bl 0x821c6768
	ctx.lr = 0x828C88B0;
	sub_821C6768(ctx, base);
	// 828C88B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C88B4: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 828C88B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C88BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C88C0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C88C4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C88C8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C88CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C88D0: 4082FFE8  bne 0x828c88b8
	if !ctx.cr[0].eq {
	pc = 0x828C88B8; continue 'dispatch;
	}
	// 828C88D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C88D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C88DC: 483E0B78  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C88E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C88E0 size=80
    let mut pc: u32 = 0x828C88E0;
    'dispatch: loop {
        match pc {
            0x828C88E0 => {
    //   block [0x828C88E0..0x828C8930)
	// 828C88E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C88E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C88E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C88EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C88F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C88F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C88F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C88FC: 48000035  bl 0x828c8930
	ctx.lr = 0x828C8900;
	sub_828C8930(ctx, base);
	// 828C8900: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828C8904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C890C: 419A000C  beq cr6, 0x828c8918
	if ctx.cr[6].eq {
	pc = 0x828C8918; continue 'dispatch;
	}
	// 828C8910: 4B953429  bl 0x8221bd38
	ctx.lr = 0x828C8914;
	sub_8221BD38(ctx, base);
	// 828C8914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C891C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C892C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8930 size=236
    let mut pc: u32 = 0x828C8930;
    'dispatch: loop {
        match pc {
            0x828C8930 => {
    //   block [0x828C8930..0x828C8A1C)
	// 828C8930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C893C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8948: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C894C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C8950: 394B32C0  addi r10, r11, 0x32c0
	ctx.r[10].s64 = ctx.r[11].s64 + 12992;
	// 828C8954: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8958: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C895C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8960: 419A0040  beq cr6, 0x828c89a0
	if ctx.cr[6].eq {
	pc = 0x828C89A0; continue 'dispatch;
	}
	// 828C8964: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C896C: 419A0030  beq cr6, 0x828c899c
	if ctx.cr[6].eq {
	pc = 0x828C899C; continue 'dispatch;
	}
	// 828C8970: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8974: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8978: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C897C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8980: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8984: 409A0018  bne cr6, 0x828c899c
	if !ctx.cr[6].eq {
	pc = 0x828C899C; continue 'dispatch;
	}
	// 828C8988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C898C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8990: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8994: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8998: 4E800421  bctrl
	ctx.lr = 0x828C899C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C899C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828C89A0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C89A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C89A8: 419A0040  beq cr6, 0x828c89e8
	if ctx.cr[6].eq {
	pc = 0x828C89E8; continue 'dispatch;
	}
	// 828C89AC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C89B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C89B4: 419A0030  beq cr6, 0x828c89e4
	if ctx.cr[6].eq {
	pc = 0x828C89E4; continue 'dispatch;
	}
	// 828C89B8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C89BC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C89C0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C89C4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C89C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C89CC: 409A0018  bne cr6, 0x828c89e4
	if !ctx.cr[6].eq {
	pc = 0x828C89E4; continue 'dispatch;
	}
	// 828C89D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C89D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C89D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C89DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C89E0: 4E800421  bctrl
	ctx.lr = 0x828C89E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C89E4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 828C89E8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828C89EC: 4B8EF12D  bl 0x821b7b18
	ctx.lr = 0x828C89F0;
	sub_821B7B18(ctx, base);
	// 828C89F0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828C89F4: 4B8EF125  bl 0x821b7b18
	ctx.lr = 0x828C89F8;
	sub_821B7B18(ctx, base);
	// 828C89F8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C89FC: 394B3268  addi r10, r11, 0x3268
	ctx.r[10].s64 = ctx.r[11].s64 + 12904;
	// 828C8A00: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C8A04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8A10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8A14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8A18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8A20 size=16
    let mut pc: u32 = 0x828C8A20;
    'dispatch: loop {
        match pc {
            0x828C8A20 => {
    //   block [0x828C8A20..0x828C8A30)
	// 828C8A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8A24: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 828C8A28: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C8A2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8A30 size=412
    let mut pc: u32 = 0x828C8A30;
    'dispatch: loop {
        match pc {
            0x828C8A30 => {
    //   block [0x828C8A30..0x828C8BCC)
	// 828C8A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8A34: 483E09D1  bl 0x82ca9404
	ctx.lr = 0x828C8A38;
	sub_82CA93D0(ctx, base);
	// 828C8A38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8A40: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8A44: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 828C8A48: 3F608000  lis r27, -0x8000
	ctx.r[27].s64 = -2147483648;
	// 828C8A4C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8A50: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8A54: 7D7CE82E  lwzx r11, r28, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8A58: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8A5C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8A60: 7D48DB78  or r8, r10, r27
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[27].u64;
	// 828C8A64: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8A68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C8A6C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C8A70: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8A74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8A78: 419A0020  beq cr6, 0x828c8a98
	if ctx.cr[6].eq {
	pc = 0x828C8A98; continue 'dispatch;
	}
	// 828C8A7C: 812B005C  lwz r9, 0x5c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8A80: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8A84: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828C8A88: 912B005C  stw r9, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828C8A8C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8A90: 910B0058  stw r8, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8A94: 48000010  b 0x828c8aa4
	pc = 0x828C8AA4; continue 'dispatch;
	// 828C8A98: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C8A9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8AA0: 4848C5B1  bl 0x82d55050
	ctx.lr = 0x828C8AA4;
	sub_82D55050(ctx, base);
	// 828C8AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8AA8: 419A001C  beq cr6, 0x828c8ac4
	if ctx.cr[6].eq {
	pc = 0x828C8AC4; continue 'dispatch;
	}
	// 828C8AAC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C8AB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8AB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8AB8: 4849AE01  bl 0x82d638b8
	ctx.lr = 0x828C8ABC;
	sub_82D638B8(ctx, base);
	// 828C8ABC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C8AC0: 48000008  b 0x828c8ac8
	pc = 0x828C8AC8; continue 'dispatch;
	// 828C8AC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C8AC8: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828C8ACC: 4BD4969D  bl 0x82612168
	ctx.lr = 0x828C8AD0;
	sub_82612168(ctx, base);
	// 828C8AD0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8AD4: 4849B32D  bl 0x82d63e00
	ctx.lr = 0x828C8AD8;
	sub_82D63E00(ctx, base);
	// 828C8AD8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8ADC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C8AE0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C8AE4: 409A0024  bne cr6, 0x828c8b08
	if !ctx.cr[6].eq {
	pc = 0x828C8B08; continue 'dispatch;
	}
	// 828C8AE8: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C8AEC: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8AF0: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 828C8AF4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8AF8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C8AFC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C8B00: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C8B04: 4848C7C5  bl 0x82d552c8
	ctx.lr = 0x828C8B08;
	sub_82D552C8(ctx, base);
	// 828C8B08: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8B0C: 7D7CE82E  lwzx r11, r28, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8B10: 83EA0008  lwz r31, 8(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8B14: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8B18: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8B1C: 7D27DB78  or r7, r9, r27
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[27].u64;
	// 828C8B20: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 828C8B24: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828C8B28: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 828C8B2C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8B30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8B34: 419A0020  beq cr6, 0x828c8b54
	if ctx.cr[6].eq {
	pc = 0x828C8B54; continue 'dispatch;
	}
	// 828C8B38: 812B005C  lwz r9, 0x5c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8B3C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8B40: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828C8B44: 912B005C  stw r9, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828C8B48: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8B4C: 910B0058  stw r8, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8B50: 48000010  b 0x828c8b60
	pc = 0x828C8B60; continue 'dispatch;
	// 828C8B54: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C8B58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8B5C: 4848C4F5  bl 0x82d55050
	ctx.lr = 0x828C8B60;
	sub_82D55050(ctx, base);
	// 828C8B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8B64: 419A001C  beq cr6, 0x828c8b80
	if ctx.cr[6].eq {
	pc = 0x828C8B80; continue 'dispatch;
	}
	// 828C8B68: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828C8B6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8B70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8B74: 4849AD45  bl 0x82d638b8
	ctx.lr = 0x828C8B78;
	sub_82D638B8(ctx, base);
	// 828C8B78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C8B7C: 48000008  b 0x828c8b84
	pc = 0x828C8B84; continue 'dispatch;
	// 828C8B80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C8B84: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828C8B88: 4BD495E1  bl 0x82612168
	ctx.lr = 0x828C8B8C;
	sub_82612168(ctx, base);
	// 828C8B8C: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8B90: 4849B271  bl 0x82d63e00
	ctx.lr = 0x828C8B94;
	sub_82D63E00(ctx, base);
	// 828C8B94: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C8B98: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C8B9C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C8BA0: 409A0024  bne cr6, 0x828c8bc4
	if !ctx.cr[6].eq {
	pc = 0x828C8BC4; continue 'dispatch;
	}
	// 828C8BA4: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C8BA8: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8BAC: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 828C8BB0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C8BB4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C8BB8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C8BBC: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C8BC0: 4848C709  bl 0x82d552c8
	ctx.lr = 0x828C8BC4;
	sub_82D552C8(ctx, base);
	// 828C8BC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8BC8: 483E088C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8BD0 size=8
    let mut pc: u32 = 0x828C8BD0;
    'dispatch: loop {
        match pc {
            0x828C8BD0 => {
    //   block [0x828C8BD0..0x828C8BD8)
	// 828C8BD0: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 828C8BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8BD8 size=156
    let mut pc: u32 = 0x828C8BD8;
    'dispatch: loop {
        match pc {
            0x828C8BD8 => {
    //   block [0x828C8BD8..0x828C8C74)
	// 828C8BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8BF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C8BF4: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8BFC: 419A003C  beq cr6, 0x828c8c38
	if ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C00: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8C08: 419A0030  beq cr6, 0x828c8c38
	if ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C0C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8C10: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8C14: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C8C18: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8C1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8C20: 409A0018  bne cr6, 0x828c8c38
	if !ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8C2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8C34: 4E800421  bctrl
	ctx.lr = 0x828C8C38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8C38: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 828C8C3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8C40: 419A001C  beq cr6, 0x828c8c5c
	if ctx.cr[6].eq {
	pc = 0x828C8C5C; continue 'dispatch;
	}
	// 828C8C44: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8C4C: 419A0010  beq cr6, 0x828c8c5c
	if ctx.cr[6].eq {
	pc = 0x828C8C5C; continue 'dispatch;
	}
	// 828C8C50: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8C54: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C8C58: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 828C8C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8C60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8C64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8C68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8C78 size=156
    let mut pc: u32 = 0x828C8C78;
    'dispatch: loop {
        match pc {
            0x828C8C78 => {
    //   block [0x828C8C78..0x828C8D14)
	// 828C8C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C8C94: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8C9C: 419A003C  beq cr6, 0x828c8cd8
	if ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CA0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8CA8: 419A0030  beq cr6, 0x828c8cd8
	if ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CAC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8CB0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8CB4: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C8CB8: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8CBC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8CC0: 409A0018  bne cr6, 0x828c8cd8
	if !ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8CC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8CCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8CD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8CD4: 4E800421  bctrl
	ctx.lr = 0x828C8CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8CD8: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 828C8CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8CE0: 419A001C  beq cr6, 0x828c8cfc
	if ctx.cr[6].eq {
	pc = 0x828C8CFC; continue 'dispatch;
	}
	// 828C8CE4: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8CEC: 419A0010  beq cr6, 0x828c8cfc
	if ctx.cr[6].eq {
	pc = 0x828C8CFC; continue 'dispatch;
	}
	// 828C8CF0: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8CF4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C8CF8: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 828C8CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8D18 size=224
    let mut pc: u32 = 0x828C8D18;
    'dispatch: loop {
        match pc {
            0x828C8D18 => {
    //   block [0x828C8D18..0x828C8DF8)
	// 828C8D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8D28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828C8D2C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8D34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C8D38: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C8D3C: 4B9B4C75  bl 0x8227d9b0
	ctx.lr = 0x828C8D40;
	sub_8227D9B0(ctx, base);
	// 828C8D40: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C8D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D48: 419A0020  beq cr6, 0x828c8d68
	if ctx.cr[6].eq {
	pc = 0x828C8D68; continue 'dispatch;
	}
	// 828C8D4C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C8D50: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828C8D54: 419A000C  beq cr6, 0x828c8d60
	if ctx.cr[6].eq {
	pc = 0x828C8D60; continue 'dispatch;
	}
	// 828C8D58: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C8D5C: 409A000C  bne cr6, 0x828c8d68
	if !ctx.cr[6].eq {
	pc = 0x828C8D68; continue 'dispatch;
	}
	// 828C8D60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8D64: 48000008  b 0x828c8d6c
	pc = 0x828C8D6C; continue 'dispatch;
	// 828C8D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D74: 419A0068  beq cr6, 0x828c8ddc
	if ctx.cr[6].eq {
	pc = 0x828C8DDC; continue 'dispatch;
	}
	// 828C8D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8D7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C8D80: 4B9B4B29  bl 0x8227d8a8
	ctx.lr = 0x828C8D84;
	sub_8227D8A8(ctx, base);
	// 828C8D84: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8D88: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8D94: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8D98: 419A0020  beq cr6, 0x828c8db8
	if ctx.cr[6].eq {
	pc = 0x828C8DB8; continue 'dispatch;
	}
	// 828C8D9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8DA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8DA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8DA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8DAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8DB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8DB4: 4082FFE8  bne 0x828c8d9c
	if !ctx.cr[0].eq {
	pc = 0x828C8D9C; continue 'dispatch;
	}
	// 828C8DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8DBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C8DC0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C8DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8DC8: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C8DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8DD0: 4E800421  bctrl
	ctx.lr = 0x828C8DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8DD8: 4B8EED41  bl 0x821b7b18
	ctx.lr = 0x828C8DDC;
	sub_821B7B18(ctx, base);
	// 828C8DDC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8DE8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828C8DEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8DF8 size=136
    let mut pc: u32 = 0x828C8DF8;
    'dispatch: loop {
        match pc {
            0x828C8DF8 => {
    //   block [0x828C8DF8..0x828C8E80)
	// 828C8DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8E04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8E0C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8E14: 419A0058  beq cr6, 0x828c8e6c
	if ctx.cr[6].eq {
	pc = 0x828C8E6C; continue 'dispatch;
	}
	// 828C8E18: 4B9B4B99  bl 0x8227d9b0
	ctx.lr = 0x828C8E1C;
	sub_8227D9B0(ctx, base);
	// 828C8E1C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8E20: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8E28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8E2C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8E30: 419A0020  beq cr6, 0x828c8e50
	if ctx.cr[6].eq {
	pc = 0x828C8E50; continue 'dispatch;
	}
	// 828C8E34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8E38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8E3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8E40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8E44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8E48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8E4C: 4082FFE8  bne 0x828c8e34
	if !ctx.cr[0].eq {
	pc = 0x828C8E34; continue 'dispatch;
	}
	// 828C8E50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8E58: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C8E5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8E60: 4E800421  bctrl
	ctx.lr = 0x828C8E64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8E68: 4B8EECB1  bl 0x821b7b18
	ctx.lr = 0x828C8E6C;
	sub_821B7B18(ctx, base);
	// 828C8E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8E78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8E7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8E80 size=656
    let mut pc: u32 = 0x828C8E80;
    'dispatch: loop {
        match pc {
            0x828C8E80 => {
    //   block [0x828C8E80..0x828C9110)
	// 828C8E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8E84: 483E0561  bl 0x82ca93e4
	ctx.lr = 0x828C8E88;
	sub_82CA93D0(ctx, base);
	// 828C8E88: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8E90: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C8E94: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 828C8E98: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828C8E9C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8EA0: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8EA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8EAC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C8EB0: 419A0020  beq cr6, 0x828c8ed0
	if ctx.cr[6].eq {
	pc = 0x828C8ED0; continue 'dispatch;
	}
	// 828C8EB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8EB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8EBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8EC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8EC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8EC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8ECC: 4082FFE8  bne 0x828c8eb4
	if !ctx.cr[0].eq {
	pc = 0x828C8EB4; continue 'dispatch;
	}
	// 828C8ED0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C8ED4: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8ED8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C8EDC: 4B9B49CD  bl 0x8227d8a8
	ctx.lr = 0x828C8EE0;
	sub_8227D8A8(ctx, base);
	// 828C8EE0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C8EE4: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C8EE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8EF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C8EF4: 4E800421  bctrl
	ctx.lr = 0x828C8EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8EFC: 4B8EEC1D  bl 0x821b7b18
	ctx.lr = 0x828C8F00;
	sub_821B7B18(ctx, base);
	// 828C8F00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C8F04: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8F08: 3A9F0008  addi r20, r31, 8
	ctx.r[20].s64 = ctx.r[31].s64 + 8;
	// 828C8F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8F10: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C8F14: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 828C8F18: 419A0020  beq cr6, 0x828c8f38
	if ctx.cr[6].eq {
	pc = 0x828C8F38; continue 'dispatch;
	}
	// 828C8F1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8F20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8F28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8F2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8F30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F34: 4082FFE8  bne 0x828c8f1c
	if !ctx.cr[0].eq {
	pc = 0x828C8F1C; continue 'dispatch;
	}
	// 828C8F38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8F3C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8F44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8F48: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8F4C: 419A0020  beq cr6, 0x828c8f6c
	if ctx.cr[6].eq {
	pc = 0x828C8F6C; continue 'dispatch;
	}
	// 828C8F50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8F54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8F5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8F60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8F64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F68: 4082FFE8  bne 0x828c8f50
	if !ctx.cr[0].eq {
	pc = 0x828C8F50; continue 'dispatch;
	}
	// 828C8F6C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828C8F70: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8F74: 4849DCDD  bl 0x82d66c50
	ctx.lr = 0x828C8F78;
	sub_82D66C50(ctx, base);
	// 828C8F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8F7C: 4B8EEB9D  bl 0x821b7b18
	ctx.lr = 0x828C8F80;
	sub_821B7B18(ctx, base);
	// 828C8F80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C8F84: 4B8EEB95  bl 0x821b7b18
	ctx.lr = 0x828C8F88;
	sub_821B7B18(ctx, base);
	// 828C8F88: E87F0028  ld r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 828C8F8C: 4BFFF5ED  bl 0x828c8578
	ctx.lr = 0x828C8F90;
	sub_828C8578(ctx, base);
	// 828C8F90: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8F94: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8F98: 3AA00030  li r21, 0x30
	ctx.r[21].s64 = 48;
	// 828C8F9C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 828C8FA0: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 828C8FA4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C8FA8: 7D2AABD7  divw. r9, r10, r21
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[21].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8FAC: 4182015C  beq 0x828c9108
	if ctx.cr[0].eq {
	pc = 0x828C9108; continue 'dispatch;
	}
	// 828C8FB0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C8FB4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828C8FB8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 828C8FBC: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 828C8FC0: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	// 828C8FC4: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8FC8: 7C98582E  lwzx r4, r24, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8FCC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828C8FD0: 419A009C  beq cr6, 0x828c906c
	if ctx.cr[6].eq {
	pc = 0x828C906C; continue 'dispatch;
	}
	// 828C8FD4: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8FD8: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8FE0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C8FE4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C8FE8: 419A0020  beq cr6, 0x828c9008
	if ctx.cr[6].eq {
	pc = 0x828C9008; continue 'dispatch;
	}
	// 828C8FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8FF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8FFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9004: 4082FFE8  bne 0x828c8fec
	if !ctx.cr[0].eq {
	pc = 0x828C8FEC; continue 'dispatch;
	}
	// 828C9008: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C900C: 7D4B20AE  lbzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 828C9010: 554907BC  rlwinm r9, r10, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C9014: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9018: 409A001C  bne cr6, 0x828c9034
	if !ctx.cr[6].eq {
	pc = 0x828C9034; continue 'dispatch;
	}
	// 828C901C: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C9020: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C9024: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 828C9028: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C902C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C9030: 4800000C  b 0x828c903c
	pc = 0x828C903C; continue 'dispatch;
	// 828C9034: 4849A9AD  bl 0x82d639e0
	ctx.lr = 0x828C9038;
	sub_82D639E0(ctx, base);
	// 828C9038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C903C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C9040: 4B8EEAD9  bl 0x821b7b18
	ctx.lr = 0x828C9044;
	sub_821B7B18(ctx, base);
	// 828C9044: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9048: E93F0010  ld r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 828C904C: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 828C9050: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 828C9054: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828C9058: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C905C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9110 size=80
    let mut pc: u32 = 0x828C9110;
    'dispatch: loop {
        match pc {
            0x828C9110 => {
    //   block [0x828C9110..0x828C9160)
	// 828C9110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C9118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C911C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C9120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9128: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C912C: 48000035  bl 0x828c9160
	ctx.lr = 0x828C9130;
	sub_828C9160(ctx, base);
	// 828C9130: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828C9134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C913C: 419A000C  beq cr6, 0x828c9148
	if ctx.cr[6].eq {
	pc = 0x828C9148; continue 'dispatch;
	}
	// 828C9140: 4B952BF9  bl 0x8221bd38
	ctx.lr = 0x828C9144;
	sub_8221BD38(ctx, base);
	// 828C9144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9148: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C914C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C9150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C9154: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C9158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C915C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9160 size=332
    let mut pc: u32 = 0x828C9160;
    'dispatch: loop {
        match pc {
            0x828C9160 => {
    //   block [0x828C9160..0x828C92AC)
	// 828C9160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9164: 483E02A1  bl 0x82ca9404
	ctx.lr = 0x828C9168;
	sub_82CA93D0(ctx, base);
	// 828C9168: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C916C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C9174: 3BDD0098  addi r30, r29, 0x98
	ctx.r[30].s64 = ctx.r[29].s64 + 152;
	// 828C9178: 394B6418  addi r10, r11, 0x6418
	ctx.r[10].s64 = ctx.r[11].s64 + 25624;
	// 828C917C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9180: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C9184: 4B8EE995  bl 0x821b7b18
	ctx.lr = 0x828C9188;
	sub_821B7B18(ctx, base);
	// 828C9188: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C918C: 937D0098  stw r27, 0x98(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(152 as u32), ctx.r[27].u32 ) };
	// 828C9190: 807D0094  lwz r3, 0x94(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9198: 419A003C  beq cr6, 0x828c91d4
	if ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C919C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C91A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C91A4: 419A0030  beq cr6, 0x828c91d4
	if ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C91A8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C91AC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C91B0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C91B4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C91B8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C91BC: 409A0018  bne cr6, 0x828c91d4
	if !ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C91C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C91C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C91C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C91CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C91D0: 4E800421  bctrl
	ctx.lr = 0x828C91D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C91D4: 815D0050  lwz r10, 0x50(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C91D8: 3B9D0048  addi r28, r29, 0x48
	ctx.r[28].s64 = ctx.r[29].s64 + 72;
	// 828C91DC: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C91E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C91E4: 40990008  ble cr6, 0x828c91ec
	if !ctx.cr[6].gt {
	pc = 0x828C91EC; continue 'dispatch;
	}
	// 828C91E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C91EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C91F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C91F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C91F8: 40990008  ble cr6, 0x828c9200
	if !ctx.cr[6].gt {
	pc = 0x828C9200; continue 'dispatch;
	}
	// 828C91FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9200: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C9204: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C9208: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C920C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828C9210: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9214: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C9218: 480020E1  bl 0x828cb2f8
	ctx.lr = 0x828C921C;
	sub_828CB2F8(ctx, base);
	// 828C921C: 815D0040  lwz r10, 0x40(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C9220: 3BFD0038  addi r31, r29, 0x38
	ctx.r[31].s64 = ctx.r[29].s64 + 56;
	// 828C9224: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C9228: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C922C: 40990008  ble cr6, 0x828c9234
	if !ctx.cr[6].gt {
	pc = 0x828C9234; continue 'dispatch;
	}
	// 828C9230: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9234: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C9238: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C923C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C9240: 40990008  ble cr6, 0x828c9248
	if !ctx.cr[6].gt {
	pc = 0x828C9248; continue 'dispatch;
	}
	// 828C9244: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9248: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C924C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C9254: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C9258: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C925C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9260: 4BF2F629  bl 0x827f8888
	ctx.lr = 0x828C9264;
	sub_827F8888(ctx, base);
	// 828C9264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9268: 4B8EE8B1  bl 0x821b7b18
	ctx.lr = 0x828C926C;
	sub_821B7B18(ctx, base);
	// 828C926C: 807D0088  lwz r3, 0x88(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 828C9270: 3BDD0084  addi r30, r29, 0x84
	ctx.r[30].s64 = ctx.r[29].s64 + 132;
	// 828C9274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9278: 419A0008  beq cr6, 0x828c9280
	if ctx.cr[6].eq {
	pc = 0x828C9280; continue 'dispatch;
	}
	// 828C927C: 4B952ABD  bl 0x8221bd38
	ctx.lr = 0x828C9280;
	sub_8221BD38(ctx, base);
	// 828C9280: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828C9284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C9288: 937E0008  stw r27, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828C928C: 937E000C  stw r27, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 828C9290: 4BB13599  bl 0x823dc828
	ctx.lr = 0x828C9294;
	sub_823DC828(ctx, base);
	// 828C9294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9298: 4BB13591  bl 0x823dc828
	ctx.lr = 0x828C929C;
	sub_823DC828(ctx, base);
	// 828C929C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C92A0: 4BFFF691  bl 0x828c8930
	ctx.lr = 0x828C92A4;
	sub_828C8930(ctx, base);
	// 828C92A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C92A8: 483E01AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C92B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C92B0 size=3340
    let mut pc: u32 = 0x828C92B0;
    'dispatch: loop {
        match pc {
            0x828C92B0 => {
    //   block [0x828C92B0..0x828C9FBC)
	// 828C92B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C92B4: 483E011D  bl 0x82ca93d0
	ctx.lr = 0x828C92B8;
	sub_82CA93D0(ctx, base);
	// 828C92B8: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C92BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 828C92C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C92C4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828C92C8: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 828C92CC: 93410284  stw r26, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[26].u32 ) };
	// 828C92D0: 386BB078  addi r3, r11, -0x4f88
	ctx.r[3].s64 = ctx.r[11].s64 + -20360;
	// 828C92D4: 92E10294  stw r23, 0x294(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), ctx.r[23].u32 ) };
	// 828C92D8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C92DC: 92C102B4  stw r22, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[22].u32 ) };
	// 828C92E0: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 828C92E4: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 828C92E8: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 828C92EC: 4848C465  bl 0x82d55750
	ctx.lr = 0x828C92F0;
	sub_82D55750(ctx, base);
	// 828C92F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C92F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C92F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C92FC: 484A81DD  bl 0x82d714d8
	ctx.lr = 0x828C9300;
	sub_82D714D8(ctx, base);
	// 828C9300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9304: 419A0CB0  beq cr6, 0x828c9fb4
	if ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C9308: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C930C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9310: 419A0CA4  beq cr6, 0x828c9fb4
	if ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C9314: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9318: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 828C931C: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 828C9320: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 828C9324: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 828C9328: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 828C932C: 81EB0000  lwz r15, 0(r11)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9330: 3BEF0008  addi r31, r15, 8
	ctx.r[31].s64 = ctx.r[15].s64 + 8;
	// 828C9334: 83CF000C  lwz r30, 0xc(r15)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9338: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C933C: 40990030  ble cr6, 0x828c936c
	if !ctx.cr[6].gt {
	pc = 0x828C936C; continue 'dispatch;
	}
	// 828C9340: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9344: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C9348: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C934C: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9350: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9354: 4848BEF5  bl 0x82d55248
	ctx.lr = 0x828C9358;
	sub_82D55248(ctx, base);
	// 828C9358: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C935C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9360: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828C9364: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 828C9368: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 828C936C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9370: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C9374: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 828C9378: 40990028  ble cr6, 0x828c93a0
	if !ctx.cr[6].gt {
	pc = 0x828C93A0; continue 'dispatch;
	}
	// 828C937C: 7D245050  subf r9, r4, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 828C9380: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C9384: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828C9388: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C938C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9390: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828C9394: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9398: 4082FFF0  bne 0x828c9388
	if !ctx.cr[0].eq {
	pc = 0x828C9388; continue 'dispatch;
	}
	// 828C939C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C93A0: 409A0030  bne cr6, 0x828c93d0
	if !ctx.cr[6].eq {
	pc = 0x828C93D0; continue 'dispatch;
	}
	// 828C93A4: 550B0000  rlwinm r11, r8, 0, 0, 0
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 828C93A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C93AC: 409A0C08  bne cr6, 0x828c9fb4
	if !ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C93B0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C93B4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C93B8: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C93BC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C93C0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C93C4: 4848BF05  bl 0x82d552c8
	ctx.lr = 0x828C93C8;
	sub_82D552C8(ctx, base);
	// 828C93C8: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 828C93CC: 483E0054  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
	// 828C93D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 828C93D4: 3BAB79E4  addi r29, r11, 0x79e4
	ctx.r[29].s64 = ctx.r[11].s64 + 31204;
	// 828C93D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C93DC: 4848C375  bl 0x82d55750
	ctx.lr = 0x828C93E0;
	sub_82D55750(ctx, base);
	// 828C93E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C93E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C93E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C93EC: 484A80ED  bl 0x82d714d8
	ctx.lr = 0x828C93F0;
	sub_82D714D8(ctx, base);
	// 828C93F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C93F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C93F8: 4848C359  bl 0x82d55750
	ctx.lr = 0x828C93FC;
	sub_82D55750(ctx, base);
	// 828C93FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9400: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C9404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C9408: 484A80D1  bl 0x82d714d8
	ctx.lr = 0x828C940C;
	sub_82D714D8(ctx, base);
	// 828C940C: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9410: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 828C9414: 82030008  lwz r16, 8(r3)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9418: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 828C941C: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 828C9420: 3BA30008  addi r29, r3, 8
	ctx.r[29].s64 = ctx.r[3].s64 + 8;
	// 828C9424: 93010078  stw r24, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[24].u32 ) };
	// 828C9428: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C942C: 4848BE1D  bl 0x82d55248
	ctx.lr = 0x828C9430;
	sub_82D55248(ctx, base);
	// 828C9430: 3B800038  li r28, 0x38
	ctx.r[28].s64 = 56;
	// 828C9434: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828C9438: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828C943C: 4849D87D  bl 0x82d66cb8
	ctx.lr = 0x828C9440;
	sub_82D66CB8(ctx, base);
	// 828C9440: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C9444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9448: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 828C944C: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 828C9450: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C9454: 4848BDF5  bl 0x82d55248
	ctx.lr = 0x828C9458;
	sub_82D55248(ctx, base);
	// 828C9458: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828C945C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C9460: 4849D859  bl 0x82d66cb8
	ctx.lr = 0x828C9464;
	sub_82D66CB8(ctx, base);
	// 828C9464: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C946C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C9470: 4BFFF769  bl 0x828c8bd8
	ctx.lr = 0x828C9474;
	sub_828C8BD8(ctx, base);
	// 828C9474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C9478: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C947C: 4BFFF7FD  bl 0x828c8c78
	ctx.lr = 0x828C9480;
	sub_828C8C78(ctx, base);
	// 828C9480: A13F0004  lhz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9484: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C9488: 419A0034  beq cr6, 0x828c94bc
	if ctx.cr[6].eq {
	pc = 0x828C94BC; continue 'dispatch;
	}
	// 828C948C: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9490: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C9494: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C9498: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C949C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C94A0: 409A001C  bne cr6, 0x828c94bc
	if !ctx.cr[6].eq {
	pc = 0x828C94BC; continue 'dispatch;
	}
	// 828C94A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C94AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C94B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C94B8: 4E800421  bctrl
	ctx.lr = 0x828C94BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C94BC: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C94C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C94C4: 419A0034  beq cr6, 0x828c94f8
	if ctx.cr[6].eq {
	pc = 0x828C94F8; continue 'dispatch;
	}
	// 828C94C8: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C94CC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C94D0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C94D4: B13D0006  sth r9, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C94D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C94DC: 409A001C  bne cr6, 0x828c94f8
	if !ctx.cr[6].eq {
	pc = 0x828C94F8; continue 'dispatch;
	}
	// 828C94E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C94E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C94EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C94F4: 4E800421  bctrl
	ctx.lr = 0x828C94F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C94F8: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 828C94FC: 7E489378  mr r8, r18
	ctx.r[8].u64 = ctx.r[18].u64;
	// 828C9500: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828C9504: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 828C9508: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828C950C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C9510: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C9514: 4BFFF51D  bl 0x828c8a30
	ctx.lr = 0x828C9518;
	sub_828C8A30(ctx, base);
	// 828C9518: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C951C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C9520: 386B3220  addi r3, r11, 0x3220
	ctx.r[3].s64 = ctx.r[11].s64 + 12832;
	// 828C9524: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C9528: 3BFA0080  addi r31, r26, 0x80
	ctx.r[31].s64 = ctx.r[26].s64 + 128;
	// 828C952C: 4B92A82D  bl 0x821f3d58
	ctx.lr = 0x828C9530;
	sub_821F3D58(ctx, base);
	// 828C9530: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9534: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C9538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C953C: 48136E75  bl 0x82a003b0
	ctx.lr = 0x828C9540;
	sub_82A003B0(ctx, base);
	// 828C9540: 91C100B4  stw r14, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[14].u32 ) };
	// 828C9544: 91C100B8  stw r14, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[14].u32 ) };
	// 828C9548: 3A9A0038  addi r20, r26, 0x38
	ctx.r[20].s64 = ctx.r[26].s64 + 56;
	// 828C954C: 91C100BC  stw r14, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[14].u32 ) };
	// 828C9550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C9554: 91C10050  stw r14, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[14].u32 ) };
	// 828C9558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C955C: 91C10054  stw r14, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[14].u32 ) };
	// 828C9560: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828C9564: 48001C6D  bl 0x828cb1d0
	ctx.lr = 0x828C9568;
	sub_828CB1D0(ctx, base);
	// 828C9568: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828C956C: 4B955CED  bl 0x8221f258
	ctx.lr = 0x828C9570;
	sub_8221F258(ctx, base);
	// 828C9570: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C9574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9578: 419A0008  beq cr6, 0x828c9580
	if ctx.cr[6].eq {
	pc = 0x828C9580; continue 'dispatch;
	}
	// 828C957C: 91CB0000  stw r14, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 828C9580: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9584: 41820008  beq 0x828c958c
	if ctx.cr[0].eq {
	pc = 0x828C958C; continue 'dispatch;
	}
	// 828C9588: 91CA0000  stw r14, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 828C958C: 354B0008  addic. r10, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9590: 41820008  beq 0x828c9598
	if ctx.cr[0].eq {
	pc = 0x828C9598; continue 'dispatch;
	}
	// 828C9594: 91CA0000  stw r14, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 828C9598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C959C: 99CB0015  stb r14, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[14].u8 ) };
	// 828C95A0: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C95A4: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C95A8: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 828C95AC: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C95B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C95B4: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 828C95B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95BC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C95C0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95C4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C95C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95CC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C95D0: 91C10060  stw r14, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[14].u32 ) };
	// 828C95D4: 4848BC75  bl 0x82d55248
	ctx.lr = 0x828C95D8;
	sub_82D55248(ctx, base);
	// 828C95D8: 90610090  stw r3, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 828C95DC: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 828C95E0: 3ADA0084  addi r22, r26, 0x84
	ctx.r[22].s64 = ctx.r[26].s64 + 132;
	// 828C95E4: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 828C95E8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 828C95EC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 828C95F0: 80900010  lwz r4, 0x10(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C95F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828C95F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C95FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C9600: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9604: 48001DED  bl 0x828cb3f0
	ctx.lr = 0x828C9608;
	sub_828CB3F0(ctx, base);
	// 828C9608: 81300010  lwz r9, 0x10(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C960C: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 828C9610: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C9614: 419A01F8  beq cr6, 0x828c980c
	if ctx.cr[6].eq {
	pc = 0x828C980C; continue 'dispatch;
	}
	// 828C9618: 56353032  slwi r21, r17, 6
	ctx.r[21].u32 = ctx.r[17].u32.wrapping_shl(6);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 828C961C: 7DD87378  mr r24, r14
	ctx.r[24].u64 = ctx.r[14].u64;
	// 828C9620: 7DD77378  mr r23, r14
	ctx.r[23].u64 = ctx.r[14].u64;
	// 828C9624: 8170000C  lwz r11, 0xc(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9628: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C962C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9630: 7D57582E  lwzx r10, r23, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9634: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9638: 4B963899  bl 0x8222ced0
	ctx.lr = 0x828C963C;
	sub_8222CED0(ctx, base);
	// 828C963C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C9640: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828C9644: 4BFFEDF5  bl 0x828c8438
	ctx.lr = 0x828C9648;
	sub_828C8438(ctx, base);
	// 828C9648: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C964C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C9650: 409A000C  bne cr6, 0x828c965c
	if !ctx.cr[6].eq {
	pc = 0x828C965C; continue 'dispatch;
	}
	// 828C9654: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828C9658: 7F6BB82E  lwzx r27, r11, r23
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 828C965C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828C9660: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C9664: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828C9668: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 828C966C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 828C9670: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	// 828C9674: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	// 828C9678: 4BFFEC89  bl 0x828c8300
	ctx.lr = 0x828C967C;
	sub_828C8300(ctx, base);
	// 828C967C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C9680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9684: 419A0040  beq cr6, 0x828c96c4
	if ctx.cr[6].eq {
	pc = 0x828C96C4; continue 'dispatch;
	}
	// 828C9688: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C968C: 809B0070  lwz r4, 0x70(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C9690: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828C9694: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 828C9698: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 828C969C: 4849B575  bl 0x82d64c10
	ctx.lr = 0x828C96A0;
	sub_82D64C10(ctx, base);
	// 828C96A0: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 828C96A4: 81500004  lwz r10, 4(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C96A8: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C96AC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 828C96B0: 7D09522E  lhzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C96B4: 7D0B0734  extsh r11, r8
	ctx.r[11].s64 = ctx.r[8].s16 as i64;
	// 828C96B8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828C96BC: 419A0008  beq cr6, 0x828c96c4
	if ctx.cr[6].eq {
	pc = 0x828C96C4; continue 'dispatch;
	}
	// 828C96C0: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 828C96C4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C96C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C96CC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C96D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C96D4: 4E800421  bctrl
	ctx.lr = 0x828C96D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C96D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C96DC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828C96E0: 4B955B79  bl 0x8221f258
	ctx.lr = 0x828C96E4;
	sub_8221F258(ctx, base);
	// 828C96E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C96E8: 419A0020  beq cr6, 0x828c9708
	if ctx.cr[6].eq {
	pc = 0x828C9708; continue 'dispatch;
	}
	// 828C96EC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828C96F0: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 828C96F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C96F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C96FC: 4BD93D65  bl 0x8265d460
	ctx.lr = 0x828C9700;
	sub_8265D460(ctx, base);
	// 828C9700: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9704: 48000008  b 0x828c970c
	pc = 0x828C970C; continue 'dispatch;
	// 828C9708: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 828C970C: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9714: 419A0018  beq cr6, 0x828c972c
	if ctx.cr[6].eq {
	pc = 0x828C972C; continue 'dispatch;
	}
	// 828C9718: 81540008  lwz r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C971C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9720: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C9724: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9728: 41980008  blt cr6, 0x828c9730
	if ctx.cr[6].lt {
	pc = 0x828C9730; continue 'dispatch;
	}
	// 828C972C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9730: 7C6BC214  add r3, r11, r24
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 828C9734: 4B9A9925  bl 0x82273058
	ctx.lr = 0x828C9738;
	sub_82273058(ctx, base);
	// 828C9738: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C973C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828C9740: 41990008  bgt cr6, 0x828c9748
	if ctx.cr[6].gt {
	pc = 0x828C9748; continue 'dispatch;
	}
	// 828C9744: 7DC87378  mr r8, r14
	ctx.r[8].u64 = ctx.r[14].u64;
	// 828C9748: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C974C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828C9750: 41990008  bgt cr6, 0x828c9758
	if ctx.cr[6].gt {
	pc = 0x828C9758; continue 'dispatch;
	}
	// 828C9754: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 828C9758: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C975C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9760: 419A0018  beq cr6, 0x828c9778
	if ctx.cr[6].eq {
	pc = 0x828C9778; continue 'dispatch;
	}
	// 828C9764: 81340008  lwz r9, 8(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9768: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828C976C: 7CE91E70  srawi r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C9770: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C9774: 41980008  blt cr6, 0x828c977c
	if ctx.cr[6].lt {
	pc = 0x828C977C; continue 'dispatch;
	}
	// 828C9778: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C977C: 7EA94378  or r9, r21, r8
	ctx.r[9].u64 = ctx.r[21].u64 | ctx.r[8].u64;
	// 828C9780: 7C6BC02E  lwzx r3, r11, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C9784: 55282834  slwi r8, r9, 5
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C9788: 7D075378  or r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 828C978C: 54E62834  slwi r6, r7, 5
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C9790: 7CC4FB78  or r4, r6, r31
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[31].u64;
	// 828C9794: 4BF89B25  bl 0x828532b8
	ctx.lr = 0x828C9798;
	sub_828532B8(ctx, base);
	// 828C9798: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828C979C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828C97A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C97A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C97A8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828C97AC: 4BAA134D  bl 0x8236aaf8
	ctx.lr = 0x828C97B0;
	sub_8236AAF8(ctx, base);
	// 828C97B0: 80A10090  lwz r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C97B4: 7FC5B92E  stwx r30, r5, r23
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[23].u32), ctx.r[30].u32) };
	// 828C97B8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C97BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C97C0: 419A0018  beq cr6, 0x828c97d8
	if ctx.cr[6].eq {
	pc = 0x828C97D8; continue 'dispatch;
	}
	// 828C97C4: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C97C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C97CC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C97D0: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C97D4: 41980008  blt cr6, 0x828c97dc
	if ctx.cr[6].lt {
	pc = 0x828C97DC; continue 'dispatch;
	}
	// 828C97D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C97DC: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C97E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C97E4: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 828C97E8: E9410068  ld r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C97EC: 7D4BC12A  stdx r10, r11, r24
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u64) };
	// 828C97F0: 4B94B5E9  bl 0x82214dd8
	ctx.lr = 0x828C97F4;
	sub_82214DD8(ctx, base);
	// 828C97F4: 81300010  lwz r9, 0x10(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C97F8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 828C97FC: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 828C9800: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 828C9804: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C9808: 409AFE1C  bne cr6, 0x828c9624
	if !ctx.cr[6].eq {
	pc = 0x828C9624; continue 'dispatch;
	}
	// 828C980C: 836F0018  lwz r27, 0x18(r15)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C9810: 3BEF0014  addi r31, r15, 0x14
	ctx.r[31].s64 = ctx.r[15].s64 + 20;
	// 828C9814: 7DD47378  mr r20, r14
	ctx.r[20].u64 = ctx.r[14].u64;
	// 828C9818: 3E408000  lis r18, -0x8000
	ctx.r[18].s64 = -2147483648;
	// 828C981C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828C9820: 40990028  ble cr6, 0x828c9848
	if !ctx.cr[6].gt {
	pc = 0x828C9848; continue 'dispatch;
	}
	// 828C9824: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9828: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C982C: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C9830: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9834: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C9838: 4848BA11  bl 0x82d55248
	ctx.lr = 0x828C983C;
	sub_82D55248(ctx, base);
	// 828C983C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9840: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 828C9844: 7F72DB78  mr r18, r27
	ctx.r[18].u64 = ctx.r[27].u64;
	// 828C9848: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C984C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828C9850: 40990024  ble cr6, 0x828c9874
	if !ctx.cr[6].gt {
	pc = 0x828C9874; continue 'dispatch;
	}
	// 828C9854: 7D345050  subf r9, r20, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[20].s64;
	// 828C9858: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828C985C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828C9860: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9864: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9868: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C986C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9870: 4082FFF0  bne 0x828c9860
	if !ctx.cr[0].eq {
	pc = 0x828C9860; continue 'dispatch;
	}
	// 828C9874: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9878: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C987C: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9880: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C9884: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C9888: 4848B9C1  bl 0x82d55248
	ctx.lr = 0x828C988C;
	sub_82D55248(ctx, base);
	// 828C988C: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828C9890: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C9894: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 828C9898: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C989C: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 828C98A0: 91C10068  stw r14, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[14].u32 ) };
	// 828C98A4: 91C1006C  stw r14, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[14].u32 ) };
	// 828C98A8: 81210284  lwz r9, 0x284(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 828C98AC: 3AE90048  addi r23, r9, 0x48
	ctx.r[23].s64 = ctx.r[9].s64 + 72;
	// 828C98B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C98B4: 4BF2F7BD  bl 0x827f9070
	ctx.lr = 0x828C98B8;
	sub_827F9070(ctx, base);
	// 828C98B8: 7DD97378  mr r25, r14
	ctx.r[25].u64 = ctx.r[14].u64;
	// 828C98BC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C98C0: 419A021C  beq cr6, 0x828c9adc
	if ctx.cr[6].eq {
	pc = 0x828C9ADC; continue 'dispatch;
	}
	// 828C98C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C98C8: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C98CC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 828C98D0: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 828C98D4: 7DD87378  mr r24, r14
	ctx.r[24].u64 = ctx.r[14].u64;
	// 828C98D8: 3ACB0B7C  addi r22, r11, 0xb7c
	ctx.r[22].s64 = ctx.r[11].s64 + 2940;
	// 828C98DC: 3AAA1360  addi r21, r10, 0x1360
	ctx.r[21].s64 = ctx.r[10].s64 + 4960;
	// 828C98E0: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 828C98E4: 7FF4D02E  lwzx r31, r20, r26
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828C98E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C98EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C98F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C98F4: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 828C98F8: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C98FC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C9900: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C9904: 4BAABB7D  bl 0x82375480
	ctx.lr = 0x828C9908;
	sub_82375480(ctx, base);
	// 828C9908: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C990C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C9910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9918: 419A0010  beq cr6, 0x828c9928
	if ctx.cr[6].eq {
	pc = 0x828C9928; continue 'dispatch;
	}
	// 828C991C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 828C9920: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9924: 419A0008  beq cr6, 0x828c992c
	if ctx.cr[6].eq {
	pc = 0x828C992C; continue 'dispatch;
	}
	// 828C9928: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C992C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C9930: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828C9934: 419A0024  beq cr6, 0x828c9958
	if ctx.cr[6].eq {
	pc = 0x828C9958; continue 'dispatch;
	}
	// 828C9938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C993C: 409A0008  bne cr6, 0x828c9944
	if !ctx.cr[6].eq {
	pc = 0x828C9944; continue 'dispatch;
	}
	// 828C9940: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9948: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C994C: 409A0008  bne cr6, 0x828c9954
	if !ctx.cr[6].eq {
	pc = 0x828C9954; continue 'dispatch;
	}
	// 828C9950: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9954: 83AA0010  lwz r29, 0x10(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C9958: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C995C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C9960: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C9964: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C9968: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C996C: 4BAABB15  bl 0x82375480
	ctx.lr = 0x828C9970;
	sub_82375480(ctx, base);
	// 828C9970: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C9974: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C9978: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C997C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9980: 419A0010  beq cr6, 0x828c9990
	if ctx.cr[6].eq {
	pc = 0x828C9990; continue 'dispatch;
	}
	// 828C9984: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828C9988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C998C: 419A0008  beq cr6, 0x828c9994
	if ctx.cr[6].eq {
	pc = 0x828C9994; continue 'dispatch;
	}
	// 828C9990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9994: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C9998: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828C999C: 419A0024  beq cr6, 0x828c99c0
	if ctx.cr[6].eq {
	pc = 0x828C99C0; continue 'dispatch;
	}
	// 828C99A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C99A4: 409A0008  bne cr6, 0x828c99ac
	if !ctx.cr[6].eq {
	pc = 0x828C99AC; continue 'dispatch;
	}
	// 828C99A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C99AC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C99B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C99B4: 409A0008  bne cr6, 0x828c99bc
	if !ctx.cr[6].eq {
	pc = 0x828C99BC; continue 'dispatch;
	}
	// 828C99B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C99BC: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C99C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C99C4: 419A0104  beq cr6, 0x828c9ac8
	if ctx.cr[6].eq {
	pc = 0x828C9AC8; continue 'dispatch;
	}
	// 828C99C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C99CC: 419A00FC  beq cr6, 0x828c9ac8
	if ctx.cr[6].eq {
	pc = 0x828C9AC8; continue 'dispatch;
	}
	// 828C99D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C99D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C99D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C99DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C99E0: 484BD871  bl 0x82d87250
	ctx.lr = 0x828C99E4;
	sub_82D87250(ctx, base);
	// 828C99E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C99E8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828C99EC: 4B95586D  bl 0x8221f258
	ctx.lr = 0x828C99F0;
	sub_8221F258(ctx, base);
	// 828C99F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C99F4: 419A0050  beq cr6, 0x828c9a44
	if ctx.cr[6].eq {
	pc = 0x828C9A44; continue 'dispatch;
	}
	// 828C99F8: 91C30004  stw r14, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 828C99FC: 91C30008  stw r14, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[14].u32 ) };
	// 828C9A00: 91C3000C  stw r14, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[14].u32 ) };
	// 828C9A04: 91C30010  stw r14, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[14].u32 ) };
	// 828C9A08: 91C30018  stw r14, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[14].u32 ) };
	// 828C9A0C: 92C30014  stw r22, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[22].u32 ) };
	// 828C9A10: 91C30020  stw r14, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[14].u32 ) };
	// 828C9A14: 91C30024  stw r14, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[14].u32 ) };
	// 828C9A18: 91C30028  stw r14, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[14].u32 ) };
	// 828C9A1C: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 828C9A20: 93A3002C  stw r29, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 828C9A24: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9A2C: 419A0010  beq cr6, 0x828c9a3c
	if ctx.cr[6].eq {
	pc = 0x828C9A3C; continue 'dispatch;
	}
	// 828C9A30: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9A34: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C9A38: B15D0006  sth r10, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 828C9A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9A40: 48000008  b 0x828c9a48
	pc = 0x828C9A48; continue 'dispatch;
	// 828C9A44: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C9A48: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9A50: 419A0018  beq cr6, 0x828c9a68
	if ctx.cr[6].eq {
	pc = 0x828C9A68; continue 'dispatch;
	}
	// 828C9A54: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9A58: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9A5C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C9A60: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9A64: 41980008  blt cr6, 0x828c9a6c
	if ctx.cr[6].lt {
	pc = 0x828C9A6C; continue 'dispatch;
	}
	// 828C9A68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C9A6C: 7FEBC214  add r31, r11, r24
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 828C9A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9A74: 4B8EE0A5  bl 0x821b7b18
	ctx.lr = 0x828C9A78;
	sub_821B7B18(ctx, base);
	// 828C9A78: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C9A7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C9A80: 419A003C  beq cr6, 0x828c9abc
	if ctx.cr[6].eq {
	pc = 0x828C9ABC; continue 'dispatch;
	}
	// 828C9A84: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C9A88: 4B9557D1  bl 0x8221f258
	ctx.lr = 0x828C9A8C;
	sub_8221F258(ctx, base);
	// 828C9A8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9A90: 419A0024  beq cr6, 0x828c9ab4
	if ctx.cr[6].eq {
	pc = 0x828C9AB4; continue 'dispatch;
	}
	// 828C9A94: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9A98: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 828C9A9C: 92630000  stw r19, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 828C9AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C9AA4: 39099238  addi r8, r9, -0x6dc8
	ctx.r[8].s64 = ctx.r[9].s64 + -28104;
	// 828C9AA8: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828C9AAC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C9AB0: 48000008  b 0x828c9ab8
	pc = 0x828C9AB8; continue 'dispatch;
	// 828C9AB4: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 828C9AB8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C9ABC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C9AC0: 7FABD12E  stwx r29, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[29].u32) };
	// 828C9AC4: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C9AC8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828C9ACC: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 828C9AD0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 828C9AD4: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828C9AD8: 409AFE0C  bne cr6, 0x828c98e4
	if !ctx.cr[6].eq {
	pc = 0x828C98E4; continue 'dispatch;
	}
	// 828C9ADC: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9AE0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C9AE4: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 828C9AE8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 828C9AEC: 7C6BD02E  lwzx r3, r11, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828C9AF0: 4848B759  bl 0x82d55248
	ctx.lr = 0x828C9AF4;
	sub_82D55248(ctx, base);
	// 828C9AF4: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828C9AF8: 7E068378  mr r6, r16
	ctx.r[6].u64 = ctx.r[16].u64;
	// 828C9AFC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828C9B00: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828C9B04: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828C9B08: 485A37D1  bl 0x82e6d2d8
	ctx.lr = 0x828C9B0C;
	sub_82E6D2D8(ctx, base);
	// 828C9B0C: 83A10284  lwz r29, 0x284(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 828C9B10: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9B14: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 828C9B18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9B1C: 907D0094  stw r3, 0x94(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 828C9B20: 419A0028  beq cr6, 0x828c9b48
	if ctx.cr[6].eq {
	pc = 0x828C9B48; continue 'dispatch;
	}
	// 828C9B24: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C9B28: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C9B2C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C9B30: 484B68B1  bl 0x82d803e0
	ctx.lr = 0x828C9B34;
	sub_82D803E0(ctx, base);
	// 828C9B34: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9B38: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C9B3C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C9B40: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9B44: 409AFFE4  bne cr6, 0x828c9b28
	if !ctx.cr[6].eq {
	pc = 0x828C9B28; continue 'dispatch;
	}
	// 828C9B48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C9B4C: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C9B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9B54: 419A005C  beq cr6, 0x828c9bb0
	if ctx.cr[6].eq {
	pc = 0x828C9BB0; continue 'dispatch;
	}
	// 828C9B58: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 828C9B5C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C9B60: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828C9B64: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9B6C: 419A0030  beq cr6, 0x828c9b9c
	if ctx.cr[6].eq {
	pc = 0x828C9B9C; continue 'dispatch;
	}
	// 828C9B70: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9B74: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C9B78: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C9B7C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C9B80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9B84: 409A0018  bne cr6, 0x828c9b9c
	if !ctx.cr[6].eq {
	pc = 0x828C9B9C; continue 'dispatch;
	}
	// 828C9B88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9B8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C9B90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9B94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C9B98: 4E800421  bctrl
	ctx.lr = 0x828C9B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C9B9C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C9BA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C9BA4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C9BA8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C9BAC: 409AFFB0  bne cr6, 0x828c9b5c
	if !ctx.cr[6].eq {
	pc = 0x828C9B5C; continue 'dispatch;
	}
	// 828C9BB0: 83810294  lwz r28, 0x294(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(660 as u32) ) } as u64;
	// 828C9BB4: 3BDD0060  addi r30, r29, 0x60
	ctx.r[30].s64 = ctx.r[29].s64 + 96;
	// 828C9BB8: 3BFD0070  addi r31, r29, 0x70
	ctx.r[31].s64 = ctx.r[29].s64 + 112;
	// 828C9BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C9BC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C9BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9BC8: 4BFFBB89  bl 0x828c5750
	ctx.lr = 0x828C9BCC;
	sub_828C5750(ctx, base);
	// 828C9BCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C9BD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9BD4: 806102B4  lwz r3, 0x2b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(692 as u32) ) } as u64;
	// 828C9BD8: 4BAC4EF9  bl 0x8238ead0
	ctx.lr = 0x828C9BDC;
	sub_8238EAD0(ctx, base);
	// 828C9BDC: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9FC0 size=272
    let mut pc: u32 = 0x828C9FC0;
    'dispatch: loop {
        match pc {
            0x828C9FC0 => {
    //   block [0x828C9FC0..0x828CA0D0)
	// 828C9FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9FC4: 483DF445  bl 0x82ca9408
	ctx.lr = 0x828C9FC8;
	sub_82CA93D0(ctx, base);
	// 828C9FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9FD0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C9FD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C9FD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9FDC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C9FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9FE4: 419A0010  beq cr6, 0x828c9ff4
	if ctx.cr[6].eq {
	pc = 0x828C9FF4; continue 'dispatch;
	}
	// 828C9FE8: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C9FEC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9FF0: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C9FF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C9FF8: 419A004C  beq cr6, 0x828ca044
	if ctx.cr[6].eq {
	pc = 0x828CA044; continue 'dispatch;
	}
	// 828C9FFC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA004: 419A0018  beq cr6, 0x828ca01c
	if ctx.cr[6].eq {
	pc = 0x828CA01C; continue 'dispatch;
	}
	// 828CA008: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA00C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA010: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA014: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA018: 41980008  blt cr6, 0x828ca020
	if ctx.cr[6].lt {
	pc = 0x828CA020; continue 'dispatch;
	}
	// 828CA01C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA020: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA024: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CA028: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA02C: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA030: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA034: 4E800421  bctrl
	ctx.lr = 0x828CA038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA038: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA03C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA040: 4BFFFF9C  b 0x828c9fdc
	pc = 0x828C9FDC; continue 'dispatch;
	// 828CA044: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CA048: 894B6B5F  lbz r10, 0x6b5f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27487 as u32) ) } as u64;
	// 828CA04C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CA050: 419A0074  beq cr6, 0x828ca0c4
	if ctx.cr[6].eq {
	pc = 0x828CA0C4; continue 'dispatch;
	}
	// 828CA054: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA058: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA05C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA064: 419A0010  beq cr6, 0x828ca074
	if ctx.cr[6].eq {
	pc = 0x828CA074; continue 'dispatch;
	}
	// 828CA068: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA06C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA070: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA074: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA078: 419A004C  beq cr6, 0x828ca0c4
	if ctx.cr[6].eq {
	pc = 0x828CA0C4; continue 'dispatch;
	}
	// 828CA07C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA084: 419A0018  beq cr6, 0x828ca09c
	if ctx.cr[6].eq {
	pc = 0x828CA09C; continue 'dispatch;
	}
	// 828CA088: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA08C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA090: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA094: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA098: 41980008  blt cr6, 0x828ca0a0
	if ctx.cr[6].lt {
	pc = 0x828CA0A0; continue 'dispatch;
	}
	// 828CA09C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA0A0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA0A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CA0A8: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA0AC: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA0B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA0B4: 4E800421  bctrl
	ctx.lr = 0x828CA0B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA0B8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA0BC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA0C0: 4BFFFF9C  b 0x828ca05c
	pc = 0x828CA05C; continue 'dispatch;
	// 828CA0C4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CA0C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA0CC: 483DF38C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA0D0 size=288
    let mut pc: u32 = 0x828CA0D0;
    'dispatch: loop {
        match pc {
            0x828CA0D0 => {
    //   block [0x828CA0D0..0x828CA1F0)
	// 828CA0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA0D4: 483DF335  bl 0x82ca9408
	ctx.lr = 0x828CA0D8;
	sub_82CA93D0(ctx, base);
	// 828CA0D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA0E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828CA0E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA0EC: 419A00F4  beq cr6, 0x828ca1e0
	if ctx.cr[6].eq {
	pc = 0x828CA1E0; continue 'dispatch;
	}
	// 828CA0F0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828CA0F4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828CA0F8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA100: 409A000C  bne cr6, 0x828ca10c
	if !ctx.cr[6].eq {
	pc = 0x828CA10C; continue 'dispatch;
	}
	// 828CA104: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CA108: 48000010  b 0x828ca118
	pc = 0x828CA118; continue 'dispatch;
	// 828CA10C: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA110: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA114: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA118: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA11C: 419A004C  beq cr6, 0x828ca168
	if ctx.cr[6].eq {
	pc = 0x828CA168; continue 'dispatch;
	}
	// 828CA120: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA124: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA12C: 419A0018  beq cr6, 0x828ca144
	if ctx.cr[6].eq {
	pc = 0x828CA144; continue 'dispatch;
	}
	// 828CA130: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA134: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA138: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA13C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA140: 41980008  blt cr6, 0x828ca148
	if ctx.cr[6].lt {
	pc = 0x828CA148; continue 'dispatch;
	}
	// 828CA144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA148: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA14C: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA150: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA154: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA158: 4E800421  bctrl
	ctx.lr = 0x828CA15C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA15C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA160: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA164: 4BFFFF94  b 0x828ca0f8
	pc = 0x828CA0F8; continue 'dispatch;
	// 828CA168: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828CA16C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828CA170: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA178: 409A000C  bne cr6, 0x828ca184
	if !ctx.cr[6].eq {
	pc = 0x828CA184; continue 'dispatch;
	}
	// 828CA17C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CA180: 48000010  b 0x828ca190
	pc = 0x828CA190; continue 'dispatch;
	// 828CA184: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA188: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA18C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA190: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA194: 419A004C  beq cr6, 0x828ca1e0
	if ctx.cr[6].eq {
	pc = 0x828CA1E0; continue 'dispatch;
	}
	// 828CA198: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA19C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA1A4: 419A0018  beq cr6, 0x828ca1bc
	if ctx.cr[6].eq {
	pc = 0x828CA1BC; continue 'dispatch;
	}
	// 828CA1A8: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA1AC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA1B0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA1B4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA1B8: 41980008  blt cr6, 0x828ca1c0
	if ctx.cr[6].lt {
	pc = 0x828CA1C0; continue 'dispatch;
	}
	// 828CA1BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA1C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA1C4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA1C8: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA1CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA1D0: 4E800421  bctrl
	ctx.lr = 0x828CA1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA1D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA1D8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA1DC: 4BFFFF94  b 0x828ca170
	pc = 0x828CA170; continue 'dispatch;
	// 828CA1E0: 9B9F0024  stb r28, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	// 828CA1E4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CA1E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA1EC: 483DF26C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA1F0 size=172
    let mut pc: u32 = 0x828CA1F0;
    'dispatch: loop {
        match pc {
            0x828CA1F0 => {
    //   block [0x828CA1F0..0x828CA29C)
	// 828CA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA1F4: 483DF219  bl 0x82ca940c
	ctx.lr = 0x828CA1F8;
	sub_82CA93D0(ctx, base);
	// 828CA1F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA200: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CA204: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828CA208: 419A0088  beq cr6, 0x828ca290
	if ctx.cr[6].eq {
	pc = 0x828CA290; continue 'dispatch;
	}
	// 828CA20C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA210: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA214: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA21C: 419A0010  beq cr6, 0x828ca22c
	if ctx.cr[6].eq {
	pc = 0x828CA22C; continue 'dispatch;
	}
	// 828CA220: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA224: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA228: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA22C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA230: 419A0060  beq cr6, 0x828ca290
	if ctx.cr[6].eq {
	pc = 0x828CA290; continue 'dispatch;
	}
	// 828CA234: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA23C: 419A0018  beq cr6, 0x828ca254
	if ctx.cr[6].eq {
	pc = 0x828CA254; continue 'dispatch;
	}
	// 828CA240: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA244: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA248: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA24C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA250: 41980008  blt cr6, 0x828ca258
	if ctx.cr[6].lt {
	pc = 0x828CA258; continue 'dispatch;
	}
	// 828CA254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA258: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA25C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA260: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CA264: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA268: 4E800421  bctrl
	ctx.lr = 0x828CA26C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA26C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CA270: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CA274: 409A0010  bne cr6, 0x828ca284
	if !ctx.cr[6].eq {
	pc = 0x828CA284; continue 'dispatch;
	}
	// 828CA278: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA27C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA280: 4BFFFF94  b 0x828ca214
	pc = 0x828CA214; continue 'dispatch;
	// 828CA284: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828CA288: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA28C: 483DF1D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828CA290: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CA294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA298: 483DF1C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA2A0 size=24
    let mut pc: u32 = 0x828CA2A0;
    'dispatch: loop {
        match pc {
            0x828CA2A0 => {
    //   block [0x828CA2A0..0x828CA2B8)
	// 828CA2A0: E9440060  ld r10, 0x60(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	// 828CA2A4: 39640060  addi r11, r4, 0x60
	ctx.r[11].s64 = ctx.r[4].s64 + 96;
	// 828CA2A8: E9240068  ld r9, 0x68(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) };
	// 828CA2AC: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828CA2B0: F9230008  std r9, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828CA2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA2B8 size=4
    let mut pc: u32 = 0x828CA2B8;
    'dispatch: loop {
        match pc {
            0x828CA2B8 => {
    //   block [0x828CA2B8..0x828CA2BC)
	// 828CA2B8: 48000008  b 0x828ca2c0
	sub_828CA2C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA2C0 size=204
    let mut pc: u32 = 0x828CA2C0;
    'dispatch: loop {
        match pc {
            0x828CA2C0 => {
    //   block [0x828CA2C0..0x828CA38C)
	// 828CA2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA2C4: 483DF149  bl 0x82ca940c
	ctx.lr = 0x828CA2C8;
	sub_82CA93D0(ctx, base);
	// 828CA2C8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA390 size=376
    let mut pc: u32 = 0x828CA390;
    'dispatch: loop {
        match pc {
            0x828CA390 => {
    //   block [0x828CA390..0x828CA508)
	// 828CA390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA394: 483DF065  bl 0x82ca93f8
	ctx.lr = 0x828CA398;
	sub_82CA93D0(ctx, base);
	// 828CA398: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA39C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CA3A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828CA3A4: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CA3A8: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828CA3AC: 419A0150  beq cr6, 0x828ca4fc
	if ctx.cr[6].eq {
	pc = 0x828CA4FC; continue 'dispatch;
	}
	// 828CA3B0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828CA3B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA3B8: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 828CA3BC: 3B200006  li r25, 6
	ctx.r[25].s64 = 6;
	// 828CA3C0: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA3C8: 419A0010  beq cr6, 0x828ca3d8
	if ctx.cr[6].eq {
	pc = 0x828CA3D8; continue 'dispatch;
	}
	// 828CA3CC: 815C0040  lwz r10, 0x40(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA3D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA3D4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA3D8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA3DC: 419A0120  beq cr6, 0x828ca4fc
	if ctx.cr[6].eq {
	pc = 0x828CA4FC; continue 'dispatch;
	}
	// 828CA3E0: 83FC003C  lwz r31, 0x3c(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA3E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CA3E8: 419A0018  beq cr6, 0x828ca400
	if ctx.cr[6].eq {
	pc = 0x828CA400; continue 'dispatch;
	}
	// 828CA3EC: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA3F0: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828CA3F4: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CA3F8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA3FC: 41980008  blt cr6, 0x828ca404
	if ctx.cr[6].lt {
	pc = 0x828CA404; continue 'dispatch;
	}
	// 828CA400: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA404: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828CA408: 409A0040  bne cr6, 0x828ca448
	if !ctx.cr[6].eq {
	pc = 0x828CA448; continue 'dispatch;
	}
	// 828CA40C: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA410: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CA414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA418: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA41C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA420: 4E800421  bctrl
	ctx.lr = 0x828CA424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA424: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA428: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828CA42C: 93030008  stw r24, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 828CA430: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA434: 5124801E  rlwimi r4, r9, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[9].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 828CA438: 4BF88E81  bl 0x828532b8
	ctx.lr = 0x828CA43C;
	sub_828532B8(ctx, base);
	// 828CA43C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA440: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA444: 4BFFFF7C  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
	// 828CA448: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 828CA44C: 409A0040  bne cr6, 0x828ca48c
	if !ctx.cr[6].eq {
	pc = 0x828CA48C; continue 'dispatch;
	}
	// 828CA450: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA454: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828CA458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA45C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA460: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA464: 4E800421  bctrl
	ctx.lr = 0x828CA468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA468: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA46C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828CA470: 93230008  stw r25, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828CA474: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA478: 5124801E  rlwimi r4, r9, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[9].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 828CA47C: 4BF88E3D  bl 0x828532b8
	ctx.lr = 0x828CA480;
	sub_828532B8(ctx, base);
	// 828CA480: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA484: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA488: 4BFFFF38  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
	// 828CA48C: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 828CA490: 409A0060  bne cr6, 0x828ca4f0
	if !ctx.cr[6].eq {
	pc = 0x828CA4F0; continue 'dispatch;
	}
	// 828CA494: 83DC0088  lwz r30, 0x88(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 828CA498: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CA49C: 419A0018  beq cr6, 0x828ca4b4
	if ctx.cr[6].eq {
	pc = 0x828CA4B4; continue 'dispatch;
	}
	// 828CA4A0: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CA4A4: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 828CA4A8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CA4AC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA4B0: 41980008  blt cr6, 0x828ca4b8
	if ctx.cr[6].lt {
	pc = 0x828CA4B8; continue 'dispatch;
	}
	// 828CA4B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA4B8: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA4BC: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828CA4C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA4C4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA4C8: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA4CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA4D0: 4E800421  bctrl
	ctx.lr = 0x828CA4D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA4D4: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA4D8: 7D1DF02E  lwzx r8, r29, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828CA4DC: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA4E0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828CA4E4: 54E6801E  slwi r6, r7, 0x10
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(16);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828CA4E8: 7CC44378  or r4, r6, r8
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[8].u64;
	// 828CA4EC: 4BF88DCD  bl 0x828532b8
	ctx.lr = 0x828CA4F0;
	sub_828532B8(ctx, base);
	// 828CA4F0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA4F4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA4F8: 4BFFFEC8  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
	// 828CA4FC: 935C0020  stw r26, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 828CA500: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CA504: 483DEF44  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA508 size=88
    let mut pc: u32 = 0x828CA508;
    'dispatch: loop {
        match pc {
            0x828CA508 => {
    //   block [0x828CA508..0x828CA560)
	// 828CA508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CA510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CA514: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA51C: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 828CA520: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CA524: E89F0060  ld r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA560 size=112
    let mut pc: u32 = 0x828CA560;
    'dispatch: loop {
        match pc {
            0x828CA560 => {
    //   block [0x828CA560..0x828CA5D0)
	// 828CA560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CA568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CA56C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA570: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 828CA574: F88100F0  std r4, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[4].u64 ) };
	// 828CA578: F8A100F8  std r5, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[5].u64 ) };
	// 828CA57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA580: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 828CA584: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CA588: 391F0060  addi r8, r31, 0x60
	ctx.r[8].s64 = ctx.r[31].s64 + 96;
	// 828CA58C: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828CA590: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828CA594: F93F0068  std r9, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA5D0 size=140
    let mut pc: u32 = 0x828CA5D0;
    'dispatch: loop {
        match pc {
            0x828CA5D0 => {
    //   block [0x828CA5D0..0x828CA65C)
	// 828CA5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA5D4: 483DEE35  bl 0x82ca9408
	ctx.lr = 0x828CA5D8;
	sub_82CA93D0(ctx, base);
	// 828CA5D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA5DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CA5E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828CA5E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CA5E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA5EC: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA5F4: 419A0010  beq cr6, 0x828ca604
	if ctx.cr[6].eq {
	pc = 0x828CA604; continue 'dispatch;
	}
	// 828CA5F8: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA5FC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA600: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA604: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA608: 419A004C  beq cr6, 0x828ca654
	if ctx.cr[6].eq {
	pc = 0x828CA654; continue 'dispatch;
	}
	// 828CA60C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA614: 419A0018  beq cr6, 0x828ca62c
	if ctx.cr[6].eq {
	pc = 0x828CA62C; continue 'dispatch;
	}
	// 828CA618: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA61C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA620: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA624: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA628: 41980008  blt cr6, 0x828ca630
	if ctx.cr[6].lt {
	pc = 0x828CA630; continue 'dispatch;
	}
	// 828CA62C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA630: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CA638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA63C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA640: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA644: 4E800421  bctrl
	ctx.lr = 0x828CA648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA648: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828CA64C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA650: 4BFFFF9C  b 0x828ca5ec
	pc = 0x828CA5EC; continue 'dispatch;
	// 828CA654: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA658: 483DEE00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA660 size=132
    let mut pc: u32 = 0x828CA660;
    'dispatch: loop {
        match pc {
            0x828CA660 => {
    //   block [0x828CA660..0x828CA6E4)
	// 828CA660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA664: 483DEDA9  bl 0x82ca940c
	ctx.lr = 0x828CA668;
	sub_82CA93D0(ctx, base);
	// 828CA668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA670: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA674: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA678: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA680: 419A0010  beq cr6, 0x828ca690
	if ctx.cr[6].eq {
	pc = 0x828CA690; continue 'dispatch;
	}
	// 828CA684: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA688: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA68C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA690: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA694: 419A0048  beq cr6, 0x828ca6dc
	if ctx.cr[6].eq {
	pc = 0x828CA6DC; continue 'dispatch;
	}
	// 828CA698: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA6A0: 419A0018  beq cr6, 0x828ca6b8
	if ctx.cr[6].eq {
	pc = 0x828CA6B8; continue 'dispatch;
	}
	// 828CA6A4: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA6A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA6AC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA6B0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA6B4: 41980008  blt cr6, 0x828ca6bc
	if ctx.cr[6].lt {
	pc = 0x828CA6BC; continue 'dispatch;
	}
	// 828CA6B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA6BC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA6C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA6C4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CA6C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA6CC: 4E800421  bctrl
	ctx.lr = 0x828CA6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA6D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA6D4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA6D8: 4BFFFFA0  b 0x828ca678
	pc = 0x828CA678; continue 'dispatch;
	// 828CA6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA6E0: 483DED7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA6E8 size=320
    let mut pc: u32 = 0x828CA6E8;
    'dispatch: loop {
        match pc {
            0x828CA6E8 => {
    //   block [0x828CA6E8..0x828CA828)
	// 828CA6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA6EC: 483DED1D  bl 0x82ca9408
	ctx.lr = 0x828CA6F0;
	sub_82CA93D0(ctx, base);
	// 828CA6F0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828CA6F4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA828 size=332
    let mut pc: u32 = 0x828CA828;
    'dispatch: loop {
        match pc {
            0x828CA828 => {
    //   block [0x828CA828..0x828CA974)
	// 828CA828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA82C: 483DEBD1  bl 0x82ca93fc
	ctx.lr = 0x828CA830;
	sub_82CA93D0(ctx, base);
	// 828CA830: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA834: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828CA838: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CA83C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CA840: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828CA844: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828CA848: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 828CA84C: 3B2B7088  addi r25, r11, 0x7088
	ctx.r[25].s64 = ctx.r[11].s64 + 28808;
	// 828CA850: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA858: 409A000C  bne cr6, 0x828ca864
	if !ctx.cr[6].eq {
	pc = 0x828CA864; continue 'dispatch;
	}
	// 828CA85C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828CA860: 48000010  b 0x828ca870
	pc = 0x828CA870; continue 'dispatch;
	// 828CA864: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA868: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA86C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA870: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA874: 419A00F4  beq cr6, 0x828ca968
	if ctx.cr[6].eq {
	pc = 0x828CA968; continue 'dispatch;
	}
	// 828CA878: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA880: 419A0018  beq cr6, 0x828ca898
	if ctx.cr[6].eq {
	pc = 0x828CA898; continue 'dispatch;
	}
	// 828CA884: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA888: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA88C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA890: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA894: 41980008  blt cr6, 0x828ca89c
	if ctx.cr[6].lt {
	pc = 0x828CA89C; continue 'dispatch;
	}
	// 828CA898: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA89C: 7C9C582E  lwzx r4, r28, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA8A4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA8A8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828CA8AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA8B0: 4E800421  bctrl
	ctx.lr = 0x828CA8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA8B4: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA8B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA8BC: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828CA8C0: 409A000C  bne cr6, 0x828ca8cc
	if !ctx.cr[6].eq {
	pc = 0x828CA8CC; continue 'dispatch;
	}
	// 828CA8C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828CA8C8: 48000024  b 0x828ca8ec
	pc = 0x828CA8EC; continue 'dispatch;
	// 828CA8CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CA8D0: 419A0018  beq cr6, 0x828ca8e8
	if ctx.cr[6].eq {
	pc = 0x828CA8E8; continue 'dispatch;
	}
	// 828CA8D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CA8D8: 419A0010  beq cr6, 0x828ca8e8
	if ctx.cr[6].eq {
	pc = 0x828CA8E8; continue 'dispatch;
	}
	// 828CA8DC: 4B9A2EB5  bl 0x8226d790
	ctx.lr = 0x828CA8E0;
	sub_8226D790(ctx, base);
	// 828CA8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA8E4: 48000008  b 0x828ca8ec
	pc = 0x828CA8EC; continue 'dispatch;
	// 828CA8E8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828CA8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA8F0: 4B8FBE79  bl 0x821c6768
	ctx.lr = 0x828CA8F4;
	sub_821C6768(ctx, base);
	// 828CA8F4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 828CA8F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828CA8FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CA900: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828CA904: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CA908: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CA90C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CA910: 4082FFE8  bne 0x828ca8f8
	if !ctx.cr[0].eq {
	pc = 0x828CA8F8; continue 'dispatch;
	}
	// 828CA914: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828CA918: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828CA91C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CA920: 409A0010  bne cr6, 0x828ca930
	if !ctx.cr[6].eq {
	pc = 0x828CA930; continue 'dispatch;
	}
	// 828CA924: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828CA928: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 828CA92C: 4BFFFF24  b 0x828ca850
	pc = 0x828CA850; continue 'dispatch;
	// 828CA930: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA938: 419A0018  beq cr6, 0x828ca950
	if ctx.cr[6].eq {
	pc = 0x828CA950; continue 'dispatch;
	}
	// 828CA93C: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA940: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA944: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA948: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA94C: 41980008  blt cr6, 0x828ca954
	if ctx.cr[6].lt {
	pc = 0x828CA954; continue 'dispatch;
	}
	// 828CA950: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CA954: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CA958: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA95C: 8069002C  lwz r3, 0x2c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CA960: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CA964: 483DEAE8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CA968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CA96C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CA970: 483DEADC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA978 size=20
    let mut pc: u32 = 0x828CA978;
    'dispatch: loop {
        match pc {
            0x828CA978 => {
    //   block [0x828CA978..0x828CA98C)
	// 828CA978: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA980: 409A000C  bne cr6, 0x828ca98c
	if !ctx.cr[6].eq {
		sub_828CA98C(ctx, base);
		return;
	}
	// 828CA984: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CA988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA98C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA98C size=16
    let mut pc: u32 = 0x828CA98C;
    'dispatch: loop {
        match pc {
            0x828CA98C => {
    //   block [0x828CA98C..0x828CA99C)
	// 828CA98C: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA990: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA994: 7D231E70  srawi r3, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA9A0 size=116
    let mut pc: u32 = 0x828CA9A0;
    'dispatch: loop {
        match pc {
            0x828CA9A0 => {
    //   block [0x828CA9A0..0x828CAA14)
	// 828CA9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CA9A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CA9AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CA9B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828CA9B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA9B8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828CA9BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828CA9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA9C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828CA9C8: 894BEBC9  lbz r10, -0x1437(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5175 as u32) ) } as u64;
	// 828CA9CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CA9D0: 409A0028  bne cr6, 0x828ca9f8
	if !ctx.cr[6].eq {
	pc = 0x828CA9F8; continue 'dispatch;
	}
	// 828CA9D4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CA9D8: 48499A21  bl 0x82d643f8
	ctx.lr = 0x828CA9DC;
	sub_82D643F8(ctx, base);
	// 828CA9DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CA9E0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CA9E4: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828CA9E8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828CA9EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CA9F0: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA9F4: 485A3955  bl 0x82e6e348
	ctx.lr = 0x828CA9F8;
	sub_82E6E348(ctx, base);
	// 828CA9F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA9FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CAA00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CAA04: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828CAA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CAA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CAA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CAA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CAA18 size=148
    let mut pc: u32 = 0x828CAA18;
    'dispatch: loop {
        match pc {
            0x828CAA18 => {
    //   block [0x828CAA18..0x828CAAAC)
	// 828CAA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CAA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CAA20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CAA24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CAA28: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CAA2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CAA30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAA34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAA38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAA3C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CAA40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CAA44: 4E800421  bctrl
	ctx.lr = 0x828CAA48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CAA48: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAA4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CAA50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAA58: 81090024  lwz r8, 0x24(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CAA5C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828CAA60: 4E800421  bctrl
	ctx.lr = 0x828CAA64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CAA64: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828CAA68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CAAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CAAB0 size=552
    let mut pc: u32 = 0x828CAAB0;
    'dispatch: loop {
        match pc {
            0x828CAAB0 => {
    //   block [0x828CAAB0..0x828CACD8)
	// 828CAAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CAAB4: 483DE941  bl 0x82ca93f4
	ctx.lr = 0x828CAAB8;
	sub_82CA93D0(ctx, base);
	// 828CAAB8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 828CAABC: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CACD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CACD8 size=268
    let mut pc: u32 = 0x828CACD8;
    'dispatch: loop {
        match pc {
            0x828CACD8 => {
    //   block [0x828CACD8..0x828CADE4)
	// 828CACD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CACDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CACE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CACE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CACE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CACEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CACF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CACF4: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828CACF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CACFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAD00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAD04: 48000465  bl 0x828cb168
	ctx.lr = 0x828CAD08;
	sub_828CB168(ctx, base);
	// 828CAD08: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CAD0C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CAD10: 419A000C  beq cr6, 0x828cad1c
	if ctx.cr[6].eq {
	pc = 0x828CAD1C; continue 'dispatch;
	}
	// 828CAD14: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CAD18: 419A0008  beq cr6, 0x828cad20
	if ctx.cr[6].eq {
	pc = 0x828CAD20; continue 'dispatch;
	}
	// 828CAD1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CAD20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAD24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CAD28: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CAD2C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CAD30: 419A0028  beq cr6, 0x828cad58
	if ctx.cr[6].eq {
	pc = 0x828CAD58; continue 'dispatch;
	}
	// 828CAD34: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CAD38: E8E90010  ld r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 828CAD3C: 7F2B3840  cmpld cr6, r11, r7
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[7].u64, &mut ctx.xer);
	// 828CAD40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CAD44: 41980008  blt cr6, 0x828cad4c
	if ctx.cr[6].lt {
	pc = 0x828CAD4C; continue 'dispatch;
	}
	// 828CAD48: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828CAD4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CAD50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAD54: 419A0058  beq cr6, 0x828cadac
	if ctx.cr[6].eq {
	pc = 0x828CADAC; continue 'dispatch;
	}
	// 828CAD58: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CAD5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CAD60: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828CAD64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828CAD68: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828CAD6C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CAD70: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828CAD74: 4BA56DCD  bl 0x82321b40
	ctx.lr = 0x828CAD78;
	sub_82321B40(ctx, base);
	// 828CAD78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAD7C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828CAD80: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CAD84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CAD88: 48000141  bl 0x828caec8
	ctx.lr = 0x828CAD8C;
	sub_828CAEC8(ctx, base);
	// 828CAD8C: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828CAD90: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828CAD94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CAD98: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828CAD9C: 419A0008  beq cr6, 0x828cada4
	if ctx.cr[6].eq {
	pc = 0x828CADA4; continue 'dispatch;
	}
	// 828CADA0: 4B950F99  bl 0x8221bd38
	ctx.lr = 0x828CADA4;
	sub_8221BD38(ctx, base);
	// 828CADA4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CADA8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CADAC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CADB0: 409A0008  bne cr6, 0x828cadb8
	if !ctx.cr[6].eq {
	pc = 0x828CADB8; continue 'dispatch;
	}
	// 828CADB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CADB8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CADBC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CADC0: 409A0008  bne cr6, 0x828cadc8
	if !ctx.cr[6].eq {
	pc = 0x828CADC8; continue 'dispatch;
	}
	// 828CADC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CADC8: 38690018  addi r3, r9, 0x18
	ctx.r[3].s64 = ctx.r[9].s64 + 24;
	// 828CADCC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CADD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CADD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CADD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CADDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CADE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CADE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CADE8 size=112
    let mut pc: u32 = 0x828CADE8;
    'dispatch: loop {
        match pc {
            0x828CADE8 => {
    //   block [0x828CADE8..0x828CAE58)
	// 828CADE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CADEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CADF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CADF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CADF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CADFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CAE00: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828CAE04: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828CAE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAE0C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CAE10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAE14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAE18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CAE1C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CAE20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828CAE24: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828CAE28: 48000881  bl 0x828cb6a8
	ctx.lr = 0x828CAE2C;
	sub_828CB6A8(ctx, base);
	// 828CAE2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAE30: 4B950F09  bl 0x8221bd38
	ctx.lr = 0x828CAE34;
	sub_8221BD38(ctx, base);
	// 828CAE34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CAE38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CAE3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CAE40: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CAE44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CAE48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CAE4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CAE50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CAE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CAE58 size=112
    let mut pc: u32 = 0x828CAE58;
    'dispatch: loop {
        match pc {
            0x828CAE58 => {
    //   block [0x828CAE58..0x828CAEC8)
	// 828CAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CAE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CAE60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CAE64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CAE68: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CAE6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CAE70: 3BEBC870  addi r31, r11, -0x3790
	ctx.r[31].s64 = ctx.r[11].s64 + -14224;
	// 828CAE74: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828CAE78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAE7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CAE80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAE84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAE88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CAE8C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CAE90: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828CAE94: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828CAE98: 48001239  bl 0x828cc0d0
	ctx.lr = 0x828CAE9C;
	sub_828CC0D0(ctx, base);
	// 828CAE9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAEA0: 4B950E99  bl 0x8221bd38
	ctx.lr = 0x828CAEA4;
	sub_8221BD38(ctx, base);
	// 828CAEA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CAEA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CAEAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CAEB0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CAEB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CAEB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CAEBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CAEC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CAEC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CAEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CAEC8 size=668
    let mut pc: u32 = 0x828CAEC8;
    'dispatch: loop {
        match pc {
            0x828CAEC8 => {
    //   block [0x828CAEC8..0x828CB164)
	// 828CAEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CAECC: 483DE531  bl 0x82ca93fc
	ctx.lr = 0x828CAED0;
	sub_82CA93D0(ctx, base);
	// 828CAED0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CAED4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CAED8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828CAEDC: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828CAEE0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828CAEE4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828CAEE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CAEEC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828CAEF0: FB4100D0  std r26, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u64 ) };
	// 828CAEF4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828CAEF8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CAEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAF00: 409A0024  bne cr6, 0x828caf24
	if !ctx.cr[6].eq {
	pc = 0x828CAF24; continue 'dispatch;
	}
	// 828CAF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAF08: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAF0C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CAF10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CAF14: 480008A5  bl 0x828cb7b8
	ctx.lr = 0x828CAF18;
	sub_828CB7B8(ctx, base);
	// 828CAF18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CAF20: 483DE52C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CAF24: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CAF28: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 828CAF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAF30: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAF34: 419A000C  beq cr6, 0x828caf40
	if ctx.cr[6].eq {
	pc = 0x828CAF40; continue 'dispatch;
	}
	// 828CAF38: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CAF3C: 419A0008  beq cr6, 0x828caf44
	if ctx.cr[6].eq {
	pc = 0x828CAF44; continue 'dispatch;
	}
	// 828CAF40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CAF44: 836100D4  lwz r27, 0xd4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828CAF48: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CAF4C: 409A004C  bne cr6, 0x828caf98
	if !ctx.cr[6].eq {
	pc = 0x828CAF98; continue 'dispatch;
	}
	// 828CAF50: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828CAF54: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 828CAF58: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 828CAF5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CAF60: 41980008  blt cr6, 0x828caf68
	if ctx.cr[6].lt {
	pc = 0x828CAF68; continue 'dispatch;
	}
	// 828CAF64: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828CAF68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CAF6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAF70: 419A01C4  beq cr6, 0x828cb134
	if ctx.cr[6].eq {
	pc = 0x828CB134; continue 'dispatch;
	}
	// 828CAF74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAF78: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CAF7C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828CAF80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CAF84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF88: 48000831  bl 0x828cb7b8
	ctx.lr = 0x828CAF8C;
	sub_828CB7B8(ctx, base);
	// 828CAF8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CAF94: 483DE4B8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CAF98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAF9C: 419A000C  beq cr6, 0x828cafa8
	if ctx.cr[6].eq {
	pc = 0x828CAFA8; continue 'dispatch;
	}
	// 828CAFA0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CAFA4: 419A0008  beq cr6, 0x828cafac
	if ctx.cr[6].eq {
	pc = 0x828CAFAC; continue 'dispatch;
	}
	// 828CAFA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CAFAC: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828CAFB0: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CAFB4: 409A0048  bne cr6, 0x828caffc
	if !ctx.cr[6].eq {
	pc = 0x828CAFFC; continue 'dispatch;
	}
	// 828CAFB8: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CAFBC: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 828CAFC0: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 828CAFC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CAFC8: 41980008  blt cr6, 0x828cafd0
	if ctx.cr[6].lt {
	pc = 0x828CAFD0; continue 'dispatch;
	}
	// 828CAFCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828CAFD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CAFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CAFD8: 419A015C  beq cr6, 0x828cb134
	if ctx.cr[6].eq {
	pc = 0x828CB134; continue 'dispatch;
	}
	// 828CAFDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAFE0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CAFE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CAFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAFEC: 480007CD  bl 0x828cb7b8
	ctx.lr = 0x828CAFF0;
	sub_828CB7B8(ctx, base);
	// 828CAFF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAFF4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CAFF8: 483DE454  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CAFFC: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 828CB000: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 828CB004: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CB008: 41980008  blt cr6, 0x828cb010
	if ctx.cr[6].lt {
	pc = 0x828CB010; continue 'dispatch;
	}
	// 828CB00C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828CB010: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CB014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB018: 419A0070  beq cr6, 0x828cb088
	if ctx.cr[6].eq {
	pc = 0x828CB088; continue 'dispatch;
	}
	// 828CB01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB020: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 828CB024: 4834710D  bl 0x82c12130
	ctx.lr = 0x828CB028;
	sub_82C12130(ctx, base);
	// 828CB028: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CB02C: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828CB030: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 828CB034: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 828CB038: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CB03C: 41980008  blt cr6, 0x828cb044
	if ctx.cr[6].lt {
	pc = 0x828CB044; continue 'dispatch;
	}
	// 828CB040: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828CB044: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CB048: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB04C: 419A0038  beq cr6, 0x828cb084
	if ctx.cr[6].eq {
	pc = 0x828CB084; continue 'dispatch;
	}
	// 828CB050: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CB058: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CB05C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB060: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB068: 409A00B8  bne cr6, 0x828cb120
	if !ctx.cr[6].eq {
	pc = 0x828CB120; continue 'dispatch;
	}
	// 828CB06C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828CB070: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CB074: 48000745  bl 0x828cb7b8
	ctx.lr = 0x828CB078;
	sub_828CB7B8(ctx, base);
	// 828CB078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB07C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CB080: 483DE3CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CB084: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB088: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 828CB08C: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 828CB090: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CB094: 41980008  blt cr6, 0x828cb09c
	if ctx.cr[6].lt {
	pc = 0x828CB09C; continue 'dispatch;
	}
	// 828CB098: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828CB09C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CB0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB0A4: 419A0090  beq cr6, 0x828cb134
	if ctx.cr[6].eq {
	pc = 0x828CB134; continue 'dispatch;
	}
	// 828CB0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB0AC: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 828CB0B0: 48347149  bl 0x82c121f8
	ctx.lr = 0x828CB0B4;
	sub_82C121F8(ctx, base);
	// 828CB0B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB0BC: 419A000C  beq cr6, 0x828cb0c8
	if ctx.cr[6].eq {
	pc = 0x828CB0C8; continue 'dispatch;
	}
	// 828CB0C0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CB0C4: 419A0008  beq cr6, 0x828cb0cc
	if ctx.cr[6].eq {
	pc = 0x828CB0CC; continue 'dispatch;
	}
	// 828CB0C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB0CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB0D0: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CB0D4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CB0D8: 419A0028  beq cr6, 0x828cb100
	if ctx.cr[6].eq {
	pc = 0x828CB100; continue 'dispatch;
	}
	// 828CB0DC: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828CB0E0: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 828CB0E4: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 828CB0E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CB0EC: 41980008  blt cr6, 0x828cb0f4
	if ctx.cr[6].lt {
	pc = 0x828CB0F4; continue 'dispatch;
	}
	// 828CB0F0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828CB0F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CB0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB0FC: 419A0038  beq cr6, 0x828cb134
	if ctx.cr[6].eq {
	pc = 0x828CB134; continue 'dispatch;
	}
	// 828CB100: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CB108: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CB10C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB110: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB118: 419AFF58  beq cr6, 0x828cb070
	if ctx.cr[6].eq {
	pc = 0x828CB070; continue 'dispatch;
	}
	// 828CB11C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828CB120: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CB124: 48000695  bl 0x828cb7b8
	ctx.lr = 0x828CB128;
	sub_828CB7B8(ctx, base);
	// 828CB128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB12C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CB130: 483DE31C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CB134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CB138: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CB13C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB140: 48000409  bl 0x828cb548
	ctx.lr = 0x828CB144;
	sub_828CB548(ctx, base);
	// 828CB144: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CB148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB14C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB150: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CB154: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB158: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CB15C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CB160: 483DE2EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CB168 size=72
    let mut pc: u32 = 0x828CB168;
    'dispatch: loop {
        match pc {
            0x828CB168 => {
    //   block [0x828CB168..0x828CB1B0)
	// 828CB168: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CB16C: 390BC864  addi r8, r11, -0x379c
	ctx.r[8].s64 = ctx.r[11].s64 + -14236;
	// 828CB170: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB174: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB178: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB17C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB180: 409A0044  bne cr6, 0x828cb1c4
	if !ctx.cr[6].eq {
		sub_828CB1B0(ctx, base);
		return;
	}
	// 828CB184: E8E50000  ld r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 828CB188: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 828CB18C: 7F2A3840  cmpld cr6, r10, r7
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[7].u64, &mut ctx.xer);
	// 828CB190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CB194: 41980008  blt cr6, 0x828cb19c
	if ctx.cr[6].lt {
	pc = 0x828CB19C; continue 'dispatch;
	}
	// 828CB198: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB19C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CB1A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB1A4: 419A000C  beq cr6, 0x828cb1b0
	if ctx.cr[6].eq {
		sub_828CB1B0(ctx, base);
		return;
	}
	// 828CB1A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB1AC: 4800000C  b 0x828cb1b8
	sub_828CB1B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CB1B0 size=32
    let mut pc: u32 = 0x828CB1B0;
    'dispatch: loop {
        match pc {
            0x828CB1B0 => {
    //   block [0x828CB1B0..0x828CB1D0)
	// 828CB1B0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828CB1B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB1B8: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB1BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB1C0: 419AFFC8  beq cr6, 0x828cb188
	if ctx.cr[6].eq {
		sub_828CB168(ctx, base);
		return;
	}
	// 828CB1C4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CB1C8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828CB1CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB1D0 size=296
    let mut pc: u32 = 0x828CB1D0;
    'dispatch: loop {
        match pc {
            0x828CB1D0 => {
    //   block [0x828CB1D0..0x828CB2F8)
	// 828CB1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB1D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CB1DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB1E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB1E4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828CB1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB1EC: 409A000C  bne cr6, 0x828cb1f8
	if !ctx.cr[6].eq {
	pc = 0x828CB1F8; continue 'dispatch;
	}
	// 828CB1F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB1F4: 48000010  b 0x828cb204
	pc = 0x828CB204; continue 'dispatch;
	// 828CB1F8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB1FC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB200: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB204: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828CB208: 4098004C  bge cr6, 0x828cb254
	if !ctx.cr[6].lt {
	pc = 0x828CB254; continue 'dispatch;
	}
	// 828CB20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB210: 409A000C  bne cr6, 0x828cb21c
	if !ctx.cr[6].eq {
	pc = 0x828CB21C; continue 'dispatch;
	}
	// 828CB214: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CB218: 48000010  b 0x828cb228
	pc = 0x828CB228; continue 'dispatch;
	// 828CB21C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB220: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB224: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB228: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB22C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB230: 40990008  ble cr6, 0x828cb238
	if !ctx.cr[6].gt {
	pc = 0x828CB238; continue 'dispatch;
	}
	// 828CB234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB238: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 828CB23C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828CB240: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828CB244: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CB248: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB24C: 480007ED  bl 0x828cba38
	ctx.lr = 0x828CB250;
	sub_828CBA38(ctx, base);
	// 828CB250: 4800008C  b 0x828cb2dc
	pc = 0x828CB2DC; continue 'dispatch;
	// 828CB254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB258: 419A0084  beq cr6, 0x828cb2dc
	if ctx.cr[6].eq {
	pc = 0x828CB2DC; continue 'dispatch;
	}
	// 828CB25C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB260: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB264: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB268: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CB26C: 40980070  bge cr6, 0x828cb2dc
	if !ctx.cr[6].lt {
	pc = 0x828CB2DC; continue 'dispatch;
	}
	// 828CB270: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB274: 40990008  ble cr6, 0x828cb27c
	if !ctx.cr[6].gt {
	pc = 0x828CB27C; continue 'dispatch;
	}
	// 828CB278: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB27C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828CB280: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB284: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828CB288: 40990008  ble cr6, 0x828cb290
	if !ctx.cr[6].gt {
	pc = 0x828CB290; continue 'dispatch;
	}
	// 828CB28C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB290: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CB294: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB298: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828CB29C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828CB2A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CB2A4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB2A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CB2AC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828CB2B0: 41990010  bgt cr6, 0x828cb2c0
	if ctx.cr[6].gt {
	pc = 0x828CB2C0; continue 'dispatch;
	}
	// 828CB2B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB2B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB2BC: 40980008  bge cr6, 0x828cb2c4
	if !ctx.cr[6].lt {
	pc = 0x828CB2C4; continue 'dispatch;
	}
	// 828CB2C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB2C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CB2C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CB2CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB2D0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828CB2D4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB2D8: 4BF2D5B1  bl 0x827f8888
	ctx.lr = 0x828CB2DC;
	sub_827F8888(ctx, base);
	// 828CB2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB2E0: 4B8EC839  bl 0x821b7b18
	ctx.lr = 0x828CB2E4;
	sub_821B7B18(ctx, base);
	// 828CB2E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CB2E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB2EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB2F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CB2F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB2F8 size=244
    let mut pc: u32 = 0x828CB2F8;
    'dispatch: loop {
        match pc {
            0x828CB2F8 => {
    //   block [0x828CB2F8..0x828CB3EC)
	// 828CB2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB2FC: 483DE0F5  bl 0x82ca93f0
	ctx.lr = 0x828CB300;
	sub_82CA93D0(ctx, base);
	// 828CB300: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB304: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 828CB308: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828CB30C: FAC100D0  std r22, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[22].u64 ) };
	// 828CB310: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828CB314: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 828CB318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB31C: F8C100D8  std r6, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[6].u64 ) };
	// 828CB320: 419A0010  beq cr6, 0x828cb330
	if ctx.cr[6].eq {
	pc = 0x828CB330; continue 'dispatch;
	}
	// 828CB324: 814100D8  lwz r10, 0xd8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 828CB328: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB32C: 419A0008  beq cr6, 0x828cb334
	if ctx.cr[6].eq {
	pc = 0x828CB334; continue 'dispatch;
	}
	// 828CB330: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB334: 814100D4  lwz r10, 0xd4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828CB338: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828CB33C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB340: 419A009C  beq cr6, 0x828cb3dc
	if ctx.cr[6].eq {
	pc = 0x828CB3DC; continue 'dispatch;
	}
	// 828CB344: 83580008  lwz r26, 8(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB348: 7D2BD050  subf r9, r11, r26
	ctx.r[9].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 828CB34C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CB350: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB354: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828CB358: 7F295214  add r25, r9, r10
	ctx.r[25].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828CB35C: 419A0058  beq cr6, 0x828cb3b4
	if ctx.cr[6].eq {
	pc = 0x828CB3B4; continue 'dispatch;
	}
	// 828CB360: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828CB364: 3BEA0004  addi r31, r10, 4
	ctx.r[31].s64 = ctx.r[10].s64 + 4;
	// 828CB368: 7F6A5850  subf r27, r10, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CB36C: 7FDFD82E  lwzx r30, r31, r27
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 828CB370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB374: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB378: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828CB37C: 419A0028  beq cr6, 0x828cb3a4
	if ctx.cr[6].eq {
	pc = 0x828CB3A4; continue 'dispatch;
	}
	// 828CB380: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 828CB384: 4B8EC795  bl 0x821b7b18
	ctx.lr = 0x828CB388;
	sub_821B7B18(ctx, base);
	// 828CB388: 939FFFFC  stw r28, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 828CB38C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CB390: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CB394: 419A0010  beq cr6, 0x828cb3a4
	if ctx.cr[6].eq {
	pc = 0x828CB3A4; continue 'dispatch;
	}
	// 828CB398: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB39C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828CB3A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB3A4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CB3A8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828CB3AC: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CB3B0: 409AFFBC  bne cr6, 0x828cb36c
	if !ctx.cr[6].eq {
	pc = 0x828CB36C; continue 'dispatch;
	}
	// 828CB3B4: 83D80008  lwz r30, 8(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB3B8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828CB3BC: 7F19F040  cmplw cr6, r25, r30
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828CB3C0: 419A0018  beq cr6, 0x828cb3d8
	if ctx.cr[6].eq {
	pc = 0x828CB3D8; continue 'dispatch;
	}
	// 828CB3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB3C8: 4B8EC751  bl 0x821b7b18
	ctx.lr = 0x828CB3CC;
	sub_821B7B18(ctx, base);
	// 828CB3CC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828CB3D0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828CB3D4: 409AFFF0  bne cr6, 0x828cb3c4
	if !ctx.cr[6].eq {
	pc = 0x828CB3C4; continue 'dispatch;
	}
	// 828CB3D8: 93380008  stw r25, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828CB3DC: FAD70000  std r22, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
	// 828CB3E0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828CB3E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CB3E8: 483DE058  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB3F0 size=344
    let mut pc: u32 = 0x828CB3F0;
    'dispatch: loop {
        match pc {
            0x828CB3F0 => {
    //   block [0x828CB3F0..0x828CB548)
	// 828CB3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB3F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB3FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB400: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 828CB404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB408: 409A000C  bne cr6, 0x828cb414
	if !ctx.cr[6].eq {
	pc = 0x828CB414; continue 'dispatch;
	}
	// 828CB40C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB410: 48000010  b 0x828cb420
	pc = 0x828CB420; continue 'dispatch;
	// 828CB414: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB418: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB41C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB420: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828CB424: 40980058  bge cr6, 0x828cb47c
	if !ctx.cr[6].lt {
	pc = 0x828CB47C; continue 'dispatch;
	}
	// 828CB428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB42C: 409A000C  bne cr6, 0x828cb438
	if !ctx.cr[6].eq {
	pc = 0x828CB438; continue 'dispatch;
	}
	// 828CB430: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CB434: 48000010  b 0x828cb444
	pc = 0x828CB444; continue 'dispatch;
	// 828CB438: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB43C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB440: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB444: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB448: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB44C: 40990008  ble cr6, 0x828cb454
	if !ctx.cr[6].gt {
	pc = 0x828CB454; continue 'dispatch;
	}
	// 828CB450: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB454: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 828CB458: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828CB45C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828CB460: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828CB464: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB468: 48000901  bl 0x828cbd68
	ctx.lr = 0x828CB46C;
	sub_828CBD68(ctx, base);
	// 828CB46C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB478: 4E800020  blr
	return;
	// 828CB47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB480: 419A00B8  beq cr6, 0x828cb538
	if ctx.cr[6].eq {
	pc = 0x828CB538; continue 'dispatch;
	}
	// 828CB484: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB488: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CB48C: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CB490: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CB494: 409800A4  bge cr6, 0x828cb538
	if !ctx.cr[6].lt {
	pc = 0x828CB538; continue 'dispatch;
	}
	// 828CB498: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB49C: 4099000C  ble cr6, 0x828cb4a8
	if !ctx.cr[6].gt {
	pc = 0x828CB4A8; continue 'dispatch;
	}
	// 828CB4A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB4A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB4A8: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828CB4AC: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB4B0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828CB4B4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828CB4B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CB4BC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB4C0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CB4C4: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 828CB4C8: 41990010  bgt cr6, 0x828cb4d8
	if ctx.cr[6].gt {
	pc = 0x828CB4D8; continue 'dispatch;
	}
	// 828CB4CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB4D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB4D4: 40980008  bge cr6, 0x828cb4dc
	if !ctx.cr[6].lt {
	pc = 0x828CB4DC; continue 'dispatch;
	}
	// 828CB4D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB4DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CB4E0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828CB4E4: 419A0008  beq cr6, 0x828cb4ec
	if ctx.cr[6].eq {
	pc = 0x828CB4EC; continue 'dispatch;
	}
	// 828CB4E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB4EC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB4F0: 419A0048  beq cr6, 0x828cb538
	if ctx.cr[6].eq {
	pc = 0x828CB538; continue 'dispatch;
	}
	// 828CB4F4: 7D0A5050  subf r8, r10, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 828CB4F8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828CB4FC: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 828CB500: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB504: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828CB508: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 828CB50C: 419A0028  beq cr6, 0x828cb534
	if ctx.cr[6].eq {
	pc = 0x828CB534; continue 'dispatch;
	}
	// 828CB510: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828CB514: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB518: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828CB51C: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 828CB520: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB524: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CB528: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828CB52C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB530: 409AFFE4  bne cr6, 0x828cb514
	if !ctx.cr[6].eq {
	pc = 0x828CB514; continue 'dispatch;
	}
	// 828CB534: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828CB538: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB53C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB540: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB548 size=348
    let mut pc: u32 = 0x828CB548;
    'dispatch: loop {
        match pc {
            0x828CB548 => {
    //   block [0x828CB548..0x828CB6A4)
	// 828CB548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB54C: 483DDEB5  bl 0x82ca9400
	ctx.lr = 0x828CB550;
	sub_82CA93D0(ctx, base);
	// 828CB550: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB554: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CB558: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828CB55C: 3B8BC864  addi r28, r11, -0x379c
	ctx.r[28].s64 = ctx.r[11].s64 + -14236;
	// 828CB560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CB564: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828CB568: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828CB56C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB570: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 828CB574: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB578: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB57C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB580: 409A0044  bne cr6, 0x828cb5c4
	if !ctx.cr[6].eq {
	pc = 0x828CB5C4; continue 'dispatch;
	}
	// 828CB584: E91B0000  ld r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 828CB588: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 828CB58C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828CB590: 7F285040  cmpld cr6, r8, r10
	ctx.cr[6].compare_u64(ctx.r[8].u64, ctx.r[10].u64, &mut ctx.xer);
	// 828CB594: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828CB598: 41980008  blt cr6, 0x828cb5a0
	if ctx.cr[6].lt {
	pc = 0x828CB5A0; continue 'dispatch;
	}
	// 828CB59C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB5A0: 555E063E  clrlwi r30, r10, 0x18
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828CB5A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CB5A8: 419A000C  beq cr6, 0x828cb5b4
	if ctx.cr[6].eq {
	pc = 0x828CB5B4; continue 'dispatch;
	}
	// 828CB5AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB5B0: 48000008  b 0x828cb5b8
	pc = 0x828CB5B8; continue 'dispatch;
	// 828CB5B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB5B8: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CB5BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CB5C0: 419AFFC8  beq cr6, 0x828cb588
	if ctx.cr[6].eq {
	pc = 0x828CB588; continue 'dispatch;
	}
	// 828CB5C4: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828CB5C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828CB5CC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828CB5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB5D4: 419A0050  beq cr6, 0x828cb624
	if ctx.cr[6].eq {
	pc = 0x828CB624; continue 'dispatch;
	}
	// 828CB5D8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB5E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB5E4: 409A003C  bne cr6, 0x828cb620
	if !ctx.cr[6].eq {
	pc = 0x828CB620; continue 'dispatch;
	}
	// 828CB5E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CB5EC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828CB5F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828CB5F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CB5F8: 480001C1  bl 0x828cb7b8
	ctx.lr = 0x828CB5FC;
	sub_828CB7B8(ctx, base);
	// 828CB5FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CB600: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828CB604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB608: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB60C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB610: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CB614: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CB618: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CB61C: 483DDE34  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828CB620: 48346B11  bl 0x82c12130
	ctx.lr = 0x828CB624;
	sub_82C12130(ctx, base);
	// 828CB624: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CB628: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 828CB62C: E92B0010  ld r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 828CB630: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828CB634: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 828CB638: 41980008  blt cr6, 0x828cb640
	if ctx.cr[6].lt {
	pc = 0x828CB640; continue 'dispatch;
	}
	// 828CB63C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CB640: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828CB644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB648: 419A0040  beq cr6, 0x828cb688
	if ctx.cr[6].eq {
	pc = 0x828CB688; continue 'dispatch;
	}
	// 828CB64C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CB650: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828CB654: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828CB658: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CB65C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB660: 48000159  bl 0x828cb7b8
	ctx.lr = 0x828CB664;
	sub_828CB7B8(ctx, base);
	// 828CB664: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CB668: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828CB66C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB670: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB674: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB678: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CB67C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CB680: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CB684: 483DDDCC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 828CB688: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CB68C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB694: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828CB698: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CB69C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CB6A0: 483DDDB0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB6A8 size=272
    let mut pc: u32 = 0x828CB6A8;
    'dispatch: loop {
        match pc {
            0x828CB6A8 => {
    //   block [0x828CB6A8..0x828CB7B8)
	// 828CB6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB6AC: 483DDD59  bl 0x82ca9404
	ctx.lr = 0x828CB6B0;
	sub_82CA93D0(ctx, base);
	// 828CB6B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB6B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CB6B8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828CB6BC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828CB6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CB6C4: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828CB6C8: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828CB6CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CB6D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB6D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB6D8: 419A000C  beq cr6, 0x828cb6e4
	if ctx.cr[6].eq {
	pc = 0x828CB6E4; continue 'dispatch;
	}
	// 828CB6DC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CB6E0: 419A0008  beq cr6, 0x828cb6e8
	if ctx.cr[6].eq {
	pc = 0x828CB6E8; continue 'dispatch;
	}
	// 828CB6E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB6E8: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CB6EC: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828CB6F0: 83A100B8  lwz r29, 0xb8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828CB6F4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB6F8: 409A0068  bne cr6, 0x828cb760
	if !ctx.cr[6].eq {
	pc = 0x828CB760; continue 'dispatch;
	}
	// 828CB6FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828CB700: 419A000C  beq cr6, 0x828cb70c
	if ctx.cr[6].eq {
	pc = 0x828CB70C; continue 'dispatch;
	}
	// 828CB704: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CB708: 419A0008  beq cr6, 0x828cb710
	if ctx.cr[6].eq {
	pc = 0x828CB710; continue 'dispatch;
	}
	// 828CB70C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB710: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB714: 409A004C  bne cr6, 0x828cb760
	if !ctx.cr[6].eq {
	pc = 0x828CB760; continue 'dispatch;
	}
	// 828CB718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB71C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB720: 48001549  bl 0x828ccc68
	ctx.lr = 0x828CB724;
	sub_828CCC68(ctx, base);
	// 828CB724: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB728: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CB72C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CB730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB734: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CB738: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CB73C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB740: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB744: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB748: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CB74C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB750: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB754: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CB758: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CB75C: 483DDCF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828CB760: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CB764: 419A000C  beq cr6, 0x828cb770
	if ctx.cr[6].eq {
	pc = 0x828CB770; continue 'dispatch;
	}
	// 828CB768: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828CB76C: 419A0008  beq cr6, 0x828cb774
	if ctx.cr[6].eq {
	pc = 0x828CB774; continue 'dispatch;
	}
	// 828CB770: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CB774: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CB778: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CB77C: 419A002C  beq cr6, 0x828cb7a8
	if ctx.cr[6].eq {
	pc = 0x828CB7A8; continue 'dispatch;
	}
	// 828CB780: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828CB784: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828CB788: 48346A71  bl 0x82c121f8
	ctx.lr = 0x828CB78C;
	sub_82C121F8(ctx, base);
	// 828CB78C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CB790: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CB794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB798: 48000A49  bl 0x828cc1e0
	ctx.lr = 0x828CB79C;
	sub_828CC1E0(ctx, base);
	// 828CB79C: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 828CB7A0: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828CB7A4: 4BFFFFBC  b 0x828cb760
	pc = 0x828CB760; continue 'dispatch;
	// 828CB7A8: F8BE0000  std r5, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828CB7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB7B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CB7B4: 483DDCA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB7B8 size=636
    let mut pc: u32 = 0x828CB7B8;
    'dispatch: loop {
        match pc {
            0x828CB7B8 => {
    //   block [0x828CB7B8..0x828CBA34)
	// 828CB7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB7BC: 483DDC3D  bl 0x82ca93f8
	ctx.lr = 0x828CB7C0;
	sub_82CA93D0(ctx, base);
	// 828CB7C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB7C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CB7C8: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 828CB7CC: 3BCBC864  addi r30, r11, -0x379c
	ctx.r[30].s64 = ctx.r[11].s64 + -14236;
	// 828CB7D0: 6149AAA9  ori r9, r10, 0xaaa9
	ctx.r[9].u64 = ctx.r[10].u64 | 43689;
	// 828CB7D4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828CB7D8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828CB7DC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828CB7E0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB7E4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 828CB7E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CB7EC: 41980048  blt cr6, 0x828cb834
	if ctx.cr[6].lt {
	pc = 0x828CB834; continue 'dispatch;
	}
	// 828CB7F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CB7F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB7F8: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 828CB7FC: 4BA26745  bl 0x822f1f40
	ctx.lr = 0x828CB800;
	sub_822F1F40(ctx, base);
	// 828CB800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB804: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CB808: 4BA265A9  bl 0x822f1db0
	ctx.lr = 0x828CB80C;
	sub_822F1DB0(ctx, base);
	// 828CB80C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828CB810: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CB814: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 828CB818: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828CB81C: 4BA26605  bl 0x822f1e20
	ctx.lr = 0x828CB820;
	sub_822F1E20(ctx, base);
	// 828CB820: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828CB824: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CB828: 4BDAFFB9  bl 0x8267b7e0
	ctx.lr = 0x828CB82C;
	sub_8267B7E0(ctx, base);
	// 828CB82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB830: 4B8A5FE1  bl 0x82171810
	ctx.lr = 0x828CB834;
	sub_82171810(ctx, base);
	// 828CB834: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828CB838: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB83C: 4B953A1D  bl 0x8221f258
	ctx.lr = 0x828CB840;
	sub_8221F258(ctx, base);
	// 828CB840: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CB844: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828CB848: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CB84C: 419A0030  beq cr6, 0x828cb87c
	if ctx.cr[6].eq {
	pc = 0x828CB87C; continue 'dispatch;
	}
	// 828CB850: 397C0010  addi r11, r28, 0x10
	ctx.r[11].s64 = ctx.r[28].s64 + 16;
	// 828CB854: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828CB858: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828CB85C: 389B0008  addi r4, r27, 8
	ctx.r[4].s64 = ctx.r[27].s64 + 8;
	// 828CB860: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828CB864: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 828CB868: E97B0000  ld r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 828CB86C: F97C0010  std r11, 0x10(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828CB870: 4BA562D1  bl 0x82321b40
	ctx.lr = 0x828CB874;
	sub_82321B40(ctx, base);
	// 828CB874: 9B3C0028  stb r25, 0x28(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 828CB878: 9B3C0029  stb r25, 0x29(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(41 as u32), ctx.r[25].u8 ) };
	// 828CB87C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB880: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB884: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB888: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB88C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CB890: 409A0018  bne cr6, 0x828cb8a8
	if !ctx.cr[6].eq {
	pc = 0x828CB8A8; continue 'dispatch;
	}
	// 828CB894: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CB898: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB89C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828CB8A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8A4: 48000044  b 0x828cb8e8
	pc = 0x828CB8E8; continue 'dispatch;
	// 828CB8A8: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828CB8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB8B0: 419A0024  beq cr6, 0x828cb8d4
	if ctx.cr[6].eq {
	pc = 0x828CB8D4; continue 'dispatch;
	}
	// 828CB8B4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828CB8B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB8C0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB8C4: 409A0028  bne cr6, 0x828cb8ec
	if !ctx.cr[6].eq {
	pc = 0x828CB8EC; continue 'dispatch;
	}
	// 828CB8C8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CB8CC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828CB8D0: 4800001C  b 0x828cb8ec
	pc = 0x828CB8EC; continue 'dispatch;
	// 828CB8D4: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828CB8D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB8E0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CB8E4: 409A0008  bne cr6, 0x828cb8ec
	if !ctx.cr[6].eq {
	pc = 0x828CB8EC; continue 'dispatch;
	}
	// 828CB8E8: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828CB8EC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8F0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828CB8F4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828CB8F8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828CB8FC: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CB900: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CB904: 409A0110  bne cr6, 0x828cba14
	if !ctx.cr[6].eq {
	pc = 0x828CBA14; continue 'dispatch;
	}
	// 828CB908: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB90C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB910: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB914: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CB918: 409A0078  bne cr6, 0x828cb990
	if !ctx.cr[6].eq {
	pc = 0x828CB990; continue 'dispatch;
	}
	// 828CB91C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB920: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CB924: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CB928: 409A0028  bne cr6, 0x828cb950
	if !ctx.cr[6].eq {
	pc = 0x828CB950; continue 'dispatch;
	}
	// 828CB92C: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828CB930: 9BA90028  stb r29, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB934: 9BAA0028  stb r29, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB938: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB93C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB940: 9B270028  stb r25, 0x28(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 828CB944: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB948: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB94C: 480000B4  b 0x828cba00
	pc = 0x828CBA00; continue 'dispatch;
	// 828CB950: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CB954: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB958: 409A0010  bne cr6, 0x828cb968
	if !ctx.cr[6].eq {
	pc = 0x828CB968; continue 'dispatch;
	}
	// 828CB95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB960: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CB964: 48000CC5  bl 0x828cc628
	ctx.lr = 0x828CB968;
	sub_828CC628(ctx, base);
	// 828CB968: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB96C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB970: 9BAB0028  stb r29, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB974: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB978: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB97C: 9B290028  stb r25, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 828CB980: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB984: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB988: 48000D21  bl 0x828cc6a8
	ctx.lr = 0x828CB98C;
	sub_828CC6A8(ctx, base);
	// 828CB98C: 48000074  b 0x828cba00
	pc = 0x828CBA00; continue 'dispatch;
	// 828CB990: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB994: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CB998: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CB99C: 409A0028  bne cr6, 0x828cb9c4
	if !ctx.cr[6].eq {
	pc = 0x828CB9C4; continue 'dispatch;
	}
	// 828CB9A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB9A4: 9BA90028  stb r29, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB9A8: 9BAA0028  stb r29, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB9AC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB9B0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9B4: 9B270028  stb r25, 0x28(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 828CB9B8: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB9BC: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9C0: 48000040  b 0x828cba00
	pc = 0x828CBA00; continue 'dispatch;
	// 828CB9C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB9C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CB9CC: 409A0010  bne cr6, 0x828cb9dc
	if !ctx.cr[6].eq {
	pc = 0x828CB9DC; continue 'dispatch;
	}
	// 828CB9D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB9D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CB9D8: 48000CD1  bl 0x828cc6a8
	ctx.lr = 0x828CB9DC;
	sub_828CC6A8(ctx, base);
	// 828CB9DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB9E4: 9BAB0028  stb r29, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CB9E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9EC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9F0: 9B290028  stb r25, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 828CB9F4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9F8: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9FC: 48000C2D  bl 0x828cc628
	ctx.lr = 0x828CBA00;
	sub_828CC628(ctx, base);
	// 828CBA00: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA04: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828CBA08: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CBA0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CBA10: 419AFEF8  beq cr6, 0x828cb908
	if ctx.cr[6].eq {
	pc = 0x828CB908; continue 'dispatch;
	}
	// 828CBA14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA18: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828CBA1C: 93980004  stw r28, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CBA20: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CBA24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA28: 9BAA0028  stb r29, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CBA2C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828CBA30: 483DDA18  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBA38 size=816
    let mut pc: u32 = 0x828CBA38;
    'dispatch: loop {
        match pc {
            0x828CBA38 => {
    //   block [0x828CBA38..0x828CBD68)
	// 828CBA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBA3C: 483DD9BD  bl 0x82ca93f8
	ctx.lr = 0x828CBA40;
	sub_82CA93D0(ctx, base);
	// 828CBA40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBA44: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBA4C: 83060000  lwz r24, 0(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBA50: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828CBA54: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 828CBA58: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828CBA5C: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828CBA60: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 828CBA64: 419A0020  beq cr6, 0x828cba84
	if ctx.cr[6].eq {
	pc = 0x828CBA84; continue 'dispatch;
	}
	// 828CBA68: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828CBA6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBA70: 7D60C828  lwarx r11, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828CBA74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828CBA78: 7D60C92D  stwcx. r11, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CBA7C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBA80: 4082FFE8  bne 0x828cba68
	if !ctx.cr[0].eq {
	pc = 0x828CBA68; continue 'dispatch;
	}
	// 828CBA84: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA88: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CBA8C: 409A000C  bne cr6, 0x828cba98
	if !ctx.cr[6].eq {
	pc = 0x828CBA98; continue 'dispatch;
	}
	// 828CBA90: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828CBA94: 48000010  b 0x828cbaa4
	pc = 0x828CBAA4; continue 'dispatch;
	// 828CBA98: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CBA9C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828CBAA0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBAA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CBAA8: 419A02B0  beq cr6, 0x828cbd58
	if ctx.cr[6].eq {
	pc = 0x828CBD58; continue 'dispatch;
	}
	// 828CBAAC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CBAB0: 409A000C  bne cr6, 0x828cbabc
	if !ctx.cr[6].eq {
	pc = 0x828CBABC; continue 'dispatch;
	}
	// 828CBAB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBAB8: 48000010  b 0x828cbac8
	pc = 0x828CBAC8; continue 'dispatch;
	// 828CBABC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBAC0: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828CBAC4: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBAC8: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 828CBACC: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828CBAD0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CBAD4: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CBAD8: 40980018  bge cr6, 0x828cbaf0
	if !ctx.cr[6].lt {
	pc = 0x828CBAF0; continue 'dispatch;
	}
	// 828CBADC: 4BC28FF5  bl 0x824f4ad0
	ctx.lr = 0x828CBAE0;
	sub_824F4AD0(ctx, base);
	// 828CBAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBAE4: 4B8EC035  bl 0x821b7b18
	ctx.lr = 0x828CBAE8;
	sub_821B7B18(ctx, base);
	// 828CBAE8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CBAEC: 483DD95C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828CBAF0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CBAF4: 409A000C  bne cr6, 0x828cbb00
	if !ctx.cr[6].eq {
	pc = 0x828CBB00; continue 'dispatch;
	}
	// 828CBAF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBAFC: 48000010  b 0x828cbb0c
	pc = 0x828CBB0C; continue 'dispatch;
	// 828CBB00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBB04: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828CBB08: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828CBB0C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828CBB10: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CBB14: 40980174  bge cr6, 0x828cbc88
	if !ctx.cr[6].lt {
	pc = 0x828CBC88; continue 'dispatch;
	}
	// 828CBB18: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CBB1C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828CBB20: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CBB24: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CBB28: 41980008  blt cr6, 0x828cbb30
	if ctx.cr[6].lt {
	pc = 0x828CBB30; continue 'dispatch;
	}
	// 828CBB2C: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828CBB30: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CBB34: 409A000C  bne cr6, 0x828cbb40
	if !ctx.cr[6].eq {
	pc = 0x828CBB40; continue 'dispatch;
	}
	// 828CBB38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBB3C: 48000010  b 0x828cbb4c
	pc = 0x828CBB4C; continue 'dispatch;
	// 828CBB40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBB44: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828CBB48: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBB4C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828CBB50: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CBB54: 40980024  bge cr6, 0x828cbb78
	if !ctx.cr[6].lt {
	pc = 0x828CBB78; continue 'dispatch;
	}
	// 828CBB58: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CBB5C: 409A000C  bne cr6, 0x828cbb68
	if !ctx.cr[6].eq {
	pc = 0x828CBB68; continue 'dispatch;
	}
	// 828CBB60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBB64: 48000010  b 0x828cbb74
	pc = 0x828CBB74; continue 'dispatch;
	// 828CBB68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBB6C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 828CBB70: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBB74: 7F4BE214  add r26, r11, r28
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828CBB78: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828CBB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBB80: 481E4DD9  bl 0x82ab0958
	ctx.lr = 0x828CBB84;
	sub_82AB0958(ctx, base);
	// 828CBB84: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828CBB88: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828CBB8C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBB90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CBB94: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828CBB98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBB9C: 4BBB50A5  bl 0x82480c40
	ctx.lr = 0x828CBBA0;
	sub_82480C40(ctx, base);
	// 828CBBA0: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 828CBBA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CBBA8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CBBAC: 419A0040  beq cr6, 0x828cbbec
	if ctx.cr[6].eq {
	pc = 0x828CBBEC; continue 'dispatch;
	}
	// 828CBBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBBB4: 419A0030  beq cr6, 0x828cbbe4
	if ctx.cr[6].eq {
	pc = 0x828CBBE4; continue 'dispatch;
	}
	// 828CBBB8: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 828CBBBC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828CBBC0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 828CBBC4: 419A0020  beq cr6, 0x828cbbe4
	if ctx.cr[6].eq {
	pc = 0x828CBBE4; continue 'dispatch;
	}
	// 828CBBC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CBBCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBBD0: 7D40C828  lwarx r10, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CBBD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CBBD8: 7D40C92D  stwcx. r10, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CBBDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBBE0: 4082FFE8  bne 0x828cbbc8
	if !ctx.cr[0].eq {
	pc = 0x828CBBC8; continue 'dispatch;
	}
	// 828CBBE4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBBE8: 4200FFC8  bdnz 0x828cbbb0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828CBBB0; continue 'dispatch;
	}
	// 828CBBEC: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CBBF0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBBF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CBBF8: 7CCB1A14  add r6, r11, r3
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828CBBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBC00: 4BBB5041  bl 0x82480c40
	ctx.lr = 0x828CBC04;
	sub_82480C40(ctx, base);
	// 828CBC04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBC0C: 409A000C  bne cr6, 0x828cbc18
	if !ctx.cr[6].eq {
	pc = 0x828CBC18; continue 'dispatch;
	}
	// 828CBC10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CBC14: 48000010  b 0x828cbc24
	pc = 0x828CBC24; continue 'dispatch;
	// 828CBC18: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBC1C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CBC20: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CBC24: 7F8AE214  add r28, r10, r28
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828CBC28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBC2C: 419A0030  beq cr6, 0x828cbc5c
	if ctx.cr[6].eq {
	pc = 0x828CBC5C; continue 'dispatch;
	}
	// 828CBC30: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBC34: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828CBC38: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828CBC3C: 419A0018  beq cr6, 0x828cbc54
	if ctx.cr[6].eq {
	pc = 0x828CBC54; continue 'dispatch;
	}
	// 828CBC40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CBC44: 4B8EBED5  bl 0x821b7b18
	ctx.lr = 0x828CBC48;
	sub_821B7B18(ctx, base);
	// 828CBC48: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828CBC4C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828CBC50: 409AFFF0  bne cr6, 0x828cbc40
	if !ctx.cr[6].eq {
	pc = 0x828CBC40; continue 'dispatch;
	}
	// 828CBC54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBC58: 4B9500E1  bl 0x8221bd38
	ctx.lr = 0x828CBC5C;
	sub_8221BD38(ctx, base);
	// 828CBC5C: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CBC60: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828CBC64: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CBC68: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828CBC6C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828CBC70: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828CBC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBC78: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CBC7C: 4B8EBE9D  bl 0x821b7b18
	ctx.lr = 0x828CBC80;
	sub_821B7B18(ctx, base);
	// 828CBC80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CBC84: 483DD7C4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 828CBC88: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBC90: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828CBC94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CBC98: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 828CBC9C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828CBCA0: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CBCA4: 4098007C  bge cr6, 0x828cbd20
	if !ctx.cr[6].lt {
	pc = 0x828CBD20; continue 'dispatch;
	}
	// 828CBCA8: 579B1838  slwi r27, r28, 3
	ctx.r[27].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 828CBCAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CBCB0: 7CDBEA14  add r6, r27, r29
	ctx.r[6].u64 = ctx.r[27].u64 + ctx.r[29].u64;
	// 828CBCB4: 4BBB4F8D  bl 0x82480c40
	ctx.lr = 0x828CBCB8;
	sub_82480C40(ctx, base);
	// 828CBCB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBCBC: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 828CBCC0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBCC4: 7D49E051  subf. r10, r9, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828CBCC8: 41820044  beq 0x828cbd0c
	if ctx.cr[0].eq {
	pc = 0x828CBD0C; continue 'dispatch;
	}
	// 828CBCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBCD0: 419A0030  beq cr6, 0x828cbd00
	if ctx.cr[6].eq {
	pc = 0x828CBD00; continue 'dispatch;
	}
	// 828CBCD4: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 828CBCD8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828CBCDC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 828CBCE0: 419A0020  beq cr6, 0x828cbd00
	if ctx.cr[6].eq {
	pc = 0x828CBD00; continue 'dispatch;
	}
	// 828CBCE4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828CBCE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBCEC: 7D20C828  lwarx r9, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828CBCF0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828CBCF4: 7D20C92D  stwcx. r9, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CBCF8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBCFC: 4082FFE8  bne 0x828cbce4
	if !ctx.cr[0].eq {
	pc = 0x828CBCE4; continue 'dispatch;
	}
	// 828CBD00: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828CBD04: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBD08: 4082FFC4  bne 0x828cbccc
	if !ctx.cr[0].eq {
	pc = 0x828CBCCC; continue 'dispatch;
	}
	// 828CBD0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBD10: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 828CBD14: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CBD18: 7C9B5850  subf r4, r27, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 828CBD1C: 48000030  b 0x828cbd4c
	pc = 0x828CBD4C; continue 'dispatch;
	// 828CBD20: 579C1838  slwi r28, r28, 3
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 828CBD24: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828CBD28: 7F7CF050  subf r27, r28, r30
	ctx.r[27].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 828CBD2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828CBD30: 4BBB4F11  bl 0x82480c40
	ctx.lr = 0x828CBD34;
	sub_82480C40(ctx, base);
	// 828CBD34: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828CBD38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CBD3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828CBD40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CBD44: 4BA8B275  bl 0x82356fb8
	ctx.lr = 0x828CBD48;
	sub_82356FB8(ctx, base);
	// 828CBD48: 7C9CEA14  add r4, r28, r29
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 828CBD4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828CBD50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CBD54: 4BE247CD  bl 0x826f0520
	ctx.lr = 0x828CBD58;
	sub_826F0520(ctx, base);
	// 828CBD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBD5C: 4B8EBDBD  bl 0x821b7b18
	ctx.lr = 0x828CBD60;
	sub_821B7B18(ctx, base);
	// 828CBD60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CBD64: 483DD6E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBD68 size=868
    let mut pc: u32 = 0x828CBD68;
    'dispatch: loop {
        match pc {
            0x828CBD68 => {
    //   block [0x828CBD68..0x828CC0CC)
	// 828CBD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBD6C: 483DD699  bl 0x82ca9404
	ctx.lr = 0x828CBD70;
	sub_82CA93D0(ctx, base);
	// 828CBD70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBD74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CBD78: EB660000  ld r27, 0(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 828CBD7C: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 828CBD80: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828CBD84: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBD88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBD8C: 409A000C  bne cr6, 0x828cbd98
	if !ctx.cr[6].eq {
	pc = 0x828CBD98; continue 'dispatch;
	}
	// 828CBD90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828CBD94: 48000010  b 0x828cbda4
	pc = 0x828CBDA4; continue 'dispatch;
	// 828CBD98: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828CBD9C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CBDA0: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CBDA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CBDA8: 419A031C  beq cr6, 0x828cc0c4
	if ctx.cr[6].eq {
	pc = 0x828CC0C4; continue 'dispatch;
	}
	// 828CBDAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBDB0: 409A000C  bne cr6, 0x828cbdbc
	if !ctx.cr[6].eq {
	pc = 0x828CBDBC; continue 'dispatch;
	}
	// 828CBDB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBDB8: 48000010  b 0x828cbdc8
	pc = 0x828CBDC8; continue 'dispatch;
	// 828CBDBC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBDC0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CBDC4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CBDC8: 3D201FFF  lis r9, 0x1fff
	ctx.r[9].s64 = 536805376;
	// 828CBDCC: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 828CBDD0: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828CBDD4: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CBDD8: 40980010  bge cr6, 0x828cbde8
	if !ctx.cr[6].lt {
	pc = 0x828CBDE8; continue 'dispatch;
	}
	// 828CBDDC: 4BC28CF5  bl 0x824f4ad0
	ctx.lr = 0x828CBDE0;
	sub_824F4AD0(ctx, base);
	// 828CBDE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CBDE4: 483DD670  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828CBDE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBDEC: 409A000C  bne cr6, 0x828cbdf8
	if !ctx.cr[6].eq {
	pc = 0x828CBDF8; continue 'dispatch;
	}
	// 828CBDF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBDF4: 48000010  b 0x828cbe04
	pc = 0x828CBE04; continue 'dispatch;
	// 828CBDF8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBDFC: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CBE00: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828CBE04: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828CBE08: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CBE0C: 40980174  bge cr6, 0x828cbf80
	if !ctx.cr[6].lt {
	pc = 0x828CBF80; continue 'dispatch;
	}
	// 828CBE10: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CBE14: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828CBE18: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828CBE1C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CBE20: 41980008  blt cr6, 0x828cbe28
	if ctx.cr[6].lt {
	pc = 0x828CBE28; continue 'dispatch;
	}
	// 828CBE24: 7F8B4214  add r28, r11, r8
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828CBE28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBE2C: 409A000C  bne cr6, 0x828cbe38
	if !ctx.cr[6].eq {
	pc = 0x828CBE38; continue 'dispatch;
	}
	// 828CBE30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBE34: 48000010  b 0x828cbe44
	pc = 0x828CBE44; continue 'dispatch;
	// 828CBE38: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBE3C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CBE40: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CBE44: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828CBE48: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CBE4C: 40980024  bge cr6, 0x828cbe70
	if !ctx.cr[6].lt {
	pc = 0x828CBE70; continue 'dispatch;
	}
	// 828CBE50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBE54: 409A000C  bne cr6, 0x828cbe60
	if !ctx.cr[6].eq {
	pc = 0x828CBE60; continue 'dispatch;
	}
	// 828CBE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBE5C: 48000010  b 0x828cbe6c
	pc = 0x828CBE6C; continue 'dispatch;
	// 828CBE60: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBE64: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828CBE68: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBE6C: 7F8BFA14  add r28, r11, r31
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828CBE70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CBE74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CBE78: 481E4AE1  bl 0x82ab0958
	ctx.lr = 0x828CBE7C;
	sub_82AB0958(ctx, base);
	// 828CBE7C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBE80: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828CBE84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CBE88: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CBE8C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828CBE90: 419A002C  beq cr6, 0x828cbebc
	if ctx.cr[6].eq {
	pc = 0x828CBEBC; continue 'dispatch;
	}
	// 828CBE94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CBE98: 419A0014  beq cr6, 0x828cbeac
	if ctx.cr[6].eq {
	pc = 0x828CBEAC; continue 'dispatch;
	}
	// 828CBE9C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBEA0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CBEA4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBEA8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828CBEAC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBEB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CBEB4: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CBEB8: 409AFFDC  bne cr6, 0x828cbe94
	if !ctx.cr[6].eq {
	pc = 0x828CBE94; continue 'dispatch;
	}
	// 828CBEBC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828CBEC0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828CBEC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CBEC8: 419A001C  beq cr6, 0x828cbee4
	if ctx.cr[6].eq {
	pc = 0x828CBEE4; continue 'dispatch;
	}
	// 828CBECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBED0: 419A0008  beq cr6, 0x828cbed8
	if ctx.cr[6].eq {
	pc = 0x828CBED8; continue 'dispatch;
	}
	// 828CBED4: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828CBED8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828CBEDC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBEE0: 4082FFEC  bne 0x828cbecc
	if !ctx.cr[0].eq {
	pc = 0x828CBECC; continue 'dispatch;
	}
	// 828CBEE4: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBEE8: 57E91838  slwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828CBEEC: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828CBEF0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CBEF4: 419A0038  beq cr6, 0x828cbf2c
	if ctx.cr[6].eq {
	pc = 0x828CBF2C; continue 'dispatch;
	}
	// 828CBEF8: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CBEFC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828CBF00: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 828CBF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBF08: 419A0014  beq cr6, 0x828cbf1c
	if ctx.cr[6].eq {
	pc = 0x828CBF1C; continue 'dispatch;
	}
	// 828CBF0C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBF10: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CBF14: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBF18: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828CBF1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CBF20: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBF24: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CBF28: 409AFFDC  bne cr6, 0x828cbf04
	if !ctx.cr[6].eq {
	pc = 0x828CBF04; continue 'dispatch;
	}
	// 828CBF2C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBF30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CBF34: 409A000C  bne cr6, 0x828cbf40
	if !ctx.cr[6].eq {
	pc = 0x828CBF40; continue 'dispatch;
	}
	// 828CBF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBF3C: 48000010  b 0x828cbf4c
	pc = 0x828CBF4C; continue 'dispatch;
	// 828CBF40: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBF44: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828CBF48: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBF4C: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828CBF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CBF54: 419A0008  beq cr6, 0x828cbf5c
	if ctx.cr[6].eq {
	pc = 0x828CBF5C; continue 'dispatch;
	}
	// 828CBF58: 4B94FDE1  bl 0x8221bd38
	ctx.lr = 0x828CBF5C;
	sub_8221BD38(ctx, base);
	// 828CBF5C: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828CBF60: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828CBF64: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CBF68: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828CBF6C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828CBF70: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828CBF74: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828CBF78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CBF7C: 483DD4D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828CBF80: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828CBF84: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBF88: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828CBF8C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828CBF90: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CBF94: 409800A0  bge cr6, 0x828cc034
	if !ctx.cr[6].lt {
	pc = 0x828CC034; continue 'dispatch;
	}
	// 828CBF98: 57E91838  slwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828CBF9C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CBFA0: 7D693A14  add r11, r9, r7
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 828CBFA4: 419A0030  beq cr6, 0x828cbfd4
	if ctx.cr[6].eq {
	pc = 0x828CBFD4; continue 'dispatch;
	}
	// 828CBFA8: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828CBFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBFB0: 419A0014  beq cr6, 0x828cbfc4
	if ctx.cr[6].eq {
	pc = 0x828CBFC4; continue 'dispatch;
	}
	// 828CBFB4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBFB8: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828CBFBC: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBFC0: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828CBFC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CBFC8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBFCC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CBFD0: 409AFFDC  bne cr6, 0x828cbfac
	if !ctx.cr[6].eq {
	pc = 0x828CBFAC; continue 'dispatch;
	}
	// 828CBFD4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CBFD8: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 828CBFDC: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CBFE0: 7D48F851  subf. r10, r8, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828CBFE4: 4182001C  beq 0x828cc000
	if ctx.cr[0].eq {
	pc = 0x828CC000; continue 'dispatch;
	}
	// 828CBFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBFEC: 419A0008  beq cr6, 0x828cbff4
	if ctx.cr[6].eq {
	pc = 0x828CBFF4; continue 'dispatch;
	}
	// 828CBFF0: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828CBFF4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828CBFF8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CBFFC: 4082FFEC  bne 0x828cbfe8
	if !ctx.cr[0].eq {
	pc = 0x828CBFE8; continue 'dispatch;
	}
	// 828CC000: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC004: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828CC008: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828CC00C: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828CC010: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC014: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC018: 419A00AC  beq cr6, 0x828cc0c4
	if ctx.cr[6].eq {
	pc = 0x828CC0C4; continue 'dispatch;
	}
	// 828CC01C: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828CC020: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CC024: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC028: 409AFFF4  bne cr6, 0x828cc01c
	if !ctx.cr[6].eq {
	pc = 0x828CC01C; continue 'dispatch;
	}
	// 828CC02C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CC030: 483DD424  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828CC034: 57E61838  slwi r6, r31, 3
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828CC038: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828CC03C: 7D664050  subf r11, r6, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 828CC040: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828CC044: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CC048: 419A002C  beq cr6, 0x828cc074
	if ctx.cr[6].eq {
	pc = 0x828CC074; continue 'dispatch;
	}
	// 828CC04C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC050: 419A0014  beq cr6, 0x828cc064
	if ctx.cr[6].eq {
	pc = 0x828CC064; continue 'dispatch;
	}
	// 828CC054: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC058: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 828CC05C: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC060: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CC064: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828CC068: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828CC06C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828CC070: 409AFFDC  bne cr6, 0x828cc04c
	if !ctx.cr[6].eq {
	pc = 0x828CC04C; continue 'dispatch;
	}
	// 828CC074: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC078: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CC07C: 419A0028  beq cr6, 0x828cc0a4
	if ctx.cr[6].eq {
	pc = 0x828CC0A4; continue 'dispatch;
	}
	// 828CC080: 7D465A14  add r10, r6, r11
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828CC084: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 828CC088: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 828CC08C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CC090: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC094: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC098: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC09C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828CC0A0: 409AFFE4  bne cr6, 0x828cc084
	if !ctx.cr[6].eq {
	pc = 0x828CC084; continue 'dispatch;
	}
	// 828CC0A4: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 828CC0A8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828CC0AC: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC0B0: 419A0014  beq cr6, 0x828cc0c4
	if ctx.cr[6].eq {
	pc = 0x828CC0C4; continue 'dispatch;
	}
	// 828CC0B4: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 828CC0B8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828CC0BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC0C0: 409AFFF4  bne cr6, 0x828cc0b4
	if !ctx.cr[6].eq {
	pc = 0x828CC0B4; continue 'dispatch;
	}
	// 828CC0C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CC0C8: 483DD38C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC0D0 size=272
    let mut pc: u32 = 0x828CC0D0;
    'dispatch: loop {
        match pc {
            0x828CC0D0 => {
    //   block [0x828CC0D0..0x828CC1E0)
	// 828CC0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC0D4: 483DD331  bl 0x82ca9404
	ctx.lr = 0x828CC0D8;
	sub_82CA93D0(ctx, base);
	// 828CC0D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC0DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CC0E0: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828CC0E4: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828CC0E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC0EC: 3BEBC870  addi r31, r11, -0x3790
	ctx.r[31].s64 = ctx.r[11].s64 + -14224;
	// 828CC0F0: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828CC0F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC0F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC0FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC100: 419A000C  beq cr6, 0x828cc10c
	if ctx.cr[6].eq {
	pc = 0x828CC10C; continue 'dispatch;
	}
	// 828CC104: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CC108: 419A0008  beq cr6, 0x828cc110
	if ctx.cr[6].eq {
	pc = 0x828CC110; continue 'dispatch;
	}
	// 828CC10C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CC110: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CC114: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828CC118: 83A100B8  lwz r29, 0xb8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828CC11C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC120: 409A0068  bne cr6, 0x828cc188
	if !ctx.cr[6].eq {
	pc = 0x828CC188; continue 'dispatch;
	}
	// 828CC124: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828CC128: 419A000C  beq cr6, 0x828cc134
	if ctx.cr[6].eq {
	pc = 0x828CC134; continue 'dispatch;
	}
	// 828CC12C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CC130: 419A0008  beq cr6, 0x828cc138
	if ctx.cr[6].eq {
	pc = 0x828CC138; continue 'dispatch;
	}
	// 828CC134: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CC138: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CC13C: 409A004C  bne cr6, 0x828cc188
	if !ctx.cr[6].eq {
	pc = 0x828CC188; continue 'dispatch;
	}
	// 828CC140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC144: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC148: 48000B99  bl 0x828ccce0
	ctx.lr = 0x828CC14C;
	sub_828CCCE0(ctx, base);
	// 828CC14C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC150: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CC154: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CC158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC15C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC160: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC164: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC168: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC16C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC170: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC174: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC178: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC17C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC180: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CC184: 483DD2D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 828CC188: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC18C: 419A000C  beq cr6, 0x828cc198
	if ctx.cr[6].eq {
	pc = 0x828CC198; continue 'dispatch;
	}
	// 828CC190: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828CC194: 419A0008  beq cr6, 0x828cc19c
	if ctx.cr[6].eq {
	pc = 0x828CC19C; continue 'dispatch;
	}
	// 828CC198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828CC19C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CC1A0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828CC1A4: 419A002C  beq cr6, 0x828cc1d0
	if ctx.cr[6].eq {
	pc = 0x828CC1D0; continue 'dispatch;
	}
	// 828CC1A8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828CC1AC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828CC1B0: 4BA48979  bl 0x82314b28
	ctx.lr = 0x828CC1B4;
	sub_82314B28(ctx, base);
	// 828CC1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC1B8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CC1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC1C0: 48000569  bl 0x828cc728
	ctx.lr = 0x828CC1C4;
	sub_828CC728(ctx, base);
	// 828CC1C4: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 828CC1C8: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828CC1CC: 4BFFFFBC  b 0x828cc188
	pc = 0x828CC188; continue 'dispatch;
	// 828CC1D0: F8BE0000  std r5, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828CC1D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC1D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CC1DC: 483DD278  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC1E0 size=1096
    let mut pc: u32 = 0x828CC1E0;
    'dispatch: loop {
        match pc {
            0x828CC1E0 => {
    //   block [0x828CC1E0..0x828CC628)
	// 828CC1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC1E4: 483DD219  bl 0x82ca93fc
	ctx.lr = 0x828CC1E8;
	sub_82CA93D0(ctx, base);
	// 828CC1E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC1EC: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 828CC1F0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828CC1F4: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828CC1F8: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC1FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC200: 419A0048  beq cr6, 0x828cc248
	if ctx.cr[6].eq {
	pc = 0x828CC248; continue 'dispatch;
	}
	// 828CC204: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CC208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC20C: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 828CC210: 4BA25D31  bl 0x822f1f40
	ctx.lr = 0x828CC214;
	sub_822F1F40(ctx, base);
	// 828CC214: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CC218: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC21C: 4BA25B95  bl 0x822f1db0
	ctx.lr = 0x828CC220;
	sub_822F1DB0(ctx, base);
	// 828CC220: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828CC224: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC228: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828CC22C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CC230: 4BA25BF1  bl 0x822f1e20
	ctx.lr = 0x828CC234;
	sub_822F1E20(ctx, base);
	// 828CC234: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CC238: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC23C: 4BDAF5A5  bl 0x8267b7e0
	ctx.lr = 0x828CC240;
	sub_8267B7E0(ctx, base);
	// 828CC240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC244: 4B8A55CD  bl 0x82171810
	ctx.lr = 0x828CC248;
	sub_82171810(ctx, base);
	// 828CC248: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828CC24C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 828CC250: 48345FA9  bl 0x82c121f8
	ctx.lr = 0x828CC254;
	sub_82C121F8(ctx, base);
	// 828CC254: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC258: 896A0029  lbz r11, 0x29(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC260: 419A000C  beq cr6, 0x828cc26c
	if ctx.cr[6].eq {
	pc = 0x828CC26C; continue 'dispatch;
	}
	// 828CC264: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC268: 4800002C  b 0x828cc294
	pc = 0x828CC294; continue 'dispatch;
	// 828CC26C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC270: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC274: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC278: 419A000C  beq cr6, 0x828cc284
	if ctx.cr[6].eq {
	pc = 0x828CC284; continue 'dispatch;
	}
	// 828CC27C: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 828CC280: 48000014  b 0x828cc294
	pc = 0x828CC294; continue 'dispatch;
	// 828CC284: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828CC288: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC28C: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC290: 409A00FC  bne cr6, 0x828cc38c
	if !ctx.cr[6].eq {
	pc = 0x828CC38C; continue 'dispatch;
	}
	// 828CC294: 897B0029  lbz r11, 0x29(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC298: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC2A0: 409A0008  bne cr6, 0x828cc2a8
	if !ctx.cr[6].eq {
	pc = 0x828CC2A8; continue 'dispatch;
	}
	// 828CC2A4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828CC2A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CC2AC: 3B8BC864  addi r28, r11, -0x379c
	ctx.r[28].s64 = ctx.r[11].s64 + -14236;
	// 828CC2B0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC2B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC2B8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC2BC: 409A000C  bne cr6, 0x828cc2c8
	if !ctx.cr[6].eq {
	pc = 0x828CC2C8; continue 'dispatch;
	}
	// 828CC2C0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828CC2C4: 4800001C  b 0x828cc2e0
	pc = 0x828CC2E0; continue 'dispatch;
	// 828CC2C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC2CC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC2D0: 409A000C  bne cr6, 0x828cc2dc
	if !ctx.cr[6].eq {
	pc = 0x828CC2DC; continue 'dispatch;
	}
	// 828CC2D4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828CC2D8: 48000008  b 0x828cc2e0
	pc = 0x828CC2E0; continue 'dispatch;
	// 828CC2DC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828CC2E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC2E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC2E8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC2EC: 409A0048  bne cr6, 0x828cc334
	if !ctx.cr[6].eq {
	pc = 0x828CC334; continue 'dispatch;
	}
	// 828CC2F0: 897B0029  lbz r11, 0x29(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC2F8: 419A000C  beq cr6, 0x828cc304
	if ctx.cr[6].eq {
	pc = 0x828CC304; continue 'dispatch;
	}
	// 828CC2FC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828CC300: 4800002C  b 0x828cc32c
	pc = 0x828CC32C; continue 'dispatch;
	// 828CC304: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC308: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828CC30C: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC310: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC314: 409A0018  bne cr6, 0x828cc32c
	if !ctx.cr[6].eq {
	pc = 0x828CC32C; continue 'dispatch;
	}
	// 828CC318: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CC31C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC320: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC324: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC328: 419AFFF0  beq cr6, 0x828cc318
	if ctx.cr[6].eq {
	pc = 0x828CC318; continue 'dispatch;
	}
	// 828CC32C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC330: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CC334: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC338: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC33C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC340: 409A00E8  bne cr6, 0x828cc428
	if !ctx.cr[6].eq {
	pc = 0x828CC428; continue 'dispatch;
	}
	// 828CC344: 897B0029  lbz r11, 0x29(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC34C: 419A0010  beq cr6, 0x828cc35c
	if ctx.cr[6].eq {
	pc = 0x828CC35C; continue 'dispatch;
	}
	// 828CC350: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828CC354: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC358: 480000D0  b 0x828cc428
	pc = 0x828CC428; continue 'dispatch;
	// 828CC35C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC360: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828CC364: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC368: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CC36C: 409A0018  bne cr6, 0x828cc384
	if !ctx.cr[6].eq {
	pc = 0x828CC384; continue 'dispatch;
	}
	// 828CC370: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CC374: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC378: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC37C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CC380: 419AFFF0  beq cr6, 0x828cc370
	if ctx.cr[6].eq {
	pc = 0x828CC370; continue 'dispatch;
	}
	// 828CC384: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC388: 480000A0  b 0x828cc428
	pc = 0x828CC428; continue 'dispatch;
	// 828CC38C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC390: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC394: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CC398: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC39C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC3A0: 409A000C  bne cr6, 0x828cc3ac
	if !ctx.cr[6].eq {
	pc = 0x828CC3AC; continue 'dispatch;
	}
	// 828CC3A4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CC3A8: 4800002C  b 0x828cc3d4
	pc = 0x828CC3D4; continue 'dispatch;
	// 828CC3AC: 895B0029  lbz r10, 0x29(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC3B0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC3B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC3B8: 409A0008  bne cr6, 0x828cc3c0
	if !ctx.cr[6].eq {
	pc = 0x828CC3C0; continue 'dispatch;
	}
	// 828CC3BC: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828CC3C0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828CC3C4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC3C8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC3CC: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC3D0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC3D4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CC3D8: 3B8AC864  addi r28, r10, -0x379c
	ctx.r[28].s64 = ctx.r[10].s64 + -14236;
	// 828CC3DC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC3E0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC3E4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC3E8: 409A000C  bne cr6, 0x828cc3f4
	if !ctx.cr[6].eq {
	pc = 0x828CC3F4; continue 'dispatch;
	}
	// 828CC3EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC3F0: 48000020  b 0x828cc410
	pc = 0x828CC410; continue 'dispatch;
	// 828CC3F4: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC3F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC3FC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC400: 409A000C  bne cr6, 0x828cc40c
	if !ctx.cr[6].eq {
	pc = 0x828CC40C; continue 'dispatch;
	}
	// 828CC404: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC408: 48000008  b 0x828cc410
	pc = 0x828CC410; continue 'dispatch;
	// 828CC40C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC410: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC414: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC418: 893A0028  lbz r9, 0x28(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC41C: 890B0028  lbz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC420: 992B0028  stb r9, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u8 ) };
	// 828CC424: 991A0028  stb r8, 0x28(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[8].u8 ) };
	// 828CC428: 897A0028  lbz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC42C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CC430: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828CC434: 409A0194  bne cr6, 0x828cc5c8
	if !ctx.cr[6].eq {
	pc = 0x828CC5C8; continue 'dispatch;
	}
	// 828CC438: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC43C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828CC440: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC444: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC448: 419A017C  beq cr6, 0x828cc5c4
	if ctx.cr[6].eq {
	pc = 0x828CC5C4; continue 'dispatch;
	}
	// 828CC44C: 897B0028  lbz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC450: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828CC454: 409A0170  bne cr6, 0x828cc5c4
	if !ctx.cr[6].eq {
	pc = 0x828CC5C4; continue 'dispatch;
	}
	// 828CC458: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC45C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CC460: 409A00A8  bne cr6, 0x828cc508
	if !ctx.cr[6].eq {
	pc = 0x828CC508; continue 'dispatch;
	}
	// 828CC464: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC468: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC46C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC470: 409A001C  bne cr6, 0x828cc48c
	if !ctx.cr[6].eq {
	pc = 0x828CC48C; continue 'dispatch;
	}
	// 828CC474: 9BAB0028  stb r29, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC478: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC47C: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 828CC480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC484: 480001A5  bl 0x828cc628
	ctx.lr = 0x828CC488;
	sub_828CC628(ctx, base);
	// 828CC488: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC48C: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC490: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC494: 409A00C8  bne cr6, 0x828cc55c
	if !ctx.cr[6].eq {
	pc = 0x828CC55C; continue 'dispatch;
	}
	// 828CC498: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC49C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC4A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC4A4: 409A0014  bne cr6, 0x828cc4b8
	if !ctx.cr[6].eq {
	pc = 0x828CC4B8; continue 'dispatch;
	}
	// 828CC4A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC4AC: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC4B0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC4B4: 419A00A4  beq cr6, 0x828cc558
	if ctx.cr[6].eq {
	pc = 0x828CC558; continue 'dispatch;
	}
	// 828CC4B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC4BC: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC4C0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC4C4: 409A0020  bne cr6, 0x828cc4e4
	if !ctx.cr[6].eq {
	pc = 0x828CC4E4; continue 'dispatch;
	}
	// 828CC4C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC4CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC4D0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828CC4D4: 9BAA0028  stb r29, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC4D8: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 828CC4DC: 480001CD  bl 0x828cc6a8
	ctx.lr = 0x828CC4E0;
	sub_828CC6A8(ctx, base);
	// 828CC4E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC4E4: 895F0028  lbz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC4E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC4EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC4F0: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 828CC4F4: 9BBF0028  stb r29, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC4F8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC4FC: 9BA90028  stb r29, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC500: 48000129  bl 0x828cc628
	ctx.lr = 0x828CC504;
	sub_828CC628(ctx, base);
	// 828CC504: 480000C0  b 0x828cc5c4
	pc = 0x828CC5C4; continue 'dispatch;
	// 828CC508: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC50C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC510: 409A001C  bne cr6, 0x828cc52c
	if !ctx.cr[6].eq {
	pc = 0x828CC52C; continue 'dispatch;
	}
	// 828CC514: 9BAB0028  stb r29, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC51C: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 828CC520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC524: 48000185  bl 0x828cc6a8
	ctx.lr = 0x828CC528;
	sub_828CC6A8(ctx, base);
	// 828CC528: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC52C: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC530: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC534: 409A0028  bne cr6, 0x828cc55c
	if !ctx.cr[6].eq {
	pc = 0x828CC55C; continue 'dispatch;
	}
	// 828CC538: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC53C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC540: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC544: 409A0034  bne cr6, 0x828cc578
	if !ctx.cr[6].eq {
	pc = 0x828CC578; continue 'dispatch;
	}
	// 828CC548: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC54C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC550: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC554: 409A0024  bne cr6, 0x828cc578
	if !ctx.cr[6].eq {
	pc = 0x828CC578; continue 'dispatch;
	}
	// 828CC558: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 828CC55C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC560: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828CC564: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC568: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC56C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC570: 409AFEDC  bne cr6, 0x828cc44c
	if !ctx.cr[6].eq {
	pc = 0x828CC44C; continue 'dispatch;
	}
	// 828CC574: 48000050  b 0x828cc5c4
	pc = 0x828CC5C4; continue 'dispatch;
	// 828CC578: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC57C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC580: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC584: 409A0020  bne cr6, 0x828cc5a4
	if !ctx.cr[6].eq {
	pc = 0x828CC5A4; continue 'dispatch;
	}
	// 828CC588: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC58C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC590: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828CC594: 9BAA0028  stb r29, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC598: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 828CC59C: 4800008D  bl 0x828cc628
	ctx.lr = 0x828CC5A0;
	sub_828CC628(ctx, base);
	// 828CC5A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC5A4: 895F0028  lbz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CC5A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC5AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC5B0: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 828CC5B4: 9BBF0028  stb r29, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC5B8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC5BC: 9BA90028  stb r29, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC5C0: 480000E9  bl 0x828cc6a8
	ctx.lr = 0x828CC5C4;
	sub_828CC6A8(ctx, base);
	// 828CC5C4: 9BBB0028  stb r29, 0x28(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[29].u8 ) };
	// 828CC5C8: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CC5CC: 3BFA0018  addi r31, r26, 0x18
	ctx.r[31].s64 = ctx.r[26].s64 + 24;
	// 828CC5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CC5D4: 419A0008  beq cr6, 0x828cc5dc
	if ctx.cr[6].eq {
	pc = 0x828CC5DC; continue 'dispatch;
	}
	// 828CC5D8: 4B94F761  bl 0x8221bd38
	ctx.lr = 0x828CC5DC;
	sub_8221BD38(ctx, base);
	// 828CC5DC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828CC5E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828CC5E4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828CC5E8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828CC5EC: 4B94F74D  bl 0x8221bd38
	ctx.lr = 0x828CC5F0;
	sub_8221BD38(ctx, base);
	// 828CC5F0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC5F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828CC5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC5FC: 419A001C  beq cr6, 0x828cc618
	if ctx.cr[6].eq {
	pc = 0x828CC618; continue 'dispatch;
	}
	// 828CC600: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828CC604: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CC608: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC60C: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828CC610: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828CC614: 483DCE38  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CC618: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828CC61C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CC620: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828CC624: 483DCE28  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC628 size=80
    let mut pc: u32 = 0x828CC628;
    'dispatch: loop {
        match pc {
            0x828CC628 => {
    //   block [0x828CC628..0x828CC678)
	// 828CC628: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC62C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC630: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC634: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC638: 892A0029  lbz r9, 0x29(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC63C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC640: 409A0008  bne cr6, 0x828cc648
	if !ctx.cr[6].eq {
	pc = 0x828CC648; continue 'dispatch;
	}
	// 828CC644: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CC648: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CC64C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC650: 390AC864  addi r8, r10, -0x379c
	ctx.r[8].s64 = ctx.r[10].s64 + -14236;
	// 828CC654: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CC658: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC65C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC660: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CC664: 409A0014  bne cr6, 0x828cc678
	if !ctx.cr[6].eq {
		sub_828CC678(ctx, base);
		return;
	}
	// 828CC668: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC66C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CC670: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC678 size=32
    let mut pc: u32 = 0x828CC678;
    'dispatch: loop {
        match pc {
            0x828CC678 => {
    //   block [0x828CC678..0x828CC698)
	// 828CC678: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC67C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC680: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC684: 409A0014  bne cr6, 0x828cc698
	if !ctx.cr[6].eq {
		sub_828CC698(ctx, base);
		return;
	}
	// 828CC688: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC68C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CC690: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC698 size=16
    let mut pc: u32 = 0x828CC698;
    'dispatch: loop {
        match pc {
            0x828CC698 => {
    //   block [0x828CC698..0x828CC6A8)
	// 828CC698: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC69C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CC6A0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC6A8 size=80
    let mut pc: u32 = 0x828CC6A8;
    'dispatch: loop {
        match pc {
            0x828CC6A8 => {
    //   block [0x828CC6A8..0x828CC6F8)
	// 828CC6A8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC6AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC6B0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CC6B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC6B8: 892A0029  lbz r9, 0x29(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(41 as u32) ) } as u64;
	// 828CC6BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC6C0: 409A0008  bne cr6, 0x828cc6c8
	if !ctx.cr[6].eq {
	pc = 0x828CC6C8; continue 'dispatch;
	}
	// 828CC6C4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CC6C8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CC6CC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC6D0: 390AC864  addi r8, r10, -0x379c
	ctx.r[8].s64 = ctx.r[10].s64 + -14236;
	// 828CC6D4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CC6D8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC6DC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC6E0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CC6E4: 409A0014  bne cr6, 0x828cc6f8
	if !ctx.cr[6].eq {
		sub_828CC6F8(ctx, base);
		return;
	}
	// 828CC6E8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC6EC: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CC6F0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC6F8 size=32
    let mut pc: u32 = 0x828CC6F8;
    'dispatch: loop {
        match pc {
            0x828CC6F8 => {
    //   block [0x828CC6F8..0x828CC718)
	// 828CC6F8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC6FC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC700: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC704: 409A0014  bne cr6, 0x828cc718
	if !ctx.cr[6].eq {
		sub_828CC718(ctx, base);
		return;
	}
	// 828CC708: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC70C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CC710: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC718 size=16
    let mut pc: u32 = 0x828CC718;
    'dispatch: loop {
        match pc {
            0x828CC718 => {
    //   block [0x828CC718..0x828CC728)
	// 828CC718: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC71C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CC720: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC728 size=1084
    let mut pc: u32 = 0x828CC728;
    'dispatch: loop {
        match pc {
            0x828CC728 => {
    //   block [0x828CC728..0x828CCB64)
	// 828CC728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC72C: 483DCCD1  bl 0x82ca93fc
	ctx.lr = 0x828CC730;
	sub_82CA93D0(ctx, base);
	// 828CC730: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC734: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 828CC738: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828CC73C: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828CC740: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC748: 419A0048  beq cr6, 0x828cc790
	if ctx.cr[6].eq {
	pc = 0x828CC790; continue 'dispatch;
	}
	// 828CC74C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828CC750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC754: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 828CC758: 4BA257E9  bl 0x822f1f40
	ctx.lr = 0x828CC75C;
	sub_822F1F40(ctx, base);
	// 828CC75C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CC760: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC764: 4BA2564D  bl 0x822f1db0
	ctx.lr = 0x828CC768;
	sub_822F1DB0(ctx, base);
	// 828CC768: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828CC76C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC770: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828CC774: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CC778: 4BA256A9  bl 0x822f1e20
	ctx.lr = 0x828CC77C;
	sub_822F1E20(ctx, base);
	// 828CC77C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CC780: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CC784: 4BDAF05D  bl 0x8267b7e0
	ctx.lr = 0x828CC788;
	sub_8267B7E0(ctx, base);
	// 828CC788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC78C: 4B8A5085  bl 0x82171810
	ctx.lr = 0x828CC790;
	sub_82171810(ctx, base);
	// 828CC790: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828CC794: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 828CC798: 4BA48391  bl 0x82314b28
	ctx.lr = 0x828CC79C;
	sub_82314B28(ctx, base);
	// 828CC79C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC7A0: 896A0021  lbz r11, 0x21(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC7A8: 419A000C  beq cr6, 0x828cc7b4
	if ctx.cr[6].eq {
	pc = 0x828CC7B4; continue 'dispatch;
	}
	// 828CC7AC: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC7B0: 4800002C  b 0x828cc7dc
	pc = 0x828CC7DC; continue 'dispatch;
	// 828CC7B4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC7B8: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC7BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC7C0: 419A000C  beq cr6, 0x828cc7cc
	if ctx.cr[6].eq {
	pc = 0x828CC7CC; continue 'dispatch;
	}
	// 828CC7C4: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 828CC7C8: 48000014  b 0x828cc7dc
	pc = 0x828CC7DC; continue 'dispatch;
	// 828CC7CC: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828CC7D0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC7D4: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC7D8: 409A00FC  bne cr6, 0x828cc8d4
	if !ctx.cr[6].eq {
	pc = 0x828CC8D4; continue 'dispatch;
	}
	// 828CC7DC: 897B0021  lbz r11, 0x21(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC7E0: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC7E8: 409A0008  bne cr6, 0x828cc7f0
	if !ctx.cr[6].eq {
	pc = 0x828CC7F0; continue 'dispatch;
	}
	// 828CC7EC: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828CC7F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828CC7F4: 3B8BC870  addi r28, r11, -0x3790
	ctx.r[28].s64 = ctx.r[11].s64 + -14224;
	// 828CC7F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC7FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC800: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC804: 409A000C  bne cr6, 0x828cc810
	if !ctx.cr[6].eq {
	pc = 0x828CC810; continue 'dispatch;
	}
	// 828CC808: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828CC80C: 4800001C  b 0x828cc828
	pc = 0x828CC828; continue 'dispatch;
	// 828CC810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC814: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC818: 409A000C  bne cr6, 0x828cc824
	if !ctx.cr[6].eq {
	pc = 0x828CC824; continue 'dispatch;
	}
	// 828CC81C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828CC820: 48000008  b 0x828cc828
	pc = 0x828CC828; continue 'dispatch;
	// 828CC824: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828CC828: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC82C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC830: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC834: 409A0048  bne cr6, 0x828cc87c
	if !ctx.cr[6].eq {
	pc = 0x828CC87C; continue 'dispatch;
	}
	// 828CC838: 897B0021  lbz r11, 0x21(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC840: 419A000C  beq cr6, 0x828cc84c
	if ctx.cr[6].eq {
	pc = 0x828CC84C; continue 'dispatch;
	}
	// 828CC844: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828CC848: 4800002C  b 0x828cc874
	pc = 0x828CC874; continue 'dispatch;
	// 828CC84C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC850: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828CC854: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC858: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC85C: 409A0018  bne cr6, 0x828cc874
	if !ctx.cr[6].eq {
	pc = 0x828CC874; continue 'dispatch;
	}
	// 828CC860: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CC864: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC868: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC86C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CC870: 419AFFF0  beq cr6, 0x828cc860
	if ctx.cr[6].eq {
	pc = 0x828CC860; continue 'dispatch;
	}
	// 828CC874: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC878: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CC87C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC880: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC884: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC888: 409A00E8  bne cr6, 0x828cc970
	if !ctx.cr[6].eq {
	pc = 0x828CC970; continue 'dispatch;
	}
	// 828CC88C: 897B0021  lbz r11, 0x21(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC894: 419A0010  beq cr6, 0x828cc8a4
	if ctx.cr[6].eq {
	pc = 0x828CC8A4; continue 'dispatch;
	}
	// 828CC898: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828CC89C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC8A0: 480000D0  b 0x828cc970
	pc = 0x828CC970; continue 'dispatch;
	// 828CC8A4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC8A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828CC8AC: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC8B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CC8B4: 409A0018  bne cr6, 0x828cc8cc
	if !ctx.cr[6].eq {
	pc = 0x828CC8CC; continue 'dispatch;
	}
	// 828CC8B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828CC8BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC8C0: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC8C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828CC8C8: 419AFFF0  beq cr6, 0x828cc8b8
	if ctx.cr[6].eq {
	pc = 0x828CC8B8; continue 'dispatch;
	}
	// 828CC8CC: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC8D0: 480000A0  b 0x828cc970
	pc = 0x828CC970; continue 'dispatch;
	// 828CC8D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC8D8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC8DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CC8E0: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC8E4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CC8E8: 409A000C  bne cr6, 0x828cc8f4
	if !ctx.cr[6].eq {
	pc = 0x828CC8F4; continue 'dispatch;
	}
	// 828CC8EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828CC8F0: 4800002C  b 0x828cc91c
	pc = 0x828CC91C; continue 'dispatch;
	// 828CC8F4: 895B0021  lbz r10, 0x21(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC8F8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC8FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC900: 409A0008  bne cr6, 0x828cc908
	if !ctx.cr[6].eq {
	pc = 0x828CC908; continue 'dispatch;
	}
	// 828CC904: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828CC908: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828CC90C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC910: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC914: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC918: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC91C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CC920: 3B8AC870  addi r28, r10, -0x3790
	ctx.r[28].s64 = ctx.r[10].s64 + -14224;
	// 828CC924: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC928: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC92C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC930: 409A000C  bne cr6, 0x828cc93c
	if !ctx.cr[6].eq {
	pc = 0x828CC93C; continue 'dispatch;
	}
	// 828CC934: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CC938: 48000020  b 0x828cc958
	pc = 0x828CC958; continue 'dispatch;
	// 828CC93C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC940: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC944: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828CC948: 409A000C  bne cr6, 0x828cc954
	if !ctx.cr[6].eq {
	pc = 0x828CC954; continue 'dispatch;
	}
	// 828CC94C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC950: 48000008  b 0x828cc958
	pc = 0x828CC958; continue 'dispatch;
	// 828CC954: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CC958: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC95C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC960: 893A0020  lbz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC964: 890B0020  lbz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC968: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 828CC96C: 991A0020  stb r8, 0x20(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[8].u8 ) };
	// 828CC970: 897A0020  lbz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC974: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828CC978: 409A0198  bne cr6, 0x828ccb10
	if !ctx.cr[6].eq {
	pc = 0x828CCB10; continue 'dispatch;
	}
	// 828CC97C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC980: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828CC984: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC988: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CC98C: 419A0180  beq cr6, 0x828ccb0c
	if ctx.cr[6].eq {
	pc = 0x828CCB0C; continue 'dispatch;
	}
	// 828CC990: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CC994: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC998: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828CC99C: 409A0170  bne cr6, 0x828ccb0c
	if !ctx.cr[6].eq {
	pc = 0x828CCB0C; continue 'dispatch;
	}
	// 828CC9A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC9A4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CC9A8: 409A00A8  bne cr6, 0x828cca50
	if !ctx.cr[6].eq {
	pc = 0x828CCA50; continue 'dispatch;
	}
	// 828CC9AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC9B0: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC9B8: 409A001C  bne cr6, 0x828cc9d4
	if !ctx.cr[6].eq {
	pc = 0x828CC9D4; continue 'dispatch;
	}
	// 828CC9BC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CC9C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CC9C4: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828CC9C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC9CC: 4800019D  bl 0x828ccb68
	ctx.lr = 0x828CC9D0;
	sub_828CCB68(ctx, base);
	// 828CC9D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC9D4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CC9D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CC9DC: 409A00C8  bne cr6, 0x828ccaa4
	if !ctx.cr[6].eq {
	pc = 0x828CCAA4; continue 'dispatch;
	}
	// 828CC9E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC9E4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC9E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC9EC: 409A0014  bne cr6, 0x828cca00
	if !ctx.cr[6].eq {
	pc = 0x828CCA00; continue 'dispatch;
	}
	// 828CC9F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CC9F4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC9F8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CC9FC: 419A00A4  beq cr6, 0x828ccaa0
	if ctx.cr[6].eq {
	pc = 0x828CCAA0; continue 'dispatch;
	}
	// 828CCA00: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCA04: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCA08: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CCA0C: 409A0020  bne cr6, 0x828cca2c
	if !ctx.cr[6].eq {
	pc = 0x828CCA2C; continue 'dispatch;
	}
	// 828CCA10: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCA14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCA18: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828CCA1C: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCA20: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828CCA24: 480001C5  bl 0x828ccbe8
	ctx.lr = 0x828CCA28;
	sub_828CCBE8(ctx, base);
	// 828CCA28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCA2C: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCA30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCA34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CCA38: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 828CCA3C: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCA40: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCA44: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCA48: 48000121  bl 0x828ccb68
	ctx.lr = 0x828CCA4C;
	sub_828CCB68(ctx, base);
	// 828CCA4C: 480000C0  b 0x828ccb0c
	pc = 0x828CCB0C; continue 'dispatch;
	// 828CCA50: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCA54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCA58: 409A001C  bne cr6, 0x828cca74
	if !ctx.cr[6].eq {
	pc = 0x828CCA74; continue 'dispatch;
	}
	// 828CCA5C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCA60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCA64: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828CCA68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CCA6C: 4800017D  bl 0x828ccbe8
	ctx.lr = 0x828CCA70;
	sub_828CCBE8(ctx, base);
	// 828CCA70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCA74: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CCA78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CCA7C: 409A0028  bne cr6, 0x828ccaa4
	if !ctx.cr[6].eq {
	pc = 0x828CCAA4; continue 'dispatch;
	}
	// 828CCA80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCA84: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCA88: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CCA8C: 409A0034  bne cr6, 0x828ccac0
	if !ctx.cr[6].eq {
	pc = 0x828CCAC0; continue 'dispatch;
	}
	// 828CCA90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCA94: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCA98: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CCA9C: 409A0024  bne cr6, 0x828ccac0
	if !ctx.cr[6].eq {
	pc = 0x828CCAC0; continue 'dispatch;
	}
	// 828CCAA0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828CCAA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCAA8: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828CCAAC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCAB0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCAB4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CCAB8: 409AFEDC  bne cr6, 0x828cc994
	if !ctx.cr[6].eq {
	pc = 0x828CC994; continue 'dispatch;
	}
	// 828CCABC: 48000050  b 0x828ccb0c
	pc = 0x828CCB0C; continue 'dispatch;
	// 828CCAC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCAC4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCAC8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828CCACC: 409A0020  bne cr6, 0x828ccaec
	if !ctx.cr[6].eq {
	pc = 0x828CCAEC; continue 'dispatch;
	}
	// 828CCAD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCAD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCAD8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828CCADC: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCAE0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828CCAE4: 48000085  bl 0x828ccb68
	ctx.lr = 0x828CCAE8;
	sub_828CCB68(ctx, base);
	// 828CCAE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCAEC: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CCAF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CCAF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CCAF8: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 828CCAFC: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCB00: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCB04: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCB08: 480000E1  bl 0x828ccbe8
	ctx.lr = 0x828CCB0C;
	sub_828CCBE8(ctx, base);
	// 828CCB0C: 9BBB0020  stb r29, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828CCB10: 3BFA0010  addi r31, r26, 0x10
	ctx.r[31].s64 = ctx.r[26].s64 + 16;
	// 828CCB14: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828CCB18: 4B8EB001  bl 0x821b7b18
	ctx.lr = 0x828CCB1C;
	sub_821B7B18(ctx, base);
	// 828CCB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCB20: 4B8EAFF9  bl 0x821b7b18
	ctx.lr = 0x828CCB24;
	sub_821B7B18(ctx, base);
	// 828CCB24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828CCB28: 4B94F211  bl 0x8221bd38
	ctx.lr = 0x828CCB2C;
	sub_8221BD38(ctx, base);
	// 828CCB2C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCB30: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828CCB34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CCB38: 419A001C  beq cr6, 0x828ccb54
	if ctx.cr[6].eq {
	pc = 0x828CCB54; continue 'dispatch;
	}
	// 828CCB3C: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828CCB40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828CCB44: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CCB48: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828CCB4C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828CCB50: 483DC8FC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 828CCB54: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 828CCB58: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CCB5C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828CCB60: 483DC8EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCB68 size=80
    let mut pc: u32 = 0x828CCB68;
    'dispatch: loop {
        match pc {
            0x828CCB68 => {
    //   block [0x828CCB68..0x828CCBB8)
	// 828CCB68: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCB6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCB70: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CCB74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCB78: 892A0021  lbz r9, 0x21(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CCB7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CCB80: 409A0008  bne cr6, 0x828ccb88
	if !ctx.cr[6].eq {
	pc = 0x828CCB88; continue 'dispatch;
	}
	// 828CCB84: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CCB88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CCB8C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCB90: 390AC870  addi r8, r10, -0x3790
	ctx.r[8].s64 = ctx.r[10].s64 + -14224;
	// 828CCB94: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CCB98: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCB9C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCBA0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CCBA4: 409A0014  bne cr6, 0x828ccbb8
	if !ctx.cr[6].eq {
		sub_828CCBB8(ctx, base);
		return;
	}
	// 828CCBA8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCBAC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CCBB0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCBB8 size=32
    let mut pc: u32 = 0x828CCBB8;
    'dispatch: loop {
        match pc {
            0x828CCBB8 => {
    //   block [0x828CCBB8..0x828CCBD8)
	// 828CCBB8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCBBC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCBC0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CCBC4: 409A0014  bne cr6, 0x828ccbd8
	if !ctx.cr[6].eq {
		sub_828CCBD8(ctx, base);
		return;
	}
	// 828CCBC8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CCBCC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CCBD0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCBD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCBD8 size=16
    let mut pc: u32 = 0x828CCBD8;
    'dispatch: loop {
        match pc {
            0x828CCBD8 => {
    //   block [0x828CCBD8..0x828CCBE8)
	// 828CCBD8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CCBDC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828CCBE0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCBE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCBE8 size=80
    let mut pc: u32 = 0x828CCBE8;
    'dispatch: loop {
        match pc {
            0x828CCBE8 => {
    //   block [0x828CCBE8..0x828CCC38)
	// 828CCBE8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCBEC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCBF0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CCBF4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCBF8: 892A0021  lbz r9, 0x21(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 828CCBFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CCC00: 409A0008  bne cr6, 0x828ccc08
	if !ctx.cr[6].eq {
	pc = 0x828CCC08; continue 'dispatch;
	}
	// 828CCC04: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828CCC08: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828CCC0C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCC10: 390AC870  addi r8, r10, -0x3790
	ctx.r[8].s64 = ctx.r[10].s64 + -14224;
	// 828CCC14: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CCC18: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCC1C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCC20: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828CCC24: 409A0014  bne cr6, 0x828ccc38
	if !ctx.cr[6].eq {
		sub_828CCC38(ctx, base);
		return;
	}
	// 828CCC28: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCC2C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CCC30: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCC34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCC38 size=32
    let mut pc: u32 = 0x828CCC38;
    'dispatch: loop {
        match pc {
            0x828CCC38 => {
    //   block [0x828CCC38..0x828CCC58)
	// 828CCC38: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCC3C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCC40: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828CCC44: 409A0014  bne cr6, 0x828ccc58
	if !ctx.cr[6].eq {
		sub_828CCC58(ctx, base);
		return;
	}
	// 828CCC48: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CCC4C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CCC50: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCC54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CCC58 size=16
    let mut pc: u32 = 0x828CCC58;
    'dispatch: loop {
        match pc {
            0x828CCC58 => {
    //   block [0x828CCC58..0x828CCC68)
	// 828CCC58: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CCC5C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828CCC60: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CCC64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


