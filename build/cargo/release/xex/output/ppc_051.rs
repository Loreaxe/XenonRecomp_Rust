pub fn sub_8259CB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CB88 size=380
    let mut pc: u32 = 0x8259CB88;
    'dispatch: loop {
        match pc {
            0x8259CB88 => {
    //   block [0x8259CB88..0x8259CD04)
	// 8259CB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CB90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CB94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8259CB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CB9C: 419A0018  beq cr6, 0x8259cbb4
	if ctx.cr[6].eq {
	pc = 0x8259CBB4; continue 'dispatch;
	}
	// 8259CBA0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259CBA4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8259CBA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259CBAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259CBB0: 409A0008  bne cr6, 0x8259cbb8
	if !ctx.cr[6].eq {
	pc = 0x8259CBB8; continue 'dispatch;
	}
	// 8259CBB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259CBB8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259CBBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259CBC0: 419A0134  beq cr6, 0x8259ccf4
	if ctx.cr[6].eq {
	pc = 0x8259CCF4; continue 'dispatch;
	}
	// 8259CBC4: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259CBC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259CBCC: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 8259CBD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8259CBD4: 419A00F8  beq cr6, 0x8259cccc
	if ctx.cr[6].eq {
	pc = 0x8259CCCC; continue 'dispatch;
	}
	// 8259CBD8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259CBDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259CBE0: 419A0024  beq cr6, 0x8259cc04
	if ctx.cr[6].eq {
	pc = 0x8259CC04; continue 'dispatch;
	}
	// 8259CBE4: 892A0002  lbz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 8259CBE8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259CBEC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8259CBF0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259CBF4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CBF8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259CBFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CC00: 480000D0  b 0x8259ccd0
	pc = 0x8259CCD0; continue 'dispatch;
	// 8259CC04: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259CC08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259CC0C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259CC10: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8259CC14: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259CC18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CC1C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259CC20: 40810054  ble 0x8259cc74
	if !ctx.cr[0].gt {
	pc = 0x8259CC74; continue 'dispatch;
	}
	// 8259CC24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259CC28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259CC2C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259CC30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CC34: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 8259CC38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259CC3C: 41980008  blt cr6, 0x8259cc44
	if ctx.cr[6].lt {
	pc = 0x8259CC44; continue 'dispatch;
	}
	// 8259CC40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259CC44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259CC48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259CC4C: 419A0014  beq cr6, 0x8259cc60
	if ctx.cr[6].eq {
	pc = 0x8259CC60; continue 'dispatch;
	}
	// 8259CC50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259CC54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259CC58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259CC5C: 4800000C  b 0x8259cc68
	pc = 0x8259CC68; continue 'dispatch;
	// 8259CC60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259CC64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259CC68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259CC6C: 4199FFB8  bgt cr6, 0x8259cc24
	if ctx.cr[6].gt {
	pc = 0x8259CC24; continue 'dispatch;
	}
	// 8259CC70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CC74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259CC78: 419A0040  beq cr6, 0x8259ccb8
	if ctx.cr[6].eq {
	pc = 0x8259CCB8; continue 'dispatch;
	}
	// 8259CC7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CC80: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259CC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CC88: 41990008  bgt cr6, 0x8259cc90
	if ctx.cr[6].gt {
	pc = 0x8259CC90; continue 'dispatch;
	}
	// 8259CC8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CC90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259CC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CC98: 409A0020  bne cr6, 0x8259ccb8
	if !ctx.cr[6].eq {
	pc = 0x8259CCB8; continue 'dispatch;
	}
	// 8259CC9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259CCA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259CCA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259CCA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CCAC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259CCB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CCB4: 4800001C  b 0x8259ccd0
	pc = 0x8259CCD0; continue 'dispatch;
	// 8259CCB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259CCBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CCC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259CCC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CCC8: 48000008  b 0x8259ccd0
	pc = 0x8259CCD0; continue 'dispatch;
	// 8259CCCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CCD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259CCD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CCD8: 419A001C  beq cr6, 0x8259ccf4
	if ctx.cr[6].eq {
	pc = 0x8259CCF4; continue 'dispatch;
	}
	// 8259CCDC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259CCE0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259CCE4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259CCE8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259CCEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259CCF0: 4E800421  bctrl
	ctx.lr = 0x8259CCF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259CCF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259CCF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CCFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CD00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CD08 size=376
    let mut pc: u32 = 0x8259CD08;
    'dispatch: loop {
        match pc {
            0x8259CD08 => {
    //   block [0x8259CD08..0x8259CE80)
	// 8259CD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CD0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CD10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CD14: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8259CD18: 419A0018  beq cr6, 0x8259cd30
	if ctx.cr[6].eq {
	pc = 0x8259CD30; continue 'dispatch;
	}
	// 8259CD1C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259CD20: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259CD24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259CD2C: 409A0008  bne cr6, 0x8259cd34
	if !ctx.cr[6].eq {
	pc = 0x8259CD34; continue 'dispatch;
	}
	// 8259CD30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CD34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259CD38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CD3C: 419A0130  beq cr6, 0x8259ce6c
	if ctx.cr[6].eq {
	pc = 0x8259CE6C; continue 'dispatch;
	}
	// 8259CD40: 81440024  lwz r10, 0x24(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259CD44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CD48: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8259CD4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259CD50: 419A00E8  beq cr6, 0x8259ce38
	if ctx.cr[6].eq {
	pc = 0x8259CE38; continue 'dispatch;
	}
	// 8259CD54: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259CD58: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259CD5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CD60: 419A001C  beq cr6, 0x8259cd7c
	if ctx.cr[6].eq {
	pc = 0x8259CD7C; continue 'dispatch;
	}
	// 8259CD64: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8259CD68: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8259CD6C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259CD70: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CD74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259CD78: 480000C4  b 0x8259ce3c
	pc = 0x8259CE3C; continue 'dispatch;
	// 8259CD7C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259CD80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CD84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CD88: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259CD8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259CD90: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259CD94: 40810054  ble 0x8259cde8
	if !ctx.cr[0].gt {
	pc = 0x8259CDE8; continue 'dispatch;
	}
	// 8259CD98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259CD9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259CDA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259CDA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CDA8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 8259CDAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259CDB0: 41980008  blt cr6, 0x8259cdb8
	if ctx.cr[6].lt {
	pc = 0x8259CDB8; continue 'dispatch;
	}
	// 8259CDB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259CDB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259CDBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259CDC0: 419A0014  beq cr6, 0x8259cdd4
	if ctx.cr[6].eq {
	pc = 0x8259CDD4; continue 'dispatch;
	}
	// 8259CDC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259CDC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259CDCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259CDD0: 4800000C  b 0x8259cddc
	pc = 0x8259CDDC; continue 'dispatch;
	// 8259CDD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259CDD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259CDDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259CDE0: 4199FFB8  bgt cr6, 0x8259cd98
	if ctx.cr[6].gt {
	pc = 0x8259CD98; continue 'dispatch;
	}
	// 8259CDE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259CDE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259CDEC: 419A003C  beq cr6, 0x8259ce28
	if ctx.cr[6].eq {
	pc = 0x8259CE28; continue 'dispatch;
	}
	// 8259CDF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CDF4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259CDF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259CDFC: 41990008  bgt cr6, 0x8259ce04
	if ctx.cr[6].gt {
	pc = 0x8259CE04; continue 'dispatch;
	}
	// 8259CE00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CE04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259CE08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259CE0C: 409A001C  bne cr6, 0x8259ce28
	if !ctx.cr[6].eq {
	pc = 0x8259CE28; continue 'dispatch;
	}
	// 8259CE10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259CE14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259CE18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259CE1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259CE20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CE24: 48000018  b 0x8259ce3c
	pc = 0x8259CE3C; continue 'dispatch;
	// 8259CE28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259CE2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259CE30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CE34: 48000008  b 0x8259ce3c
	pc = 0x8259CE3C; continue 'dispatch;
	// 8259CE38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259CE3C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259CE40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259CE44: 419A0028  beq cr6, 0x8259ce6c
	if ctx.cr[6].eq {
	pc = 0x8259CE6C; continue 'dispatch;
	}
	// 8259CE48: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259CE4C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259CE50: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259CE54: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259CE58: 4E800421  bctrl
	ctx.lr = 0x8259CE5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259CE5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259CE60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CE64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CE68: 4E800020  blr
	return;
	// 8259CE6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259CE70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259CE74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CE78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CE7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CE80 size=164
    let mut pc: u32 = 0x8259CE80;
    'dispatch: loop {
        match pc {
            0x8259CE80 => {
    //   block [0x8259CE80..0x8259CF24)
	// 8259CE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CE84: 4870C585  bl 0x82ca9408
	ctx.lr = 0x8259CE88;
	sub_82CA93D0(ctx, base);
	// 8259CE88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CE8C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 8259CE90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CE94: 4BC8B265  bl 0x822280f8
	ctx.lr = 0x8259CE98;
	sub_822280F8(ctx, base);
	// 8259CE98: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8259CE9C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 8259CEA0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8259CEA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259CEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259CEAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8259CEB0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8259CEB4: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8259CEB8: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259CEBC: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CEC0: 4BC8B239  bl 0x822280f8
	ctx.lr = 0x8259CEC4;
	sub_822280F8(ctx, base);
	// 8259CEC4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CEC8: 4BC8A699  bl 0x82227560
	ctx.lr = 0x8259CECC;
	sub_82227560(ctx, base);
	// 8259CECC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259CED0: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259CED4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259CED8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 8259CEDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CEE0: 4BD651A1  bl 0x82302080
	ctx.lr = 0x8259CEE4;
	sub_82302080(ctx, base);
	// 8259CEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259CEE8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8259CEEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CEF0: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8259CEF4: 4BD89795  bl 0x82326688
	ctx.lr = 0x8259CEF8;
	sub_82326688(ctx, base);
	// 8259CEF8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259CEFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259CF00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259CF04: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8259CF08: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 8259CF0C: 4E800421  bctrl
	ctx.lr = 0x8259CF10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259CF10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CF14: 4BC1AC05  bl 0x821b7b18
	ctx.lr = 0x8259CF18;
	sub_821B7B18(ctx, base);
	// 8259CF18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259CF1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8259CF20: 4870C538  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259CF28 size=8
    let mut pc: u32 = 0x8259CF28;
    'dispatch: loop {
        match pc {
            0x8259CF28 => {
    //   block [0x8259CF28..0x8259CF30)
	// 8259CF28: 3863FFAC  addi r3, r3, -0x54
	ctx.r[3].s64 = ctx.r[3].s64 + -84;
	// 8259CF2C: 4BFF9A84  b 0x825969b0
	sub_825969B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259CF30 size=16
    let mut pc: u32 = 0x8259CF30;
    'dispatch: loop {
        match pc {
            0x8259CF30 => {
    //   block [0x8259CF30..0x8259CF40)
	// 8259CF30: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259CF34: 816C009C  lwz r11, 0x9c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(156 as u32) ) } as u64;
	// 8259CF38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259CF3C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CF40 size=60
    let mut pc: u32 = 0x8259CF40;
    'dispatch: loop {
        match pc {
            0x8259CF40 => {
    //   block [0x8259CF40..0x8259CF7C)
	// 8259CF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CF4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CF50: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8259CF54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259CF58: 388B86DC  addi r4, r11, -0x7924
	ctx.r[4].s64 = ctx.r[11].s64 + -31012;
	// 8259CF5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259CF60: 4BC8FF71  bl 0x8222ced0
	ctx.lr = 0x8259CF64;
	sub_8222CED0(ctx, base);
	// 8259CF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259CF68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259CF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259CF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259CF74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259CF78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259CF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259CF80 size=492
    let mut pc: u32 = 0x8259CF80;
    'dispatch: loop {
        match pc {
            0x8259CF80 => {
    //   block [0x8259CF80..0x8259D16C)
	// 8259CF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259CF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259CF88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259CF8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259CF90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259CF94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259CF98: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259CF9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259CFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259CFA4: 388B4C48  addi r4, r11, 0x4c48
	ctx.r[4].s64 = ctx.r[11].s64 + 19528;
	// 8259CFA8: 4BD732E9  bl 0x82310290
	ctx.lr = 0x8259CFAC;
	sub_82310290(ctx, base);
	// 8259CFAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259CFB0: 987E0051  stb r3, 0x51(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 8259CFB4: 419A0090  beq cr6, 0x8259d044
	if ctx.cr[6].eq {
	pc = 0x8259D044; continue 'dispatch;
	}
	// 8259CFB8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8259CFBC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259CFC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259CFC4: 3BEB4C54  addi r31, r11, 0x4c54
	ctx.r[31].s64 = ctx.r[11].s64 + 19540;
	// 8259CFC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259CFCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259CFD0: 419A0028  beq cr6, 0x8259cff8
	if ctx.cr[6].eq {
	pc = 0x8259CFF8; continue 'dispatch;
	}
	// 8259CFD4: 4BC3D3DD  bl 0x821da3b0
	ctx.lr = 0x8259CFD8;
	sub_821DA3B0(ctx, base);
	// 8259CFD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259CFDC: 4BC1551D  bl 0x821b24f8
	ctx.lr = 0x8259CFE0;
	sub_821B24F8(ctx, base);
	// 8259CFE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259CFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259CFE8: 481E6431  bl 0x82783418
	ctx.lr = 0x8259CFEC;
	sub_82783418(ctx, base);
	// 8259CFEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259CFF0: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8259CFF4: 48000028  b 0x8259d01c
	pc = 0x8259D01C; continue 'dispatch;
	// 8259CFF8: 4BC3D3B9  bl 0x821da3b0
	ctx.lr = 0x8259CFFC;
	sub_821DA3B0(ctx, base);
	// 8259CFFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259D000: 38AB4C60  addi r5, r11, 0x4c60
	ctx.r[5].s64 = ctx.r[11].s64 + 19552;
	// 8259D004: 4BC154F5  bl 0x821b24f8
	ctx.lr = 0x8259D008;
	sub_821B24F8(ctx, base);
	// 8259D008: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D010: 481E6409  bl 0x82783418
	ctx.lr = 0x8259D014;
	sub_82783418(ctx, base);
	// 8259D014: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259D018: 915E0028  stw r10, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8259D01C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D020: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D024: 4BC3D38D  bl 0x821da3b0
	ctx.lr = 0x8259D028;
	sub_821DA3B0(ctx, base);
	// 8259D028: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259D02C: 4BC154CD  bl 0x821b24f8
	ctx.lr = 0x8259D030;
	sub_821B24F8(ctx, base);
	// 8259D030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D038: 481E63E1  bl 0x82783418
	ctx.lr = 0x8259D03C;
	sub_82783418(ctx, base);
	// 8259D03C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259D040: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8259D044: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D048: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259D04C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259D050: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 8259D054: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8259D058: 419A00D8  beq cr6, 0x8259d130
	if ctx.cr[6].eq {
	pc = 0x8259D130; continue 'dispatch;
	}
	// 8259D05C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259D060: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259D064: 419A001C  beq cr6, 0x8259d080
	if ctx.cr[6].eq {
	pc = 0x8259D080; continue 'dispatch;
	}
	// 8259D068: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 8259D06C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D070: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259D074: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259D078: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D07C: 480000B4  b 0x8259d130
	pc = 0x8259D130; continue 'dispatch;
	// 8259D080: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D084: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259D088: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259D08C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8259D090: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259D094: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D098: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D09C: 40810054  ble 0x8259d0f0
	if !ctx.cr[0].gt {
	pc = 0x8259D0F0; continue 'dispatch;
	}
	// 8259D0A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259D0A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259D0A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259D0AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D0B0: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 8259D0B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259D0B8: 41980008  blt cr6, 0x8259d0c0
	if ctx.cr[6].lt {
	pc = 0x8259D0C0; continue 'dispatch;
	}
	// 8259D0BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259D0C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259D0C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259D0C8: 419A0014  beq cr6, 0x8259d0dc
	if ctx.cr[6].eq {
	pc = 0x8259D0DC; continue 'dispatch;
	}
	// 8259D0CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259D0D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259D0D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259D0D8: 4800000C  b 0x8259d0e4
	pc = 0x8259D0E4; continue 'dispatch;
	// 8259D0DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259D0E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259D0E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D0E8: 4199FFB8  bgt cr6, 0x8259d0a0
	if ctx.cr[6].gt {
	pc = 0x8259D0A0; continue 'dispatch;
	}
	// 8259D0EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D0F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259D0F4: 419A0034  beq cr6, 0x8259d128
	if ctx.cr[6].eq {
	pc = 0x8259D128; continue 'dispatch;
	}
	// 8259D0F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D0FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8259D100: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D104: 41990008  bgt cr6, 0x8259d10c
	if ctx.cr[6].gt {
	pc = 0x8259D10C; continue 'dispatch;
	}
	// 8259D108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259D10C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D114: 409A0014  bne cr6, 0x8259d128
	if !ctx.cr[6].eq {
	pc = 0x8259D128; continue 'dispatch;
	}
	// 8259D118: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259D11C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8259D120: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259D124: 48000008  b 0x8259d12c
	pc = 0x8259D12C; continue 'dispatch;
	// 8259D128: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259D12C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D130: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 8259D134: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259D138: 386A000C  addi r3, r10, 0xc
	ctx.r[3].s64 = ctx.r[10].s64 + 12;
	// 8259D13C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259D140: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259D144: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8259D148: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 8259D14C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8259D150: 484FA219  bl 0x82a97368
	ctx.lr = 0x8259D154;
	sub_82A97368(ctx, base);
	// 8259D154: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259D158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D15C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D170 size=140
    let mut pc: u32 = 0x8259D170;
    'dispatch: loop {
        match pc {
            0x8259D170 => {
    //   block [0x8259D170..0x8259D1FC)
	// 8259D170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259D17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D184: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259D188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D18C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D190: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259D194: 388B4C6C  addi r4, r11, 0x4c6c
	ctx.r[4].s64 = ctx.r[11].s64 + 19564;
	// 8259D198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D19C: 4BC8FD35  bl 0x8222ced0
	ctx.lr = 0x8259D1A0;
	sub_8222CED0(ctx, base);
	// 8259D1A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D1A4: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 8259D1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D1AC: 4847FC9D  bl 0x82a1ce48
	ctx.lr = 0x8259D1B0;
	sub_82A1CE48(ctx, base);
	// 8259D1B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D1B4: 4BC77C25  bl 0x82214dd8
	ctx.lr = 0x8259D1B8;
	sub_82214DD8(ctx, base);
	// 8259D1B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8259D1BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259D1C0: 388A2EBC  addi r4, r10, 0x2ebc
	ctx.r[4].s64 = ctx.r[10].s64 + 11964;
	// 8259D1C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D1C8: 4BC8FD09  bl 0x8222ced0
	ctx.lr = 0x8259D1CC;
	sub_8222CED0(ctx, base);
	// 8259D1CC: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 8259D1D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259D1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D1D8: 4847FC71  bl 0x82a1ce48
	ctx.lr = 0x8259D1DC;
	sub_82A1CE48(ctx, base);
	// 8259D1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D1E0: 4BC77BF9  bl 0x82214dd8
	ctx.lr = 0x8259D1E4;
	sub_82214DD8(ctx, base);
	// 8259D1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D200 size=72
    let mut pc: u32 = 0x8259D200;
    'dispatch: loop {
        match pc {
            0x8259D200 => {
    //   block [0x8259D200..0x8259D248)
	// 8259D200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D20C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D210: 3BE3FFF4  addi r31, r3, -0xc
	ctx.r[31].s64 = ctx.r[3].s64 + -12;
	// 8259D214: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8259D218: 4BC510A1  bl 0x821ee2b8
	ctx.lr = 0x8259D21C;
	sub_821EE2B8(ctx, base);
	// 8259D21C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 8259D220: 4BC51099  bl 0x821ee2b8
	ctx.lr = 0x8259D224;
	sub_821EE2B8(ctx, base);
	// 8259D224: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8259D228: 4BC51091  bl 0x821ee2b8
	ctx.lr = 0x8259D22C;
	sub_821EE2B8(ctx, base);
	// 8259D22C: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 8259D230: 4BC51089  bl 0x821ee2b8
	ctx.lr = 0x8259D234;
	sub_821EE2B8(ctx, base);
	// 8259D234: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259D238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D240: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D248 size=124
    let mut pc: u32 = 0x8259D248;
    'dispatch: loop {
        match pc {
            0x8259D248 => {
    //   block [0x8259D248..0x8259D2C4)
	// 8259D248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259D254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D25C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D260: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259D264: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8259D268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D26C: 4BFE21BD  bl 0x8257f428
	ctx.lr = 0x8259D270;
	sub_8257F428(ctx, base);
	// 8259D270: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 8259D274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D278: 4BFE21B1  bl 0x8257f428
	ctx.lr = 0x8259D27C;
	sub_8257F428(ctx, base);
	// 8259D27C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259D280: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 8259D284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D288: 4099000C  ble cr6, 0x8259d294
	if !ctx.cr[6].gt {
	pc = 0x8259D294; continue 'dispatch;
	}
	// 8259D28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D290: 4BFE2199  bl 0x8257f428
	ctx.lr = 0x8259D294;
	sub_8257F428(ctx, base);
	// 8259D294: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8259D298: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 8259D29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D2A0: 4099000C  ble cr6, 0x8259d2ac
	if !ctx.cr[6].gt {
	pc = 0x8259D2AC; continue 'dispatch;
	}
	// 8259D2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259D2A8: 4BFE2181  bl 0x8257f428
	ctx.lr = 0x8259D2AC;
	sub_8257F428(ctx, base);
	// 8259D2AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D2B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259D2BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D2C8 size=184
    let mut pc: u32 = 0x8259D2C8;
    'dispatch: loop {
        match pc {
            0x8259D2C8 => {
    //   block [0x8259D2C8..0x8259D380)
	// 8259D2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D2CC: 4870C13D  bl 0x82ca9408
	ctx.lr = 0x8259D2D0;
	sub_82CA93D0(ctx, base);
	// 8259D2D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D2D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259D2D8: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 8259D2DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259D2E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259D2E4: 3BAA44B0  addi r29, r10, 0x44b0
	ctx.r[29].s64 = ctx.r[10].s64 + 17584;
	// 8259D2E8: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D2EC: 3BCB113C  addi r30, r11, 0x113c
	ctx.r[30].s64 = ctx.r[11].s64 + 4412;
	// 8259D2F0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8259D2F4: 419A001C  beq cr6, 0x8259d310
	if ctx.cr[6].eq {
	pc = 0x8259D310; continue 'dispatch;
	}
	// 8259D2F8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8259D2FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259D300: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259D304: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259D308: 4BC8D7C1  bl 0x8222aac8
	ctx.lr = 0x8259D30C;
	sub_8222AAC8(ctx, base);
	// 8259D30C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8259D310: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259D314: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8259D318: 419A001C  beq cr6, 0x8259d334
	if ctx.cr[6].eq {
	pc = 0x8259D334; continue 'dispatch;
	}
	// 8259D31C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8259D320: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259D324: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8259D328: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259D32C: 4BC8D79D  bl 0x8222aac8
	ctx.lr = 0x8259D330;
	sub_8222AAC8(ctx, base);
	// 8259D330: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8259D334: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259D338: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8259D33C: 419A001C  beq cr6, 0x8259d358
	if ctx.cr[6].eq {
	pc = 0x8259D358; continue 'dispatch;
	}
	// 8259D340: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8259D344: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259D348: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8259D34C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259D350: 4BC8D779  bl 0x8222aac8
	ctx.lr = 0x8259D354;
	sub_8222AAC8(ctx, base);
	// 8259D354: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8259D358: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8259D35C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8259D360: 419A0018  beq cr6, 0x8259d378
	if ctx.cr[6].eq {
	pc = 0x8259D378; continue 'dispatch;
	}
	// 8259D364: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 8259D368: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259D36C: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 8259D370: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8259D374: 4BC8D755  bl 0x8222aac8
	ctx.lr = 0x8259D378;
	sub_8222AAC8(ctx, base);
	// 8259D378: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259D37C: 4870C0DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D380 size=120
    let mut pc: u32 = 0x8259D380;
    'dispatch: loop {
        match pc {
            0x8259D380 => {
    //   block [0x8259D380..0x8259D3F8)
	// 8259D380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D38C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D390: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D39C: 419A001C  beq cr6, 0x8259d3b8
	if ctx.cr[6].eq {
	pc = 0x8259D3B8; continue 'dispatch;
	}
	// 8259D3A0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8259D3A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D3A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D3AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D3B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D3B4: 4E800020  blr
	return;
	// 8259D3B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259D3BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D3C0: 4BC3CFF1  bl 0x821da3b0
	ctx.lr = 0x8259D3C4;
	sub_821DA3B0(ctx, base);
	// 8259D3C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259D3C8: 38AB4C54  addi r5, r11, 0x4c54
	ctx.r[5].s64 = ctx.r[11].s64 + 19540;
	// 8259D3CC: 4BC1512D  bl 0x821b24f8
	ctx.lr = 0x8259D3D0;
	sub_821B24F8(ctx, base);
	// 8259D3D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D3D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D3D8: 481E6041  bl 0x82783418
	ctx.lr = 0x8259D3DC;
	sub_82783418(ctx, base);
	// 8259D3DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259D3E0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8259D3E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D3E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D3EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D3F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D3F8 size=136
    let mut pc: u32 = 0x8259D3F8;
    'dispatch: loop {
        match pc {
            0x8259D3F8 => {
    //   block [0x8259D3F8..0x8259D480)
	// 8259D3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D404: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D408: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D40C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D414: 419A002C  beq cr6, 0x8259d440
	if ctx.cr[6].eq {
	pc = 0x8259D440; continue 'dispatch;
	}
	// 8259D418: 895F0051  lbz r10, 0x51(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(81 as u32) ) } as u64;
	// 8259D41C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259D420: 419A0008  beq cr6, 0x8259d428
	if ctx.cr[6].eq {
	pc = 0x8259D428; continue 'dispatch;
	}
	// 8259D424: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8259D428: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8259D42C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D438: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D43C: 4E800020  blr
	return;
	// 8259D440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259D444: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259D448: 4BC3CF69  bl 0x821da3b0
	ctx.lr = 0x8259D44C;
	sub_821DA3B0(ctx, base);
	// 8259D44C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259D450: 38AB4C60  addi r5, r11, 0x4c60
	ctx.r[5].s64 = ctx.r[11].s64 + 19552;
	// 8259D454: 4BC150A5  bl 0x821b24f8
	ctx.lr = 0x8259D458;
	sub_821B24F8(ctx, base);
	// 8259D458: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259D460: 481E5FB9  bl 0x82783418
	ctx.lr = 0x8259D464;
	sub_82783418(ctx, base);
	// 8259D464: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259D468: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8259D46C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259D470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D480 size=512
    let mut pc: u32 = 0x8259D480;
    'dispatch: loop {
        match pc {
            0x8259D480 => {
    //   block [0x8259D480..0x8259D680)
	// 8259D480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D484: 4870BF89  bl 0x82ca940c
	ctx.lr = 0x8259D488;
	sub_82CA93D0(ctx, base);
	// 8259D488: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D48C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259D490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259D494: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D498: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 8259D49C: 419A01D0  beq cr6, 0x8259d66c
	if ctx.cr[6].eq {
	pc = 0x8259D66C; continue 'dispatch;
	}
	// 8259D4A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D4A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259D4A8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259D4AC: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8259D4B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259D4B4: 419A00E8  beq cr6, 0x8259d59c
	if ctx.cr[6].eq {
	pc = 0x8259D59C; continue 'dispatch;
	}
	// 8259D4B8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259D4BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259D4C0: 419A0020  beq cr6, 0x8259d4e0
	if ctx.cr[6].eq {
	pc = 0x8259D4E0; continue 'dispatch;
	}
	// 8259D4C4: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8259D4C8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D4CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259D4D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259D4D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D4D8: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D4DC: 480000C4  b 0x8259d5a0
	pc = 0x8259D5A0; continue 'dispatch;
	// 8259D4E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D4E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259D4E8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8259D4EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259D4F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D4F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D4F8: 40810054  ble 0x8259d54c
	if !ctx.cr[0].gt {
	pc = 0x8259D54C; continue 'dispatch;
	}
	// 8259D4FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259D500: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259D504: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259D508: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D50C: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8259D510: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259D514: 41980008  blt cr6, 0x8259d51c
	if ctx.cr[6].lt {
	pc = 0x8259D51C; continue 'dispatch;
	}
	// 8259D518: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8259D51C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259D520: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259D524: 419A0014  beq cr6, 0x8259d538
	if ctx.cr[6].eq {
	pc = 0x8259D538; continue 'dispatch;
	}
	// 8259D528: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259D52C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259D530: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259D534: 4800000C  b 0x8259d540
	pc = 0x8259D540; continue 'dispatch;
	// 8259D538: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259D53C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259D540: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D544: 4199FFB8  bgt cr6, 0x8259d4fc
	if ctx.cr[6].gt {
	pc = 0x8259D4FC; continue 'dispatch;
	}
	// 8259D548: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D54C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259D550: 419A003C  beq cr6, 0x8259d58c
	if ctx.cr[6].eq {
	pc = 0x8259D58C; continue 'dispatch;
	}
	// 8259D554: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D558: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8259D55C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D560: 41990008  bgt cr6, 0x8259d568
	if ctx.cr[6].gt {
	pc = 0x8259D568; continue 'dispatch;
	}
	// 8259D564: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259D568: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D570: 409A001C  bne cr6, 0x8259d58c
	if !ctx.cr[6].eq {
	pc = 0x8259D58C; continue 'dispatch;
	}
	// 8259D574: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259D578: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259D57C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D580: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D588: 48000018  b 0x8259d5a0
	pc = 0x8259D5A0; continue 'dispatch;
	// 8259D58C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259D590: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D594: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D598: 48000008  b 0x8259d5a0
	pc = 0x8259D5A0; continue 'dispatch;
	// 8259D59C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259D5A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D5A8: 419A00C4  beq cr6, 0x8259d66c
	if ctx.cr[6].eq {
	pc = 0x8259D66C; continue 'dispatch;
	}
	// 8259D5AC: 4BC99E7D  bl 0x82237428
	ctx.lr = 0x8259D5B0;
	sub_82237428(ctx, base);
	// 8259D5B0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8259D5B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D5B8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8259D5BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8259D5C0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8259D5C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D5C8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D5CC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259D5D0: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259D5D4: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259D5D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D680 size=512
    let mut pc: u32 = 0x8259D680;
    'dispatch: loop {
        match pc {
            0x8259D680 => {
    //   block [0x8259D680..0x8259D880)
	// 8259D680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D684: 4870BD89  bl 0x82ca940c
	ctx.lr = 0x8259D688;
	sub_82CA93D0(ctx, base);
	// 8259D688: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D68C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259D690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259D694: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259D698: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 8259D69C: 419A01D0  beq cr6, 0x8259d86c
	if ctx.cr[6].eq {
	pc = 0x8259D86C; continue 'dispatch;
	}
	// 8259D6A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D6A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259D6A8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259D6AC: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8259D6B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259D6B4: 419A00E8  beq cr6, 0x8259d79c
	if ctx.cr[6].eq {
	pc = 0x8259D79C; continue 'dispatch;
	}
	// 8259D6B8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259D6BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259D6C0: 419A0020  beq cr6, 0x8259d6e0
	if ctx.cr[6].eq {
	pc = 0x8259D6E0; continue 'dispatch;
	}
	// 8259D6C4: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8259D6C8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D6CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259D6D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259D6D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D6D8: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D6DC: 480000C4  b 0x8259d7a0
	pc = 0x8259D7A0; continue 'dispatch;
	// 8259D6E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D6E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259D6E8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8259D6EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259D6F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D6F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D6F8: 40810054  ble 0x8259d74c
	if !ctx.cr[0].gt {
	pc = 0x8259D74C; continue 'dispatch;
	}
	// 8259D6FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259D700: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259D704: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259D708: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D70C: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8259D710: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259D714: 41980008  blt cr6, 0x8259d71c
	if ctx.cr[6].lt {
	pc = 0x8259D71C; continue 'dispatch;
	}
	// 8259D718: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8259D71C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259D720: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259D724: 419A0014  beq cr6, 0x8259d738
	if ctx.cr[6].eq {
	pc = 0x8259D738; continue 'dispatch;
	}
	// 8259D728: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259D72C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259D730: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259D734: 4800000C  b 0x8259d740
	pc = 0x8259D740; continue 'dispatch;
	// 8259D738: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259D73C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259D740: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D744: 4199FFB8  bgt cr6, 0x8259d6fc
	if ctx.cr[6].gt {
	pc = 0x8259D6FC; continue 'dispatch;
	}
	// 8259D748: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D74C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259D750: 419A003C  beq cr6, 0x8259d78c
	if ctx.cr[6].eq {
	pc = 0x8259D78C; continue 'dispatch;
	}
	// 8259D754: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D758: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8259D75C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D760: 41990008  bgt cr6, 0x8259d768
	if ctx.cr[6].gt {
	pc = 0x8259D768; continue 'dispatch;
	}
	// 8259D764: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259D768: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D770: 409A001C  bne cr6, 0x8259d78c
	if !ctx.cr[6].eq {
	pc = 0x8259D78C; continue 'dispatch;
	}
	// 8259D774: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259D778: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259D77C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D780: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D788: 48000018  b 0x8259d7a0
	pc = 0x8259D7A0; continue 'dispatch;
	// 8259D78C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259D790: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D794: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D798: 48000008  b 0x8259d7a0
	pc = 0x8259D7A0; continue 'dispatch;
	// 8259D79C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259D7A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D7A8: 419A00C4  beq cr6, 0x8259d86c
	if ctx.cr[6].eq {
	pc = 0x8259D86C; continue 'dispatch;
	}
	// 8259D7AC: 4BC99C7D  bl 0x82237428
	ctx.lr = 0x8259D7B0;
	sub_82237428(ctx, base);
	// 8259D7B0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8259D7B4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259D7B8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8259D7BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8259D7C0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8259D7C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259D7C8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D7CC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259D7D0: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259D7D4: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259D7D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D880 size=108
    let mut pc: u32 = 0x8259D880;
    'dispatch: loop {
        match pc {
            0x8259D880 => {
    //   block [0x8259D880..0x8259D8EC)
	// 8259D880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D88C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259D894: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 8259D898: 895F0060  lbz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259D89C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8259D8A0: 419A0038  beq cr6, 0x8259d8d8
	if ctx.cr[6].eq {
	pc = 0x8259D8D8; continue 'dispatch;
	}
	// 8259D8A4: 989F0060  stb r4, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[4].u8 ) };
	// 8259D8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D8AC: 409A0024  bne cr6, 0x8259d8d0
	if !ctx.cr[6].eq {
	pc = 0x8259D8D0; continue 'dispatch;
	}
	// 8259D8B0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8259D8B4: 4BC50A05  bl 0x821ee2b8
	ctx.lr = 0x8259D8B8;
	sub_821EE2B8(ctx, base);
	// 8259D8B8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 8259D8BC: 4BC509FD  bl 0x821ee2b8
	ctx.lr = 0x8259D8C0;
	sub_821EE2B8(ctx, base);
	// 8259D8C0: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8259D8C4: 4BC509F5  bl 0x821ee2b8
	ctx.lr = 0x8259D8C8;
	sub_821EE2B8(ctx, base);
	// 8259D8C8: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 8259D8CC: 4BC509ED  bl 0x821ee2b8
	ctx.lr = 0x8259D8D0;
	sub_821EE2B8(ctx, base);
	// 8259D8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259D8D4: 4800001D  bl 0x8259d8f0
	ctx.lr = 0x8259D8D8;
	sub_8259D8F0(ctx, base);
	// 8259D8D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259D8DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259D8E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259D8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259D8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259D8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259D8F0 size=392
    let mut pc: u32 = 0x8259D8F0;
    'dispatch: loop {
        match pc {
            0x8259D8F0 => {
    //   block [0x8259D8F0..0x8259DA78)
	// 8259D8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259D8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259D8F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259D8FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259D900: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259D904: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259D908: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D90C: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259D910: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 8259D914: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259D918: 419A00EC  beq cr6, 0x8259da04
	if ctx.cr[6].eq {
	pc = 0x8259DA04; continue 'dispatch;
	}
	// 8259D91C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259D920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D924: 419A0020  beq cr6, 0x8259d944
	if ctx.cr[6].eq {
	pc = 0x8259D944; continue 'dispatch;
	}
	// 8259D928: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 8259D92C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D930: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259D934: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259D938: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259D93C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D940: 480000C8  b 0x8259da08
	pc = 0x8259DA08; continue 'dispatch;
	// 8259D944: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259D948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259D94C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259D950: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259D954: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259D958: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D95C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D960: 40810054  ble 0x8259d9b4
	if !ctx.cr[0].gt {
	pc = 0x8259D9B4; continue 'dispatch;
	}
	// 8259D964: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259D968: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259D96C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259D970: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D974: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 8259D978: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259D97C: 41980008  blt cr6, 0x8259d984
	if ctx.cr[6].lt {
	pc = 0x8259D984; continue 'dispatch;
	}
	// 8259D980: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259D984: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259D988: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259D98C: 419A0014  beq cr6, 0x8259d9a0
	if ctx.cr[6].eq {
	pc = 0x8259D9A0; continue 'dispatch;
	}
	// 8259D990: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259D994: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259D998: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259D99C: 4800000C  b 0x8259d9a8
	pc = 0x8259D9A8; continue 'dispatch;
	// 8259D9A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259D9A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259D9A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259D9AC: 4199FFB8  bgt cr6, 0x8259d964
	if ctx.cr[6].gt {
	pc = 0x8259D964; continue 'dispatch;
	}
	// 8259D9B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259D9B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259D9B8: 419A003C  beq cr6, 0x8259d9f4
	if ctx.cr[6].eq {
	pc = 0x8259D9F4; continue 'dispatch;
	}
	// 8259D9BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259D9C0: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 8259D9C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259D9C8: 41990008  bgt cr6, 0x8259d9d0
	if ctx.cr[6].gt {
	pc = 0x8259D9D0; continue 'dispatch;
	}
	// 8259D9CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259D9D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259D9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259D9D8: 409A001C  bne cr6, 0x8259d9f4
	if !ctx.cr[6].eq {
	pc = 0x8259D9F4; continue 'dispatch;
	}
	// 8259D9DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259D9E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259D9E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259D9E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259D9EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259D9F0: 48000018  b 0x8259da08
	pc = 0x8259DA08; continue 'dispatch;
	// 8259D9F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259D9F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259D9FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DA00: 48000008  b 0x8259da08
	pc = 0x8259DA08; continue 'dispatch;
	// 8259DA04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259DA08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259DA0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259DA10: 419A0054  beq cr6, 0x8259da64
	if ctx.cr[6].eq {
	pc = 0x8259DA64; continue 'dispatch;
	}
	// 8259DA14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259DA18: 4BC770E1  bl 0x82214af8
	ctx.lr = 0x8259DA1C;
	sub_82214AF8(ctx, base);
	// 8259DA1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8259DA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DA24: 419A0040  beq cr6, 0x8259da64
	if ctx.cr[6].eq {
	pc = 0x8259DA64; continue 'dispatch;
	}
	// 8259DA28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8259DA2C: 89440060  lbz r10, 0x60(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259DA30: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8259DA34: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8259DA38: 39096438  addi r8, r9, 0x6438
	ctx.r[8].s64 = ctx.r[9].s64 + 25656;
	// 8259DA3C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259DA40: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 8259DA44: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8259DA48: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259DA4C: 83E7008C  lwz r31, 0x8c(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259DA50: 4BC14941  bl 0x821b2390
	ctx.lr = 0x8259DA54;
	sub_821B2390(ctx, base);
	// 8259DA54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259DA58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259DA60: 4800EFD1  bl 0x825aca30
	ctx.lr = 0x8259DA64;
	sub_825ACA30(ctx, base);
	// 8259DA64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259DA68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259DA6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259DA70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259DA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259DA78 size=336
    let mut pc: u32 = 0x8259DA78;
    'dispatch: loop {
        match pc {
            0x8259DA78 => {
    //   block [0x8259DA78..0x8259DBC8)
	// 8259DA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DA7C: 4870B991  bl 0x82ca940c
	ctx.lr = 0x8259DA80;
	sub_82CA93D0(ctx, base);
	// 8259DA80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DA84: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259DA88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259DA8C: 3BAB4C80  addi r29, r11, 0x4c80
	ctx.r[29].s64 = ctx.r[11].s64 + 19584;
	// 8259DA90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DA98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259DA9C: 4BC8F435  bl 0x8222ced0
	ctx.lr = 0x8259DAA0;
	sub_8222CED0(ctx, base);
	// 8259DAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DAA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DAA8: 48000121  bl 0x8259dbc8
	ctx.lr = 0x8259DAAC;
	sub_8259DBC8(ctx, base);
	// 8259DAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DAB0: 4BC77329  bl 0x82214dd8
	ctx.lr = 0x8259DAB4;
	sub_82214DD8(ctx, base);
	// 8259DAB4: 3D40825A  lis r10, -0x7da6
	ctx.r[10].s64 = -2108030976;
	// 8259DAB8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8259DABC: 390AD480  addi r8, r10, -0x2b80
	ctx.r[8].s64 = ctx.r[10].s64 + -11136;
	// 8259DAC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259DAC4: 38894C88  addi r4, r9, 0x4c88
	ctx.r[4].s64 = ctx.r[9].s64 + 19592;
	// 8259DAC8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8259DACC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DAD0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8259DAD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DAD8: 4BC8F3F9  bl 0x8222ced0
	ctx.lr = 0x8259DADC;
	sub_8222CED0(ctx, base);
	// 8259DADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259DAE0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DAE8: 4BC8F3E9  bl 0x8222ced0
	ctx.lr = 0x8259DAEC;
	sub_8222CED0(ctx, base);
	// 8259DAEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DAF0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8259DAF4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8259DAF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DAFC: 48000315  bl 0x8259de10
	ctx.lr = 0x8259DB00;
	sub_8259DE10(ctx, base);
	// 8259DB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DB04: 4BC772D5  bl 0x82214dd8
	ctx.lr = 0x8259DB08;
	sub_82214DD8(ctx, base);
	// 8259DB08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DB0C: 4BC772CD  bl 0x82214dd8
	ctx.lr = 0x8259DB10;
	sub_82214DD8(ctx, base);
	// 8259DB10: 3CE0825A  lis r7, -0x7da6
	ctx.r[7].s64 = -2108030976;
	// 8259DB14: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 8259DB18: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8259DB1C: 3867D480  addi r3, r7, -0x2b80
	ctx.r[3].s64 = ctx.r[7].s64 + -11136;
	// 8259DB20: 38864C98  addi r4, r6, 0x4c98
	ctx.r[4].s64 = ctx.r[6].s64 + 19608;
	// 8259DB24: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8259DB28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DB30: 4BC8F3A1  bl 0x8222ced0
	ctx.lr = 0x8259DB34;
	sub_8222CED0(ctx, base);
	// 8259DB34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259DB38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DB3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DB40: 4BC8F391  bl 0x8222ced0
	ctx.lr = 0x8259DB44;
	sub_8222CED0(ctx, base);
	// 8259DB44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DB48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259DB4C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8259DB50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259DB54: 480002BD  bl 0x8259de10
	ctx.lr = 0x8259DB58;
	sub_8259DE10(ctx, base);
	// 8259DB58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DB5C: 4BC7727D  bl 0x82214dd8
	ctx.lr = 0x8259DB60;
	sub_82214DD8(ctx, base);
	// 8259DB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DB64: 4BC77275  bl 0x82214dd8
	ctx.lr = 0x8259DB68;
	sub_82214DD8(ctx, base);
	// 8259DB68: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259DB6C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8259DB70: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8259DB74: 392BD880  addi r9, r11, -0x2780
	ctx.r[9].s64 = ctx.r[11].s64 + -10112;
	// 8259DB78: 388A4CA8  addi r4, r10, 0x4ca8
	ctx.r[4].s64 = ctx.r[10].s64 + 19624;
	// 8259DB7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DB80: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8259DB84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DB88: 4BC8F349  bl 0x8222ced0
	ctx.lr = 0x8259DB8C;
	sub_8222CED0(ctx, base);
	// 8259DB8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259DB90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259DB94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DB98: 4BC8F339  bl 0x8222ced0
	ctx.lr = 0x8259DB9C;
	sub_8222CED0(ctx, base);
	// 8259DB9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259DBA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8259DBA4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8259DBA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DBAC: 48000475  bl 0x8259e020
	ctx.lr = 0x8259DBB0;
	sub_8259E020(ctx, base);
	// 8259DBB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8259DBB4: 4BC77225  bl 0x82214dd8
	ctx.lr = 0x8259DBB8;
	sub_82214DD8(ctx, base);
	// 8259DBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DBBC: 4BC7721D  bl 0x82214dd8
	ctx.lr = 0x8259DBC0;
	sub_82214DD8(ctx, base);
	// 8259DBC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259DBC4: 4870B898  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259DBC8 size=584
    let mut pc: u32 = 0x8259DBC8;
    'dispatch: loop {
        match pc {
            0x8259DBC8 => {
    //   block [0x8259DBC8..0x8259DE10)
	// 8259DBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DBCC: 4870B835  bl 0x82ca9400
	ctx.lr = 0x8259DBD0;
	sub_82CA93D0(ctx, base);
	// 8259DBD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DBD4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DBD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8259DBDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DBE0: 409A0010  bne cr6, 0x8259dbf0
	if !ctx.cr[6].eq {
	pc = 0x8259DBF0; continue 'dispatch;
	}
	// 8259DBE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8259DBE8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 8259DBEC: 48000008  b 0x8259dbf4
	pc = 0x8259DBF4; continue 'dispatch;
	// 8259DBF0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DBF4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DBF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DBFC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DC00: 4BE309C1  bl 0x823ce5c0
	ctx.lr = 0x8259DC04;
	sub_823CE5C0(ctx, base);
	// 8259DC04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259DC08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DC0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DC10: 4BE305F1  bl 0x823ce200
	ctx.lr = 0x8259DC14;
	sub_823CE200(ctx, base);
	// 8259DC14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DC18: 4BC19F01  bl 0x821b7b18
	ctx.lr = 0x8259DC1C;
	sub_821B7B18(ctx, base);
	// 8259DC1C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8259DC20: 4BC81639  bl 0x8221f258
	ctx.lr = 0x8259DC24;
	sub_8221F258(ctx, base);
	// 8259DC24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259DC28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259DC2C: 419A0040  beq cr6, 0x8259dc6c
	if ctx.cr[6].eq {
	pc = 0x8259DC6C; continue 'dispatch;
	}
	// 8259DC30: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8259DC34: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8259DC38: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 8259DC3C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259DC40: 4BC81619  bl 0x8221f258
	ctx.lr = 0x8259DC44;
	sub_8221F258(ctx, base);
	// 8259DC44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DC48: 419A0028  beq cr6, 0x8259dc70
	if ctx.cr[6].eq {
	pc = 0x8259DC70; continue 'dispatch;
	}
	// 8259DC4C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8259DC50: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8259DC54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259DC58: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8259DC5C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259DC60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259DC64: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8259DC68: 4800000C  b 0x8259dc74
	pc = 0x8259DC74; continue 'dispatch;
	// 8259DC6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259DC70: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8259DC74: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259DC78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259DC7C: 419A00FC  beq cr6, 0x8259dd78
	if ctx.cr[6].eq {
	pc = 0x8259DD78; continue 'dispatch;
	}
	// 8259DC80: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DC84: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8259DC88: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DC8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259DC90: 4BC8B479  bl 0x82229108
	ctx.lr = 0x8259DC94;
	sub_82229108(ctx, base);
	// 8259DC94: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259DC98: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259DC9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259DCA0: 3BCBE230  addi r30, r11, -0x1dd0
	ctx.r[30].s64 = ctx.r[11].s64 + -7632;
	// 8259DCA4: 4BC89BDD  bl 0x82227880
	ctx.lr = 0x8259DCA8;
	sub_82227880(ctx, base);
	// 8259DCA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259DCAC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 8259DCB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259DCB4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 8259DCB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259DCBC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8259DCC0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8259DCC4: 4BBFCDBD  bl 0x8219aa80
	ctx.lr = 0x8259DCC8;
	sub_8219AA80(ctx, base);
	// 8259DCC8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8259DCCC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8259DCD0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8259DCD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DCD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259DCDC: 4BE30745  bl 0x823ce420
	ctx.lr = 0x8259DCE0;
	sub_823CE420(ctx, base);
	// 8259DCE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8259DCE4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8259DCE8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259DCEC: 484869DD  bl 0x82a246c8
	ctx.lr = 0x8259DCF0;
	sub_82A246C8(ctx, base);
	// 8259DCF0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259DCF4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8259DCF8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8259DCFC: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8259DD00: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DD04: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DD0C: 4BC8B3FD  bl 0x82229108
	ctx.lr = 0x8259DD10;
	sub_82229108(ctx, base);
	// 8259DD10: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8259DD14: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259DD18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DD1C: 3BEBB838  addi r31, r11, -0x47c8
	ctx.r[31].s64 = ctx.r[11].s64 + -18376;
	// 8259DD20: 4BC89B61  bl 0x82227880
	ctx.lr = 0x8259DD24;
	sub_82227880(ctx, base);
	// 8259DD24: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8259DD28: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 8259DD2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259DD30: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8259DD34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DD38: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8259DD3C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8259DD40: 4BBFCD41  bl 0x8219aa80
	ctx.lr = 0x8259DD44;
	sub_8219AA80(ctx, base);
	// 8259DD44: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 8259DD48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259DD4C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 8259DD50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DD54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DD58: 4BE306C9  bl 0x823ce420
	ctx.lr = 0x8259DD5C;
	sub_823CE420(ctx, base);
	// 8259DD5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DD60: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8259DD64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259DD68: 48486961  bl 0x82a246c8
	ctx.lr = 0x8259DD6C;
	sub_82A246C8(ctx, base);
	// 8259DD6C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259DD70: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8259DD74: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 8259DD78: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8259DD7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8259DD80: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8259DD84: 419A0020  beq cr6, 0x8259dda4
	if ctx.cr[6].eq {
	pc = 0x8259DDA4; continue 'dispatch;
	}
	// 8259DD88: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259DD8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DD90: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259DD94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8259DD98: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DD9C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DDA0: 4082FFE8  bne 0x8259dd88
	if !ctx.cr[0].eq {
	pc = 0x8259DD88; continue 'dispatch;
	}
	// 8259DDA4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DDA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259DDAC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8259DDB0: 4BD57B99  bl 0x822f5948
	ctx.lr = 0x8259DDB4;
	sub_822F5948(ctx, base);
	// 8259DDB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259DDB8: 4BC19D61  bl 0x821b7b18
	ctx.lr = 0x8259DDBC;
	sub_821B7B18(ctx, base);
	// 8259DDBC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8259DDC0: 419A0040  beq cr6, 0x8259de00
	if ctx.cr[6].eq {
	pc = 0x8259DE00; continue 'dispatch;
	}
	// 8259DDC4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259DDC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DDCC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259DDD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259DDD4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DDD8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DDDC: 4082FFE8  bne 0x8259ddc4
	if !ctx.cr[0].eq {
	pc = 0x8259DDC4; continue 'dispatch;
	}
	// 8259DDE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259DDE4: 409A001C  bne cr6, 0x8259de00
	if !ctx.cr[6].eq {
	pc = 0x8259DE00; continue 'dispatch;
	}
	// 8259DDE8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259DDEC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DDF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259DDF4: 4E800421  bctrl
	ctx.lr = 0x8259DDF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259DDF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259DDFC: 4BC7DF3D  bl 0x8221bd38
	ctx.lr = 0x8259DE00;
	sub_8221BD38(ctx, base);
	// 8259DE00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DE04: 4BC19D15  bl 0x821b7b18
	ctx.lr = 0x8259DE08;
	sub_821B7B18(ctx, base);
	// 8259DE08: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259DE0C: 4870B644  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259DE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259DE10 size=528
    let mut pc: u32 = 0x8259DE10;
    'dispatch: loop {
        match pc {
            0x8259DE10 => {
    //   block [0x8259DE10..0x8259E020)
	// 8259DE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259DE14: 4870B5E9  bl 0x82ca93fc
	ctx.lr = 0x8259DE18;
	sub_82CA93D0(ctx, base);
	// 8259DE18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259DE1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259DE20: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8259DE24: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8259DE28: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8259DE2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8259DE30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DE34: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8259DE38: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8259DE3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DE40: 419A0008  beq cr6, 0x8259de48
	if ctx.cr[6].eq {
	pc = 0x8259DE48; continue 'dispatch;
	}
	// 8259DE44: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DE48: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DE4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DE50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DE54: 4BE3076D  bl 0x823ce5c0
	ctx.lr = 0x8259DE58;
	sub_823CE5C0(ctx, base);
	// 8259DE58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259DE5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259DE60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DE64: 4BE302AD  bl 0x823ce110
	ctx.lr = 0x8259DE68;
	sub_823CE110(ctx, base);
	// 8259DE68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259DE6C: 4BC19CAD  bl 0x821b7b18
	ctx.lr = 0x8259DE70;
	sub_821B7B18(ctx, base);
	// 8259DE70: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8259DE74: 4BC813E5  bl 0x8221f258
	ctx.lr = 0x8259DE78;
	sub_8221F258(ctx, base);
	// 8259DE78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259DE7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259DE80: 419A006C  beq cr6, 0x8259deec
	if ctx.cr[6].eq {
	pc = 0x8259DEEC; continue 'dispatch;
	}
	// 8259DE84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8259DE88: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 8259DE8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259DE90: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259DE94: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 8259DE98: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259DE9C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8259DEA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259DEA4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259DEA8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8259DEAC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8259DEB0: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 8259DEB4: 4BC5238D  bl 0x821f0240
	ctx.lr = 0x8259DEB8;
	sub_821F0240(ctx, base);
	// 8259DEB8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8259DEBC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8259DEC0: 4BC81399  bl 0x8221f258
	ctx.lr = 0x8259DEC4;
	sub_8221F258(ctx, base);
	// 8259DEC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259DEC8: 419A0028  beq cr6, 0x8259def0
	if ctx.cr[6].eq {
	pc = 0x8259DEF0; continue 'dispatch;
	}
	// 8259DECC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8259DED0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8259DED4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259DED8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8259DEDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259DEE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259DEE4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8259DEE8: 4800000C  b 0x8259def4
	pc = 0x8259DEF4; continue 'dispatch;
	// 8259DEEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8259DEF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259DEF4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DEF8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8259DEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DF00: 419A0008  beq cr6, 0x8259df08
	if ctx.cr[6].eq {
	pc = 0x8259DF08; continue 'dispatch;
	}
	// 8259DF04: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DF08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259DF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259DF10: 419A0078  beq cr6, 0x8259df88
	if ctx.cr[6].eq {
	pc = 0x8259DF88; continue 'dispatch;
	}
	// 8259DF14: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259DF18: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8259DF1C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DF20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259DF24: 4BC8B1E5  bl 0x82229108
	ctx.lr = 0x8259DF28;
	sub_82229108(ctx, base);
	// 8259DF28: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259DF2C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259DF30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259DF34: 3BCBE270  addi r30, r11, -0x1d90
	ctx.r[30].s64 = ctx.r[11].s64 + -7568;
	// 8259DF38: 4BC89949  bl 0x82227880
	ctx.lr = 0x8259DF3C;
	sub_82227880(ctx, base);
	// 8259DF3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259DF40: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 8259DF44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259DF48: 388ADBF8  addi r4, r10, -0x2408
	ctx.r[4].s64 = ctx.r[10].s64 + -9224;
	// 8259DF4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259DF50: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8259DF54: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8259DF58: 4BBFCB29  bl 0x8219aa80
	ctx.lr = 0x8259DF5C;
	sub_8219AA80(ctx, base);
	// 8259DF5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8259DF64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259DF68: 4BE304B9  bl 0x823ce420
	ctx.lr = 0x8259DF6C;
	sub_823CE420(ctx, base);
	// 8259DF6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259DF70: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8259DF74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259DF78: 48486751  bl 0x82a246c8
	ctx.lr = 0x8259DF7C;
	sub_82A246C8(ctx, base);
	// 8259DF7C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259DF80: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8259DF84: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8259DF88: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8259DF8C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259DF90: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8259DF94: 419A0020  beq cr6, 0x8259dfb4
	if ctx.cr[6].eq {
	pc = 0x8259DFB4; continue 'dispatch;
	}
	// 8259DF98: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259DF9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DFA0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259DFA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8259DFA8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DFAC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DFB0: 4082FFE8  bne 0x8259df98
	if !ctx.cr[0].eq {
	pc = 0x8259DF98; continue 'dispatch;
	}
	// 8259DFB4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259DFB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259DFBC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8259DFC0: 4BD57989  bl 0x822f5948
	ctx.lr = 0x8259DFC4;
	sub_822F5948(ctx, base);
	// 8259DFC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259DFC8: 4BC19B51  bl 0x821b7b18
	ctx.lr = 0x8259DFCC;
	sub_821B7B18(ctx, base);
	// 8259DFCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259DFD0: 419A0040  beq cr6, 0x8259e010
	if ctx.cr[6].eq {
	pc = 0x8259E010; continue 'dispatch;
	}
	// 8259DFD4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259DFD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DFDC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259DFE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259DFE4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259DFE8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259DFEC: 4082FFE8  bne 0x8259dfd4
	if !ctx.cr[0].eq {
	pc = 0x8259DFD4; continue 'dispatch;
	}
	// 8259DFF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259DFF4: 409A001C  bne cr6, 0x8259e010
	if !ctx.cr[6].eq {
	pc = 0x8259E010; continue 'dispatch;
	}
	// 8259DFF8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259DFFC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259E004: 4E800421  bctrl
	ctx.lr = 0x8259E008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259E008: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259E00C: 4BC7DD2D  bl 0x8221bd38
	ctx.lr = 0x8259E010;
	sub_8221BD38(ctx, base);
	// 8259E010: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E014: 4BC19B05  bl 0x821b7b18
	ctx.lr = 0x8259E018;
	sub_821B7B18(ctx, base);
	// 8259E018: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8259E01C: 4870B430  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E020 size=528
    let mut pc: u32 = 0x8259E020;
    'dispatch: loop {
        match pc {
            0x8259E020 => {
    //   block [0x8259E020..0x8259E230)
	// 8259E020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E024: 4870B3D9  bl 0x82ca93fc
	ctx.lr = 0x8259E028;
	sub_82CA93D0(ctx, base);
	// 8259E028: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E02C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259E030: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8259E034: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8259E038: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8259E03C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8259E040: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E044: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8259E048: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8259E04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E050: 419A0008  beq cr6, 0x8259e058
	if ctx.cr[6].eq {
	pc = 0x8259E058; continue 'dispatch;
	}
	// 8259E054: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E058: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E05C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259E060: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E064: 4BE3055D  bl 0x823ce5c0
	ctx.lr = 0x8259E068;
	sub_823CE5C0(ctx, base);
	// 8259E068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259E06C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E070: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E074: 4BE3009D  bl 0x823ce110
	ctx.lr = 0x8259E078;
	sub_823CE110(ctx, base);
	// 8259E078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259E07C: 4BC19A9D  bl 0x821b7b18
	ctx.lr = 0x8259E080;
	sub_821B7B18(ctx, base);
	// 8259E080: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8259E084: 4BC811D5  bl 0x8221f258
	ctx.lr = 0x8259E088;
	sub_8221F258(ctx, base);
	// 8259E088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E08C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259E090: 419A006C  beq cr6, 0x8259e0fc
	if ctx.cr[6].eq {
	pc = 0x8259E0FC; continue 'dispatch;
	}
	// 8259E094: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8259E098: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 8259E09C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259E0A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259E0A4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 8259E0A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259E0AC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8259E0B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259E0B4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259E0B8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8259E0BC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8259E0C0: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 8259E0C4: 4BC5217D  bl 0x821f0240
	ctx.lr = 0x8259E0C8;
	sub_821F0240(ctx, base);
	// 8259E0C8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8259E0CC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8259E0D0: 4BC81189  bl 0x8221f258
	ctx.lr = 0x8259E0D4;
	sub_8221F258(ctx, base);
	// 8259E0D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E0D8: 419A0028  beq cr6, 0x8259e100
	if ctx.cr[6].eq {
	pc = 0x8259E100; continue 'dispatch;
	}
	// 8259E0DC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8259E0E0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8259E0E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259E0E8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8259E0EC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259E0F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259E0F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8259E0F8: 4800000C  b 0x8259e104
	pc = 0x8259E104; continue 'dispatch;
	// 8259E0FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8259E100: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259E104: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E108: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8259E10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E110: 419A0008  beq cr6, 0x8259e118
	if ctx.cr[6].eq {
	pc = 0x8259E118; continue 'dispatch;
	}
	// 8259E114: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E118: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259E11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E120: 419A0078  beq cr6, 0x8259e198
	if ctx.cr[6].eq {
	pc = 0x8259E198; continue 'dispatch;
	}
	// 8259E124: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E128: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8259E12C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E130: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259E134: 4BC8AFD5  bl 0x82229108
	ctx.lr = 0x8259E138;
	sub_82229108(ctx, base);
	// 8259E138: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 8259E13C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8259E140: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259E144: 3BCBE3F8  addi r30, r11, -0x1c08
	ctx.r[30].s64 = ctx.r[11].s64 + -7176;
	// 8259E148: 4BC89739  bl 0x82227880
	ctx.lr = 0x8259E14C;
	sub_82227880(ctx, base);
	// 8259E14C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259E150: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 8259E154: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259E158: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 8259E15C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259E160: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8259E164: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8259E168: 4BBFC919  bl 0x8219aa80
	ctx.lr = 0x8259E16C;
	sub_8219AA80(ctx, base);
	// 8259E16C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E170: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8259E174: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E178: 4BE302A9  bl 0x823ce420
	ctx.lr = 0x8259E17C;
	sub_823CE420(ctx, base);
	// 8259E17C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8259E180: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8259E184: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259E188: 48486541  bl 0x82a246c8
	ctx.lr = 0x8259E18C;
	sub_82A246C8(ctx, base);
	// 8259E18C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259E190: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8259E194: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8259E198: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8259E19C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259E1A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8259E1A4: 419A0020  beq cr6, 0x8259e1c4
	if ctx.cr[6].eq {
	pc = 0x8259E1C4; continue 'dispatch;
	}
	// 8259E1A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259E1AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E1B0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259E1B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8259E1B8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259E1BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E1C0: 4082FFE8  bne 0x8259e1a8
	if !ctx.cr[0].eq {
	pc = 0x8259E1A8; continue 'dispatch;
	}
	// 8259E1C4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E1C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259E1CC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8259E1D0: 4BD57779  bl 0x822f5948
	ctx.lr = 0x8259E1D4;
	sub_822F5948(ctx, base);
	// 8259E1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E1D8: 4BC19941  bl 0x821b7b18
	ctx.lr = 0x8259E1DC;
	sub_821B7B18(ctx, base);
	// 8259E1DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259E1E0: 419A0040  beq cr6, 0x8259e220
	if ctx.cr[6].eq {
	pc = 0x8259E220; continue 'dispatch;
	}
	// 8259E1E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8259E1E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E1EC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8259E1F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259E1F4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8259E1F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8259E1FC: 4082FFE8  bne 0x8259e1e4
	if !ctx.cr[0].eq {
	pc = 0x8259E1E4; continue 'dispatch;
	}
	// 8259E200: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E204: 409A001C  bne cr6, 0x8259e220
	if !ctx.cr[6].eq {
	pc = 0x8259E220; continue 'dispatch;
	}
	// 8259E208: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259E20C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8259E214: 4E800421  bctrl
	ctx.lr = 0x8259E218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259E218: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259E21C: 4BC7DB1D  bl 0x8221bd38
	ctx.lr = 0x8259E220;
	sub_8221BD38(ctx, base);
	// 8259E220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E224: 4BC198F5  bl 0x821b7b18
	ctx.lr = 0x8259E228;
	sub_821B7B18(ctx, base);
	// 8259E228: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8259E22C: 4870B220  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E230 size=56
    let mut pc: u32 = 0x8259E230;
    'dispatch: loop {
        match pc {
            0x8259E230 => {
    //   block [0x8259E230..0x8259E268)
	// 8259E230: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8259E234: 419A0018  beq cr6, 0x8259e24c
	if ctx.cr[6].eq {
	pc = 0x8259E24C; continue 'dispatch;
	}
	// 8259E238: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259E23C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259E240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E248: 409A0008  bne cr6, 0x8259e250
	if !ctx.cr[6].eq {
	pc = 0x8259E250; continue 'dispatch;
	}
	// 8259E24C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E250: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E258: 419A0010  beq cr6, 0x8259e268
	if ctx.cr[6].eq {
		sub_8259E268(ctx, base);
		return;
	}
	// 8259E25C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259E260: 5563CFFE  rlwinm r3, r11, 0x19, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8259E264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259E268 size=8
    let mut pc: u32 = 0x8259E268;
    'dispatch: loop {
        match pc {
            0x8259E268 => {
    //   block [0x8259E268..0x8259E270)
	// 8259E268: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8259E26C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E270 size=392
    let mut pc: u32 = 0x8259E270;
    'dispatch: loop {
        match pc {
            0x8259E270 => {
    //   block [0x8259E270..0x8259E3F8)
	// 8259E270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E27C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E284: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8259E288: 419A0018  beq cr6, 0x8259e2a0
	if ctx.cr[6].eq {
	pc = 0x8259E2A0; continue 'dispatch;
	}
	// 8259E28C: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259E290: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259E294: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E298: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E29C: 409A0008  bne cr6, 0x8259e2a4
	if !ctx.cr[6].eq {
	pc = 0x8259E2A4; continue 'dispatch;
	}
	// 8259E2A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E2A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E2AC: 419A0134  beq cr6, 0x8259e3e0
	if ctx.cr[6].eq {
	pc = 0x8259E3E0; continue 'dispatch;
	}
	// 8259E2B0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259E2B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E2B8: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8259E2BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259E2C0: 419A00EC  beq cr6, 0x8259e3ac
	if ctx.cr[6].eq {
	pc = 0x8259E3AC; continue 'dispatch;
	}
	// 8259E2C4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259E2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E2CC: 419A0020  beq cr6, 0x8259e2ec
	if ctx.cr[6].eq {
	pc = 0x8259E2EC; continue 'dispatch;
	}
	// 8259E2D0: 894B0007  lbz r10, 7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 8259E2D4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259E2D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259E2DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259E2E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259E2E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E2E8: 480000C8  b 0x8259e3b0
	pc = 0x8259E3B0; continue 'dispatch;
	// 8259E2EC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259E2F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E2F4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259E2F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8259E2FC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259E300: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259E304: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E308: 40810054  ble 0x8259e35c
	if !ctx.cr[0].gt {
	pc = 0x8259E35C; continue 'dispatch;
	}
	// 8259E30C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259E310: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259E314: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259E318: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E31C: 2F070007  cmpwi cr6, r7, 7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 7, &mut ctx.xer);
	// 8259E320: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259E324: 41980008  blt cr6, 0x8259e32c
	if ctx.cr[6].lt {
	pc = 0x8259E32C; continue 'dispatch;
	}
	// 8259E328: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259E32C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259E330: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259E334: 419A0014  beq cr6, 0x8259e348
	if ctx.cr[6].eq {
	pc = 0x8259E348; continue 'dispatch;
	}
	// 8259E338: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259E33C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259E340: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259E344: 4800000C  b 0x8259e350
	pc = 0x8259E350; continue 'dispatch;
	// 8259E348: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259E34C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259E350: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E354: 4199FFB8  bgt cr6, 0x8259e30c
	if ctx.cr[6].gt {
	pc = 0x8259E30C; continue 'dispatch;
	}
	// 8259E358: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259E35C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259E360: 419A003C  beq cr6, 0x8259e39c
	if ctx.cr[6].eq {
	pc = 0x8259E39C; continue 'dispatch;
	}
	// 8259E364: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E368: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8259E36C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E370: 41990008  bgt cr6, 0x8259e378
	if ctx.cr[6].gt {
	pc = 0x8259E378; continue 'dispatch;
	}
	// 8259E374: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E378: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E380: 409A001C  bne cr6, 0x8259e39c
	if !ctx.cr[6].eq {
	pc = 0x8259E39C; continue 'dispatch;
	}
	// 8259E384: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259E388: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259E38C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259E390: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E398: 48000018  b 0x8259e3b0
	pc = 0x8259E3B0; continue 'dispatch;
	// 8259E39C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259E3A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259E3A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E3A8: 48000008  b 0x8259e3b0
	pc = 0x8259E3B0; continue 'dispatch;
	// 8259E3AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259E3B0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259E3B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E3B8: 419A0028  beq cr6, 0x8259e3e0
	if ctx.cr[6].eq {
	pc = 0x8259E3E0; continue 'dispatch;
	}
	// 8259E3BC: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259E3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E3C4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259E3C8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259E3CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259E3D0: 4E800421  bctrl
	ctx.lr = 0x8259E3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259E3D4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E3F8 size=380
    let mut pc: u32 = 0x8259E3F8;
    'dispatch: loop {
        match pc {
            0x8259E3F8 => {
    //   block [0x8259E3F8..0x8259E574)
	// 8259E3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E400: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E404: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8259E408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E40C: 419A0018  beq cr6, 0x8259e424
	if ctx.cr[6].eq {
	pc = 0x8259E424; continue 'dispatch;
	}
	// 8259E410: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259E414: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8259E418: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259E41C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259E420: 409A0008  bne cr6, 0x8259e428
	if !ctx.cr[6].eq {
	pc = 0x8259E428; continue 'dispatch;
	}
	// 8259E424: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259E428: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259E42C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E430: 419A0134  beq cr6, 0x8259e564
	if ctx.cr[6].eq {
	pc = 0x8259E564; continue 'dispatch;
	}
	// 8259E434: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259E438: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259E43C: 5528CFFE  rlwinm r8, r9, 0x19, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 8259E440: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8259E444: 419A00F8  beq cr6, 0x8259e53c
	if ctx.cr[6].eq {
	pc = 0x8259E53C; continue 'dispatch;
	}
	// 8259E448: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259E44C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E450: 419A0024  beq cr6, 0x8259e474
	if ctx.cr[6].eq {
	pc = 0x8259E474; continue 'dispatch;
	}
	// 8259E454: 892A0007  lbz r9, 7(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 8259E458: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259E45C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8259E460: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259E464: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E468: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259E46C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E470: 480000D0  b 0x8259e540
	pc = 0x8259E540; continue 'dispatch;
	// 8259E474: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259E478: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8259E47C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259E480: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8259E484: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259E488: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259E48C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E490: 40810054  ble 0x8259e4e4
	if !ctx.cr[0].gt {
	pc = 0x8259E4E4; continue 'dispatch;
	}
	// 8259E494: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259E498: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259E49C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259E4A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E4A4: 2F070007  cmpwi cr6, r7, 7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 7, &mut ctx.xer);
	// 8259E4A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259E4AC: 41980008  blt cr6, 0x8259e4b4
	if ctx.cr[6].lt {
	pc = 0x8259E4B4; continue 'dispatch;
	}
	// 8259E4B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259E4B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259E4B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259E4BC: 419A0014  beq cr6, 0x8259e4d0
	if ctx.cr[6].eq {
	pc = 0x8259E4D0; continue 'dispatch;
	}
	// 8259E4C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259E4C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259E4C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259E4CC: 4800000C  b 0x8259e4d8
	pc = 0x8259E4D8; continue 'dispatch;
	// 8259E4D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259E4D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259E4D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259E4DC: 4199FFB8  bgt cr6, 0x8259e494
	if ctx.cr[6].gt {
	pc = 0x8259E494; continue 'dispatch;
	}
	// 8259E4E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259E4E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259E4E8: 419A0040  beq cr6, 0x8259e528
	if ctx.cr[6].eq {
	pc = 0x8259E528; continue 'dispatch;
	}
	// 8259E4EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E4F0: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8259E4F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E4F8: 41990008  bgt cr6, 0x8259e500
	if ctx.cr[6].gt {
	pc = 0x8259E500; continue 'dispatch;
	}
	// 8259E4FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E500: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E508: 409A0020  bne cr6, 0x8259e528
	if !ctx.cr[6].eq {
	pc = 0x8259E528; continue 'dispatch;
	}
	// 8259E50C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259E510: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259E514: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E518: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E51C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259E520: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E524: 4800001C  b 0x8259e540
	pc = 0x8259E540; continue 'dispatch;
	// 8259E528: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259E52C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E530: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259E534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E538: 48000008  b 0x8259e540
	pc = 0x8259E540; continue 'dispatch;
	// 8259E53C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259E540: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E548: 419A001C  beq cr6, 0x8259e564
	if ctx.cr[6].eq {
	pc = 0x8259E564; continue 'dispatch;
	}
	// 8259E54C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259E550: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8259E554: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259E558: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259E55C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259E560: 4E800421  bctrl
	ctx.lr = 0x8259E564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259E564: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259E568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E56C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E578 size=292
    let mut pc: u32 = 0x8259E578;
    'dispatch: loop {
        match pc {
            0x8259E578 => {
    //   block [0x8259E578..0x8259E69C)
	// 8259E578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E584: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8259E588: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E590: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8259E594: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259E598: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8259E59C: 4BC15EED  bl 0x821b4488
	ctx.lr = 0x8259E5A0;
	sub_821B4488(ctx, base);
	// 8259E5A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8259E5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E5A8: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8259E5AC: 480000F5  bl 0x8259e6a0
	ctx.lr = 0x8259E5B0;
	sub_8259E6A0(ctx, base);
	// 8259E5B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259E5B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E5B8: 4BF1F651  bl 0x824bdc08
	ctx.lr = 0x8259E5BC;
	sub_824BDC08(ctx, base);
	// 8259E5BC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8259E5C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8259E5C4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8259E5C8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8259E5CC: 38C89060  addi r6, r8, -0x6fa0
	ctx.r[6].s64 = ctx.r[8].s64 + -28576;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259E6A0 size=188
    let mut pc: u32 = 0x8259E6A0;
    'dispatch: loop {
        match pc {
            0x8259E6A0 => {
    //   block [0x8259E6A0..0x8259E75C)
	// 8259E6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E6A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259E6AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E6B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8259E6B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E6B8: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 8259E6BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E6C0: 397E9484  addi r11, r30, -0x6b7c
	ctx.r[11].s64 = ctx.r[30].s64 + -27516;
	// 8259E6C4: C00BFE50  lfs f0, -0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E6C8: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8259E6CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E6D0: 4BC9B8C1  bl 0x82239f90
	ctx.lr = 0x8259E6D4;
	sub_82239F90(ctx, base);
	// 8259E6D4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259E6D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8259E6DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8259E6E0: 4BC9B7D1  bl 0x82239eb0
	ctx.lr = 0x8259E6E4;
	sub_82239EB0(ctx, base);
	// 8259E6E4: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 8259E6E8: C01E9484  lfs f0, -0x6b7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259E6EC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8259E6F0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8259E6F4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8259E6F8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8259E6FC: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 8259E700: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8259E704: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8259E708: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E760 size=60
    let mut pc: u32 = 0x8259E760;
    'dispatch: loop {
        match pc {
            0x8259E760 => {
    //   block [0x8259E760..0x8259E79C)
	// 8259E760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E76C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E770: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259E774: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259E778: 388B4CB4  addi r4, r11, 0x4cb4
	ctx.r[4].s64 = ctx.r[11].s64 + 19636;
	// 8259E77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259E780: 4BC8E751  bl 0x8222ced0
	ctx.lr = 0x8259E784;
	sub_8222CED0(ctx, base);
	// 8259E784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259E788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259E78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E7A0 size=232
    let mut pc: u32 = 0x8259E7A0;
    'dispatch: loop {
        match pc {
            0x8259E7A0 => {
    //   block [0x8259E7A0..0x8259E888)
	// 8259E7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259E7A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259E7AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E7B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259E7B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259E7B8: 388B4CC4  addi r4, r11, 0x4cc4
	ctx.r[4].s64 = ctx.r[11].s64 + 19652;
	// 8259E7BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E7C0: 4BC8E711  bl 0x8222ced0
	ctx.lr = 0x8259E7C4;
	sub_8222CED0(ctx, base);
	// 8259E7C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259E7C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E7CC: 4BBFDE1D  bl 0x8219c5e8
	ctx.lr = 0x8259E7D0;
	sub_8219C5E8(ctx, base);
	// 8259E7D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E7D4: 4BC76605  bl 0x82214dd8
	ctx.lr = 0x8259E7D8;
	sub_82214DD8(ctx, base);
	// 8259E7D8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259E7DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259E7E0: 419A0094  beq cr6, 0x8259e874
	if ctx.cr[6].eq {
	pc = 0x8259E874; continue 'dispatch;
	}
	// 8259E7E4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8259E7E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E7EC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259E7F0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259E7F4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259E7F8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259E7FC: 4BC13CFD  bl 0x821b24f8
	ctx.lr = 0x8259E800;
	sub_821B24F8(ctx, base);
	// 8259E800: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259E804: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E808: 48462189  bl 0x82a00990
	ctx.lr = 0x8259E80C;
	sub_82A00990(ctx, base);
	// 8259E80C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259E810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E814: 419A0058  beq cr6, 0x8259e86c
	if ctx.cr[6].eq {
	pc = 0x8259E86C; continue 'dispatch;
	}
	// 8259E818: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259E81C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259E820: 1D4A24A1  mulli r10, r10, 0x24a1
	ctx.r[10].s64 = ctx.r[10].s64 * 9377;
	// 8259E824: 390A24DF  addi r8, r10, 0x24df
	ctx.r[8].s64 = ctx.r[10].s64 + 9439;
	// 8259E828: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259E82C: 5507983E  rotlwi r7, r8, 0x13
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(19)) as u64;
	// 8259E830: 7CC75B96  divwu r6, r7, r11
	ctx.r[6].u32 = ctx.r[7].u32 / ctx.r[11].u32;
	// 8259E834: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 8259E838: 7CA659D6  mullw r5, r6, r11
	ctx.r[5].s64 = (ctx.r[6].s32 as i64) * (ctx.r[11].s32 as i64);
	// 8259E83C: 7D653850  subf r11, r5, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 8259E840: 4098000C  bge cr6, 0x8259e84c
	if !ctx.cr[6].lt {
	pc = 0x8259E84C; continue 'dispatch;
	}
	// 8259E844: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8259E848: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8259E84C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259E850: 48462629  bl 0x82a00e78
	ctx.lr = 0x8259E854;
	sub_82A00E78(ctx, base);
	// 8259E854: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8259E858: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259E85C: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 8259E860: 4BC459F1  bl 0x821e4250
	ctx.lr = 0x8259E864;
	sub_821E4250(ctx, base);
	// 8259E864: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8259E868: 906A6C90  stw r3, 0x6c90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27792 as u32), ctx.r[3].u32 ) };
	// 8259E86C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259E870: 4BC7D4C9  bl 0x8221bd38
	ctx.lr = 0x8259E874;
	sub_8221BD38(ctx, base);
	// 8259E874: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259E878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259E87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259E880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259E884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259E888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259E888 size=692
    let mut pc: u32 = 0x8259E888;
    'dispatch: loop {
        match pc {
            0x8259E888 => {
    //   block [0x8259E888..0x8259EB3C)
	// 8259E888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259E88C: 4870AB45  bl 0x82ca93d0
	ctx.lr = 0x8259E890;
	sub_82CA93D0(ctx, base);
	// 8259E890: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259E894: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 8259E898: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 8259E89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E8A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8259E8A4: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 8259E8A8: 7CD03378  mr r16, r6
	ctx.r[16].u64 = ctx.r[6].u64;
	// 8259E8AC: 806B6C90  lwz r3, 0x6c90(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27792 as u32) ) } as u64;
	// 8259E8B0: 419A0010  beq cr6, 0x8259e8c0
	if ctx.cr[6].eq {
	pc = 0x8259E8C0; continue 'dispatch;
	}
	// 8259E8B4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8259E8B8: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 8259E8BC: 4800000C  b 0x8259e8c8
	pc = 0x8259E8C8; continue 'dispatch;
	// 8259E8C0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8259E8C4: 388A4CE0  addi r4, r10, 0x4ce0
	ctx.r[4].s64 = ctx.r[10].s64 + 19680;
	// 8259E8C8: 4BD0B121  bl 0x822a99e8
	ctx.lr = 0x8259E8CC;
	sub_822A99E8(ctx, base);
	// 8259E8CC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8259E8D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E8D4: 419A0254  beq cr6, 0x8259eb28
	if ctx.cr[6].eq {
	pc = 0x8259EB28; continue 'dispatch;
	}
	// 8259E8D8: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 8259E8DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259E8E0: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 8259E8E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E8E8: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 8259E8EC: 484620A5  bl 0x82a00990
	ctx.lr = 0x8259E8F0;
	sub_82A00990(ctx, base);
	// 8259E8F0: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 8259E8F4: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259E8F8: 82210054  lwz r17, 0x54(r1)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259E8FC: 82610050  lwz r19, 0x50(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259E900: 7F1D8840  cmplw cr6, r29, r17
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[17].u32, &mut ctx.xer);
	// 8259E904: 419A014C  beq cr6, 0x8259ea50
	if ctx.cr[6].eq {
	pc = 0x8259EA50; continue 'dispatch;
	}
	// 8259E908: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 8259E90C: 82E10050  lwz r23, 0x50(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259E910: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8259E914: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8259E918: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8259E91C: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 8259E920: 839A6DA0  lwz r28, 0x6da0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 8259E924: 3EA0834A  lis r21, -0x7cb6
	ctx.r[21].s64 = -2092302336;
	// 8259E928: 3ACBE460  addi r22, r11, -0x1ba0
	ctx.r[22].s64 = ctx.r[11].s64 + -7072;
	// 8259E92C: 3B0AD838  addi r24, r10, -0x27c8
	ctx.r[24].s64 = ctx.r[10].s64 + -10184;
	// 8259E930: 3B694CEC  addi r27, r9, 0x4cec
	ctx.r[27].s64 = ctx.r[9].s64 + 19692;
	// 8259E934: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259E938: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8259E93C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259E940: 7D6B9A14  add r11, r11, r19
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 8259E944: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259E948: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E94C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8259E950: 419A0020  beq cr6, 0x8259e970
	if ctx.cr[6].eq {
	pc = 0x8259E970; continue 'dispatch;
	}
	// 8259E954: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8259E958: 409A0018  bne cr6, 0x8259e970
	if !ctx.cr[6].eq {
	pc = 0x8259E970; continue 'dispatch;
	}
	// 8259E95C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E960: 8135E454  lwz r9, -0x1bac(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 8259E964: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8259E968: 409A0008  bne cr6, 0x8259e970
	if !ctx.cr[6].eq {
	pc = 0x8259E970; continue 'dispatch;
	}
	// 8259E96C: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 8259E970: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E974: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8259E978: 419A00CC  beq cr6, 0x8259ea44
	if ctx.cr[6].eq {
	pc = 0x8259EA44; continue 'dispatch;
	}
	// 8259E97C: 81726AB8  lwz r11, 0x6ab8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259E980: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 8259E984: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 8259E988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E98C: 409A0010  bne cr6, 0x8259e99c
	if !ctx.cr[6].eq {
	pc = 0x8259E99C; continue 'dispatch;
	}
	// 8259E990: 81746AC0  lwz r11, 0x6ac0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(27328 as u32) ) } as u64;
	// 8259E994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E998: 419A0010  beq cr6, 0x8259e9a8
	if ctx.cr[6].eq {
	pc = 0x8259E9A8; continue 'dispatch;
	}
	// 8259E99C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259E9A0: 4BC458B1  bl 0x821e4250
	ctx.lr = 0x8259E9A4;
	sub_821E4250(ctx, base);
	// 8259E9A4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8259E9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259E9AC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 8259E9B0: 4BC13B49  bl 0x821b24f8
	ctx.lr = 0x8259E9B4;
	sub_821B24F8(ctx, base);
	// 8259E9B4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8259E9B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259E9BC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8259E9C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259E9C4: 4BC55395  bl 0x821f3d58
	ctx.lr = 0x8259E9C8;
	sub_821F3D58(ctx, base);
	// 8259E9C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259E9CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259E9D0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8259E9D4: 48461CF5  bl 0x82a006c8
	ctx.lr = 0x8259E9D8;
	sub_82A006C8(ctx, base);
	// 8259E9D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259E9DC: 419A0010  beq cr6, 0x8259e9ec
	if ctx.cr[6].eq {
	pc = 0x8259E9EC; continue 'dispatch;
	}
	// 8259E9E0: 82E30000  lwz r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259E9E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259E9E8: 48000008  b 0x8259e9f0
	pc = 0x8259E9F0; continue 'dispatch;
	// 8259E9EC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 8259E9F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259E9F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259E9F8: 419A0008  beq cr6, 0x8259ea00
	if ctx.cr[6].eq {
	pc = 0x8259EA00; continue 'dispatch;
	}
	// 8259E9FC: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 8259EA00: 7F1F7800  cmpw cr6, r31, r15
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[15].s32, &mut ctx.xer);
	// 8259EA04: 409A0040  bne cr6, 0x8259ea44
	if !ctx.cr[6].eq {
	pc = 0x8259EA44; continue 'dispatch;
	}
	// 8259EA08: 2F100000  cmpwi cr6, r16, 0
	ctx.cr[6].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 8259EA0C: 419A0028  beq cr6, 0x8259ea34
	if ctx.cr[6].eq {
	pc = 0x8259EA34; continue 'dispatch;
	}
	// 8259EA10: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8259EA14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EA18: 4BE20E09  bl 0x823bf820
	ctx.lr = 0x8259EA1C;
	sub_823BF820(ctx, base);
	// 8259EA1C: 7D701850  subf r11, r16, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[16].s64;
	// 8259EA20: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 8259EA24: 7D695278  xor r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 8259EA28: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8259EA2C: 2F08000A  cmpwi cr6, r8, 0xa
	ctx.cr[6].compare_i32(ctx.r[8].s32, 10, &mut ctx.xer);
	// 8259EA30: 41990014  bgt cr6, 0x8259ea44
	if ctx.cr[6].gt {
	pc = 0x8259EA44; continue 'dispatch;
	}
	// 8259EA34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259EA38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259EA3C: 4BE8D45D  bl 0x8242be98
	ctx.lr = 0x8259EA40;
	sub_8242BE98(ctx, base);
	// 8259EA40: 839A6DA0  lwz r28, 0x6da0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 8259EA44: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8259EA48: 7F1D8840  cmplw cr6, r29, r17
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[17].u32, &mut ctx.xer);
	// 8259EA4C: 409AFEE8  bne cr6, 0x8259e934
	if !ctx.cr[6].eq {
	pc = 0x8259E934; continue 'dispatch;
	}
	// 8259EA50: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259EA54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EA58: 419A00B8  beq cr6, 0x8259eb10
	if ctx.cr[6].eq {
	pc = 0x8259EB10; continue 'dispatch;
	}
	// 8259EA5C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8259EA60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8259EA64: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 8259EA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EA6C: 419A00A4  beq cr6, 0x8259eb10
	if ctx.cr[6].eq {
	pc = 0x8259EB10; continue 'dispatch;
	}
	// 8259EA70: 81526AB8  lwz r10, 0x6ab8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259EA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EA78: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259EA7C: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259EA80: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EA84: 80E90078  lwz r7, 0x78(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) } as u64;
	// 8259EA88: 1D4724A1  mulli r10, r7, 0x24a1
	ctx.r[10].s64 = ctx.r[7].s64 * 9377;
	// 8259EA8C: 38CA24DF  addi r6, r10, 0x24df
	ctx.r[6].s64 = ctx.r[10].s64 + 9439;
	// 8259EA90: 54CA983E  rotlwi r10, r6, 0x13
	ctx.r[10].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 8259EA94: 91490078  stw r10, 0x78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8259EA98: 419A0014  beq cr6, 0x8259eaac
	if ctx.cr[6].eq {
	pc = 0x8259EAAC; continue 'dispatch;
	}
	// 8259EA9C: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 8259EAA0: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 8259EAA4: 7D685050  subf r11, r8, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259EAA8: 48000008  b 0x8259eab0
	pc = 0x8259EAB0; continue 'dispatch;
	// 8259EAAC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 8259EAB0: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259EAB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259EAB8: 419A0018  beq cr6, 0x8259ead0
	if ctx.cr[6].eq {
	pc = 0x8259EAD0; continue 'dispatch;
	}
	// 8259EABC: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8259EAC0: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8259EAC4: 7D091E70  srawi r9, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 8259EAC8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8259EACC: 41980008  blt cr6, 0x8259ead4
	if ctx.cr[6].lt {
	pc = 0x8259EAD4; continue 'dispatch;
	}
	// 8259EAD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8259EAD4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259EAD8: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 8259EADC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259EAE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EAE4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EAE8: 914E0000  stw r10, 0(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8259EAEC: 912E0004  stw r9, 4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8259EAF0: 4BC7D249  bl 0x8221bd38
	ctx.lr = 0x8259EAF4;
	sub_8221BD38(ctx, base);
	// 8259EAF4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259EAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EAFC: 419A0034  beq cr6, 0x8259eb30
	if ctx.cr[6].eq {
	pc = 0x8259EB30; continue 'dispatch;
	}
	// 8259EB00: 4BC7D239  bl 0x8221bd38
	ctx.lr = 0x8259EB04;
	sub_8221BD38(ctx, base);
	// 8259EB04: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 8259EB08: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8259EB0C: 4870A914  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
	// 8259EB10: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 8259EB14: 4BC7D225  bl 0x8221bd38
	ctx.lr = 0x8259EB18;
	sub_8221BD38(ctx, base);
	// 8259EB18: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259EB1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EB20: 419A0008  beq cr6, 0x8259eb28
	if ctx.cr[6].eq {
	pc = 0x8259EB28; continue 'dispatch;
	}
	// 8259EB24: 4BC7D215  bl 0x8221bd38
	ctx.lr = 0x8259EB28;
	sub_8221BD38(ctx, base);
	// 8259EB28: 932E0000  stw r25, 0(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8259EB2C: 932E0004  stw r25, 4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 8259EB30: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 8259EB34: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8259EB38: 4870A8E8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259EB40 size=576
    let mut pc: u32 = 0x8259EB40;
    'dispatch: loop {
        match pc {
            0x8259EB40 => {
    //   block [0x8259EB40..0x8259ED80)
	// 8259EB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EB44: 4870A8A1  bl 0x82ca93e4
	ctx.lr = 0x8259EB48;
	sub_82CA93D0(ctx, base);
	// 8259EB48: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EB4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259EB50: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8259EB54: 388B4CF4  addi r4, r11, 0x4cf4
	ctx.r[4].s64 = ctx.r[11].s64 + 19700;
	// 8259EB58: 4BD0AE91  bl 0x822a99e8
	ctx.lr = 0x8259EB5C;
	sub_822A99E8(ctx, base);
	// 8259EB5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259EB60: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8259EB64: 419A0214  beq cr6, 0x8259ed78
	if ctx.cr[6].eq {
	pc = 0x8259ED78; continue 'dispatch;
	}
	// 8259EB68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259EB6C: 48461E25  bl 0x82a00990
	ctx.lr = 0x8259EB70;
	sub_82A00990(ctx, base);
	// 8259EB70: 83610078  lwz r27, 0x78(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8259EB74: 82A10074  lwz r21, 0x74(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8259EB78: 83010070  lwz r24, 0x70(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8259EB7C: 7F1BA840  cmplw cr6, r27, r21
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[21].u32, &mut ctx.xer);
	// 8259EB80: 419A01F0  beq cr6, 0x8259ed70
	if ctx.cr[6].eq {
	pc = 0x8259ED70; continue 'dispatch;
	}
	// 8259EB84: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259EB88: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 8259EB8C: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 8259EB90: 3AC0000F  li r22, 0xf
	ctx.r[22].s64 = 15;
	// 8259EB94: 3B2BD838  addi r25, r11, -0x27c8
	ctx.r[25].s64 = ctx.r[11].s64 + -10184;
	// 8259EB98: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259EB9C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259EBA0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259EBA4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EBA8: 812B0078  lwz r9, 0x78(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8259EBAC: 1D4924A1  mulli r10, r9, 0x24a1
	ctx.r[10].s64 = ctx.r[9].s64 * 9377;
	// 8259EBB0: 390A24DF  addi r8, r10, 0x24df
	ctx.r[8].s64 = ctx.r[10].s64 + 9439;
	// 8259EBB4: 5507983E  rotlwi r7, r8, 0x13
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(19)) as u64;
	// 8259EBB8: 54EA073E  clrlwi r10, r7, 0x1c
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x0000000Fu64;
	// 8259EBBC: 90EB0078  stw r7, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 8259EBC0: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 8259EBC4: 4098000C  bge cr6, 0x8259ebd0
	if !ctx.cr[6].lt {
	pc = 0x8259EBD0; continue 'dispatch;
	}
	// 8259EBC8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8259EBCC: 48000010  b 0x8259ebdc
	pc = 0x8259EBDC; continue 'dispatch;
	// 8259EBD0: 7D765010  subfc r11, r22, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[22].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[22].s64;
	// 8259EBD4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8259EBD8: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 8259EBDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8259EBE0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259EBE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259EBE8: 4BFFFCA1  bl 0x8259e888
	ctx.lr = 0x8259EBEC;
	sub_8259E888(ctx, base);
	// 8259EBEC: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259EBF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259EBF4: 419A0170  beq cr6, 0x8259ed64
	if ctx.cr[6].eq {
	pc = 0x8259ED64; continue 'dispatch;
	}
	// 8259EBF8: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259EBFC: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259EC00: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8259EC04: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 8259EC08: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8259EC0C: 92810088  stw r20, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[20].u32 ) };
	// 8259EC10: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8259EC14: 9281008C  stw r20, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[20].u32 ) };
	// 8259EC18: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259EC1C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8259EC20: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 8259EC24: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 8259EC28: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 8259EC2C: 3A610050  addi r19, r1, 0x50
	ctx.r[19].s64 = ctx.r[1].s64 + 80;
	// 8259EC30: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259EC34: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EC38: 4BC55121  bl 0x821f3d58
	ctx.lr = 0x8259EC3C;
	sub_821F3D58(ctx, base);
	// 8259EC3C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8259EC40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259EC44: 4BC138B5  bl 0x821b24f8
	ctx.lr = 0x8259EC48;
	sub_821B24F8(ctx, base);
	// 8259EC48: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8259EC4C: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 8259EC50: 4BC46DB9  bl 0x821e5a08
	ctx.lr = 0x8259EC54;
	sub_821E5A08(ctx, base);
	// 8259EC54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EC58: 419A0008  beq cr6, 0x8259ec60
	if ctx.cr[6].eq {
	pc = 0x8259EC60; continue 'dispatch;
	}
	// 8259EC5C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EC60: 7CDFF051  subf. r6, r31, r30
	ctx.r[6].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8259EC64: 41820068  beq 0x8259eccc
	if ctx.cr[0].eq {
	pc = 0x8259ECCC; continue 'dispatch;
	}
	// 8259EC68: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259EC6C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259EC70: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259EC74: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EC78: 812B0078  lwz r9, 0x78(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8259EC7C: 1D4924A1  mulli r10, r9, 0x24a1
	ctx.r[10].s64 = ctx.r[9].s64 * 9377;
	// 8259EC80: 390A24DF  addi r8, r10, 0x24df
	ctx.r[8].s64 = ctx.r[10].s64 + 9439;
	// 8259EC84: 5507983E  rotlwi r7, r8, 0x13
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(19)) as u64;
	// 8259EC88: 54EA073E  clrlwi r10, r7, 0x1c
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x0000000Fu64;
	// 8259EC8C: 90EB0078  stw r7, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 8259EC90: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 8259EC94: 4098000C  bge cr6, 0x8259eca0
	if !ctx.cr[6].lt {
	pc = 0x8259ECA0; continue 'dispatch;
	}
	// 8259EC98: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8259EC9C: 48000010  b 0x8259ecac
	pc = 0x8259ECAC; continue 'dispatch;
	// 8259ECA0: 7D765010  subfc r11, r22, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[22].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[22].s64;
	// 8259ECA4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8259ECA8: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 8259ECAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8259ECB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259ECB4: 4BFFFBD5  bl 0x8259e888
	ctx.lr = 0x8259ECB8;
	sub_8259E888(ctx, base);
	// 8259ECB8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259ECBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259ECC0: 419A000C  beq cr6, 0x8259eccc
	if ctx.cr[6].eq {
	pc = 0x8259ECCC; continue 'dispatch;
	}
	// 8259ECC4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8259ECC8: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8259ECCC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259ECD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259ECD4: 409A000C  bne cr6, 0x8259ece0
	if !ctx.cr[6].eq {
	pc = 0x8259ECE0; continue 'dispatch;
	}
	// 8259ECD8: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 8259ECDC: 48000010  b 0x8259ecec
	pc = 0x8259ECEC; continue 'dispatch;
	// 8259ECE0: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259ECE4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8259ECE8: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 8259ECEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259ECF0: 419A0048  beq cr6, 0x8259ed38
	if ctx.cr[6].eq {
	pc = 0x8259ED38; continue 'dispatch;
	}
	// 8259ECF4: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259ECF8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8259ECFC: 7D0A2670  srawi r10, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 8259ED00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8259ED04: 40980034  bge cr6, 0x8259ed38
	if !ctx.cr[6].lt {
	pc = 0x8259ED38; continue 'dispatch;
	}
	// 8259ED08: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259ED0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259ED10: 419A001C  beq cr6, 0x8259ed2c
	if ctx.cr[6].eq {
	pc = 0x8259ED2C; continue 'dispatch;
	}
	// 8259ED14: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 8259ED18: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259ED1C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8259ED20: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8259ED24: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8259ED28: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 8259ED2C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8259ED30: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8259ED34: 48000030  b 0x8259ed64
	pc = 0x8259ED64; continue 'dispatch;
	// 8259ED38: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259ED3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8259ED40: 40990008  ble cr6, 0x8259ed48
	if !ctx.cr[6].gt {
	pc = 0x8259ED48; continue 'dispatch;
	}
	// 8259ED44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8259ED48: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8259ED4C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8259ED50: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8259ED54: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 8259ED58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259ED5C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8259ED60: 48001891  bl 0x825a05f0
	ctx.lr = 0x8259ED64;
	sub_825A05F0(ctx, base);
	// 8259ED64: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 8259ED68: 7F1BA840  cmplw cr6, r27, r21
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[21].u32, &mut ctx.xer);
	// 8259ED6C: 409AFE2C  bne cr6, 0x8259eb98
	if !ctx.cr[6].eq {
	pc = 0x8259EB98; continue 'dispatch;
	}
	// 8259ED70: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8259ED74: 4BC7CFC5  bl 0x8221bd38
	ctx.lr = 0x8259ED78;
	sub_8221BD38(ctx, base);
	// 8259ED78: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8259ED7C: 4870A6B8  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259ED80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259ED80 size=124
    let mut pc: u32 = 0x8259ED80;
    'dispatch: loop {
        match pc {
            0x8259ED80 => {
    //   block [0x8259ED80..0x8259EDFC)
	// 8259ED80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259ED84: 4870A685  bl 0x82ca9408
	ctx.lr = 0x8259ED88;
	sub_82CA93D0(ctx, base);
	// 8259ED88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259ED8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259ED90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259ED94: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 8259ED98: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8259ED9C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8259EDA0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8259EDA4: 4BBF5095  bl 0x82193e38
	ctx.lr = 0x8259EDA8;
	sub_82193E38(ctx, base);
	// 8259EDA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259EDAC: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 8259EDB0: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 8259EDB4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259EDB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EDBC: 419A0008  beq cr6, 0x8259edc4
	if ctx.cr[6].eq {
	pc = 0x8259EDC4; continue 'dispatch;
	}
	// 8259EDC0: 4BC7CF79  bl 0x8221bd38
	ctx.lr = 0x8259EDC4;
	sub_8221BD38(ctx, base);
	// 8259EDC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8259EDC8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8259EDCC: 578A07FE  clrlwi r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 8259EDD0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8259EDD4: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 8259EDD8: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 8259EDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259EDE0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8259EDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EDE8: 419A000C  beq cr6, 0x8259edf4
	if ctx.cr[6].eq {
	pc = 0x8259EDF4; continue 'dispatch;
	}
	// 8259EDEC: 4BC7CF4D  bl 0x8221bd38
	ctx.lr = 0x8259EDF0;
	sub_8221BD38(ctx, base);
	// 8259EDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EDF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259EDF8: 4870A660  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259EE00 size=188
    let mut pc: u32 = 0x8259EE00;
    'dispatch: loop {
        match pc {
            0x8259EE00 => {
    //   block [0x8259EE00..0x8259EEBC)
	// 8259EE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EE04: 4870A605  bl 0x82ca9408
	ctx.lr = 0x8259EE08;
	sub_82CA93D0(ctx, base);
	// 8259EE08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EE0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8259EE10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259EE14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8259EE18: 419A009C  beq cr6, 0x8259eeb4
	if ctx.cr[6].eq {
	pc = 0x8259EEB4; continue 'dispatch;
	}
	// 8259EE1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8259EE20: 409A0094  bne cr6, 0x8259eeb4
	if !ctx.cr[6].eq {
	pc = 0x8259EEB4; continue 'dispatch;
	}
	// 8259EE24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EE28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259EE2C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8259EE30: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8259EE34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8259EE38: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8259EE3C: 4800081D  bl 0x8259f658
	ctx.lr = 0x8259EE40;
	sub_8259F658(ctx, base);
	// 8259EE40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8259EE44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259EE48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8259EE4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8259EE50: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 8259EE54: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 8259EE58: 4BFFFCE9  bl 0x8259eb40
	ctx.lr = 0x8259EE5C;
	sub_8259EB40(ctx, base);
	// 8259EE5C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8259EE60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8259EE64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259EE68: 419A004C  beq cr6, 0x8259eeb4
	if ctx.cr[6].eq {
	pc = 0x8259EEB4; continue 'dispatch;
	}
	// 8259EE6C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8259EE70: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 8259EE74: 7D4B2670  srawi r11, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 8259EE78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259EE7C: 40980034  bge cr6, 0x8259eeb0
	if !ctx.cr[6].lt {
	pc = 0x8259EEB0; continue 'dispatch;
	}
	// 8259EE80: 7FBC1A14  add r29, r28, r3
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 8259EE84: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 8259EE88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EE8C: 4BF2AF65  bl 0x824c9df0
	ctx.lr = 0x8259EE90;
	sub_824C9DF0(ctx, base);
	// 8259EE90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EE94: 48000AED  bl 0x8259f980
	ctx.lr = 0x8259EE98;
	sub_8259F980(ctx, base);
	// 8259EE98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EE9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259EEA0: 48000969  bl 0x8259f808
	ctx.lr = 0x8259EEA4;
	sub_8259F808(ctx, base);
	// 8259EEA4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8259EEA8: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 8259EEAC: 4BFFFFB4  b 0x8259ee60
	pc = 0x8259EE60; continue 'dispatch;
	// 8259EEB0: 4BC7CE89  bl 0x8221bd38
	ctx.lr = 0x8259EEB4;
	sub_8221BD38(ctx, base);
	// 8259EEB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259EEB8: 4870A5A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259EEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259EEC0 size=344
    let mut pc: u32 = 0x8259EEC0;
    'dispatch: loop {
        match pc {
            0x8259EEC0 => {
    //   block [0x8259EEC0..0x8259F018)
	// 8259EEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259EEC4: 4870A539  bl 0x82ca93fc
	ctx.lr = 0x8259EEC8;
	sub_82CA93D0(ctx, base);
	// 8259EEC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259EECC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8259EED0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8259EED4: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 8259EED8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8259EEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259EEE0: 419A0094  beq cr6, 0x8259ef74
	if ctx.cr[6].eq {
	pc = 0x8259EF74; continue 'dispatch;
	}
	// 8259EEE4: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259EEE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259EEEC: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259EEF0: 3BBB000C  addi r29, r27, 0xc
	ctx.r[29].s64 = ctx.r[27].s64 + 12;
	// 8259EEF4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8259EEF8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8259EEFC: 7D282671  srawi. r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8259EF00: 41820110  beq 0x8259f010
	if ctx.cr[0].eq {
	pc = 0x8259F010; continue 'dispatch;
	}
	// 8259EF04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259EF08: 3B2B4D0C  addi r25, r11, 0x4d0c
	ctx.r[25].s64 = ctx.r[11].s64 + 19724;
	// 8259EF0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EF10: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8259EF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EF18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EF1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8259EF20: 4E800421  bctrl
	ctx.lr = 0x8259EF24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259EF24: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259EF28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8259EF2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259EF30: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8259EF34: 4800135D  bl 0x825a0290
	ctx.lr = 0x8259EF38;
	sub_825A0290(ctx, base);
	// 8259EF38: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EF3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EF40: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259EF44: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8259EF48: 4E800421  bctrl
	ctx.lr = 0x8259EF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259EF4C: 80FD0008  lwz r7, 8(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259EF50: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259EF54: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8259EF58: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8259EF5C: 7CA63850  subf r5, r6, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 8259EF60: 7CA42670  srawi r4, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 8259EF64: 7F1C2040  cmplw cr6, r28, r4
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[4].u32, &mut ctx.xer);
	// 8259EF68: 4198FFA4  blt cr6, 0x8259ef0c
	if ctx.cr[6].lt {
	pc = 0x8259EF0C; continue 'dispatch;
	}
	// 8259EF6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259EF70: 4870A4DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 8259EF74: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EF78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259EF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EF80: 3BAB4D0C  addi r29, r11, 0x4d0c
	ctx.r[29].s64 = ctx.r[11].s64 + 19724;
	// 8259EF84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EF88: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259EF8C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8259EF90: 4E800421  bctrl
	ctx.lr = 0x8259EF94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259EF94: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8259EF98: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8259EF9C: 419A0074  beq cr6, 0x8259f010
	if ctx.cr[6].eq {
	pc = 0x8259F010; continue 'dispatch;
	}
	// 8259EFA0: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 8259EFA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259EFA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259EFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259EFB0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8259EFB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259EFB8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8259EFBC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8259EFC0: 4BF2AE31  bl 0x824c9df0
	ctx.lr = 0x8259EFC4;
	sub_824C9DF0(ctx, base);
	// 8259EFC4: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259EFC8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8259EFCC: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 8259EFD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259EFD4: 480012BD  bl 0x825a0290
	ctx.lr = 0x8259EFD8;
	sub_825A0290(ctx, base);
	// 8259EFD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EFDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EFE0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259EFE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8259EFE8: 4E800421  bctrl
	ctx.lr = 0x8259EFEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259EFEC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259EFF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259EFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259EFF8: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259EFFC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8259F000: 4E800421  bctrl
	ctx.lr = 0x8259F004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259F004: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8259F008: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259F00C: 409AFF9C  bne cr6, 0x8259efa8
	if !ctx.cr[6].eq {
	pc = 0x8259EFA8; continue 'dispatch;
	}
	// 8259F010: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8259F014: 4870A438  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F018 size=84
    let mut pc: u32 = 0x8259F018;
    'dispatch: loop {
        match pc {
            0x8259F018 => {
    //   block [0x8259F018..0x8259F06C)
	// 8259F018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F024: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F02C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F030: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8259F034: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259F038: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259F03C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8259F040: 55070036  rlwinm r7, r8, 0, 0, 0x1b
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 8259F044: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8259F048: 419A0010  beq cr6, 0x8259f058
	if ctx.cr[6].eq {
	pc = 0x8259F058; continue 'dispatch;
	}
	// 8259F04C: 48000935  bl 0x8259f980
	ctx.lr = 0x8259F050;
	sub_8259F980(ctx, base);
	// 8259F050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F054: 4800084D  bl 0x8259f8a0
	ctx.lr = 0x8259F058;
	sub_8259F8A0(ctx, base);
	// 8259F058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8259F05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F070 size=1348
    let mut pc: u32 = 0x8259F070;
    'dispatch: loop {
        match pc {
            0x8259F070 => {
    //   block [0x8259F070..0x8259F5B4)
	// 8259F070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F074: 4870A395  bl 0x82ca9408
	ctx.lr = 0x8259F078;
	sub_82CA93D0(ctx, base);
	// 8259F078: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F07C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8259F080: 48001019  bl 0x825a0098
	ctx.lr = 0x8259F084;
	sub_825A0098(ctx, base);
	// 8259F084: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8259F088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F08C: 409A0014  bne cr6, 0x8259f0a0
	if !ctx.cr[6].eq {
	pc = 0x8259F0A0; continue 'dispatch;
	}
	// 8259F090: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8259F094: 48000EC5  bl 0x8259ff58
	ctx.lr = 0x8259F098;
	sub_8259FF58(ctx, base);
	// 8259F098: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8259F09C: 4870A3BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 8259F0A0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259F0A4: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259F0A8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8259F0AC: 7D2B2671  srawi. r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259F0B0: 408104FC  ble 0x8259f5ac
	if !ctx.cr[0].gt {
	pc = 0x8259F5AC; continue 'dispatch;
	}
	// 8259F0B4: 815C0024  lwz r10, 0x24(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259F0B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8259F0BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8259F0C0: 41980008  blt cr6, 0x8259f0c8
	if ctx.cr[6].lt {
	pc = 0x8259F0C8; continue 'dispatch;
	}
	// 8259F0C4: 93BC0024  stw r29, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 8259F0C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F0CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8259F0D0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8259F0D4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8259F0D8: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8259F0DC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8259F0E0: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8259F0E4: 55286FFE  rlwinm r8, r9, 0xd, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 8259F0E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8259F0EC: 419A00F4  beq cr6, 0x8259f1e0
	if ctx.cr[6].eq {
	pc = 0x8259F1E0; continue 'dispatch;
	}
	// 8259F0F0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259F0F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259F0F8: 419A0024  beq cr6, 0x8259f11c
	if ctx.cr[6].eq {
	pc = 0x8259F11C; continue 'dispatch;
	}
	// 8259F0FC: 894A00B3  lbz r10, 0xb3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(179 as u32) ) } as u64;
	// 8259F100: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259F104: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259F108: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259F10C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F110: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259F114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F118: 480000CC  b 0x8259f1e4
	pc = 0x8259F1E4; continue 'dispatch;
	// 8259F11C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259F120: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259F124: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8259F128: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259F12C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259F130: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259F134: 40810054  ble 0x8259f188
	if !ctx.cr[0].gt {
	pc = 0x8259F188; continue 'dispatch;
	}
	// 8259F138: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259F13C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259F140: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8259F144: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F148: 2F0700B3  cmpwi cr6, r7, 0xb3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 179, &mut ctx.xer);
	// 8259F14C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259F150: 41980008  blt cr6, 0x8259f158
	if ctx.cr[6].lt {
	pc = 0x8259F158; continue 'dispatch;
	}
	// 8259F154: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8259F158: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259F15C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259F160: 419A0014  beq cr6, 0x8259f174
	if ctx.cr[6].eq {
	pc = 0x8259F174; continue 'dispatch;
	}
	// 8259F164: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259F168: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259F16C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259F170: 4800000C  b 0x8259f17c
	pc = 0x8259F17C; continue 'dispatch;
	// 8259F174: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259F178: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259F17C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259F180: 4199FFB8  bgt cr6, 0x8259f138
	if ctx.cr[6].gt {
	pc = 0x8259F138; continue 'dispatch;
	}
	// 8259F184: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259F188: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259F18C: 419A0040  beq cr6, 0x8259f1cc
	if ctx.cr[6].eq {
	pc = 0x8259F1CC; continue 'dispatch;
	}
	// 8259F190: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F194: 2F0B00B3  cmpwi cr6, r11, 0xb3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 179, &mut ctx.xer);
	// 8259F198: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F19C: 41990008  bgt cr6, 0x8259f1a4
	if ctx.cr[6].gt {
	pc = 0x8259F1A4; continue 'dispatch;
	}
	// 8259F1A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8259F1A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259F1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F1AC: 409A0020  bne cr6, 0x8259f1cc
	if !ctx.cr[6].eq {
	pc = 0x8259F1CC; continue 'dispatch;
	}
	// 8259F1B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259F1B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8259F1B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259F1BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F1C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259F1C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F1C8: 4800001C  b 0x8259f1e4
	pc = 0x8259F1E4; continue 'dispatch;
	// 8259F1CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259F1D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F1D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8259F1D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F1DC: 48000008  b 0x8259f1e4
	pc = 0x8259F1E4; continue 'dispatch;
	// 8259F1E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8259F1E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259F1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F1EC: 419A0018  beq cr6, 0x8259f204
	if ctx.cr[6].eq {
	pc = 0x8259F204; continue 'dispatch;
	}
	// 8259F1F0: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259F1F4: 4BFC222D  bl 0x82561420
	ctx.lr = 0x8259F1F8;
	sub_82561420(ctx, base);
	// 8259F1F8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 8259F1FC: 409A0008  bne cr6, 0x8259f204
	if !ctx.cr[6].eq {
	pc = 0x8259F204; continue 'dispatch;
	}
	// 8259F200: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8259F204: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 8259F208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F210: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8259F214: 388BB7D4  addi r4, r11, -0x482c
	ctx.r[4].s64 = ctx.r[11].s64 + -18476;
	// 8259F218: 419A0044  beq cr6, 0x8259f25c
	if ctx.cr[6].eq {
	pc = 0x8259F25C; continue 'dispatch;
	}
	// 8259F21C: 4BC51025  bl 0x821f0240
	ctx.lr = 0x8259F220;
	sub_821F0240(ctx, base);
	// 8259F220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F22C: 4BC51015  bl 0x821f0240
	ctx.lr = 0x8259F230;
	sub_821F0240(ctx, base);
	// 8259F230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F234: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8259F238: 4BC75BA1  bl 0x82214dd8
	ctx.lr = 0x8259F23C;
	sub_82214DD8(ctx, base);
	// 8259F23C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259F240: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259F244: 4BFCC61D  bl 0x8256b860
	ctx.lr = 0x8259F248;
	sub_8256B860(ctx, base);
	// 8259F248: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F24C: 4BC75B8D  bl 0x82214dd8
	ctx.lr = 0x8259F250;
	sub_82214DD8(ctx, base);
	// 8259F250: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8259F254: 388AB7DC  addi r4, r10, -0x4824
	ctx.r[4].s64 = ctx.r[10].s64 + -18468;
	// 8259F258: 48000040  b 0x8259f298
	pc = 0x8259F298; continue 'dispatch;
	// 8259F25C: 4BC50FE5  bl 0x821f0240
	ctx.lr = 0x8259F260;
	sub_821F0240(ctx, base);
	// 8259F260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F268: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F26C: 4BC50FD5  bl 0x821f0240
	ctx.lr = 0x8259F270;
	sub_821F0240(ctx, base);
	// 8259F270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F274: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8259F278: 4BC75B61  bl 0x82214dd8
	ctx.lr = 0x8259F27C;
	sub_82214DD8(ctx, base);
	// 8259F27C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259F280: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259F284: 4BFCC5DD  bl 0x8256b860
	ctx.lr = 0x8259F288;
	sub_8256B860(ctx, base);
	// 8259F288: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F28C: 4BC75B4D  bl 0x82214dd8
	ctx.lr = 0x8259F290;
	sub_82214DD8(ctx, base);
	// 8259F290: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8259F294: 388AB7E0  addi r4, r10, -0x4820
	ctx.r[4].s64 = ctx.r[10].s64 + -18464;
	// 8259F298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F29C: 4BC50FA5  bl 0x821f0240
	ctx.lr = 0x8259F2A0;
	sub_821F0240(ctx, base);
	// 8259F2A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F2A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F2A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F2AC: 4BC50F95  bl 0x821f0240
	ctx.lr = 0x8259F2B0;
	sub_821F0240(ctx, base);
	// 8259F2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F2B4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8259F2B8: 4BC75B21  bl 0x82214dd8
	ctx.lr = 0x8259F2BC;
	sub_82214DD8(ctx, base);
	// 8259F2BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8259F2C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8259F2C4: 4BFCC59D  bl 0x8256b860
	ctx.lr = 0x8259F2C8;
	sub_8256B860(ctx, base);
	// 8259F2C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F2CC: 4BC75B0D  bl 0x82214dd8
	ctx.lr = 0x8259F2D0;
	sub_82214DD8(ctx, base);
	// 8259F2D0: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259F2D4: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259F2D8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259F2DC: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259F2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F2E4: 48001095  bl 0x825a0378
	ctx.lr = 0x8259F2E8;
	sub_825A0378(ctx, base);
	// 8259F2E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8259F2EC: 419A02B8  beq cr6, 0x8259f5a4
	if ctx.cr[6].eq {
	pc = 0x8259F5A4; continue 'dispatch;
	}
	// 8259F2F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F2F8: 419A02AC  beq cr6, 0x8259f5a4
	if ctx.cr[6].eq {
	pc = 0x8259F5A4; continue 'dispatch;
	}
	// 8259F2FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259F300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F304: 38EB4D1C  addi r7, r11, 0x4d1c
	ctx.r[7].s64 = ctx.r[11].s64 + 19740;
	// 8259F308: 4BC131F1  bl 0x821b24f8
	ctx.lr = 0x8259F30C;
	sub_821B24F8(ctx, base);
	// 8259F30C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8259F310: 4BDB4D29  bl 0x82354038
	ctx.lr = 0x8259F314;
	sub_82354038(ctx, base);
	// 8259F314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F318: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F31C: 419A0288  beq cr6, 0x8259f5a4
	if ctx.cr[6].eq {
	pc = 0x8259F5A4; continue 'dispatch;
	}
	// 8259F320: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 8259F324: 3BDC001C  addi r30, r28, 0x1c
	ctx.r[30].s64 = ctx.r[28].s64 + 28;
	// 8259F328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F32C: 419A0038  beq cr6, 0x8259f364
	if ctx.cr[6].eq {
	pc = 0x8259F364; continue 'dispatch;
	}
	// 8259F330: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259F338: 419A012C  beq cr6, 0x8259f464
	if ctx.cr[6].eq {
	pc = 0x8259F464; continue 'dispatch;
	}
	// 8259F33C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259F340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F344: 419A0020  beq cr6, 0x8259f364
	if ctx.cr[6].eq {
	pc = 0x8259F364; continue 'dispatch;
	}
	// 8259F348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F34C: 4BBD4AED  bl 0x82173e38
	ctx.lr = 0x8259F350;
	sub_82173E38(ctx, base);
	// 8259F350: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259F354: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259F358: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259F360: 409A0008  bne cr6, 0x8259f368
	if !ctx.cr[6].eq {
	pc = 0x8259F368; continue 'dispatch;
	}
	// 8259F364: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8259F368: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259F36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F370: 409A0234  bne cr6, 0x8259f5a4
	if !ctx.cr[6].eq {
	pc = 0x8259F5A4; continue 'dispatch;
	}
	// 8259F374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8259F378: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8259F37C: 388B54D4  addi r4, r11, 0x54d4
	ctx.r[4].s64 = ctx.r[11].s64 + 21716;
	// 8259F380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F384: 4BC8DB4D  bl 0x8222ced0
	ctx.lr = 0x8259F388;
	sub_8222CED0(ctx, base);
	// 8259F388: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F38C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259F390: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 8259F394: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F398: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 8259F39C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8259F3A0: 4E800421  bctrl
	ctx.lr = 0x8259F3A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8259F3A4: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 8259F3A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8259F3AC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8259F3B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8259F3B4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8259F3B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8259F3BC: 81646AB8  lwz r11, 0x6ab8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259F3C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8259F5B8 size=4
    let mut pc: u32 = 0x8259F5B8;
    'dispatch: loop {
        match pc {
            0x8259F5B8 => {
    //   block [0x8259F5B8..0x8259F5BC)
	// 8259F5B8: 480003C8  b 0x8259f980
	sub_8259F980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F5C0 size=80
    let mut pc: u32 = 0x8259F5C0;
    'dispatch: loop {
        match pc {
            0x8259F5C0 => {
    //   block [0x8259F5C0..0x8259F610)
	// 8259F5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F5C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F5CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F5D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F5D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8259F5DC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8259F5E0: 4BF2A811  bl 0x824c9df0
	ctx.lr = 0x8259F5E4;
	sub_824C9DF0(ctx, base);
	// 8259F5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F5E8: 48000399  bl 0x8259f980
	ctx.lr = 0x8259F5EC;
	sub_8259F980(ctx, base);
	// 8259F5EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259F5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F5F4: 48000215  bl 0x8259f808
	ctx.lr = 0x8259F5F8;
	sub_8259F808(ctx, base);
	// 8259F5F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F5FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F60C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F610 size=72
    let mut pc: u32 = 0x8259F610;
    'dispatch: loop {
        match pc {
            0x8259F610 => {
    //   block [0x8259F610..0x8259F658)
	// 8259F610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F61C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F628: 4BBFCFC1  bl 0x8219c5e8
	ctx.lr = 0x8259F62C;
	sub_8219C5E8(ctx, base);
	// 8259F62C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259F630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F634: 419A0010  beq cr6, 0x8259f644
	if ctx.cr[6].eq {
	pc = 0x8259F644; continue 'dispatch;
	}
	// 8259F638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259F63C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F640: 48000019  bl 0x8259f658
	ctx.lr = 0x8259F644;
	sub_8259F658(ctx, base);
	// 8259F644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F64C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F658 size=428
    let mut pc: u32 = 0x8259F658;
    'dispatch: loop {
        match pc {
            0x8259F658 => {
    //   block [0x8259F658..0x8259F804)
	// 8259F658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F65C: 48709D8D  bl 0x82ca93e8
	ctx.lr = 0x8259F660;
	sub_82CA93D0(ctx, base);
	// 8259F660: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F664: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 8259F668: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259F66C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8259F670: 38EB8C3C  addi r7, r11, -0x73c4
	ctx.r[7].s64 = ctx.r[11].s64 + -29636;
	// 8259F674: 4BC12E85  bl 0x821b24f8
	ctx.lr = 0x8259F678;
	sub_821B24F8(ctx, base);
	// 8259F678: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8259F67C: 4BD0A36D  bl 0x822a99e8
	ctx.lr = 0x8259F680;
	sub_822A99E8(ctx, base);
	// 8259F680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F684: 419A0178  beq cr6, 0x8259f7fc
	if ctx.cr[6].eq {
	pc = 0x8259F7FC; continue 'dispatch;
	}
	// 8259F688: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8259F68C: 388B8C9C  addi r4, r11, -0x7364
	ctx.r[4].s64 = ctx.r[11].s64 + -29540;
	// 8259F690: 4BD0A359  bl 0x822a99e8
	ctx.lr = 0x8259F694;
	sub_822A99E8(ctx, base);
	// 8259F694: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259F698: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8259F69C: 419A0160  beq cr6, 0x8259f7fc
	if ctx.cr[6].eq {
	pc = 0x8259F7FC; continue 'dispatch;
	}
	// 8259F6A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F6A4: 484612ED  bl 0x82a00990
	ctx.lr = 0x8259F6A8;
	sub_82A00990(ctx, base);
	// 8259F6A8: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8259F6AC: 82A1005C  lwz r21, 0x5c(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259F6B0: 83210058  lwz r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259F6B4: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 8259F6B8: 419A013C  beq cr6, 0x8259f7f4
	if ctx.cr[6].eq {
	pc = 0x8259F7F4; continue 'dispatch;
	}
	// 8259F6BC: 3D00811C  lis r8, -0x7ee4
	ctx.r[8].s64 = -2128871424;
	// 8259F6C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8259F6C4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8259F6C8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8259F6CC: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 8259F6D0: 611C9DC5  ori r28, r8, 0x9dc5
	ctx.r[28].u64 = ctx.r[8].u64 | 40389;
	// 8259F6D4: 3EC0834A  lis r22, -0x7cb6
	ctx.r[22].s64 = -2092302336;
	// 8259F6D8: 3AEBE460  addi r23, r11, -0x1ba0
	ctx.r[23].s64 = ctx.r[11].s64 + -7072;
	// 8259F6DC: 3B6A8CC0  addi r27, r10, -0x7340
	ctx.r[27].s64 = ctx.r[10].s64 + -29504;
	// 8259F6E0: 3B498CB4  addi r26, r9, -0x734c
	ctx.r[26].s64 = ctx.r[9].s64 + -29516;
	// 8259F6E4: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259F6E8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8259F6EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8259F6F0: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 8259F6F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259F6F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F6FC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8259F700: 419A0020  beq cr6, 0x8259f720
	if ctx.cr[6].eq {
	pc = 0x8259F720; continue 'dispatch;
	}
	// 8259F704: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8259F708: 409A0018  bne cr6, 0x8259f720
	if !ctx.cr[6].eq {
	pc = 0x8259F720; continue 'dispatch;
	}
	// 8259F70C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F710: 8136E454  lwz r9, -0x1bac(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 8259F714: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8259F718: 409A0008  bne cr6, 0x8259f720
	if !ctx.cr[6].eq {
	pc = 0x8259F720; continue 'dispatch;
	}
	// 8259F71C: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 8259F720: 80786DA0  lwz r3, 0x6da0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28064 as u32) ) } as u64;
	// 8259F724: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F728: 4BC44B29  bl 0x821e4250
	ctx.lr = 0x8259F72C;
	sub_821E4250(ctx, base);
	// 8259F72C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F730: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259F734: 419A00B4  beq cr6, 0x8259f7e8
	if ctx.cr[6].eq {
	pc = 0x8259F7E8; continue 'dispatch;
	}
	// 8259F738: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8259F73C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259F740: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259F744: 4BC54615  bl 0x821f3d58
	ctx.lr = 0x8259F748;
	sub_821F3D58(ctx, base);
	// 8259F748: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259F74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F750: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8259F754: 48460F75  bl 0x82a006c8
	ctx.lr = 0x8259F758;
	sub_82A006C8(ctx, base);
	// 8259F758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F75C: 419A0008  beq cr6, 0x8259f764
	if ctx.cr[6].eq {
	pc = 0x8259F764; continue 'dispatch;
	}
	// 8259F760: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259F768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F76C: 4BC3ABDD  bl 0x821da348
	ctx.lr = 0x8259F770;
	sub_821DA348(ctx, base);
	// 8259F770: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8259F774: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8259F778: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259F77C: 4BC545DD  bl 0x821f3d58
	ctx.lr = 0x8259F780;
	sub_821F3D58(ctx, base);
	// 8259F780: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8259F784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F788: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 8259F78C: 48460F3D  bl 0x82a006c8
	ctx.lr = 0x8259F790;
	sub_82A006C8(ctx, base);
	// 8259F790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259F794: 419A0008  beq cr6, 0x8259f79c
	if ctx.cr[6].eq {
	pc = 0x8259F79C; continue 'dispatch;
	}
	// 8259F798: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F79C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8259F7A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F7A4: 4BC3ABA5  bl 0x821da348
	ctx.lr = 0x8259F7A8;
	sub_821DA348(ctx, base);
	// 8259F7A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8259F7AC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259F7B0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259F7B4: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8259F7B8: 3874000C  addi r3, r20, 0xc
	ctx.r[3].s64 = ctx.r[20].s64 + 12;
	// 8259F7BC: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8259F7C0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8259F7C4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8259F7C8: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 8259F7CC: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 8259F7D0: 4BF2A621  bl 0x824c9df0
	ctx.lr = 0x8259F7D4;
	sub_824C9DF0(ctx, base);
	// 8259F7D4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 8259F7D8: 480001A9  bl 0x8259f980
	ctx.lr = 0x8259F7DC;
	sub_8259F980(ctx, base);
	// 8259F7DC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8259F7E0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 8259F7E4: 48000025  bl 0x8259f808
	ctx.lr = 0x8259F7E8;
	sub_8259F808(ctx, base);
	// 8259F7E8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8259F7EC: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 8259F7F0: 409AFEF4  bne cr6, 0x8259f6e4
	if !ctx.cr[6].eq {
	pc = 0x8259F6E4; continue 'dispatch;
	}
	// 8259F7F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8259F7F8: 4BC7C541  bl 0x8221bd38
	ctx.lr = 0x8259F7FC;
	sub_8221BD38(ctx, base);
	// 8259F7FC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8259F800: 48709C38  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F808 size=148
    let mut pc: u32 = 0x8259F808;
    'dispatch: loop {
        match pc {
            0x8259F808 => {
    //   block [0x8259F808..0x8259F89C)
	// 8259F808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F814: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F818: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8259F81C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8259F820: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8259F824: 83EA008C  lwz r31, 0x8c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259F828: 893F0034  lbz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8259F82C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259F830: 419A0014  beq cr6, 0x8259f844
	if ctx.cr[6].eq {
	pc = 0x8259F844; continue 'dispatch;
	}
	// 8259F834: 897F0035  lbz r11, 0x35(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(53 as u32) ) } as u64;
	// 8259F838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F83C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F840: 409A0008  bne cr6, 0x8259f848
	if !ctx.cr[6].eq {
	pc = 0x8259F848; continue 'dispatch;
	}
	// 8259F844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259F848: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259F84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259F850: 419A0038  beq cr6, 0x8259f888
	if ctx.cr[6].eq {
	pc = 0x8259F888; continue 'dispatch;
	}
	// 8259F854: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F858: 4BC12B39  bl 0x821b2390
	ctx.lr = 0x8259F85C;
	sub_821B2390(ctx, base);
	// 8259F85C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F860: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8259F864: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259F868: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259F86C: 390A600C  addi r8, r10, 0x600c
	ctx.r[8].s64 = ctx.r[10].s64 + 24588;
	// 8259F870: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259F874: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8259F878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F87C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8259F880: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8259F884: 48001245  bl 0x825a0ac8
	ctx.lr = 0x8259F888;
	sub_825A0AC8(ctx, base);
	// 8259F888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F8A0 size=92
    let mut pc: u32 = 0x8259F8A0;
    'dispatch: loop {
        match pc {
            0x8259F8A0 => {
    //   block [0x8259F8A0..0x8259F8FC)
	// 8259F8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8259F8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F8B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8259F8B8: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259F8BC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259F8C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259F8C4: 419A0020  beq cr6, 0x8259f8e4
	if ctx.cr[6].eq {
	pc = 0x8259F8E4; continue 'dispatch;
	}
	// 8259F8C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8259F8CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F8D0: 4BFFFF39  bl 0x8259f808
	ctx.lr = 0x8259F8D4;
	sub_8259F808(ctx, base);
	// 8259F8D4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259F8D8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 8259F8DC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8259F8E0: 409AFFE8  bne cr6, 0x8259f8c8
	if !ctx.cr[6].eq {
	pc = 0x8259F8C8; continue 'dispatch;
	}
	// 8259F8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259F8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8259F8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259F900 size=128
    let mut pc: u32 = 0x8259F900;
    'dispatch: loop {
        match pc {
            0x8259F900 => {
    //   block [0x8259F900..0x8259F980)
	// 8259F900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259F908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259F90C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F910: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8259F914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259F918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259F91C: 80860008  lwz r4, 8(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 8259F920: 4BC3AA29  bl 0x821da348
	ctx.lr = 0x8259F924;
	sub_821DA348(ctx, base);
	// 8259F924: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8259F928: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F92C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8259F930: 4BC3AA19  bl 0x821da348
	ctx.lr = 0x8259F934;
	sub_821DA348(ctx, base);
	// 8259F934: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8259F938: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F93C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8259F940: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F944: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8259F948: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259F94C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F950: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8259F954: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 8259F958: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 8259F95C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 8259F960: 4BF2A491  bl 0x824c9df0
	ctx.lr = 0x8259F964;
	sub_824C9DF0(ctx, base);
	// 8259F964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259F968: 48000019  bl 0x8259f980
	ctx.lr = 0x8259F96C;
	sub_8259F980(ctx, base);
	// 8259F96C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259F970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259F974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8259F978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8259F97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259F980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8259F980 size=1492
    let mut pc: u32 = 0x8259F980;
    'dispatch: loop {
        match pc {
            0x8259F980 => {
    //   block [0x8259F980..0x8259FF54)
	// 8259F980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259F984: 48709A89  bl 0x82ca940c
	ctx.lr = 0x8259F988;
	sub_82CA93D0(ctx, base);
	// 8259F988: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259F98C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8259F990: 480005C9  bl 0x8259ff58
	ctx.lr = 0x8259F994;
	sub_8259FF58(ctx, base);
	// 8259F994: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F998: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8259F99C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8259F9A0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8259F9A4: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8259F9A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259F9AC: 419A00F4  beq cr6, 0x8259faa0
	if ctx.cr[6].eq {
	pc = 0x8259FAA0; continue 'dispatch;
	}
	// 8259F9B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259F9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259F9B8: 419A0024  beq cr6, 0x8259f9dc
	if ctx.cr[6].eq {
	pc = 0x8259F9DC; continue 'dispatch;
	}
	// 8259F9BC: 894A0053  lbz r10, 0x53(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(83 as u32) ) } as u64;
	// 8259F9C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259F9C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259F9C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259F9CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259F9D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259F9D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259F9D8: 480000CC  b 0x8259faa4
	pc = 0x8259FAA4; continue 'dispatch;
	// 8259F9DC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259F9E0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259F9E4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259F9E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259F9EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259F9F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259F9F4: 40810054  ble 0x8259fa48
	if !ctx.cr[0].gt {
	pc = 0x8259FA48; continue 'dispatch;
	}
	// 8259F9F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259F9FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259FA00: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8259FA04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FA08: 2F070053  cmpwi cr6, r7, 0x53
	ctx.cr[6].compare_i32(ctx.r[7].s32, 83, &mut ctx.xer);
	// 8259FA0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259FA10: 41980008  blt cr6, 0x8259fa18
	if ctx.cr[6].lt {
	pc = 0x8259FA18; continue 'dispatch;
	}
	// 8259FA14: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259FA18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259FA1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259FA20: 419A0014  beq cr6, 0x8259fa34
	if ctx.cr[6].eq {
	pc = 0x8259FA34; continue 'dispatch;
	}
	// 8259FA24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259FA28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259FA2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259FA30: 4800000C  b 0x8259fa3c
	pc = 0x8259FA3C; continue 'dispatch;
	// 8259FA34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259FA38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259FA3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FA40: 4199FFB8  bgt cr6, 0x8259f9f8
	if ctx.cr[6].gt {
	pc = 0x8259F9F8; continue 'dispatch;
	}
	// 8259FA44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FA48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259FA4C: 419A0040  beq cr6, 0x8259fa8c
	if ctx.cr[6].eq {
	pc = 0x8259FA8C; continue 'dispatch;
	}
	// 8259FA50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FA54: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 8259FA58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FA5C: 41990008  bgt cr6, 0x8259fa64
	if ctx.cr[6].gt {
	pc = 0x8259FA64; continue 'dispatch;
	}
	// 8259FA60: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FA64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FA6C: 409A0020  bne cr6, 0x8259fa8c
	if !ctx.cr[6].eq {
	pc = 0x8259FA8C; continue 'dispatch;
	}
	// 8259FA70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259FA74: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259FA78: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259FA7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FA80: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259FA84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FA88: 4800001C  b 0x8259faa4
	pc = 0x8259FAA4; continue 'dispatch;
	// 8259FA8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259FA90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FA94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259FA98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FA9C: 48000008  b 0x8259faa4
	pc = 0x8259FAA4; continue 'dispatch;
	// 8259FAA0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FAA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FAA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FAAC: 419A0470  beq cr6, 0x8259ff1c
	if ctx.cr[6].eq {
	pc = 0x8259FF1C; continue 'dispatch;
	}
	// 8259FAB0: 48318491  bl 0x828b7f40
	ctx.lr = 0x8259FAB4;
	sub_828B7F40(ctx, base);
	// 8259FAB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8259FAB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8259FABC: 419A0018  beq cr6, 0x8259fad4
	if ctx.cr[6].eq {
	pc = 0x8259FAD4; continue 'dispatch;
	}
	// 8259FAC0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259FAC4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259FAC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FAD0: 409A0008  bne cr6, 0x8259fad8
	if !ctx.cr[6].eq {
	pc = 0x8259FAD8; continue 'dispatch;
	}
	// 8259FAD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FAD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FAE0: 419A043C  beq cr6, 0x8259ff1c
	if ctx.cr[6].eq {
	pc = 0x8259FF1C; continue 'dispatch;
	}
	// 8259FAE4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259FAE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FAEC: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 8259FAF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259FAF4: 419A00E8  beq cr6, 0x8259fbdc
	if ctx.cr[6].eq {
	pc = 0x8259FBDC; continue 'dispatch;
	}
	// 8259FAF8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259FAFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FB00: 419A0020  beq cr6, 0x8259fb20
	if ctx.cr[6].eq {
	pc = 0x8259FB20; continue 'dispatch;
	}
	// 8259FB04: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259FB08: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259FB0C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8259FB10: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8259FB14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FB18: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FB1C: 480000C4  b 0x8259fbe0
	pc = 0x8259FBE0; continue 'dispatch;
	// 8259FB20: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259FB24: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259FB28: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259FB2C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259FB30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FB34: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FB38: 40810054  ble 0x8259fb8c
	if !ctx.cr[0].gt {
	pc = 0x8259FB8C; continue 'dispatch;
	}
	// 8259FB3C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259FB40: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259FB44: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8259FB48: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FB4C: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 8259FB50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259FB54: 41980008  blt cr6, 0x8259fb5c
	if ctx.cr[6].lt {
	pc = 0x8259FB5C; continue 'dispatch;
	}
	// 8259FB58: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259FB5C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259FB60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259FB64: 419A0014  beq cr6, 0x8259fb78
	if ctx.cr[6].eq {
	pc = 0x8259FB78; continue 'dispatch;
	}
	// 8259FB68: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259FB6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259FB70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259FB74: 4800000C  b 0x8259fb80
	pc = 0x8259FB80; continue 'dispatch;
	// 8259FB78: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259FB7C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259FB80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FB84: 4199FFB8  bgt cr6, 0x8259fb3c
	if ctx.cr[6].gt {
	pc = 0x8259FB3C; continue 'dispatch;
	}
	// 8259FB88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FB8C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259FB90: 419A003C  beq cr6, 0x8259fbcc
	if ctx.cr[6].eq {
	pc = 0x8259FBCC; continue 'dispatch;
	}
	// 8259FB94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FB98: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8259FB9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FBA0: 41990008  bgt cr6, 0x8259fba8
	if ctx.cr[6].gt {
	pc = 0x8259FBA8; continue 'dispatch;
	}
	// 8259FBA4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FBA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FBAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FBB0: 409A001C  bne cr6, 0x8259fbcc
	if !ctx.cr[6].eq {
	pc = 0x8259FBCC; continue 'dispatch;
	}
	// 8259FBB4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259FBB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FBBC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259FBC0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259FBC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FBC8: 48000018  b 0x8259fbe0
	pc = 0x8259FBE0; continue 'dispatch;
	// 8259FBCC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259FBD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FBD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FBD8: 48000008  b 0x8259fbe0
	pc = 0x8259FBE0; continue 'dispatch;
	// 8259FBDC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8259FBE0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259FBE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FBE8: 419A000C  beq cr6, 0x8259fbf4
	if ctx.cr[6].eq {
	pc = 0x8259FBF4; continue 'dispatch;
	}
	// 8259FBEC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259FBF0: 4BE093A9  bl 0x823a8f98
	ctx.lr = 0x8259FBF4;
	sub_823A8F98(ctx, base);
	// 8259FBF4: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259FBF8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FBFC: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8259FC00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259FC04: 419A00E4  beq cr6, 0x8259fce8
	if ctx.cr[6].eq {
	pc = 0x8259FCE8; continue 'dispatch;
	}
	// 8259FC08: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259FC0C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259FC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FC14: 419A001C  beq cr6, 0x8259fc30
	if ctx.cr[6].eq {
	pc = 0x8259FC30; continue 'dispatch;
	}
	// 8259FC18: 896B0018  lbz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8259FC1C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8259FC20: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259FC24: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FC28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FC2C: 480000C0  b 0x8259fcec
	pc = 0x8259FCEC; continue 'dispatch;
	// 8259FC30: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259FC34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259FC38: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259FC3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FC40: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FC44: 40810054  ble 0x8259fc98
	if !ctx.cr[0].gt {
	pc = 0x8259FC98; continue 'dispatch;
	}
	// 8259FC48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259FC4C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259FC50: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8259FC54: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FC58: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 8259FC5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259FC60: 41980008  blt cr6, 0x8259fc68
	if ctx.cr[6].lt {
	pc = 0x8259FC68; continue 'dispatch;
	}
	// 8259FC64: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259FC68: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259FC6C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259FC70: 419A0014  beq cr6, 0x8259fc84
	if ctx.cr[6].eq {
	pc = 0x8259FC84; continue 'dispatch;
	}
	// 8259FC74: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259FC78: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259FC7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259FC80: 4800000C  b 0x8259fc8c
	pc = 0x8259FC8C; continue 'dispatch;
	// 8259FC84: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259FC88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259FC8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FC90: 4199FFB8  bgt cr6, 0x8259fc48
	if ctx.cr[6].gt {
	pc = 0x8259FC48; continue 'dispatch;
	}
	// 8259FC94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FC98: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259FC9C: 419A003C  beq cr6, 0x8259fcd8
	if ctx.cr[6].eq {
	pc = 0x8259FCD8; continue 'dispatch;
	}
	// 8259FCA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FCA4: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 8259FCA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FCAC: 41990008  bgt cr6, 0x8259fcb4
	if ctx.cr[6].gt {
	pc = 0x8259FCB4; continue 'dispatch;
	}
	// 8259FCB0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FCB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FCBC: 409A001C  bne cr6, 0x8259fcd8
	if !ctx.cr[6].eq {
	pc = 0x8259FCD8; continue 'dispatch;
	}
	// 8259FCC0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259FCC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FCC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259FCCC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259FCD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FCD4: 48000018  b 0x8259fcec
	pc = 0x8259FCEC; continue 'dispatch;
	// 8259FCD8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259FCDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FCE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FCE4: 48000008  b 0x8259fcec
	pc = 0x8259FCEC; continue 'dispatch;
	// 8259FCE8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8259FCEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259FCF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FCF4: 419A000C  beq cr6, 0x8259fd00
	if ctx.cr[6].eq {
	pc = 0x8259FD00; continue 'dispatch;
	}
	// 8259FCF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259FCFC: 4BF5A3F5  bl 0x824fa0f0
	ctx.lr = 0x8259FD00;
	sub_824FA0F0(ctx, base);
	// 8259FD00: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8259FD04: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FD08: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 8259FD0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259FD10: 419A00E4  beq cr6, 0x8259fdf4
	if ctx.cr[6].eq {
	pc = 0x8259FDF4; continue 'dispatch;
	}
	// 8259FD14: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259FD18: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259FD1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FD20: 419A001C  beq cr6, 0x8259fd3c
	if ctx.cr[6].eq {
	pc = 0x8259FD3C; continue 'dispatch;
	}
	// 8259FD24: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 8259FD28: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8259FD2C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259FD30: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FD34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FD38: 480000C0  b 0x8259fdf8
	pc = 0x8259FDF8; continue 'dispatch;
	// 8259FD3C: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259FD40: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259FD44: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259FD48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FD4C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FD50: 40810054  ble 0x8259fda4
	if !ctx.cr[0].gt {
	pc = 0x8259FDA4; continue 'dispatch;
	}
	// 8259FD54: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259FD58: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259FD5C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8259FD60: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FD64: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8259FD68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259FD6C: 41980008  blt cr6, 0x8259fd74
	if ctx.cr[6].lt {
	pc = 0x8259FD74; continue 'dispatch;
	}
	// 8259FD70: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259FD74: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259FD78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259FD7C: 419A0014  beq cr6, 0x8259fd90
	if ctx.cr[6].eq {
	pc = 0x8259FD90; continue 'dispatch;
	}
	// 8259FD80: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259FD84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259FD88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259FD8C: 4800000C  b 0x8259fd98
	pc = 0x8259FD98; continue 'dispatch;
	// 8259FD90: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259FD94: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259FD98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FD9C: 4199FFB8  bgt cr6, 0x8259fd54
	if ctx.cr[6].gt {
	pc = 0x8259FD54; continue 'dispatch;
	}
	// 8259FDA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FDA4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259FDA8: 419A003C  beq cr6, 0x8259fde4
	if ctx.cr[6].eq {
	pc = 0x8259FDE4; continue 'dispatch;
	}
	// 8259FDAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FDB0: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 8259FDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FDB8: 41990008  bgt cr6, 0x8259fdc0
	if ctx.cr[6].gt {
	pc = 0x8259FDC0; continue 'dispatch;
	}
	// 8259FDBC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FDC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FDC8: 409A001C  bne cr6, 0x8259fde4
	if !ctx.cr[6].eq {
	pc = 0x8259FDE4; continue 'dispatch;
	}
	// 8259FDCC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259FDD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FDD4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259FDD8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259FDDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FDE0: 48000018  b 0x8259fdf8
	pc = 0x8259FDF8; continue 'dispatch;
	// 8259FDE4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259FDE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FDEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FDF0: 48000008  b 0x8259fdf8
	pc = 0x8259FDF8; continue 'dispatch;
	// 8259FDF4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8259FDF8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259FDFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FE00: 419A0010  beq cr6, 0x8259fe10
	if ctx.cr[6].eq {
	pc = 0x8259FE10; continue 'dispatch;
	}
	// 8259FE04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8259FE08: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8259FE0C: D00B0874  stfs f0, 0x874(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2164 as u32), tmp.u32 ) };
	// 8259FE10: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8259FE14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FE18: 55498FFE  rlwinm r9, r10, 0x11, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 8259FE1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8259FE20: 419A00E4  beq cr6, 0x8259ff04
	if ctx.cr[6].eq {
	pc = 0x8259FF04; continue 'dispatch;
	}
	// 8259FE24: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8259FE28: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8259FE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FE30: 419A001C  beq cr6, 0x8259fe4c
	if ctx.cr[6].eq {
	pc = 0x8259FE4C; continue 'dispatch;
	}
	// 8259FE34: 896B000F  lbz r11, 0xf(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 8259FE38: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8259FE3C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8259FE40: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FE44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FE48: 480000C0  b 0x8259ff08
	pc = 0x8259FF08; continue 'dispatch;
	// 8259FE4C: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8259FE50: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8259FE54: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8259FE58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FE5C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FE60: 40810054  ble 0x8259feb4
	if !ctx.cr[0].gt {
	pc = 0x8259FEB4; continue 'dispatch;
	}
	// 8259FE64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8259FE68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8259FE6C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8259FE70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FE74: 2F07000F  cmpwi cr6, r7, 0xf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 15, &mut ctx.xer);
	// 8259FE78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8259FE7C: 41980008  blt cr6, 0x8259fe84
	if ctx.cr[6].lt {
	pc = 0x8259FE84; continue 'dispatch;
	}
	// 8259FE80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8259FE84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8259FE88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8259FE8C: 419A0014  beq cr6, 0x8259fea0
	if ctx.cr[6].eq {
	pc = 0x8259FEA0; continue 'dispatch;
	}
	// 8259FE90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8259FE94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8259FE98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8259FE9C: 4800000C  b 0x8259fea8
	pc = 0x8259FEA8; continue 'dispatch;
	// 8259FEA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8259FEA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8259FEA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8259FEAC: 4199FFB8  bgt cr6, 0x8259fe64
	if ctx.cr[6].gt {
	pc = 0x8259FE64; continue 'dispatch;
	}
	// 8259FEB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FEB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8259FEB8: 419A003C  beq cr6, 0x8259fef4
	if ctx.cr[6].eq {
	pc = 0x8259FEF4; continue 'dispatch;
	}
	// 8259FEBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FEC0: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 8259FEC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FEC8: 41990008  bgt cr6, 0x8259fed0
	if ctx.cr[6].gt {
	pc = 0x8259FED0; continue 'dispatch;
	}
	// 8259FECC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8259FED0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FED8: 409A001C  bne cr6, 0x8259fef4
	if !ctx.cr[6].eq {
	pc = 0x8259FEF4; continue 'dispatch;
	}
	// 8259FEDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8259FEE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FEE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8259FEE8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8259FEEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FEF0: 48000018  b 0x8259ff08
	pc = 0x8259FF08; continue 'dispatch;
	// 8259FEF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8259FEF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8259FEFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FF00: 48000008  b 0x8259ff08
	pc = 0x8259FF08; continue 'dispatch;
	// 8259FF04: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8259FF08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8259FF0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FF10: 419A000C  beq cr6, 0x8259ff1c
	if ctx.cr[6].eq {
	pc = 0x8259FF1C; continue 'dispatch;
	}
	// 8259FF14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8259FF18: 4BF21819  bl 0x824c1730
	ctx.lr = 0x8259FF1C;
	sub_824C1730(ctx, base);
	// 8259FF1C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8259FF20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8259FF24: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 8259FF28: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8259FF2C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8259FF30: 55280036  rlwinm r8, r9, 0, 0, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8259FF34: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8259FF38: 409A0010  bne cr6, 0x8259ff48
	if !ctx.cr[6].eq {
	pc = 0x8259FF48; continue 'dispatch;
	}
	// 8259FF3C: 4BDED705  bl 0x8238d640
	ctx.lr = 0x8259FF40;
	sub_8238D640(ctx, base);
	// 8259FF40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259FF44: 48709518  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 8259FF48: 4BDED571  bl 0x8238d4b8
	ctx.lr = 0x8259FF4C;
	sub_8238D4B8(ctx, base);
	// 8259FF4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8259FF50: 4870950C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8259FF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8259FF58 size=192
    let mut pc: u32 = 0x8259FF58;
    'dispatch: loop {
        match pc {
            0x8259FF58 => {
    //   block [0x8259FF58..0x825A0018)
	// 8259FF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8259FF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8259FF60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8259FF64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8259FF68: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8259FF6C: 3BE3001C  addi r31, r3, 0x1c
	ctx.r[31].s64 = ctx.r[3].s64 + 28;
	// 8259FF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FF74: 419A009C  beq cr6, 0x825a0010
	if ctx.cr[6].eq {
	pc = 0x825A0010; continue 'dispatch;
	}
	// 8259FF78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8259FF7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FF80: 419A0088  beq cr6, 0x825a0008
	if ctx.cr[6].eq {
	pc = 0x825A0008; continue 'dispatch;
	}
	// 8259FF84: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8259FF88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8259FF8C: 419A0018  beq cr6, 0x8259ffa4
	if ctx.cr[6].eq {
	pc = 0x8259FFA4; continue 'dispatch;
	}
	// 8259FF90: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8259FF94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8259FF98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8259FF9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8259FFA0: 409A0008  bne cr6, 0x8259ffa8
	if !ctx.cr[6].eq {
	pc = 0x8259FFA8; continue 'dispatch;
	}
	// 8259FFA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8259FFA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8259FFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8259FFB0: 419A0044  beq cr6, 0x8259fff4
	if ctx.cr[6].eq {
	pc = 0x8259FFF4; continue 'dispatch;
	}
	// 8259FFB4: 4BDED875  bl 0x8238d828
	ctx.lr = 0x8259FFB8;
	sub_8238D828(ctx, base);
	// 8259FFB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8259FFBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8259FFC0: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 8259FFC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8259FFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FFCC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8259FFD0: 4BBF3E69  bl 0x82193e38
	ctx.lr = 0x8259FFD4;
	sub_82193E38(ctx, base);
	// 8259FFD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8259FFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8259FFDC: 4BF31EED  bl 0x824d1ec8
	ctx.lr = 0x8259FFE0;
	sub_824D1EC8(ctx, base);
	// 8259FFE0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8259FFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8259FFE8: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 8259FFEC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 8259FFF0: 4BBF3E49  bl 0x82193e38
	ctx.lr = 0x8259FFF4;
	sub_82193E38(ctx, base);
	// 8259FFF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8259FFF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8259FFFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0004: 4E800020  blr
	return;
	// 825A0008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A000C: 4BBF3E2D  bl 0x82193e38
	ctx.lr = 0x825A0010;
	sub_82193E38(ctx, base);
	// 825A0010: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A0014: 4BFFFF90  b 0x8259ffa4
	pc = 0x8259FFA4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0018 size=124
    let mut pc: u32 = 0x825A0018;
    'dispatch: loop {
        match pc {
            0x825A0018 => {
    //   block [0x825A0018..0x825A0094)
	// 825A0018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A001C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0024: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0028: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825A002C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0030: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825A0034: 388BA450  addi r4, r11, -0x5bb0
	ctx.r[4].s64 = ctx.r[11].s64 + -23472;
	// 825A0038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A003C: 4BC8CE95  bl 0x8222ced0
	ctx.lr = 0x825A0040;
	sub_8222CED0(ctx, base);
	// 825A0040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0044: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0048: 4BBFC5A1  bl 0x8219c5e8
	ctx.lr = 0x825A004C;
	sub_8219C5E8(ctx, base);
	// 825A004C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0050: 4BC74D89  bl 0x82214dd8
	ctx.lr = 0x825A0054;
	sub_82214DD8(ctx, base);
	// 825A0054: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A005C: 409A0010  bne cr6, 0x825a006c
	if !ctx.cr[6].eq {
	pc = 0x825A006C; continue 'dispatch;
	}
	// 825A0060: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825A0064: 38EBFFDF  addi r7, r11, -0x21
	ctx.r[7].s64 = ctx.r[11].s64 + -33;
	// 825A0068: 48000008  b 0x825a0070
	pc = 0x825A0070; continue 'dispatch;
	// 825A006C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0070: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0074: 4BC12485  bl 0x821b24f8
	ctx.lr = 0x825A0078;
	sub_821B24F8(ctx, base);
	// 825A0078: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825A007C: 4BBF6B05  bl 0x82196b80
	ctx.lr = 0x825A0080;
	sub_82196B80(ctx, base);
	// 825A0080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A0084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A008C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A0090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A0098 size=500
    let mut pc: u32 = 0x825A0098;
    'dispatch: loop {
        match pc {
            0x825A0098 => {
    //   block [0x825A0098..0x825A028C)
	// 825A0098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A009C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A00A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A00A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A00A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A00AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A00B0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A00B4: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 825A00B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A00BC: 409A01B8  bne cr6, 0x825a0274
	if !ctx.cr[6].eq {
	pc = 0x825A0274; continue 'dispatch;
	}
	// 825A00C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A00C4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A00C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A00CC: 419A0164  beq cr6, 0x825a0230
	if ctx.cr[6].eq {
	pc = 0x825A0230; continue 'dispatch;
	}
	// 825A00D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A00D4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A00D8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A00DC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A00E0: 4BC8C0D9  bl 0x8222c1b8
	ctx.lr = 0x825A00E4;
	sub_8222C1B8(ctx, base);
	// 825A00E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A00E8: 419A0018  beq cr6, 0x825a0100
	if ctx.cr[6].eq {
	pc = 0x825A0100; continue 'dispatch;
	}
	// 825A00EC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A00F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A00F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A00F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A00FC: 409A0008  bne cr6, 0x825a0104
	if !ctx.cr[6].eq {
	pc = 0x825A0104; continue 'dispatch;
	}
	// 825A0100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0104: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A0108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A010C: 419A0124  beq cr6, 0x825a0230
	if ctx.cr[6].eq {
	pc = 0x825A0230; continue 'dispatch;
	}
	// 825A0110: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A0114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0118: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825A011C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A0120: 419A00EC  beq cr6, 0x825a020c
	if ctx.cr[6].eq {
	pc = 0x825A020C; continue 'dispatch;
	}
	// 825A0124: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A0128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A012C: 419A0020  beq cr6, 0x825a014c
	if ctx.cr[6].eq {
	pc = 0x825A014C; continue 'dispatch;
	}
	// 825A0130: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825A0134: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A0138: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825A013C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A0140: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0144: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0148: 480000C8  b 0x825a0210
	pc = 0x825A0210; continue 'dispatch;
	// 825A014C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A0150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0154: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A0158: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825A015C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A0160: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A0164: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0168: 40810054  ble 0x825a01bc
	if !ctx.cr[0].gt {
	pc = 0x825A01BC; continue 'dispatch;
	}
	// 825A016C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A0170: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A0174: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A0178: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A017C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825A0180: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A0184: 41980008  blt cr6, 0x825a018c
	if ctx.cr[6].lt {
	pc = 0x825A018C; continue 'dispatch;
	}
	// 825A0188: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825A018C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A0190: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A0194: 419A0014  beq cr6, 0x825a01a8
	if ctx.cr[6].eq {
	pc = 0x825A01A8; continue 'dispatch;
	}
	// 825A0198: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A019C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A01A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A01A4: 4800000C  b 0x825a01b0
	pc = 0x825A01B0; continue 'dispatch;
	// 825A01A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A01AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A01B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A01B4: 4199FFB8  bgt cr6, 0x825a016c
	if ctx.cr[6].gt {
	pc = 0x825A016C; continue 'dispatch;
	}
	// 825A01B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A01BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A01C0: 419A003C  beq cr6, 0x825a01fc
	if ctx.cr[6].eq {
	pc = 0x825A01FC; continue 'dispatch;
	}
	// 825A01C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A01C8: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825A01CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A01D0: 41990008  bgt cr6, 0x825a01d8
	if ctx.cr[6].gt {
	pc = 0x825A01D8; continue 'dispatch;
	}
	// 825A01D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A01D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A01DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A01E0: 409A001C  bne cr6, 0x825a01fc
	if !ctx.cr[6].eq {
	pc = 0x825A01FC; continue 'dispatch;
	}
	// 825A01E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A01E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A01EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A01F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A01F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A01F8: 48000018  b 0x825a0210
	pc = 0x825A0210; continue 'dispatch;
	// 825A01FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A0200: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0204: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0208: 48000008  b 0x825a0210
	pc = 0x825A0210; continue 'dispatch;
	// 825A020C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A0210: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825A0214: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0218: 419A0018  beq cr6, 0x825a0230
	if ctx.cr[6].eq {
	pc = 0x825A0230; continue 'dispatch;
	}
	// 825A021C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825A0220: C1AB0088  lfs f13, 0x88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A0224: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A0228: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A022C: 41990048  bgt cr6, 0x825a0274
	if ctx.cr[6].gt {
	pc = 0x825A0274; continue 'dispatch;
	}
	// 825A0230: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0238: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A023C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0240: 812A004C  lwz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A0244: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825A0248: 4E800421  bctrl
	ctx.lr = 0x825A024C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0290 size=232
    let mut pc: u32 = 0x825A0290;
    'dispatch: loop {
        match pc {
            0x825A0290 => {
    //   block [0x825A0290..0x825A0378)
	// 825A0290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0294: 48709179  bl 0x82ca940c
	ctx.lr = 0x825A0298;
	sub_82CA93D0(ctx, base);
	// 825A0298: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A029C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A02A0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825A02A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A02A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825A02AC: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 825A02B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A02B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A02B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A02BC: 4BC8CC15  bl 0x8222ced0
	ctx.lr = 0x825A02C0;
	sub_8222CED0(ctx, base);
	// 825A02C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825A02C4: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 825A02C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A02CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A02D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A02D4: 419A0008  beq cr6, 0x825a02dc
	if ctx.cr[6].eq {
	pc = 0x825A02DC; continue 'dispatch;
	}
	// 825A02D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A02DC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825A02E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A02E4: 4BDEFDA5  bl 0x82390088
	ctx.lr = 0x825A02E8;
	sub_82390088(ctx, base);
	// 825A02E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A02EC: 4BC74AED  bl 0x82214dd8
	ctx.lr = 0x825A02F0;
	sub_82214DD8(ctx, base);
	// 825A02F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A02F4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A02F8: 4BC3A051  bl 0x821da348
	ctx.lr = 0x825A02FC;
	sub_821DA348(ctx, base);
	// 825A02FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A0300: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0304: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825A0308: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825A030C: 38894CE0  addi r4, r9, 0x4ce0
	ctx.r[4].s64 = ctx.r[9].s64 + 19680;
	// 825A0310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0314: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0318: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A031C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0320: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825A0324: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825A0328: 4BC8CBA9  bl 0x8222ced0
	ctx.lr = 0x825A032C;
	sub_8222CED0(ctx, base);
	// 825A032C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A0330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A0334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0338: 419A0008  beq cr6, 0x825a0340
	if ctx.cr[6].eq {
	pc = 0x825A0340; continue 'dispatch;
	}
	// 825A033C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0340: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825A0344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0348: 4BDEFD41  bl 0x82390088
	ctx.lr = 0x825A034C;
	sub_82390088(ctx, base);
	// 825A034C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0350: 4BC74A89  bl 0x82214dd8
	ctx.lr = 0x825A0354;
	sub_82214DD8(ctx, base);
	// 825A0354: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0358: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A035C: 4BC39FED  bl 0x821da348
	ctx.lr = 0x825A0360;
	sub_821DA348(ctx, base);
	// 825A0360: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0364: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825A0368: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A036C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825A0370: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A0374: 487090E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0378 size=96
    let mut pc: u32 = 0x825A0378;
    'dispatch: loop {
        match pc {
            0x825A0378 => {
    //   block [0x825A0378..0x825A03D8)
	// 825A0378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A037C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0380: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0384: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A038C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825A0390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0394: 419A0030  beq cr6, 0x825a03c4
	if ctx.cr[6].eq {
	pc = 0x825A03C4; continue 'dispatch;
	}
	// 825A0398: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A039C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A03A0: 38EB0EBC  addi r7, r11, 0xebc
	ctx.r[7].s64 = ctx.r[11].s64 + 3772;
	// 825A03A4: 4BC12155  bl 0x821b24f8
	ctx.lr = 0x825A03A8;
	sub_821B24F8(ctx, base);
	// 825A03A8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825A03AC: 4BED2455  bl 0x82472800
	ctx.lr = 0x825A03B0;
	sub_82472800(ctx, base);
	// 825A03B0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A03B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A03B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A03BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A03C0: 4E800020  blr
	return;
	// 825A03C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825A03C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A03CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A03D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A03D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A03D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A03D8 size=84
    let mut pc: u32 = 0x825A03D8;
    'dispatch: loop {
        match pc {
            0x825A03D8 => {
    //   block [0x825A03D8..0x825A042C)
	// 825A03D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A03DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A03E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A03E4: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 825A03E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A03EC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825A03F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A03F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A03F8: 419A0024  beq cr6, 0x825a041c
	if ctx.cr[6].eq {
	pc = 0x825A041C; continue 'dispatch;
	}
	// 825A03FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A0400: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825A0404: 38EA0EBC  addi r7, r10, 0xebc
	ctx.r[7].s64 = ctx.r[10].s64 + 3772;
	// 825A0408: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A040C: 4BC120ED  bl 0x821b24f8
	ctx.lr = 0x825A0410;
	sub_821B24F8(ctx, base);
	// 825A0410: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825A0414: 4BED23ED  bl 0x82472800
	ctx.lr = 0x825A0418;
	sub_82472800(ctx, base);
	// 825A0418: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A041C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A0420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A0424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A0428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0430 size=132
    let mut pc: u32 = 0x825A0430;
    'dispatch: loop {
        match pc {
            0x825A0430 => {
    //   block [0x825A0430..0x825A04B4)
	// 825A0430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A0438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A043C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A0440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0444: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A0448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A044C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0450: 4BFFFF29  bl 0x825a0378
	ctx.lr = 0x825A0454;
	sub_825A0378(ctx, base);
	// 825A0454: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 825A0458: 409A0014  bne cr6, 0x825a046c
	if !ctx.cr[6].eq {
	pc = 0x825A046C; continue 'dispatch;
	}
	// 825A045C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0460: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0464: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0468: 4800002C  b 0x825a0494
	pc = 0x825A0494; continue 'dispatch;
	// 825A046C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0470: 4BFFFF69  bl 0x825a03d8
	ctx.lr = 0x825A0474;
	sub_825A03D8(ctx, base);
	// 825A0474: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 825A0478: 409A0014  bne cr6, 0x825a048c
	if !ctx.cr[6].eq {
	pc = 0x825A048C; continue 'dispatch;
	}
	// 825A047C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0480: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0484: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A0488: 4800000C  b 0x825a0494
	pc = 0x825A0494; continue 'dispatch;
	// 825A048C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A0490: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A0494: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A0498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A049C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A04A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A04A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A04A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A04AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A04B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A04B8 size=208
    let mut pc: u32 = 0x825A04B8;
    'dispatch: loop {
        match pc {
            0x825A04B8 => {
    //   block [0x825A04B8..0x825A0588)
	// 825A04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A04BC: 48708F45  bl 0x82ca9400
	ctx.lr = 0x825A04C0;
	sub_82CA93D0(ctx, base);
	// 825A04C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A04C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825A04C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825A04CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825A04D0: 38EB4D50  addi r7, r11, 0x4d50
	ctx.r[7].s64 = ctx.r[11].s64 + 19792;
	// 825A04D4: 4BC12025  bl 0x821b24f8
	ctx.lr = 0x825A04D8;
	sub_821B24F8(ctx, base);
	// 825A04D8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825A04DC: 4BD0950D  bl 0x822a99e8
	ctx.lr = 0x825A04E0;
	sub_822A99E8(ctx, base);
	// 825A04E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A04E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825A04E8: 419A0098  beq cr6, 0x825a0580
	if ctx.cr[6].eq {
	pc = 0x825A0580; continue 'dispatch;
	}
	// 825A04EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A04F0: 484604A1  bl 0x82a00990
	ctx.lr = 0x825A04F4;
	sub_82A00990(ctx, base);
	// 825A04F4: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825A04F8: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825A04FC: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A0500: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825A0504: 419A0074  beq cr6, 0x825a0578
	if ctx.cr[6].eq {
	pc = 0x825A0578; continue 'dispatch;
	}
	// 825A0508: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825A050C: 3F80834A  lis r28, -0x7cb6
	ctx.r[28].s64 = -2092302336;
	// 825A0510: 3BABE460  addi r29, r11, -0x1ba0
	ctx.r[29].s64 = ctx.r[11].s64 + -7072;
	// 825A0514: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A0518: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825A051C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A0520: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825A0524: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0528: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A052C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825A0530: 419A0020  beq cr6, 0x825a0550
	if ctx.cr[6].eq {
	pc = 0x825A0550; continue 'dispatch;
	}
	// 825A0534: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825A0538: 409A0018  bne cr6, 0x825a0550
	if !ctx.cr[6].eq {
	pc = 0x825A0550; continue 'dispatch;
	}
	// 825A053C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0540: 813CE454  lwz r9, -0x1bac(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825A0544: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A0548: 409A0008  bne cr6, 0x825a0550
	if !ctx.cr[6].eq {
	pc = 0x825A0550; continue 'dispatch;
	}
	// 825A054C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825A0550: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0558: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825A055C: 419A0010  beq cr6, 0x825a056c
	if ctx.cr[6].eq {
	pc = 0x825A056C; continue 'dispatch;
	}
	// 825A0560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0564: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825A0568: 4BD55AE9  bl 0x822f6050
	ctx.lr = 0x825A056C;
	sub_822F6050(ctx, base);
	// 825A056C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A0570: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825A0574: 409AFFA0  bne cr6, 0x825a0514
	if !ctx.cr[6].eq {
	pc = 0x825A0514; continue 'dispatch;
	}
	// 825A0578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A057C: 4BC7B7BD  bl 0x8221bd38
	ctx.lr = 0x825A0580;
	sub_8221BD38(ctx, base);
	// 825A0580: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A0584: 48708ECC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0588 size=16
    let mut pc: u32 = 0x825A0588;
    'dispatch: loop {
        match pc {
            0x825A0588 => {
    //   block [0x825A0588..0x825A0598)
	// 825A0588: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A058C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0590: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0594: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A0598 size=88
    let mut pc: u32 = 0x825A0598;
    'dispatch: loop {
        match pc {
            0x825A0598 => {
    //   block [0x825A0598..0x825A05F0)
	// 825A0598: 7D0A5050  subf r8, r10, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 825A059C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825A05A0: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 825A05A4: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A05A8: 54E82036  slwi r8, r7, 4
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A05AC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825A05B0: 419A0038  beq cr6, 0x825a05e8
	if ctx.cr[6].eq {
	pc = 0x825A05E8; continue 'dispatch;
	}
	// 825A05B4: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825A05B8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A05BC: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825A05C0: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 825A05C4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A05C8: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825A05CC: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A05D0: 90860008  stw r4, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825A05D4: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A05D8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A05DC: 90E6000C  stw r7, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825A05E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A05E4: 409AFFD4  bne cr6, 0x825a05b8
	if !ctx.cr[6].eq {
	pc = 0x825A05B8; continue 'dispatch;
	}
	// 825A05E8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825A05EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A05F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A05F0 size=220
    let mut pc: u32 = 0x825A05F0;
    'dispatch: loop {
        match pc {
            0x825A05F0 => {
    //   block [0x825A05F0..0x825A06CC)
	// 825A05F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A05F4: 48708E19  bl 0x82ca940c
	ctx.lr = 0x825A05F8;
	sub_82CA93D0(ctx, base);
	// 825A05F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A05FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A0600: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A0604: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0608: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 825A060C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0614: 419A0014  beq cr6, 0x825a0628
	if ctx.cr[6].eq {
	pc = 0x825A0628; continue 'dispatch;
	}
	// 825A0618: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A061C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0620: 7D292671  srawi. r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825A0624: 4082000C  bne 0x825a0630
	if !ctx.cr[0].eq {
	pc = 0x825A0630; continue 'dispatch;
	}
	// 825A0628: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A062C: 48000034  b 0x825a0660
	pc = 0x825A0660; continue 'dispatch;
	// 825A0630: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0634: 40990008  ble cr6, 0x825a063c
	if !ctx.cr[6].gt {
	pc = 0x825A063C; continue 'dispatch;
	}
	// 825A0638: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825A063C: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825A0640: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0644: 419A000C  beq cr6, 0x825a0650
	if ctx.cr[6].eq {
	pc = 0x825A0650; continue 'dispatch;
	}
	// 825A0648: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825A064C: 419A0008  beq cr6, 0x825a0654
	if ctx.cr[6].eq {
	pc = 0x825A0654; continue 'dispatch;
	}
	// 825A0650: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825A0654: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825A0658: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A065C: 7D3E2670  srawi r30, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 825A0660: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A0664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0668: 48000069  bl 0x825a06d0
	ctx.lr = 0x825A066C;
	sub_825A06D0(ctx, base);
	// 825A066C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0670: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0674: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0678: 40990008  ble cr6, 0x825a0680
	if !ctx.cr[6].gt {
	pc = 0x825A0680; continue 'dispatch;
	}
	// 825A067C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825A0680: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A0684: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0688: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A068C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A0690: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A0694: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A0698: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A069C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825A06A0: 41990010  bgt cr6, 0x825a06b0
	if ctx.cr[6].gt {
	pc = 0x825A06B0; continue 'dispatch;
	}
	// 825A06A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A06A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A06AC: 40980008  bge cr6, 0x825a06b4
	if !ctx.cr[6].lt {
	pc = 0x825A06B4; continue 'dispatch;
	}
	// 825A06B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825A06B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A06B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A06BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A06C0: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825A06C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A06C8: 48708D94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A06D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A06D0 size=1016
    let mut pc: u32 = 0x825A06D0;
    'dispatch: loop {
        match pc {
            0x825A06D0 => {
    //   block [0x825A06D0..0x825A0AC8)
	// 825A06D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A06D4: 48708D29  bl 0x82ca93fc
	ctx.lr = 0x825A06D8;
	sub_82CA93D0(ctx, base);
	// 825A06D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A06DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A06E0: 83E60000  lwz r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A06E4: 83660004  lwz r27, 4(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A06E8: 83460008  lwz r26, 8(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A06EC: 8326000C  lwz r25, 0xc(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A06F0: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 825A06F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A06F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825A06FC: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825A0700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0704: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 825A0708: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825A070C: 409A000C  bne cr6, 0x825a0718
	if !ctx.cr[6].eq {
	pc = 0x825A0718; continue 'dispatch;
	}
	// 825A0710: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A0714: 48000010  b 0x825a0724
	pc = 0x825A0724; continue 'dispatch;
	// 825A0718: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A071C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0720: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 825A0724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0728: 409A000C  bne cr6, 0x825a0734
	if !ctx.cr[6].eq {
	pc = 0x825A0734; continue 'dispatch;
	}
	// 825A072C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A0730: 48000010  b 0x825a0740
	pc = 0x825A0740; continue 'dispatch;
	// 825A0734: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0738: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A073C: 7D0A2670  srawi r10, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 825A0740: 3D000FFF  lis r8, 0xfff
	ctx.r[8].s64 = 268369920;
	// 825A0744: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 825A0748: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825A074C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825A0750: 40980010  bge cr6, 0x825a0760
	if !ctx.cr[6].lt {
	pc = 0x825A0760; continue 'dispatch;
	}
	// 825A0754: 4BF5437D  bl 0x824f4ad0
	ctx.lr = 0x825A0758;
	sub_824F4AD0(ctx, base);
	// 825A0758: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A075C: 48708CF0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 825A0760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0764: 409A000C  bne cr6, 0x825a0770
	if !ctx.cr[6].eq {
	pc = 0x825A0770; continue 'dispatch;
	}
	// 825A0768: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A076C: 48000010  b 0x825a077c
	pc = 0x825A077C; continue 'dispatch;
	// 825A0770: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0774: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0778: 7CEA2670  srawi r10, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 4) as i64;
	// 825A077C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A0780: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0784: 4098017C  bge cr6, 0x825a0900
	if !ctx.cr[6].lt {
	pc = 0x825A0900; continue 'dispatch;
	}
	// 825A0788: 552AF87E  srwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A078C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A0790: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825A0794: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A0798: 41980008  blt cr6, 0x825a07a0
	if ctx.cr[6].lt {
	pc = 0x825A07A0; continue 'dispatch;
	}
	// 825A079C: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825A07A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A07A4: 409A000C  bne cr6, 0x825a07b0
	if !ctx.cr[6].eq {
	pc = 0x825A07B0; continue 'dispatch;
	}
	// 825A07A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A07AC: 48000010  b 0x825a07bc
	pc = 0x825A07BC; continue 'dispatch;
	// 825A07B0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A07B4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A07B8: 7D2A2670  srawi r10, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 825A07BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A07C0: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A07C4: 4098001C  bge cr6, 0x825a07e0
	if !ctx.cr[6].lt {
	pc = 0x825A07E0; continue 'dispatch;
	}
	// 825A07C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A07CC: 419A0010  beq cr6, 0x825a07dc
	if ctx.cr[6].eq {
	pc = 0x825A07DC; continue 'dispatch;
	}
	// 825A07D0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A07D4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A07D8: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 825A07DC: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 825A07E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A07E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A07E8: 4BE82A51  bl 0x82423238
	ctx.lr = 0x825A07EC;
	sub_82423238(ctx, base);
	// 825A07EC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A07F0: 812100BC  lwz r9, 0xbc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825A07F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A07F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A07FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A0800: 419A003C  beq cr6, 0x825a083c
	if ctx.cr[6].eq {
	pc = 0x825A083C; continue 'dispatch;
	}
	// 825A0804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0808: 419A0024  beq cr6, 0x825a082c
	if ctx.cr[6].eq {
	pc = 0x825A082C; continue 'dispatch;
	}
	// 825A080C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0810: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A0814: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0818: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825A081C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0820: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825A0824: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0828: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825A082C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825A0830: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A0834: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A0838: 409AFFCC  bne cr6, 0x825a0804
	if !ctx.cr[6].eq {
	pc = 0x825A0804; continue 'dispatch;
	}
	// 825A083C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0840: 419A0014  beq cr6, 0x825a0854
	if ctx.cr[6].eq {
	pc = 0x825A0854; continue 'dispatch;
	}
	// 825A0844: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825A0848: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825A084C: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825A0850: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 825A0854: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0858: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 825A085C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A0860: 419A004C  beq cr6, 0x825a08ac
	if ctx.cr[6].eq {
	pc = 0x825A08AC; continue 'dispatch;
	}
	// 825A0864: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A0868: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825A086C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825A0870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0874: 419A0024  beq cr6, 0x825a0898
	if ctx.cr[6].eq {
	pc = 0x825A0898; continue 'dispatch;
	}
	// 825A0878: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825A087C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0880: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0884: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825A0888: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A088C: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825A0890: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0894: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825A0898: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A089C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825A08A0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 825A08A4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A08A8: 409AFFC8  bne cr6, 0x825a0870
	if !ctx.cr[6].eq {
	pc = 0x825A0870; continue 'dispatch;
	}
	// 825A08AC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A08B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A08B4: 409A000C  bne cr6, 0x825a08c0
	if !ctx.cr[6].eq {
	pc = 0x825A08C0; continue 'dispatch;
	}
	// 825A08B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A08BC: 48000010  b 0x825a08cc
	pc = 0x825A08CC; continue 'dispatch;
	// 825A08C0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A08C4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825A08C8: 7D4B2670  srawi r11, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 825A08CC: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 825A08D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A08D4: 419A0008  beq cr6, 0x825a08dc
	if ctx.cr[6].eq {
	pc = 0x825A08DC; continue 'dispatch;
	}
	// 825A08D8: 4BC7B461  bl 0x8221bd38
	ctx.lr = 0x825A08DC;
	sub_8221BD38(ctx, base);
	// 825A08DC: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A08E0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A08E4: 57EA2036  slwi r10, r31, 4
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A08E8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825A08EC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825A08F0: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825A08F4: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A08F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A08FC: 48708B50  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 825A0900: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825A0904: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0908: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 825A090C: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 825A0910: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825A0914: 409800E0  bge cr6, 0x825a09f4
	if !ctx.cr[6].lt {
	pc = 0x825A09F4; continue 'dispatch;
	}
	// 825A0918: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 825A091C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A0920: 419A0044  beq cr6, 0x825a0964
	if ctx.cr[6].eq {
	pc = 0x825A0964; continue 'dispatch;
	}
	// 825A0924: 396AFFF4  addi r11, r10, -0xc
	ctx.r[11].s64 = ctx.r[10].s64 + -12;
	// 825A0928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A092C: 419A0024  beq cr6, 0x825a0950
	if ctx.cr[6].eq {
	pc = 0x825A0950; continue 'dispatch;
	}
	// 825A0930: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825A0934: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0938: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A093C: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 825A0940: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0944: 90AB0014  stw r5, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 825A0948: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A094C: 908B0018  stw r4, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 825A0950: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A0954: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825A0958: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 825A095C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A0960: 409AFFC8  bne cr6, 0x825a0928
	if !ctx.cr[6].eq {
	pc = 0x825A0928; continue 'dispatch;
	}
	// 825A0964: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0968: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 825A096C: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 825A0970: 21490001  subfic r10, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[9].s64;
	// 825A0974: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0978: 419A0028  beq cr6, 0x825a09a0
	if ctx.cr[6].eq {
	pc = 0x825A09A0; continue 'dispatch;
	}
	// 825A097C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0980: 419A0014  beq cr6, 0x825a0994
	if ctx.cr[6].eq {
	pc = 0x825A0994; continue 'dispatch;
	}
	// 825A0984: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825A0988: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825A098C: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825A0990: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 825A0994: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A0998: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A099C: 4082FFE0  bne 0x825a097c
	if !ctx.cr[0].eq {
	pc = 0x825A097C; continue 'dispatch;
	}
	// 825A09A0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A09A4: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825A09A8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825A09AC: 392AFFF0  addi r9, r10, -0x10
	ctx.r[9].s64 = ctx.r[10].s64 + -16;
	// 825A09B0: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A09B4: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A09B8: 419A0108  beq cr6, 0x825a0ac0
	if ctx.cr[6].eq {
	pc = 0x825A0AC0; continue 'dispatch;
	}
	// 825A09BC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825A09C0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A09C4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A09C8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A09CC: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A09D0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A09D4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825A09D8: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825A09DC: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825A09E0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A09E4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A09E8: 409AFFD4  bne cr6, 0x825a09bc
	if !ctx.cr[6].eq {
	pc = 0x825A09BC; continue 'dispatch;
	}
	// 825A09EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A09F0: 48708A5C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 825A09F4: 3968FFF0  addi r11, r8, -0x10
	ctx.r[11].s64 = ctx.r[8].s64 + -16;
	// 825A09F8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825A09FC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825A0A00: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A0A04: 419A003C  beq cr6, 0x825a0a40
	if ctx.cr[6].eq {
	pc = 0x825A0A40; continue 'dispatch;
	}
	// 825A0A08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A0A0C: 419A0024  beq cr6, 0x825a0a30
	if ctx.cr[6].eq {
	pc = 0x825A0A30; continue 'dispatch;
	}
	// 825A0A10: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0A14: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825A0A18: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0A1C: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825A0A20: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0A24: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825A0A28: 8069000C  lwz r3, 0xc(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0A2C: 906A000C  stw r3, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 825A0A30: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 825A0A34: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825A0A38: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A0A3C: 409AFFCC  bne cr6, 0x825a0a08
	if !ctx.cr[6].eq {
	pc = 0x825A0A08; continue 'dispatch;
	}
	// 825A0A40: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A0A44: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A0A48: 419A0038  beq cr6, 0x825a0a80
	if ctx.cr[6].eq {
	pc = 0x825A0A80; continue 'dispatch;
	}
	// 825A0A4C: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 825A0A50: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825A0A54: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 825A0A58: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825A0A5C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0A60: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0A64: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0A68: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825A0A6C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0A70: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825A0A74: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0A78: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825A0A7C: 409AFFD4  bne cr6, 0x825a0a50
	if !ctx.cr[6].eq {
	pc = 0x825A0A50; continue 'dispatch;
	}
	// 825A0A80: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 825A0A84: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825A0A88: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0A8C: 419A0034  beq cr6, 0x825a0ac0
	if ctx.cr[6].eq {
	pc = 0x825A0AC0; continue 'dispatch;
	}
	// 825A0A90: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825A0A94: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0A98: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0A9C: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0AA0: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A0AA4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A0AA8: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825A0AAC: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825A0AB0: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825A0AB4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825A0AB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A0ABC: 409AFFD4  bne cr6, 0x825a0a90
	if !ctx.cr[6].eq {
	pc = 0x825A0A90; continue 'dispatch;
	}
	// 825A0AC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A0AC4: 48708988  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0AC8 size=268
    let mut pc: u32 = 0x825A0AC8;
    'dispatch: loop {
        match pc {
            0x825A0AC8 => {
    //   block [0x825A0AC8..0x825A0BD4)
	// 825A0AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0ACC: 48708941  bl 0x82ca940c
	ctx.lr = 0x825A0AD0;
	sub_82CA93D0(ctx, base);
	// 825A0AD0: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0AD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0AD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A0ADC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A0AE0: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825A0AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0AE8: 409900E4  ble cr6, 0x825a0bcc
	if !ctx.cr[6].gt {
	pc = 0x825A0BCC; continue 'dispatch;
	}
	// 825A0AEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A0AF4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0AF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A0AFC: 4E800421  bctrl
	ctx.lr = 0x825A0B00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0B00: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825A0B04: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 825A0B08: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825A0B0C: 419A0010  beq cr6, 0x825a0b1c
	if ctx.cr[6].eq {
	pc = 0x825A0B1C; continue 'dispatch;
	}
	// 825A0B10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A0B14: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825A0B18: 48000010  b 0x825a0b28
	pc = 0x825A0B28; continue 'dispatch;
	// 825A0B1C: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825A0B20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0B24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A0B28: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825A0B2C: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825A0B30: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825A0B34: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825A0B38: 486E74A9  bl 0x82c87fe0
	ctx.lr = 0x825A0B3C;
	sub_82C87FE0(ctx, base);
	// 825A0B3C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A0B40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A0B44: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825A0B48: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825A0B4C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825A0B50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0B54: 486E744D  bl 0x82c87fa0
	ctx.lr = 0x825A0B58;
	sub_82C87FA0(ctx, base);
	// 825A0B58: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825A0B5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A0B60: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825A0B64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0B68: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825A0B6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0B70: 4BD68FC9  bl 0x82309b38
	ctx.lr = 0x825A0B74;
	sub_82309B38(ctx, base);
	// 825A0B74: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825A0B78: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0B7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A0B80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0B84: 80C70070  lwz r6, 0x70(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(112 as u32) ) } as u64;
	// 825A0B88: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825A0B8C: 4E800421  bctrl
	ctx.lr = 0x825A0B90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0B90: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825A0B94: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0B98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A0B9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0BA0: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 825A0BA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A0BA8: 4E800421  bctrl
	ctx.lr = 0x825A0BAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0BAC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A0BB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0BB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A0BB8: 4BD948C1  bl 0x82335478
	ctx.lr = 0x825A0BBC;
	sub_82335478(ctx, base);
	// 825A0BBC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825A0BC0: 485F62B9  bl 0x82b96e78
	ctx.lr = 0x825A0BC4;
	sub_82B96E78(ctx, base);
	// 825A0BC4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825A0BC8: 485F62B1  bl 0x82b96e78
	ctx.lr = 0x825A0BCC;
	sub_82B96E78(ctx, base);
	// 825A0BCC: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825A0BD0: 4870888C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0BD8 size=584
    let mut pc: u32 = 0x825A0BD8;
    'dispatch: loop {
        match pc {
            0x825A0BD8 => {
    //   block [0x825A0BD8..0x825A0E20)
	// 825A0BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0BDC: 48708825  bl 0x82ca9400
	ctx.lr = 0x825A0BE0;
	sub_82CA93D0(ctx, base);
	// 825A0BE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0BE4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0BE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A0BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0BF0: 409A0010  bne cr6, 0x825a0c00
	if !ctx.cr[6].eq {
	pc = 0x825A0C00; continue 'dispatch;
	}
	// 825A0BF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825A0BF8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 825A0BFC: 48000008  b 0x825a0c04
	pc = 0x825A0C04; continue 'dispatch;
	// 825A0C00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C04: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0C08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0C0C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C10: 4BE2D9B1  bl 0x823ce5c0
	ctx.lr = 0x825A0C14;
	sub_823CE5C0(ctx, base);
	// 825A0C14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A0C18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0C1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0C20: 4BE2D5E1  bl 0x823ce200
	ctx.lr = 0x825A0C24;
	sub_823CE200(ctx, base);
	// 825A0C24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0C28: 4BC16EF1  bl 0x821b7b18
	ctx.lr = 0x825A0C2C;
	sub_821B7B18(ctx, base);
	// 825A0C2C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825A0C30: 4BC7E629  bl 0x8221f258
	ctx.lr = 0x825A0C34;
	sub_8221F258(ctx, base);
	// 825A0C34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0C38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A0C3C: 419A0040  beq cr6, 0x825a0c7c
	if ctx.cr[6].eq {
	pc = 0x825A0C7C; continue 'dispatch;
	}
	// 825A0C40: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 825A0C44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825A0C48: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 825A0C4C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A0C50: 4BC7E609  bl 0x8221f258
	ctx.lr = 0x825A0C54;
	sub_8221F258(ctx, base);
	// 825A0C54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A0C58: 419A0028  beq cr6, 0x825a0c80
	if ctx.cr[6].eq {
	pc = 0x825A0C80; continue 'dispatch;
	}
	// 825A0C5C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825A0C60: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825A0C64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0C68: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825A0C6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A0C70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A0C74: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825A0C78: 4800000C  b 0x825a0c84
	pc = 0x825A0C84; continue 'dispatch;
	// 825A0C7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A0C80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A0C84: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A0C88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A0C8C: 419A00FC  beq cr6, 0x825a0d88
	if ctx.cr[6].eq {
	pc = 0x825A0D88; continue 'dispatch;
	}
	// 825A0C90: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0C94: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A0C98: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0C9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825A0CA0: 4BC88469  bl 0x82229108
	ctx.lr = 0x825A0CA4;
	sub_82229108(ctx, base);
	// 825A0CA4: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A0CA8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A0CAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825A0CB0: 3BCB1028  addi r30, r11, 0x1028
	ctx.r[30].s64 = ctx.r[11].s64 + 4136;
	// 825A0CB4: 4BC86BCD  bl 0x82227880
	ctx.lr = 0x825A0CB8;
	sub_82227880(ctx, base);
	// 825A0CB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A0CBC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 825A0CC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A0CC4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 825A0CC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825A0CCC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825A0CD0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A0CD4: 4BBF9DAD  bl 0x8219aa80
	ctx.lr = 0x825A0CD8;
	sub_8219AA80(ctx, base);
	// 825A0CD8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825A0CDC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A0CE0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 825A0CE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0CE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A0CEC: 4BE2D735  bl 0x823ce420
	ctx.lr = 0x825A0CF0;
	sub_823CE420(ctx, base);
	// 825A0CF0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A0CF4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A0CF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825A0CFC: 484839CD  bl 0x82a246c8
	ctx.lr = 0x825A0D00;
	sub_82A246C8(ctx, base);
	// 825A0D00: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0D04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A0D08: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825A0D0C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825A0D10: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0D14: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0D18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0D1C: 4BC883ED  bl 0x82229108
	ctx.lr = 0x825A0D20;
	sub_82229108(ctx, base);
	// 825A0D20: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 825A0D24: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A0D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0D2C: 3BEB6B40  addi r31, r11, 0x6b40
	ctx.r[31].s64 = ctx.r[11].s64 + 27456;
	// 825A0D30: 4BC86B51  bl 0x82227880
	ctx.lr = 0x825A0D34;
	sub_82227880(ctx, base);
	// 825A0D34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825A0D38: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 825A0D3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A0D40: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 825A0D44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0D48: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825A0D4C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825A0D50: 4BBF9D31  bl 0x8219aa80
	ctx.lr = 0x825A0D54;
	sub_8219AA80(ctx, base);
	// 825A0D54: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 825A0D58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A0D5C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 825A0D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0D64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0D68: 4BE2D6B9  bl 0x823ce420
	ctx.lr = 0x825A0D6C;
	sub_823CE420(ctx, base);
	// 825A0D6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0D70: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A0D74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A0D78: 48483951  bl 0x82a246c8
	ctx.lr = 0x825A0D7C;
	sub_82A246C8(ctx, base);
	// 825A0D7C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0D80: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 825A0D84: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825A0D88: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825A0D8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825A0D90: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825A0D94: 419A0020  beq cr6, 0x825a0db4
	if ctx.cr[6].eq {
	pc = 0x825A0DB4; continue 'dispatch;
	}
	// 825A0D98: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825A0D9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0DA0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825A0DA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825A0DA8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A0DAC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0DB0: 4082FFE8  bne 0x825a0d98
	if !ctx.cr[0].eq {
	pc = 0x825A0D98; continue 'dispatch;
	}
	// 825A0DB4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0DB8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825A0DBC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825A0DC0: 4BD54B89  bl 0x822f5948
	ctx.lr = 0x825A0DC4;
	sub_822F5948(ctx, base);
	// 825A0DC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0DC8: 4BC16D51  bl 0x821b7b18
	ctx.lr = 0x825A0DCC;
	sub_821B7B18(ctx, base);
	// 825A0DCC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825A0DD0: 419A0040  beq cr6, 0x825a0e10
	if ctx.cr[6].eq {
	pc = 0x825A0E10; continue 'dispatch;
	}
	// 825A0DD4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825A0DD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0DDC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825A0DE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A0DE4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A0DE8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0DEC: 4082FFE8  bne 0x825a0dd4
	if !ctx.cr[0].eq {
	pc = 0x825A0DD4; continue 'dispatch;
	}
	// 825A0DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0DF4: 409A001C  bne cr6, 0x825a0e10
	if !ctx.cr[6].eq {
	pc = 0x825A0E10; continue 'dispatch;
	}
	// 825A0DF8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0DFC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0E00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A0E04: 4E800421  bctrl
	ctx.lr = 0x825A0E08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A0E08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825A0E0C: 4BC7AF2D  bl 0x8221bd38
	ctx.lr = 0x825A0E10;
	sub_8221BD38(ctx, base);
	// 825A0E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0E14: 4BC16D05  bl 0x821b7b18
	ctx.lr = 0x825A0E18;
	sub_821B7B18(ctx, base);
	// 825A0E18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A0E1C: 48708634  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A0E20 size=516
    let mut pc: u32 = 0x825A0E20;
    'dispatch: loop {
        match pc {
            0x825A0E20 => {
    //   block [0x825A0E20..0x825A1024)
	// 825A0E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A0E24: 487085D9  bl 0x82ca93fc
	ctx.lr = 0x825A0E28;
	sub_82CA93D0(ctx, base);
	// 825A0E28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A0E2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A0E30: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 825A0E34: 3D40825A  lis r10, -0x7da6
	ctx.r[10].s64 = -2108030976;
	// 825A0E38: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 825A0E3C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825A0E40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0E44: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825A0E48: 3BAAF610  addi r29, r10, -0x9f0
	ctx.r[29].s64 = ctx.r[10].s64 + -2544;
	// 825A0E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0E50: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825A0E54: 419A0008  beq cr6, 0x825a0e5c
	if ctx.cr[6].eq {
	pc = 0x825A0E5C; continue 'dispatch;
	}
	// 825A0E58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0E5C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0E60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0E64: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0E68: 4BE2D759  bl 0x823ce5c0
	ctx.lr = 0x825A0E6C;
	sub_823CE5C0(ctx, base);
	// 825A0E6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A0E70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0E74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0E78: 4BE2D299  bl 0x823ce110
	ctx.lr = 0x825A0E7C;
	sub_823CE110(ctx, base);
	// 825A0E7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A0E80: 4BC16C99  bl 0x821b7b18
	ctx.lr = 0x825A0E84;
	sub_821B7B18(ctx, base);
	// 825A0E84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825A0E88: 4BC7E3D1  bl 0x8221f258
	ctx.lr = 0x825A0E8C;
	sub_8221F258(ctx, base);
	// 825A0E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A0E90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A0E94: 419A005C  beq cr6, 0x825a0ef0
	if ctx.cr[6].eq {
	pc = 0x825A0EF0; continue 'dispatch;
	}
	// 825A0E98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825A0E9C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A0EA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A0EA4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 825A0EA8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A0EAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A0EB0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A0EB4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825A0EB8: 4BC4F389  bl 0x821f0240
	ctx.lr = 0x825A0EBC;
	sub_821F0240(ctx, base);
	// 825A0EBC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825A0EC0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825A0EC4: 4BC7E395  bl 0x8221f258
	ctx.lr = 0x825A0EC8;
	sub_8221F258(ctx, base);
	// 825A0EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A0ECC: 419A0028  beq cr6, 0x825a0ef4
	if ctx.cr[6].eq {
	pc = 0x825A0EF4; continue 'dispatch;
	}
	// 825A0ED0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825A0ED4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825A0ED8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A0EDC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825A0EE0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A0EE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A0EE8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825A0EEC: 4800000C  b 0x825a0ef8
	pc = 0x825A0EF8; continue 'dispatch;
	// 825A0EF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A0EF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A0EF8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0EFC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825A0F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0F04: 419A0008  beq cr6, 0x825a0f0c
	if ctx.cr[6].eq {
	pc = 0x825A0F0C; continue 'dispatch;
	}
	// 825A0F08: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0F0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A0F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A0F14: 419A0078  beq cr6, 0x825a0f8c
	if ctx.cr[6].eq {
	pc = 0x825A0F8C; continue 'dispatch;
	}
	// 825A0F18: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A0F1C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A0F20: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0F24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A0F28: 4BC881E1  bl 0x82229108
	ctx.lr = 0x825A0F2C;
	sub_82229108(ctx, base);
	// 825A0F2C: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A0F30: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A0F34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A0F38: 3BCB1068  addi r30, r11, 0x1068
	ctx.r[30].s64 = ctx.r[11].s64 + 4200;
	// 825A0F3C: 4BC86945  bl 0x82227880
	ctx.lr = 0x825A0F40;
	sub_82227880(ctx, base);
	// 825A0F40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A0F44: 3D40825A  lis r10, -0x7da6
	ctx.r[10].s64 = -2108030976;
	// 825A0F48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A0F4C: 388A11E0  addi r4, r10, 0x11e0
	ctx.r[4].s64 = ctx.r[10].s64 + 4576;
	// 825A0F50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A0F54: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A0F58: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A0F5C: 4BBF9B25  bl 0x8219aa80
	ctx.lr = 0x825A0F60;
	sub_8219AA80(ctx, base);
	// 825A0F60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0F64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A0F68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A0F6C: 4BE2D4B5  bl 0x823ce420
	ctx.lr = 0x825A0F70;
	sub_823CE420(ctx, base);
	// 825A0F70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A0F74: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A0F78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A0F7C: 4848374D  bl 0x82a246c8
	ctx.lr = 0x825A0F80;
	sub_82A246C8(ctx, base);
	// 825A0F80: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A0F84: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825A0F88: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825A0F8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825A0F90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A0F94: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825A0F98: 419A0020  beq cr6, 0x825a0fb8
	if ctx.cr[6].eq {
	pc = 0x825A0FB8; continue 'dispatch;
	}
	// 825A0F9C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825A0FA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0FA4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825A0FA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825A0FAC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A0FB0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0FB4: 4082FFE8  bne 0x825a0f9c
	if !ctx.cr[0].eq {
	pc = 0x825A0F9C; continue 'dispatch;
	}
	// 825A0FB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A0FBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A0FC0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825A0FC4: 4BD54985  bl 0x822f5948
	ctx.lr = 0x825A0FC8;
	sub_822F5948(ctx, base);
	// 825A0FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A0FCC: 4BC16B4D  bl 0x821b7b18
	ctx.lr = 0x825A0FD0;
	sub_821B7B18(ctx, base);
	// 825A0FD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A0FD4: 419A0040  beq cr6, 0x825a1014
	if ctx.cr[6].eq {
	pc = 0x825A1014; continue 'dispatch;
	}
	// 825A0FD8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825A0FDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0FE0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825A0FE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A0FE8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A0FEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A0FF0: 4082FFE8  bne 0x825a0fd8
	if !ctx.cr[0].eq {
	pc = 0x825A0FD8; continue 'dispatch;
	}
	// 825A0FF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A0FF8: 409A001C  bne cr6, 0x825a1014
	if !ctx.cr[6].eq {
	pc = 0x825A1014; continue 'dispatch;
	}
	// 825A0FFC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1000: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1004: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A1008: 4E800421  bctrl
	ctx.lr = 0x825A100C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A100C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A1010: 4BC7AD29  bl 0x8221bd38
	ctx.lr = 0x825A1014;
	sub_8221BD38(ctx, base);
	// 825A1014: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A1018: 4BC16B01  bl 0x821b7b18
	ctx.lr = 0x825A101C;
	sub_821B7B18(ctx, base);
	// 825A101C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A1020: 4870842C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1028 size=56
    let mut pc: u32 = 0x825A1028;
    'dispatch: loop {
        match pc {
            0x825A1028 => {
    //   block [0x825A1028..0x825A1060)
	// 825A1028: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825A102C: 419A0018  beq cr6, 0x825a1044
	if ctx.cr[6].eq {
	pc = 0x825A1044; continue 'dispatch;
	}
	// 825A1030: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A1034: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A1038: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A103C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A1040: 409A0008  bne cr6, 0x825a1048
	if !ctx.cr[6].eq {
	pc = 0x825A1048; continue 'dispatch;
	}
	// 825A1044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A1048: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A104C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1050: 419A0010  beq cr6, 0x825a1060
	if ctx.cr[6].eq {
		sub_825A1060(ctx, base);
		return;
	}
	// 825A1054: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 825A1058: 556377FE  rlwinm r3, r11, 0xe, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 825A105C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1060 size=8
    let mut pc: u32 = 0x825A1060;
    'dispatch: loop {
        match pc {
            0x825A1060 => {
    //   block [0x825A1060..0x825A1068)
	// 825A1060: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A1064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1068 size=376
    let mut pc: u32 = 0x825A1068;
    'dispatch: loop {
        match pc {
            0x825A1068 => {
    //   block [0x825A1068..0x825A11E0)
	// 825A1068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A106C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1070: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1074: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825A1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A107C: 419A0018  beq cr6, 0x825a1094
	if ctx.cr[6].eq {
	pc = 0x825A1094; continue 'dispatch;
	}
	// 825A1080: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A1084: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825A1088: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A108C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A1090: 409A0008  bne cr6, 0x825a1098
	if !ctx.cr[6].eq {
	pc = 0x825A1098; continue 'dispatch;
	}
	// 825A1094: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A1098: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825A109C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A10A0: 419A0130  beq cr6, 0x825a11d0
	if ctx.cr[6].eq {
	pc = 0x825A11D0; continue 'dispatch;
	}
	// 825A10A4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825A10A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A10AC: 552877FE  rlwinm r8, r9, 0xe, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0003FFFFu64;
	// 825A10B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825A10B4: 419A00F8  beq cr6, 0x825a11ac
	if ctx.cr[6].eq {
	pc = 0x825A11AC; continue 'dispatch;
	}
	// 825A10B8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A10BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A10C0: 419A0024  beq cr6, 0x825a10e4
	if ctx.cr[6].eq {
	pc = 0x825A10E4; continue 'dispatch;
	}
	// 825A10C4: 892A0052  lbz r9, 0x52(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(82 as u32) ) } as u64;
	// 825A10C8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A10CC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825A10D0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825A10D4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A10D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825A10DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A10E0: 480000D0  b 0x825a11b0
	pc = 0x825A11B0; continue 'dispatch;
	// 825A10E4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A10E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A10EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A10F0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A10F4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A10F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A10FC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A1100: 40810054  ble 0x825a1154
	if !ctx.cr[0].gt {
	pc = 0x825A1154; continue 'dispatch;
	}
	// 825A1104: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A1108: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A110C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A1110: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1114: 2F070052  cmpwi cr6, r7, 0x52
	ctx.cr[6].compare_i32(ctx.r[7].s32, 82, &mut ctx.xer);
	// 825A1118: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A111C: 41980008  blt cr6, 0x825a1124
	if ctx.cr[6].lt {
	pc = 0x825A1124; continue 'dispatch;
	}
	// 825A1120: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825A1124: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A1128: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A112C: 419A0014  beq cr6, 0x825a1140
	if ctx.cr[6].eq {
	pc = 0x825A1140; continue 'dispatch;
	}
	// 825A1130: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A1134: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1138: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A113C: 4800000C  b 0x825a1148
	pc = 0x825A1148; continue 'dispatch;
	// 825A1140: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A1144: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A1148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A114C: 4199FFB8  bgt cr6, 0x825a1104
	if ctx.cr[6].gt {
	pc = 0x825A1104; continue 'dispatch;
	}
	// 825A1150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A1154: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A1158: 419A0040  beq cr6, 0x825a1198
	if ctx.cr[6].eq {
	pc = 0x825A1198; continue 'dispatch;
	}
	// 825A115C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1160: 2F0B0052  cmpwi cr6, r11, 0x52
	ctx.cr[6].compare_i32(ctx.r[11].s32, 82, &mut ctx.xer);
	// 825A1164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A1168: 41990008  bgt cr6, 0x825a1170
	if ctx.cr[6].gt {
	pc = 0x825A1170; continue 'dispatch;
	}
	// 825A116C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A1170: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A1174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1178: 409A0020  bne cr6, 0x825a1198
	if !ctx.cr[6].eq {
	pc = 0x825A1198; continue 'dispatch;
	}
	// 825A117C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A1180: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A1184: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1188: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A118C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825A1190: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A1194: 4800001C  b 0x825a11b0
	pc = 0x825A11B0; continue 'dispatch;
	// 825A1198: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A119C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A11A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825A11A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A11A8: 48000008  b 0x825a11b0
	pc = 0x825A11B0; continue 'dispatch;
	// 825A11AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A11B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A11B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A11B8: 419A0018  beq cr6, 0x825a11d0
	if ctx.cr[6].eq {
	pc = 0x825A11D0; continue 'dispatch;
	}
	// 825A11BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A11C0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A11C4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825A11C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A11CC: 4E800421  bctrl
	ctx.lr = 0x825A11D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A11D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A11D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A11D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A11DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A11E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A11E0 size=132
    let mut pc: u32 = 0x825A11E0;
    'dispatch: loop {
        match pc {
            0x825A11E0 => {
    //   block [0x825A11E0..0x825A1264)
	// 825A11E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A11E4: 48708225  bl 0x82ca9408
	ctx.lr = 0x825A11E8;
	sub_82CA93D0(ctx, base);
	// 825A11E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A11EC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 825A11F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A11F4: 4BC86F05  bl 0x822280f8
	ctx.lr = 0x825A11F8;
	sub_822280F8(ctx, base);
	// 825A11F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825A11FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825A1200: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A1204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1208: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A120C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 825A1210: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1214: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1218: 4BC86EE1  bl 0x822280f8
	ctx.lr = 0x825A121C;
	sub_822280F8(ctx, base);
	// 825A121C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1220: 4BC86341  bl 0x82227560
	ctx.lr = 0x825A1224;
	sub_82227560(ctx, base);
	// 825A1224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A1228: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A122C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 825A1230: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A1234: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1238: 4BD60DB1  bl 0x82301fe8
	ctx.lr = 0x825A123C;
	sub_82301FE8(ctx, base);
	// 825A123C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825A1240: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A1244: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A1248: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 825A124C: 4E800421  bctrl
	ctx.lr = 0x825A1250;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825A1254: 4BC73B85  bl 0x82214dd8
	ctx.lr = 0x825A1258;
	sub_82214DD8(ctx, base);
	// 825A1258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A125C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A1260: 487081F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1268 size=260
    let mut pc: u32 = 0x825A1268;
    'dispatch: loop {
        match pc {
            0x825A1268 => {
    //   block [0x825A1268..0x825A136C)
	// 825A1268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A126C: 487081A1  bl 0x82ca940c
	ctx.lr = 0x825A1270;
	sub_82CA93D0(ctx, base);
	// 825A1270: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1274: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A1278: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A127C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A1280: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A1284: 419A0018  beq cr6, 0x825a129c
	if ctx.cr[6].eq {
	pc = 0x825A129C; continue 'dispatch;
	}
	// 825A1288: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A128C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A1290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A1294: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A1298: 409A0008  bne cr6, 0x825a12a0
	if !ctx.cr[6].eq {
	pc = 0x825A12A0; continue 'dispatch;
	}
	// 825A129C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A12A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A12A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A12A8: 419A00B8  beq cr6, 0x825a1360
	if ctx.cr[6].eq {
	pc = 0x825A1360; continue 'dispatch;
	}
	// 825A12AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A12B0: 419A0018  beq cr6, 0x825a12c8
	if ctx.cr[6].eq {
	pc = 0x825A12C8; continue 'dispatch;
	}
	// 825A12B4: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A12B8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A12BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A12C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A12C4: 409A0008  bne cr6, 0x825a12cc
	if !ctx.cr[6].eq {
	pc = 0x825A12CC; continue 'dispatch;
	}
	// 825A12C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A12CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A12D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A12D4: 409A0010  bne cr6, 0x825a12e4
	if !ctx.cr[6].eq {
	pc = 0x825A12E4; continue 'dispatch;
	}
	// 825A12D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A12DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A12E0: 4870817C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 825A12E4: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A12E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A12EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A12F0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A12F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A12F8: 4E800421  bctrl
	ctx.lr = 0x825A12FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A12FC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1370 size=260
    let mut pc: u32 = 0x825A1370;
    'dispatch: loop {
        match pc {
            0x825A1370 => {
    //   block [0x825A1370..0x825A1474)
	// 825A1370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1374: 48708099  bl 0x82ca940c
	ctx.lr = 0x825A1378;
	sub_82CA93D0(ctx, base);
	// 825A1378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A137C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A1380: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A1384: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A1388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A138C: 419A0018  beq cr6, 0x825a13a4
	if ctx.cr[6].eq {
	pc = 0x825A13A4; continue 'dispatch;
	}
	// 825A1390: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A1394: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A1398: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A139C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A13A0: 409A0008  bne cr6, 0x825a13a8
	if !ctx.cr[6].eq {
	pc = 0x825A13A8; continue 'dispatch;
	}
	// 825A13A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A13A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A13AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A13B0: 419A00B8  beq cr6, 0x825a1468
	if ctx.cr[6].eq {
	pc = 0x825A1468; continue 'dispatch;
	}
	// 825A13B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A13B8: 419A0018  beq cr6, 0x825a13d0
	if ctx.cr[6].eq {
	pc = 0x825A13D0; continue 'dispatch;
	}
	// 825A13BC: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A13C0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A13C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A13C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A13CC: 409A0008  bne cr6, 0x825a13d4
	if !ctx.cr[6].eq {
	pc = 0x825A13D4; continue 'dispatch;
	}
	// 825A13D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A13D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A13D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A13DC: 409A0010  bne cr6, 0x825a13ec
	if !ctx.cr[6].eq {
	pc = 0x825A13EC; continue 'dispatch;
	}
	// 825A13E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A13E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A13E8: 48708074  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 825A13EC: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A13F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A13F4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A13F8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A13FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A1400: 4E800421  bctrl
	ctx.lr = 0x825A1404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1404: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1478 size=72
    let mut pc: u32 = 0x825A1478;
    'dispatch: loop {
        match pc {
            0x825A1478 => {
    //   block [0x825A1478..0x825A14C0)
	// 825A1478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A147C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1484: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A148C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1490: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 825A1494: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 825A1498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A149C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825A14A0: 419A000C  beq cr6, 0x825a14ac
	if ctx.cr[6].eq {
	pc = 0x825A14AC; continue 'dispatch;
	}
	// 825A14A4: 4BC7A895  bl 0x8221bd38
	ctx.lr = 0x825A14A8;
	sub_8221BD38(ctx, base);
	// 825A14A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A14AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A14B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A14B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A14B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A14BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A14C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A14C0 size=644
    let mut pc: u32 = 0x825A14C0;
    'dispatch: loop {
        match pc {
            0x825A14C0 => {
    //   block [0x825A14C0..0x825A1744)
	// 825A14C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A14C4: 48707F39  bl 0x82ca93fc
	ctx.lr = 0x825A14C8;
	sub_82CA93D0(ctx, base);
	// 825A14C8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 825A14CC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825A14D0: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A14D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A14D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A14DC: 4800026D  bl 0x825a1748
	ctx.lr = 0x825A14E0;
	sub_825A1748(ctx, base);
	// 825A14E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A14E4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825A14E8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825A14EC: 392BD5C8  addi r9, r11, -0x2a38
	ctx.r[9].s64 = ctx.r[11].s64 + -10808;
	// 825A14F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A14F4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825A14F8: C00BD5C8  lfs f0, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A14FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825A1500: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 825A1504: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825A1508: C3C9BEC8  lfs f30, -0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825A150C: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825A1510: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825A1514: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1748 size=132
    let mut pc: u32 = 0x825A1748;
    'dispatch: loop {
        match pc {
            0x825A1748 => {
    //   block [0x825A1748..0x825A17CC)
	// 825A1748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A174C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A175C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1760: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1764: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 825A1768: 419A004C  beq cr6, 0x825a17b4
	if ctx.cr[6].eq {
	pc = 0x825A17B4; continue 'dispatch;
	}
	// 825A176C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1770: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1774: 4BBD41A5  bl 0x82175918
	ctx.lr = 0x825A1778;
	sub_82175918(ctx, base);
	// 825A1778: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 825A177C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1780: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A1784: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825A1788: 4BBD4191  bl 0x82175918
	ctx.lr = 0x825A178C;
	sub_82175918(ctx, base);
	// 825A178C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 825A1790: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A1794: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825A1798: 4BBD4181  bl 0x82175918
	ctx.lr = 0x825A179C;
	sub_82175918(ctx, base);
	// 825A179C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 825A17A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A17A4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825A17A8: 4BBD4171  bl 0x82175918
	ctx.lr = 0x825A17AC;
	sub_82175918(ctx, base);
	// 825A17AC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 825A17B0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A17B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A17B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A17BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A17C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A17C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A17C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A17D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A17D0 size=612
    let mut pc: u32 = 0x825A17D0;
    'dispatch: loop {
        match pc {
            0x825A17D0 => {
    //   block [0x825A17D0..0x825A1A34)
	// 825A17D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A17D4: 48707C31  bl 0x82ca9404
	ctx.lr = 0x825A17D8;
	sub_82CA93D0(ctx, base);
	// 825A17D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A17DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A17E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A17E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825A17E8: 4BE1D7B9  bl 0x823befa0
	ctx.lr = 0x825A17EC;
	sub_823BEFA0(ctx, base);
	// 825A17EC: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A17F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A17F4: 419A00FC  beq cr6, 0x825a18f0
	if ctx.cr[6].eq {
	pc = 0x825A18F0; continue 'dispatch;
	}
	// 825A17F8: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A17FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A1800: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1804: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A1808: 4BC87901  bl 0x82229108
	ctx.lr = 0x825A180C;
	sub_82229108(ctx, base);
	// 825A180C: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A1810: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A1814: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A1818: 3BAB1A38  addi r29, r11, 0x1a38
	ctx.r[29].s64 = ctx.r[11].s64 + 6712;
	// 825A181C: 4BC86065  bl 0x82227880
	ctx.lr = 0x825A1820;
	sub_82227880(ctx, base);
	// 825A1820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A1824: 3D40825A  lis r10, -0x7da6
	ctx.r[10].s64 = -2108030976;
	// 825A1828: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A182C: 388A1C10  addi r4, r10, 0x1c10
	ctx.r[4].s64 = ctx.r[10].s64 + 7184;
	// 825A1830: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A1834: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825A1838: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A183C: 4BBF9245  bl 0x8219aa80
	ctx.lr = 0x825A1840;
	sub_8219AA80(ctx, base);
	// 825A1840: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825A1844: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A1848: 3BA94D58  addi r29, r9, 0x4d58
	ctx.r[29].s64 = ctx.r[9].s64 + 19800;
	// 825A184C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A1850: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825A1854: 4BE2CBCD  bl 0x823ce420
	ctx.lr = 0x825A1858;
	sub_823CE420(ctx, base);
	// 825A1858: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825A185C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A1860: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A1864: 48482E65  bl 0x82a246c8
	ctx.lr = 0x825A1868;
	sub_82A246C8(ctx, base);
	// 825A1868: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A186C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A1870: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825A1874: 911B0008  stw r8, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825A1878: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A187C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A1884: 4BC87885  bl 0x82229108
	ctx.lr = 0x825A1888;
	sub_82229108(ctx, base);
	// 825A1888: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A188C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A1890: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A1894: 3BEB1AE8  addi r31, r11, 0x1ae8
	ctx.r[31].s64 = ctx.r[11].s64 + 6888;
	// 825A1898: 4BC85FE9  bl 0x82227880
	ctx.lr = 0x825A189C;
	sub_82227880(ctx, base);
	// 825A189C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825A18A0: 3CC08248  lis r6, -0x7db8
	ctx.r[6].s64 = -2109210624;
	// 825A18A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A18A8: 38861200  addi r4, r6, 0x1200
	ctx.r[4].s64 = ctx.r[6].s64 + 4608;
	// 825A18AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A18B0: 93C70000  stw r30, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825A18B4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825A18B8: 4BBF91C9  bl 0x8219aa80
	ctx.lr = 0x825A18BC;
	sub_8219AA80(ctx, base);
	// 825A18BC: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 825A18C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A18C4: 3BE54D6C  addi r31, r5, 0x4d6c
	ctx.r[31].s64 = ctx.r[5].s64 + 19820;
	// 825A18C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A18CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A18D0: 4BE2CB51  bl 0x823ce420
	ctx.lr = 0x825A18D4;
	sub_823CE420(ctx, base);
	// 825A18D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A18D8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A18DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A18E0: 48482DE9  bl 0x82a246c8
	ctx.lr = 0x825A18E4;
	sub_82A246C8(ctx, base);
	// 825A18E4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A18E8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 825A18EC: 909D0008  stw r4, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825A18F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A18F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A18F8: 4BE2CCC9  bl 0x823ce5c0
	ctx.lr = 0x825A18FC;
	sub_823CE5C0(ctx, base);
	// 825A18FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1900: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825A1904: 38AB464C  addi r5, r11, 0x464c
	ctx.r[5].s64 = ctx.r[11].s64 + 17996;
	// 825A1908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A190C: 4BE2C8F5  bl 0x823ce200
	ctx.lr = 0x825A1910;
	sub_823CE200(ctx, base);
	// 825A1910: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1914: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A1918: 419A00FC  beq cr6, 0x825a1a14
	if ctx.cr[6].eq {
	pc = 0x825A1A14; continue 'dispatch;
	}
	// 825A191C: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1920: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A1924: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1928: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825A192C: 4BC877DD  bl 0x82229108
	ctx.lr = 0x825A1930;
	sub_82229108(ctx, base);
	// 825A1930: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A1934: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A1938: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825A193C: 3BAB1BF0  addi r29, r11, 0x1bf0
	ctx.r[29].s64 = ctx.r[11].s64 + 7152;
	// 825A1940: 4BC85F41  bl 0x82227880
	ctx.lr = 0x825A1944;
	sub_82227880(ctx, base);
	// 825A1944: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A1948: 3D408296  lis r10, -0x7d6a
	ctx.r[10].s64 = -2104098816;
	// 825A194C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A1950: 388A46A0  addi r4, r10, 0x46a0
	ctx.r[4].s64 = ctx.r[10].s64 + 18080;
	// 825A1954: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825A1958: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825A195C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A1960: 4BBF9121  bl 0x8219aa80
	ctx.lr = 0x825A1964;
	sub_8219AA80(ctx, base);
	// 825A1964: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825A1968: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A196C: 3BA94D7C  addi r29, r9, 0x4d7c
	ctx.r[29].s64 = ctx.r[9].s64 + 19836;
	// 825A1970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A1974: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825A1978: 4BE2CAA9  bl 0x823ce420
	ctx.lr = 0x825A197C;
	sub_823CE420(ctx, base);
	// 825A197C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825A1980: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A1984: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825A1988: 48482D41  bl 0x82a246c8
	ctx.lr = 0x825A198C;
	sub_82A246C8(ctx, base);
	// 825A198C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1990: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825A1994: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825A1998: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825A199C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A19A0: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A19A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A19A8: 4BC87761  bl 0x82229108
	ctx.lr = 0x825A19AC;
	sub_82229108(ctx, base);
	// 825A19AC: 3D60825A  lis r11, -0x7da6
	ctx.r[11].s64 = -2108030976;
	// 825A19B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A19B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A19B8: 3BEB1BF8  addi r31, r11, 0x1bf8
	ctx.r[31].s64 = ctx.r[11].s64 + 7160;
	// 825A19BC: 4BC85EC5  bl 0x82227880
	ctx.lr = 0x825A19C0;
	sub_82227880(ctx, base);
	// 825A19C0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825A19C4: 3CC08261  lis r6, -0x7d9f
	ctx.r[6].s64 = -2107572224;
	// 825A19C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A19CC: 3886DCD8  addi r4, r6, -0x2328
	ctx.r[4].s64 = ctx.r[6].s64 + -9000;
	// 825A19D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A19D4: 93C70000  stw r30, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825A19D8: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825A19DC: 4BBF90A5  bl 0x8219aa80
	ctx.lr = 0x825A19E0;
	sub_8219AA80(ctx, base);
	// 825A19E0: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 825A19E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A19E8: 3BE54D8C  addi r31, r5, 0x4d8c
	ctx.r[31].s64 = ctx.r[5].s64 + 19852;
	// 825A19EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A19F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A19F4: 4BE2CA2D  bl 0x823ce420
	ctx.lr = 0x825A19F8;
	sub_823CE420(ctx, base);
	// 825A19F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825A19FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825A1A00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A1A04: 48482CC5  bl 0x82a246c8
	ctx.lr = 0x825A1A08;
	sub_82A246C8(ctx, base);
	// 825A1A08: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1A0C: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 825A1A10: 909D0008  stw r4, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825A1A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A1A18: 4BC16101  bl 0x821b7b18
	ctx.lr = 0x825A1A1C;
	sub_821B7B18(ctx, base);
	// 825A1A1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A1A20: 4BC160F9  bl 0x821b7b18
	ctx.lr = 0x825A1A24;
	sub_821B7B18(ctx, base);
	// 825A1A24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A1A28: 4BC160F1  bl 0x821b7b18
	ctx.lr = 0x825A1A2C;
	sub_821B7B18(ctx, base);
	// 825A1A2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A1A30: 48707A24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825A1A38 size=176
    let mut pc: u32 = 0x825A1A38;
    'dispatch: loop {
        match pc {
            0x825A1A38 => {
    //   block [0x825A1A38..0x825A1AE8)
	// 825A1A38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1A3C: D0E30034  stfs f7, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 825A1A40: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 825A1A44: D0A3002C  stfs f5, 0x2c(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 825A1A48: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825A1A4C: D0C30030  stfs f6, 0x30(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 825A1A50: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 825A1A54: D0630024  stfs f3, 0x24(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825A1A58: D0830028  stfs f4, 0x28(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 825A1A5C: C1AB9490  lfs f13, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A1A60: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1A64: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825A1A68: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825A1A6C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 825A1A70: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 825A1A74: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 825A1A78: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825A1A7C: 548BDF7A  rlwinm r11, r4, 0x1b, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 825A1A80: 548AF77A  rlwinm r10, r4, 0x1e, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 825A1A84: 7CC92B78  or r9, r6, r5
	ctx.r[9].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 825A1A88: 7D675378  or r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825A1A8C: 7D884C2E  lfsx f12, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A1A90: 7D683C2E  lfsx f11, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825A1A94: FD4C006E  fsel f10, f12, f1, f0
	ctx.f[10].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[0].f64 };
	// 825A1A98: FD2B00AE  fsel f9, f11, f2, f0
	ctx.f[9].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[2].f64 } else { ctx.f[0].f64 };
	// 825A1A9C: ED0A6828  fsubs f8, f10, f13
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A1AA0: ECE96828  fsubs f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A1AA4: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 825A1AA8: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825A1AAC: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 825A1AB0: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825A1AB4: 54C4DF7A  rlwinm r4, r6, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 825A1AB8: 54CBF77A  rlwinm r11, r6, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 825A1ABC: 54AADF7A  rlwinm r10, r5, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 825A1AC0: 54A9F77A  rlwinm r9, r5, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 825A1AC4: 7C875B78  or r7, r4, r11
	ctx.r[7].u64 = ctx.r[4].u64 | ctx.r[11].u64;
	// 825A1AC8: 7D464B78  or r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 825A1ACC: 7CC83C2E  lfsx f6, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825A1AD0: 7CA8342E  lfsx f5, r8, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 825A1AD4: FC86536E  fsel f4, f6, f13, f10
	ctx.f[4].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[10].f64 };
	// 825A1AD8: FC654B6E  fsel f3, f5, f13, f9
	ctx.f[3].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 825A1ADC: D083001C  stfs f4, 0x1c(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825A1AE0: D0630020  stfs f3, 0x20(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825A1AE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A1AE8 size=260
    let mut pc: u32 = 0x825A1AE8;
    'dispatch: loop {
        match pc {
            0x825A1AE8 => {
    //   block [0x825A1AE8..0x825A1BEC)
	// 825A1AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1AF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1AF4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1AF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1AFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A1B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1B04: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1B08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A1B0C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825A1B10: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825A1B14: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825A1B18: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825A1B1C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A1B20: 4BC015E1  bl 0x821a3100
	ctx.lr = 0x825A1B24;
	sub_821A3100(ctx, base);
	// 825A1B24: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A1B2C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825A1B30: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1B34: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A1B38: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 825A1B3C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A1B40: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825A1B44: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A1B48: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825A1B4C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A1B50: C1210064  lfs f9, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825A1B54: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1B5C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1B60: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1B64: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1B68: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1B70: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1B74: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1B78: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1B7C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1B84: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1B88: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1B8C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1B90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1B94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1B98: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1B9C: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1BA0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1BA4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1BA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1BAC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1BB0: D14A0000  stfs f10, 0(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1BB4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1BB8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1BBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A1BC0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825A1BC4: D12A0000  stfs f9, 0(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1BC8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825A1BCC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1BD0: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 825A1BD4: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825A1BD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A1BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1BF0 size=8
    let mut pc: u32 = 0x825A1BF0;
    'dispatch: loop {
        match pc {
            0x825A1BF0 => {
    //   block [0x825A1BF0..0x825A1BF8)
	// 825A1BF0: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 825A1BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1BF8 size=8
    let mut pc: u32 = 0x825A1BF8;
    'dispatch: loop {
        match pc {
            0x825A1BF8 => {
    //   block [0x825A1BF8..0x825A1C00)
	// 825A1BF8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825A1BFC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1C00 size=8
    let mut pc: u32 = 0x825A1C00;
    'dispatch: loop {
        match pc {
            0x825A1C00 => {
    //   block [0x825A1C00..0x825A1C08)
	// 825A1C00: 2F040007  cmpwi cr6, r4, 7
	ctx.cr[6].compare_i32(ctx.r[4].s32, 7, &mut ctx.xer);
	// 825A1C04: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A1C08 size=8
    let mut pc: u32 = 0x825A1C08;
    'dispatch: loop {
        match pc {
            0x825A1C08 => {
    //   block [0x825A1C08..0x825A1C10)
	// 825A1C08: 90830038  stw r4, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[4].u32 ) };
	// 825A1C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1C10 size=56
    let mut pc: u32 = 0x825A1C10;
    'dispatch: loop {
        match pc {
            0x825A1C10 => {
    //   block [0x825A1C10..0x825A1C48)
	// 825A1C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1C18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1C1C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 825A1C20: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825A1C24: 4BC864D5  bl 0x822280f8
	ctx.lr = 0x825A1C28;
	sub_822280F8(ctx, base);
	// 825A1C28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825A1C2C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A1C30: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1C34: 48000015  bl 0x825a1c48
	ctx.lr = 0x825A1C38;
	sub_825A1C48(ctx, base);
	// 825A1C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A1C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A1C48 size=284
    let mut pc: u32 = 0x825A1C48;
    'dispatch: loop {
        match pc {
            0x825A1C48 => {
    //   block [0x825A1C48..0x825A1D64)
	// 825A1C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1C4C: 487077C1  bl 0x82ca940c
	ctx.lr = 0x825A1C50;
	sub_82CA93D0(ctx, base);
	// 825A1C50: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 825A1C54: 4870C07D  bl 0x82cadcd0
	ctx.lr = 0x825A1C58;
	sub_82CADCA0(ctx, base);
	// 825A1C58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1C5C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825A1C60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A1C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1C68: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 825A1C6C: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 825A1C70: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1C74: 38E10053  addi r7, r1, 0x53
	ctx.r[7].s64 = ctx.r[1].s64 + 83;
	// 825A1C78: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825A1C7C: 38610055  addi r3, r1, 0x55
	ctx.r[3].s64 = ctx.r[1].s64 + 85;
	// 825A1C80: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1C84: 39410056  addi r10, r1, 0x56
	ctx.r[10].s64 = ctx.r[1].s64 + 86;
	// 825A1C88: 99680000  stb r11, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1C8C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825A1C90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A1C94: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1C98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1C9C: 99660000  stb r11, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1CA0: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 825A1CA4: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1CA8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825A1CAC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1CB0: 4BD60249  bl 0x82301ef8
	ctx.lr = 0x825A1CB4;
	sub_82301EF8(ctx, base);
	// 825A1CB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1CB8: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825A1CBC: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825A1CC0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825A1CC4: 4BD60235  bl 0x82301ef8
	ctx.lr = 0x825A1CC8;
	sub_82301EF8(ctx, base);
	// 825A1CC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1CCC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 825A1CD0: 88610052  lbz r3, 0x52(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 825A1CD4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825A1CD8: 4BD60221  bl 0x82301ef8
	ctx.lr = 0x825A1CDC;
	sub_82301EF8(ctx, base);
	// 825A1CDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1CE0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825A1CE4: 88610053  lbz r3, 0x53(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 825A1CE8: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 825A1CEC: 4BD6020D  bl 0x82301ef8
	ctx.lr = 0x825A1CF0;
	sub_82301EF8(ctx, base);
	// 825A1CF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1CF4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A1CF8: 88610054  lbz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A1CFC: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 825A1D00: 4BD601F9  bl 0x82301ef8
	ctx.lr = 0x825A1D04;
	sub_82301EF8(ctx, base);
	// 825A1D04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1D08: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825A1D0C: 88610055  lbz r3, 0x55(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 825A1D10: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 825A1D14: 4BD601E5  bl 0x82301ef8
	ctx.lr = 0x825A1D18;
	sub_82301EF8(ctx, base);
	// 825A1D18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A1D1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A1D20: 88610056  lbz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 825A1D24: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 825A1D28: 4BD601D1  bl 0x82301ef8
	ctx.lr = 0x825A1D2C;
	sub_82301EF8(ctx, base);
	// 825A1D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1D30: FC40D090  fmr f2, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[26].f64;
	// 825A1D34: FC60D890  fmr f3, f27
	ctx.f[3].f64 = ctx.f[27].f64;
	// 825A1D38: FC80E090  fmr f4, f28
	ctx.f[4].f64 = ctx.f[28].f64;
	// 825A1D3C: FCA0E890  fmr f5, f29
	ctx.f[5].f64 = ctx.f[29].f64;
	// 825A1D40: FCC0F090  fmr f6, f30
	ctx.f[6].f64 = ctx.f[30].f64;
	// 825A1D44: FCE0F890  fmr f7, f31
	ctx.f[7].f64 = ctx.f[31].f64;
	// 825A1D48: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 825A1D4C: 4E800421  bctrl
	ctx.lr = 0x825A1D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A1D50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A1D54: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A1D58: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 825A1D5C: 4870BFC1  bl 0x82cadd1c
	ctx.lr = 0x825A1D60;
	sub_82CADCEC(ctx, base);
	// 825A1D60: 487076FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A1D68 size=508
    let mut pc: u32 = 0x825A1D68;
    'dispatch: loop {
        match pc {
            0x825A1D68 => {
    //   block [0x825A1D68..0x825A1F64)
	// 825A1D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1D6C: 48707679  bl 0x82ca93e4
	ctx.lr = 0x825A1D70;
	sub_82CA93D0(ctx, base);
	// 825A1D70: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 825A1D74: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1D78: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825A1D7C: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 825A1D80: 38CB0AC8  addi r6, r11, 0xac8
	ctx.r[6].s64 = ctx.r[11].s64 + 2760;
	// 825A1D84: 38E30080  addi r7, r3, 0x80
	ctx.r[7].s64 = ctx.r[3].s64 + 128;
	// 825A1D88: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 825A1D8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A1D90: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 825A1D94: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 825A1D98: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825A1D9C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1DA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A1DA4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A1DA8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825A1DAC: 4200FFF0  bdnz 0x825a1d9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825A1D9C; continue 'dispatch;
	}
	// 825A1DB0: 39290014  addi r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 + 20;
	// 825A1DB4: 39660064  addi r11, r6, 0x64
	ctx.r[11].s64 = ctx.r[6].s64 + 100;
	// 825A1DB8: 38E70014  addi r7, r7, 0x14
	ctx.r[7].s64 = ctx.r[7].s64 + 20;
	// 825A1DBC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A1DC0: 4198FFCC  blt cr6, 0x825a1d8c
	if ctx.cr[6].lt {
	pc = 0x825A1D8C; continue 'dispatch;
	}
	// 825A1DC4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 825A1DC8: 419A0190  beq cr6, 0x825a1f58
	if ctx.cr[6].eq {
	pc = 0x825A1F58; continue 'dispatch;
	}
	// 825A1DCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825A1DD0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825A1DD4: 3A8B8BB8  addi r20, r11, -0x7448
	ctx.r[20].s64 = ctx.r[11].s64 + -29768;
	// 825A1DD8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1DDC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 825A1DE0: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 825A1DE4: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 825A1DE8: 82EA6DA0  lwz r23, 0x6da0(r10)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825A1DEC: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 825A1DF0: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 825A1DF4: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A1DF8: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 825A1DFC: 82A9E454  lwz r21, -0x1bac(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825A1E00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825A1E04: 83088974  lwz r24, -0x768c(r8)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30348 as u32) ) } as u64;
	// 825A1E08: 83278970  lwz r25, -0x7690(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30352 as u32) ) } as u64;
	// 825A1E0C: 3BC30088  addi r30, r3, 0x88
	ctx.r[30].s64 = ctx.r[3].s64 + 136;
	// 825A1E10: 83468968  lwz r26, -0x7698(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-30360 as u32) ) } as u64;
	// 825A1E14: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 825A1E18: 83658964  lwz r27, -0x769c(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-30364 as u32) ) } as u64;
	// 825A1E1C: 3ACBE460  addi r22, r11, -0x1ba0
	ctx.r[22].s64 = ctx.r[11].s64 + -7072;
	// 825A1E20: 83848960  lwz r28, -0x76a0(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-30368 as u32) ) } as u64;
	// 825A1E24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A1E28: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1E2C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 825A1E30: 4BC43BD9  bl 0x821e5a08
	ctx.lr = 0x825A1E34;
	sub_821E5A08(ctx, base);
	// 825A1E34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1E38: 419A0034  beq cr6, 0x825a1e6c
	if ctx.cr[6].eq {
	pc = 0x825A1E6C; continue 'dispatch;
	}
	// 825A1E3C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A1E40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A1E44: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 825A1E48: 419A001C  beq cr6, 0x825a1e64
	if ctx.cr[6].eq {
	pc = 0x825A1E64; continue 'dispatch;
	}
	// 825A1E4C: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 825A1E50: 409A0014  bne cr6, 0x825a1e64
	if !ctx.cr[6].eq {
	pc = 0x825A1E64; continue 'dispatch;
	}
	// 825A1E54: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1E58: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825A1E5C: 409A0008  bne cr6, 0x825a1e64
	if !ctx.cr[6].eq {
	pc = 0x825A1E64; continue 'dispatch;
	}
	// 825A1E60: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825A1E64: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1E68: 48000008  b 0x825a1e70
	pc = 0x825A1E70; continue 'dispatch;
	// 825A1E6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A1E70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825A1E74: 419A00C0  beq cr6, 0x825a1f34
	if ctx.cr[6].eq {
	pc = 0x825A1F34; continue 'dispatch;
	}
	// 825A1E78: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825A1E7C: 4BC423D5  bl 0x821e4250
	ctx.lr = 0x825A1E80;
	sub_821E4250(ctx, base);
	// 825A1E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1E84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A1E88: 419A00AC  beq cr6, 0x825a1f34
	if ctx.cr[6].eq {
	pc = 0x825A1F34; continue 'dispatch;
	}
	// 825A1E8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A1E90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A1E94: 4845E835  bl 0x82a006c8
	ctx.lr = 0x825A1E98;
	sub_82A006C8(ctx, base);
	// 825A1E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1E9C: 419A000C  beq cr6, 0x825a1ea8
	if ctx.cr[6].eq {
	pc = 0x825A1EA8; continue 'dispatch;
	}
	// 825A1EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1EA4: 917EFFF8  stw r11, -8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 825A1EA8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A1EAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A1EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1EB4: 4845E815  bl 0x82a006c8
	ctx.lr = 0x825A1EB8;
	sub_82A006C8(ctx, base);
	// 825A1EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1EBC: 419A000C  beq cr6, 0x825a1ec8
	if ctx.cr[6].eq {
	pc = 0x825A1EC8; continue 'dispatch;
	}
	// 825A1EC0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1EC4: D01EFFFC  stfs f0, -4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825A1EC8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A1ECC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A1ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1ED4: 4845E7F5  bl 0x82a006c8
	ctx.lr = 0x825A1ED8;
	sub_82A006C8(ctx, base);
	// 825A1ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1EDC: 419A000C  beq cr6, 0x825a1ee8
	if ctx.cr[6].eq {
	pc = 0x825A1EE8; continue 'dispatch;
	}
	// 825A1EE0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1EE4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A1EE8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A1EEC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825A1EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1EF4: 4845E7D5  bl 0x82a006c8
	ctx.lr = 0x825A1EF8;
	sub_82A006C8(ctx, base);
	// 825A1EF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1EFC: 419A000C  beq cr6, 0x825a1f08
	if ctx.cr[6].eq {
	pc = 0x825A1F08; continue 'dispatch;
	}
	// 825A1F00: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A1F04: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A1F08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A1F0C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825A1F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1F14: 4845E7B5  bl 0x82a006c8
	ctx.lr = 0x825A1F18;
	sub_82A006C8(ctx, base);
	// 825A1F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A1F1C: 419A0018  beq cr6, 0x825a1f34
	if ctx.cr[6].eq {
	pc = 0x825A1F34; continue 'dispatch;
	}
	// 825A1F20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A1F24: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825A1F28: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825A1F2C: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 825A1F30: 991E0008  stb r8, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 825A1F34: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A1F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A1F3C: 409A0008  bne cr6, 0x825a1f44
	if !ctx.cr[6].eq {
	pc = 0x825A1F44; continue 'dispatch;
	}
	// 825A1F40: D3FEFFFC  stfs f31, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825A1F44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825A1F48: 39740014  addi r11, r20, 0x14
	ctx.r[11].s64 = ctx.r[20].s64 + 20;
	// 825A1F4C: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 825A1F50: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A1F54: 4198FED0  blt cr6, 0x825a1e24
	if ctx.cr[6].lt {
	pc = 0x825A1E24; continue 'dispatch;
	}
	// 825A1F58: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825A1F5C: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 825A1F60: 487074D4  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A1F68 size=136
    let mut pc: u32 = 0x825A1F68;
    'dispatch: loop {
        match pc {
            0x825A1F68 => {
    //   block [0x825A1F68..0x825A1FF0)
	// 825A1F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A1F74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A1F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A1F7C: 48343B55  bl 0x828e5ad0
	ctx.lr = 0x825A1F80;
	sub_828E5AD0(ctx, base);
	// 825A1F80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A1F84: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A1F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1F8C: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A1F90: 48343791  bl 0x828e5720
	ctx.lr = 0x825A1F94;
	sub_828E5720(ctx, base);
	// 825A1F94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825A1F98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A1F9C: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 825A1FA0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825A1FA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A1FA8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825A1FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A1FB0: 4BC728E9  bl 0x82214898
	ctx.lr = 0x825A1FB4;
	sub_82214898(ctx, base);
	// 825A1FB4: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825A1FB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A1FBC: 4BF2FF0D  bl 0x824d1ec8
	ctx.lr = 0x825A1FC0;
	sub_824D1EC8(ctx, base);
	// 825A1FC0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825A1FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A1FC8: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 825A1FCC: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 825A1FD0: 4BBF1E69  bl 0x82193e38
	ctx.lr = 0x825A1FD4;
	sub_82193E38(ctx, base);
	// 825A1FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A1FD8: 480001B1  bl 0x825a2188
	ctx.lr = 0x825A1FDC;
	sub_825A2188(ctx, base);
	// 825A1FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A1FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A1FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A1FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A1FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A1FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A1FF0 size=232
    let mut pc: u32 = 0x825A1FF0;
    'dispatch: loop {
        match pc {
            0x825A1FF0 => {
    //   block [0x825A1FF0..0x825A20D8)
	// 825A1FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A1FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A1FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A1FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2008: 483433E9  bl 0x828e53f0
	ctx.lr = 0x825A200C;
	sub_828E53F0(ctx, base);
	// 825A200C: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A2010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2014: 419A0008  beq cr6, 0x825a201c
	if ctx.cr[6].eq {
	pc = 0x825A201C; continue 'dispatch;
	}
	// 825A2018: 48001539  bl 0x825a3550
	ctx.lr = 0x825A201C;
	sub_825A3550(ctx, base);
	// 825A201C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825A2020: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825A2024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2028: 419A0078  beq cr6, 0x825a20a0
	if ctx.cr[6].eq {
	pc = 0x825A20A0; continue 'dispatch;
	}
	// 825A202C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2034: 419A009C  beq cr6, 0x825a20d0
	if ctx.cr[6].eq {
	pc = 0x825A20D0; continue 'dispatch;
	}
	// 825A2038: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A203C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2040: 419A0060  beq cr6, 0x825a20a0
	if ctx.cr[6].eq {
	pc = 0x825A20A0; continue 'dispatch;
	}
	// 825A2044: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A2048: C1BF0050  lfs f13, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A204C: C00B92D4  lfs f0, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A2050: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A2054: 4198004C  blt cr6, 0x825a20a0
	if ctx.cr[6].lt {
	pc = 0x825A20A0; continue 'dispatch;
	}
	// 825A2058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A205C: 4BBD1DDD  bl 0x82173e38
	ctx.lr = 0x825A2060;
	sub_82173E38(ctx, base);
	// 825A2060: 48056259  bl 0x825f82b8
	ctx.lr = 0x825A2064;
	sub_825F82B8(ctx, base);
	// 825A2064: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A2068: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A206C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A2070: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A2074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2078: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A207C: 4BBF1DBD  bl 0x82193e38
	ctx.lr = 0x825A2080;
	sub_82193E38(ctx, base);
	// 825A2080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2088: 4BF2FE41  bl 0x824d1ec8
	ctx.lr = 0x825A208C;
	sub_824D1EC8(ctx, base);
	// 825A208C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A2090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2094: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A2098: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A209C: 4BBF1D9D  bl 0x82193e38
	ctx.lr = 0x825A20A0;
	sub_82193E38(ctx, base);
	// 825A20A0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A20A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A20A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A20AC: 4199000C  bgt cr6, 0x825a20b8
	if ctx.cr[6].gt {
	pc = 0x825A20B8; continue 'dispatch;
	}
	// 825A20B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A20B4: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 825A20B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A20BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A20C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A20C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A20C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A20CC: 4E800020  blr
	return;
	// 825A20D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A20D4: 4BFFFFC8  b 0x825a209c
	pc = 0x825A209C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A20D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A20D8 size=176
    let mut pc: u32 = 0x825A20D8;
    'dispatch: loop {
        match pc {
            0x825A20D8 => {
    //   block [0x825A20D8..0x825A2188)
	// 825A20D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A20DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A20E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A20E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A20E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A20EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A20F0: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 825A20F4: 817E00EC  lwz r11, 0xec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 825A20F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A20FC: 419A0020  beq cr6, 0x825a211c
	if ctx.cr[6].eq {
	pc = 0x825A211C; continue 'dispatch;
	}
	// 825A2100: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2108: 419A000C  beq cr6, 0x825a2114
	if ctx.cr[6].eq {
	pc = 0x825A2114; continue 'dispatch;
	}
	// 825A210C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A2110: 48000010  b 0x825a2120
	pc = 0x825A2120; continue 'dispatch;
	// 825A2114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2118: 4BBF1D21  bl 0x82193e38
	ctx.lr = 0x825A211C;
	sub_82193E38(ctx, base);
	// 825A211C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A2120: 48056199  bl 0x825f82b8
	ctx.lr = 0x825A2124;
	sub_825F82B8(ctx, base);
	// 825A2124: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A2128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A212C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A2130: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A2134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2138: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A213C: 4BBF1CFD  bl 0x82193e38
	ctx.lr = 0x825A2140;
	sub_82193E38(ctx, base);
	// 825A2140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A2144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2148: 4BF2FD81  bl 0x824d1ec8
	ctx.lr = 0x825A214C;
	sub_824D1EC8(ctx, base);
	// 825A214C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A2150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A2154: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A2158: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A215C: 4BBF1CDD  bl 0x82193e38
	ctx.lr = 0x825A2160;
	sub_82193E38(ctx, base);
	// 825A2160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2164: 48000235  bl 0x825a2398
	ctx.lr = 0x825A2168;
	sub_825A2398(ctx, base);
	// 825A2168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A216C: 48343175  bl 0x828e52e0
	ctx.lr = 0x825A2170;
	sub_828E52E0(ctx, base);
	// 825A2170: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A2174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A217C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A2180: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2188 size=524
    let mut pc: u32 = 0x825A2188;
    'dispatch: loop {
        match pc {
            0x825A2188 => {
    //   block [0x825A2188..0x825A2394)
	// 825A2188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A218C: 48707271  bl 0x82ca93fc
	ctx.lr = 0x825A2190;
	sub_82CA93D0(ctx, base);
	// 825A2190: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2398 size=108
    let mut pc: u32 = 0x825A2398;
    'dispatch: loop {
        match pc {
            0x825A2398 => {
    //   block [0x825A2398..0x825A2404)
	// 825A2398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A239C: 4870706D  bl 0x82ca9408
	ctx.lr = 0x825A23A0;
	sub_82CA93D0(ctx, base);
	// 825A23A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A23A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A23A8: 807D00E4  lwz r3, 0xe4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A23AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A23B0: 419A004C  beq cr6, 0x825a23fc
	if ctx.cr[6].eq {
	pc = 0x825A23FC; continue 'dispatch;
	}
	// 825A23B4: 480013B5  bl 0x825a3768
	ctx.lr = 0x825A23B8;
	sub_825A3768(ctx, base);
	// 825A23B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A23BC: 83FD00E4  lwz r31, 0xe4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A23C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A23C4: 419A0034  beq cr6, 0x825a23f8
	if ctx.cr[6].eq {
	pc = 0x825A23F8; continue 'dispatch;
	}
	// 825A23C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A23CC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825A23D0: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 825A23D4: 939F00E8  stw r28, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[28].u32 ) };
	// 825A23D8: 4BBF1A61  bl 0x82193e38
	ctx.lr = 0x825A23DC;
	sub_82193E38(ctx, base);
	// 825A23DC: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 825A23E0: 939F00E0  stw r28, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 825A23E4: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 825A23E8: 4BBF1A51  bl 0x82193e38
	ctx.lr = 0x825A23EC;
	sub_82193E38(ctx, base);
	// 825A23EC: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 825A23F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A23F4: 4BC79945  bl 0x8221bd38
	ctx.lr = 0x825A23F8;
	sub_8221BD38(ctx, base);
	// 825A23F8: 93DD00E4  stw r30, 0xe4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 825A23FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2400: 48707058  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A2408 size=508
    let mut pc: u32 = 0x825A2408;
    'dispatch: loop {
        match pc {
            0x825A2408 => {
    //   block [0x825A2408..0x825A2604)
	// 825A2408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A240C: 48706FD9  bl 0x82ca93e4
	ctx.lr = 0x825A2410;
	sub_82CA93D0(ctx, base);
	// 825A2410: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 825A2414: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2418: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825A241C: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 825A2420: 38CB0B30  addi r6, r11, 0xb30
	ctx.r[6].s64 = ctx.r[11].s64 + 2864;
	// 825A2424: 38E30060  addi r7, r3, 0x60
	ctx.r[7].s64 = ctx.r[3].s64 + 96;
	// 825A2428: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 825A242C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A2430: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 825A2434: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 825A2438: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825A243C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2440: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A2444: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825A2448: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825A244C: 4200FFF0  bdnz 0x825a243c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825A243C; continue 'dispatch;
	}
	// 825A2450: 39290014  addi r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 + 20;
	// 825A2454: 39660064  addi r11, r6, 0x64
	ctx.r[11].s64 = ctx.r[6].s64 + 100;
	// 825A2458: 38E70014  addi r7, r7, 0x14
	ctx.r[7].s64 = ctx.r[7].s64 + 20;
	// 825A245C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A2460: 4198FFCC  blt cr6, 0x825a242c
	if ctx.cr[6].lt {
	pc = 0x825A242C; continue 'dispatch;
	}
	// 825A2464: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 825A2468: 419A0190  beq cr6, 0x825a25f8
	if ctx.cr[6].eq {
	pc = 0x825A25F8; continue 'dispatch;
	}
	// 825A246C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825A2470: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825A2474: 3A8B8BB8  addi r20, r11, -0x7448
	ctx.r[20].s64 = ctx.r[11].s64 + -29768;
	// 825A2478: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A247C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 825A2480: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 825A2484: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 825A2488: 82EA6DA0  lwz r23, 0x6da0(r10)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825A248C: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 825A2490: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 825A2494: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A2498: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 825A249C: 82A9E454  lwz r21, -0x1bac(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825A24A0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825A24A4: 83088974  lwz r24, -0x768c(r8)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30348 as u32) ) } as u64;
	// 825A24A8: 83278970  lwz r25, -0x7690(r7)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30352 as u32) ) } as u64;
	// 825A24AC: 3BC30068  addi r30, r3, 0x68
	ctx.r[30].s64 = ctx.r[3].s64 + 104;
	// 825A24B0: 8346896C  lwz r26, -0x7694(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-30356 as u32) ) } as u64;
	// 825A24B4: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 825A24B8: 83658964  lwz r27, -0x769c(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-30364 as u32) ) } as u64;
	// 825A24BC: 3ACBE460  addi r22, r11, -0x1ba0
	ctx.r[22].s64 = ctx.r[11].s64 + -7072;
	// 825A24C0: 83848960  lwz r28, -0x76a0(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-30368 as u32) ) } as u64;
	// 825A24C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A24C8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A24CC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 825A24D0: 4BC43539  bl 0x821e5a08
	ctx.lr = 0x825A24D4;
	sub_821E5A08(ctx, base);
	// 825A24D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A24D8: 419A0034  beq cr6, 0x825a250c
	if ctx.cr[6].eq {
	pc = 0x825A250C; continue 'dispatch;
	}
	// 825A24DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A24E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A24E4: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 825A24E8: 419A001C  beq cr6, 0x825a2504
	if ctx.cr[6].eq {
	pc = 0x825A2504; continue 'dispatch;
	}
	// 825A24EC: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 825A24F0: 409A0014  bne cr6, 0x825a2504
	if !ctx.cr[6].eq {
	pc = 0x825A2504; continue 'dispatch;
	}
	// 825A24F4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A24F8: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825A24FC: 409A0008  bne cr6, 0x825a2504
	if !ctx.cr[6].eq {
	pc = 0x825A2504; continue 'dispatch;
	}
	// 825A2500: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 825A2504: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2508: 48000008  b 0x825a2510
	pc = 0x825A2510; continue 'dispatch;
	// 825A250C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A2510: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825A2514: 419A00C0  beq cr6, 0x825a25d4
	if ctx.cr[6].eq {
	pc = 0x825A25D4; continue 'dispatch;
	}
	// 825A2518: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825A251C: 4BC41D35  bl 0x821e4250
	ctx.lr = 0x825A2520;
	sub_821E4250(ctx, base);
	// 825A2520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2524: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2528: 419A00AC  beq cr6, 0x825a25d4
	if ctx.cr[6].eq {
	pc = 0x825A25D4; continue 'dispatch;
	}
	// 825A252C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A2530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A2534: 4845E195  bl 0x82a006c8
	ctx.lr = 0x825A2538;
	sub_82A006C8(ctx, base);
	// 825A2538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A253C: 419A000C  beq cr6, 0x825a2548
	if ctx.cr[6].eq {
	pc = 0x825A2548; continue 'dispatch;
	}
	// 825A2540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2544: 917EFFF8  stw r11, -8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 825A2548: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A254C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A2550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2554: 4845E175  bl 0x82a006c8
	ctx.lr = 0x825A2558;
	sub_82A006C8(ctx, base);
	// 825A2558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A255C: 419A000C  beq cr6, 0x825a2568
	if ctx.cr[6].eq {
	pc = 0x825A2568; continue 'dispatch;
	}
	// 825A2560: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A2564: D01EFFFC  stfs f0, -4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825A2568: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A256C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A2570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2574: 4845E155  bl 0x82a006c8
	ctx.lr = 0x825A2578;
	sub_82A006C8(ctx, base);
	// 825A2578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A257C: 419A000C  beq cr6, 0x825a2588
	if ctx.cr[6].eq {
	pc = 0x825A2588; continue 'dispatch;
	}
	// 825A2580: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A2584: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A2588: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825A258C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825A2590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2594: 4845E135  bl 0x82a006c8
	ctx.lr = 0x825A2598;
	sub_82A006C8(ctx, base);
	// 825A2598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A259C: 419A000C  beq cr6, 0x825a25a8
	if ctx.cr[6].eq {
	pc = 0x825A25A8; continue 'dispatch;
	}
	// 825A25A0: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A25A4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825A25A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A25AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825A25B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A25B4: 4845E115  bl 0x82a006c8
	ctx.lr = 0x825A25B8;
	sub_82A006C8(ctx, base);
	// 825A25B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A25BC: 419A0018  beq cr6, 0x825a25d4
	if ctx.cr[6].eq {
	pc = 0x825A25D4; continue 'dispatch;
	}
	// 825A25C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A25C4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825A25C8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825A25CC: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 825A25D0: 991E0008  stb r8, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 825A25D4: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A25D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A25DC: 409A0008  bne cr6, 0x825a25e4
	if !ctx.cr[6].eq {
	pc = 0x825A25E4; continue 'dispatch;
	}
	// 825A25E0: D3FEFFFC  stfs f31, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825A25E4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825A25E8: 39740014  addi r11, r20, 0x14
	ctx.r[11].s64 = ctx.r[20].s64 + 20;
	// 825A25EC: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 825A25F0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A25F4: 4198FED0  blt cr6, 0x825a24c4
	if ctx.cr[6].lt {
	pc = 0x825A24C4; continue 'dispatch;
	}
	// 825A25F8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825A25FC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 825A2600: 48706E34  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2608 size=16
    let mut pc: u32 = 0x825A2608;
    'dispatch: loop {
        match pc {
            0x825A2608 => {
    //   block [0x825A2608..0x825A2618)
	// 825A2608: 896300C4  lbz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 825A260C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825A2610: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825A2614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A2618 size=116
    let mut pc: u32 = 0x825A2618;
    'dispatch: loop {
        match pc {
            0x825A2618 => {
    //   block [0x825A2618..0x825A268C)
	// 825A2618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A261C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A2624: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A262C: 48343575  bl 0x828e5ba0
	ctx.lr = 0x825A2630;
	sub_828E5BA0(ctx, base);
	// 825A2630: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A2634: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A2638: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825A263C: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825A2640: 390A9150  addi r8, r10, -0x6eb0
	ctx.r[8].s64 = ctx.r[10].s64 + -28336;
	// 825A2644: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825A2648: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A264C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2650: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A2654: C0094138  lfs f0, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A2658: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2690 size=84
    let mut pc: u32 = 0x825A2690;
    'dispatch: loop {
        match pc {
            0x825A2690 => {
    //   block [0x825A2690..0x825A26E4)
	// 825A2690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A2698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A269C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A26A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A26A4: 48342D4D  bl 0x828e53f0
	ctx.lr = 0x825A26A8;
	sub_828E53F0(ctx, base);
	// 825A26A8: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825A26AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A26B0: 419A0008  beq cr6, 0x825a26b8
	if ctx.cr[6].eq {
	pc = 0x825A26B8; continue 'dispatch;
	}
	// 825A26B4: 48000E9D  bl 0x825a3550
	ctx.lr = 0x825A26B8;
	sub_825A3550(ctx, base);
	// 825A26B8: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825A26BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A26C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A26C4: 4199000C  bgt cr6, 0x825a26d0
	if ctx.cr[6].gt {
	pc = 0x825A26D0; continue 'dispatch;
	}
	// 825A26C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A26CC: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 825A26D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A26D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A26D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A26DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A26E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A26E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A26E8 size=52
    let mut pc: u32 = 0x825A26E8;
    'dispatch: loop {
        match pc {
            0x825A26E8 => {
    //   block [0x825A26E8..0x825A271C)
	// 825A26E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A26EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A26F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A26F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A26F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A26FC: 480003BD  bl 0x825a2ab8
	ctx.lr = 0x825A2700;
	sub_825A2AB8(ctx, base);
	// 825A2700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2704: 48342BDD  bl 0x828e52e0
	ctx.lr = 0x825A2708;
	sub_828E52E0(ctx, base);
	// 825A2708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A270C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A2710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A2714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A2718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2720 size=920
    let mut pc: u32 = 0x825A2720;
    'dispatch: loop {
        match pc {
            0x825A2720 => {
    //   block [0x825A2720..0x825A2AB8)
	// 825A2720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2724: 48706CD9  bl 0x82ca93fc
	ctx.lr = 0x825A2728;
	sub_82CA93D0(ctx, base);
	// 825A2728: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825A272C: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A2AB8 size=480
    let mut pc: u32 = 0x825A2AB8;
    'dispatch: loop {
        match pc {
            0x825A2AB8 => {
    //   block [0x825A2AB8..0x825A2C98)
	// 825A2AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2ABC: 4870694D  bl 0x82ca9408
	ctx.lr = 0x825A2AC0;
	sub_82CA93D0(ctx, base);
	// 825A2AC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A2AC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A2ACC: 807E00C8  lwz r3, 0xc8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 825A2AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A2AD4: 419A0048  beq cr6, 0x825a2b1c
	if ctx.cr[6].eq {
	pc = 0x825A2B1C; continue 'dispatch;
	}
	// 825A2AD8: 48000C91  bl 0x825a3768
	ctx.lr = 0x825A2ADC;
	sub_825A3768(ctx, base);
	// 825A2ADC: 83FE00C8  lwz r31, 0xc8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 825A2AE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A2AE4: 419A0034  beq cr6, 0x825a2b18
	if ctx.cr[6].eq {
	pc = 0x825A2B18; continue 'dispatch;
	}
	// 825A2AE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A2AEC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825A2AF0: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 825A2AF4: 939F00E8  stw r28, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[28].u32 ) };
	// 825A2AF8: 4BBF1341  bl 0x82193e38
	ctx.lr = 0x825A2AFC;
	sub_82193E38(ctx, base);
	// 825A2AFC: 93BF00EC  stw r29, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[29].u32 ) };
	// 825A2B00: 939F00E0  stw r28, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 825A2B04: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 825A2B08: 4BBF1331  bl 0x82193e38
	ctx.lr = 0x825A2B0C;
	sub_82193E38(ctx, base);
	// 825A2B0C: 93BF00E4  stw r29, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 825A2B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A2B14: 4BC79225  bl 0x8221bd38
	ctx.lr = 0x825A2B18;
	sub_8221BD38(ctx, base);
	// 825A2B18: 93BE00C8  stw r29, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 825A2B1C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825A2B20: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 825A2B24: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825A2B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2B2C: 419A0030  beq cr6, 0x825a2b5c
	if ctx.cr[6].eq {
	pc = 0x825A2B5C; continue 'dispatch;
	}
	// 825A2B30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2B34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2B38: 419A0078  beq cr6, 0x825a2bb0
	if ctx.cr[6].eq {
	pc = 0x825A2BB0; continue 'dispatch;
	}
	// 825A2B3C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A2B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2B44: 419A0018  beq cr6, 0x825a2b5c
	if ctx.cr[6].eq {
	pc = 0x825A2B5C; continue 'dispatch;
	}
	// 825A2B48: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A2B4C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A2B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2B54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2B58: 409A0008  bne cr6, 0x825a2b60
	if !ctx.cr[6].eq {
	pc = 0x825A2B60; continue 'dispatch;
	}
	// 825A2B5C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A2B60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A2B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2B68: 419A0128  beq cr6, 0x825a2c90
	if ctx.cr[6].eq {
	pc = 0x825A2C90; continue 'dispatch;
	}
	// 825A2B6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A2B70: 483B6001  bl 0x82958b70
	ctx.lr = 0x825A2B74;
	sub_82958B70(ctx, base);
	// 825A2B74: 89630028  lbz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A2B78: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825A2B7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2B80: 419A00FC  beq cr6, 0x825a2c7c
	if ctx.cr[6].eq {
	pc = 0x825A2C7C; continue 'dispatch;
	}
	// 825A2B84: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A2B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2B8C: 419A002C  beq cr6, 0x825a2bb8
	if ctx.cr[6].eq {
	pc = 0x825A2BB8; continue 'dispatch;
	}
	// 825A2B90: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825A2B94: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A2B98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825A2B9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A2BA0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2BA4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A2BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2BAC: 480000D4  b 0x825a2c80
	pc = 0x825A2C80; continue 'dispatch;
	// 825A2BB0: 4BBF1289  bl 0x82193e38
	ctx.lr = 0x825A2BB4;
	sub_82193E38(ctx, base);
	// 825A2BB4: 4BFFFFA8  b 0x825a2b5c
	pc = 0x825A2B5C; continue 'dispatch;
	// 825A2BB8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A2BBC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A2BC0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825A2BC4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A2BC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A2BCC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A2BD0: 40810054  ble 0x825a2c24
	if !ctx.cr[0].gt {
	pc = 0x825A2C24; continue 'dispatch;
	}
	// 825A2BD4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A2BD8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A2BDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A2BE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2BE4: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 825A2BE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A2BEC: 41980008  blt cr6, 0x825a2bf4
	if ctx.cr[6].lt {
	pc = 0x825A2BF4; continue 'dispatch;
	}
	// 825A2BF0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825A2BF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A2BF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A2BFC: 419A0014  beq cr6, 0x825a2c10
	if ctx.cr[6].eq {
	pc = 0x825A2C10; continue 'dispatch;
	}
	// 825A2C00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A2C04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A2C08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A2C0C: 4800000C  b 0x825a2c18
	pc = 0x825A2C18; continue 'dispatch;
	// 825A2C10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A2C14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A2C18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A2C1C: 4199FFB8  bgt cr6, 0x825a2bd4
	if ctx.cr[6].gt {
	pc = 0x825A2BD4; continue 'dispatch;
	}
	// 825A2C20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A2C24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A2C28: 419A0040  beq cr6, 0x825a2c68
	if ctx.cr[6].eq {
	pc = 0x825A2C68; continue 'dispatch;
	}
	// 825A2C2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A2C30: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 825A2C34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2C38: 41990008  bgt cr6, 0x825a2c40
	if ctx.cr[6].gt {
	pc = 0x825A2C40; continue 'dispatch;
	}
	// 825A2C3C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A2C40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A2C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2C48: 409A0020  bne cr6, 0x825a2c68
	if !ctx.cr[6].eq {
	pc = 0x825A2C68; continue 'dispatch;
	}
	// 825A2C4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A2C50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A2C54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A2C58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2C5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A2C60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2C64: 4800001C  b 0x825a2c80
	pc = 0x825A2C80; continue 'dispatch;
	// 825A2C68: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A2C6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A2C70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A2C74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2C78: 48000008  b 0x825a2c80
	pc = 0x825A2C80; continue 'dispatch;
	// 825A2C7C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A2C80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A2C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A2C88: 419A0008  beq cr6, 0x825a2c90
	if ctx.cr[6].eq {
	pc = 0x825A2C90; continue 'dispatch;
	}
	// 825A2C8C: 93BF01E0  stw r29, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 825A2C90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A2C94: 487067C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2C98 size=16
    let mut pc: u32 = 0x825A2C98;
    'dispatch: loop {
        match pc {
            0x825A2C98 => {
    //   block [0x825A2C98..0x825A2CA8)
	// 825A2C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A2C9C: 894B00C4  lbz r10, 0xc4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 825A2CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A2CA4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2CA8 size=92
    let mut pc: u32 = 0x825A2CA8;
    'dispatch: loop {
        match pc {
            0x825A2CA8 => {
    //   block [0x825A2CA8..0x825A2D04)
	// 825A2CA8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A2CAC: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825A2CB0: 40980008  bge cr6, 0x825a2cb8
	if !ctx.cr[6].lt {
	pc = 0x825A2CB8; continue 'dispatch;
	}
	// 825A2CB4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825A2CB8: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A2CBC: 806B00C8  lwz r3, 0xc8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825A2CC0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825A2CC4: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 825A2CC8: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825A2CCC: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825A2CD0: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A2CD4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A2CD8: 7CA75A14  add r5, r7, r11
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825A2CDC: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825A2CE0: 80850060  lwz r4, 0x60(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(96 as u32) ) } as u64;
	// 825A2CE4: 80A80060  lwz r5, 0x60(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(96 as u32) ) } as u64;
	// 825A2CE8: 7CE92214  add r7, r9, r4
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 825A2CEC: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825A2CF0: 40990008  ble cr6, 0x825a2cf8
	if !ctx.cr[6].gt {
	pc = 0x825A2CF8; continue 'dispatch;
	}
	// 825A2CF4: 7C892850  subf r4, r9, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 825A2CF8: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 825A2CFC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825A2D00: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2D04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2D04 size=8
    let mut pc: u32 = 0x825A2D04;
    'dispatch: loop {
        match pc {
            0x825A2D04 => {
    //   block [0x825A2D04..0x825A2D0C)
	// 825A2D04: 4800038C  b 0x825a3090
	sub_825A3090(ctx, base);
	return;
	// 825A2D08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A2D10 size=344
    let mut pc: u32 = 0x825A2D10;
    'dispatch: loop {
        match pc {
            0x825A2D10 => {
    //   block [0x825A2D10..0x825A2E68)
	// 825A2D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2D14: 487066F9  bl 0x82ca940c
	ctx.lr = 0x825A2D18;
	sub_82CA93D0(ctx, base);
	// 825A2D18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A2D1C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825A2D20: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 825A2D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A2D28: 390992CC  addi r8, r9, -0x6d34
	ctx.r[8].s64 = ctx.r[9].s64 + -27956;
	// 825A2D2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A2D30: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825A2D34: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825A2D38: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 825A2D3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A2D40: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825A2D44: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825A2D48: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825A2D4C: C1A801C4  lfs f13, 0x1c4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(452 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A2D50: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 825A2D54: C18824D8  lfs f12, 0x24d8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9432 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A2D58: 997F0049  stb r11, 0x49(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(73 as u32), ctx.r[11].u8 ) };
	// 825A2D5C: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 825A2D60: 997F004A  stb r11, 0x4a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(74 as u32), ctx.r[11].u8 ) };
	// 825A2D64: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 825A2D68: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 825A2D6C: D19F0030  stfs f12, 0x30(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 825A2D70: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825A2D74: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 825A2D78: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A2D7C: 9BDF0044  stb r30, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u8 ) };
	// 825A2D80: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 825A2D84: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 825A2D88: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A2D8C: 38869140  addi r4, r6, -0x6ec0
	ctx.r[4].s64 = ctx.r[6].s64 + -28352;
	// 825A2D90: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 825A2D94: C00801B8  lfs f0, 0x1b8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A2D98: 9BDF0045  stb r30, 0x45(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(69 as u32), ctx.r[30].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A2E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A2E68 size=548
    let mut pc: u32 = 0x825A2E68;
    'dispatch: loop {
        match pc {
            0x825A2E68 => {
    //   block [0x825A2E68..0x825A308C)
	// 825A2E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A2E6C: 48706591  bl 0x82ca93fc
	ctx.lr = 0x825A2E70;
	sub_82CA93D0(ctx, base);
	// 825A2E70: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825A2E74: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3090 size=260
    let mut pc: u32 = 0x825A3090;
    'dispatch: loop {
        match pc {
            0x825A3090 => {
    //   block [0x825A3090..0x825A3194)
	// 825A3090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A3094: 4870636D  bl 0x82ca9400
	ctx.lr = 0x825A3098;
	sub_82CA93D0(ctx, base);
	// 825A3098: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A309C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A30A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825A30A4: 2F050008  cmpwi cr6, r5, 8
	ctx.cr[6].compare_i32(ctx.r[5].s32, 8, &mut ctx.xer);
	// 825A30A8: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825A30AC: 4099000C  ble cr6, 0x825a30b8
	if !ctx.cr[6].gt {
	pc = 0x825A30B8; continue 'dispatch;
	}
	// 825A30B0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 825A30B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825A30B8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A30BC: 3B7F00A0  addi r27, r31, 0xa0
	ctx.r[27].s64 = ctx.r[31].s64 + 160;
	// 825A30C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825A30C4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A3198 size=224
    let mut pc: u32 = 0x825A3198;
    'dispatch: loop {
        match pc {
            0x825A3198 => {
    //   block [0x825A3198..0x825A3278)
	// 825A3198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A319C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A31A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A31A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A31A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A31AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825A31B0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825A31B4: 40980044  bge cr6, 0x825a31f8
	if !ctx.cr[6].lt {
	pc = 0x825A31F8; continue 'dispatch;
	}
	// 825A31B8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A31BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A31C0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825A31C4: 4099009C  ble cr6, 0x825a3260
	if !ctx.cr[6].gt {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A31C8: 39630074  addi r11, r3, 0x74
	ctx.r[11].s64 = ctx.r[3].s64 + 116;
	// 825A31CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A31D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A31D4: 419A0010  beq cr6, 0x825a31e4
	if ctx.cr[6].eq {
	pc = 0x825A31E4; continue 'dispatch;
	}
	// 825A31D8: 81290054  lwz r9, 0x54(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A31DC: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 825A31E0: 409A0048  bne cr6, 0x825a3228
	if !ctx.cr[6].eq {
	pc = 0x825A3228; continue 'dispatch;
	}
	// 825A31E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A31E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A31EC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825A31F0: 4198FFDC  blt cr6, 0x825a31cc
	if ctx.cr[6].lt {
	pc = 0x825A31CC; continue 'dispatch;
	}
	// 825A31F4: 4800006C  b 0x825a3260
	pc = 0x825A3260; continue 'dispatch;
	// 825A31F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A31FC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A3200: 40980060  bge cr6, 0x825a3260
	if !ctx.cr[6].lt {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A3204: 3964001D  addi r11, r4, 0x1d
	ctx.r[11].s64 = ctx.r[4].s64 + 29;
	// 825A3208: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A320C: 7D6A182E  lwzx r11, r10, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825A3210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3214: 419A004C  beq cr6, 0x825a3260
	if ctx.cr[6].eq {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A3218: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A321C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 825A3220: 419A0040  beq cr6, 0x825a3260
	if ctx.cr[6].eq {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A3224: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825A3228: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A322C: 41980034  blt cr6, 0x825a3260
	if ctx.cr[6].lt {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A3230: 396A001D  addi r11, r10, 0x1d
	ctx.r[11].s64 = ctx.r[10].s64 + 29;
	// 825A3234: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A3238: 7FEA182E  lwzx r31, r10, r3
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825A323C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A3240: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 825A3244: 419A001C  beq cr6, 0x825a3260
	if ctx.cr[6].eq {
	pc = 0x825A3260; continue 'dispatch;
	}
	// 825A3248: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A324C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A3250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3254: C02BD5C8  lfs f1, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A3258: 48004589  bl 0x825a77e0
	ctx.lr = 0x825A325C;
	sub_825A77E0(ctx, base);
	// 825A325C: 9BDF009C  stb r30, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u8 ) };
	// 825A3260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A3264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A3268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A326C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A3270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A3274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3278 size=348
    let mut pc: u32 = 0x825A3278;
    'dispatch: loop {
        match pc {
            0x825A3278 => {
    //   block [0x825A3278..0x825A33D4)
	// 825A3278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A327C: 4870617D  bl 0x82ca93f8
	ctx.lr = 0x825A3280;
	sub_82CA93D0(ctx, base);
	// 825A3280: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3284: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A3288: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825A328C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3290: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A3294: 40990138  ble cr6, 0x825a33cc
	if !ctx.cr[6].gt {
	pc = 0x825A33CC; continue 'dispatch;
	}
	// 825A3298: 3B1B0074  addi r24, r27, 0x74
	ctx.r[24].s64 = ctx.r[27].s64 + 116;
	// 825A329C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 825A32A0: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A32A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A32A8: 419A0110  beq cr6, 0x825a33b8
	if ctx.cr[6].eq {
	pc = 0x825A33B8; continue 'dispatch;
	}
	// 825A32AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A32B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A32B4: 419A001C  beq cr6, 0x825a32d0
	if ctx.cr[6].eq {
	pc = 0x825A32D0; continue 'dispatch;
	}
	// 825A32B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A32BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A32C0: 419A000C  beq cr6, 0x825a32cc
	if ctx.cr[6].eq {
	pc = 0x825A32CC; continue 'dispatch;
	}
	// 825A32C4: 555C003E  slwi r28, r10, 0
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 825A32C8: 4800000C  b 0x825a32d4
	pc = 0x825A32D4; continue 'dispatch;
	// 825A32CC: 4BBF0B6D  bl 0x82193e38
	ctx.lr = 0x825A32D0;
	sub_82193E38(ctx, base);
	// 825A32D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A32D4: 817B00E4  lwz r11, 0xe4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A32D8: 387B00E0  addi r3, r27, 0xe0
	ctx.r[3].s64 = ctx.r[27].s64 + 224;
	// 825A32DC: 83FC007C  lwz r31, 0x7c(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A32E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A32E4: 419A001C  beq cr6, 0x825a3300
	if ctx.cr[6].eq {
	pc = 0x825A3300; continue 'dispatch;
	}
	// 825A32E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A32EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A32F0: 419A000C  beq cr6, 0x825a32fc
	if ctx.cr[6].eq {
	pc = 0x825A32FC; continue 'dispatch;
	}
	// 825A32F4: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825A32F8: 4800000C  b 0x825a3304
	pc = 0x825A3304; continue 'dispatch;
	// 825A32FC: 4BBF0B3D  bl 0x82193e38
	ctx.lr = 0x825A3300;
	sub_82193E38(ctx, base);
	// 825A3300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A3304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3308: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A330C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3310: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A3314: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A3318: 4E800421  bctrl
	ctx.lr = 0x825A331C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A331C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3320: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A3324: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825A3328: 40990090  ble cr6, 0x825a33b8
	if !ctx.cr[6].gt {
	pc = 0x825A33B8; continue 'dispatch;
	}
	// 825A332C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 825A3330: 7F1AF000  cmpw cr6, r26, r30
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825A3334: 419A0070  beq cr6, 0x825a33a4
	if ctx.cr[6].eq {
	pc = 0x825A33A4; continue 'dispatch;
	}
	// 825A3338: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A333C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A3340: 419A0064  beq cr6, 0x825a33a4
	if ctx.cr[6].eq {
	pc = 0x825A33A4; continue 'dispatch;
	}
	// 825A3344: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A3348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A334C: 419A001C  beq cr6, 0x825a3368
	if ctx.cr[6].eq {
	pc = 0x825A3368; continue 'dispatch;
	}
	// 825A3350: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A3358: 419A000C  beq cr6, 0x825a3364
	if ctx.cr[6].eq {
	pc = 0x825A3364; continue 'dispatch;
	}
	// 825A335C: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825A3360: 4800000C  b 0x825a336c
	pc = 0x825A336C; continue 'dispatch;
	// 825A3364: 4BBF0AD5  bl 0x82193e38
	ctx.lr = 0x825A3368;
	sub_82193E38(ctx, base);
	// 825A3368: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825A336C: 807C007C  lwz r3, 0x7c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A3370: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A3374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A3378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A337C: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A3380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A3384: 4E800421  bctrl
	ctx.lr = 0x825A3388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A3388: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A338C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A3390: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A3394: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3398: 81090098  lwz r8, 0x98(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A339C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825A33A0: 4E800421  bctrl
	ctx.lr = 0x825A33A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A33A4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A33A8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825A33AC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825A33B0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A33B4: 4198FF7C  blt cr6, 0x825a3330
	if ctx.cr[6].lt {
	pc = 0x825A3330; continue 'dispatch;
	}
	// 825A33B8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A33BC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 825A33C0: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 825A33C4: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A33C8: 4198FED8  blt cr6, 0x825a32a0
	if ctx.cr[6].lt {
	pc = 0x825A32A0; continue 'dispatch;
	}
	// 825A33CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A33D0: 48706078  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A33D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A33D8 size=372
    let mut pc: u32 = 0x825A33D8;
    'dispatch: loop {
        match pc {
            0x825A33D8 => {
    //   block [0x825A33D8..0x825A354C)
	// 825A33D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A33DC: 48706025  bl 0x82ca9400
	ctx.lr = 0x825A33E0;
	sub_82CA93D0(ctx, base);
	// 825A33E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A33E4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825A33E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A33EC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825A33F0: 41980154  blt cr6, 0x825a3544
	if ctx.cr[6].lt {
	pc = 0x825A3544; continue 'dispatch;
	}
	// 825A33F4: 397A001D  addi r11, r26, 0x1d
	ctx.r[11].s64 = ctx.r[26].s64 + 29;
	// 825A33F8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A33FC: 7C6AE02E  lwzx r3, r10, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825A3400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A3404: 419A0140  beq cr6, 0x825a3544
	if ctx.cr[6].eq {
	pc = 0x825A3544; continue 'dispatch;
	}
	// 825A3408: 4BBD0A31  bl 0x82173e38
	ctx.lr = 0x825A340C;
	sub_82173E38(ctx, base);
	// 825A340C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A3410: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825A3414: 419A0018  beq cr6, 0x825a342c
	if ctx.cr[6].eq {
	pc = 0x825A342C; continue 'dispatch;
	}
	// 825A3418: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A341C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A3420: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A3424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A3428: 409A0008  bne cr6, 0x825a3430
	if !ctx.cr[6].eq {
	pc = 0x825A3430; continue 'dispatch;
	}
	// 825A342C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A3430: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A3434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3438: 419A010C  beq cr6, 0x825a3544
	if ctx.cr[6].eq {
	pc = 0x825A3544; continue 'dispatch;
	}
	// 825A343C: 3BFC00E0  addi r31, r28, 0xe0
	ctx.r[31].s64 = ctx.r[28].s64 + 224;
	// 825A3440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3444: 4BBD09F5  bl 0x82173e38
	ctx.lr = 0x825A3448;
	sub_82173E38(ctx, base);
	// 825A3448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A344C: 419A0018  beq cr6, 0x825a3464
	if ctx.cr[6].eq {
	pc = 0x825A3464; continue 'dispatch;
	}
	// 825A3450: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A3454: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A3458: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A345C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A3460: 409A0008  bne cr6, 0x825a3468
	if !ctx.cr[6].eq {
	pc = 0x825A3468; continue 'dispatch;
	}
	// 825A3464: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A3468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A346C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3470: 419A00D4  beq cr6, 0x825a3544
	if ctx.cr[6].eq {
	pc = 0x825A3544; continue 'dispatch;
	}
	// 825A3474: 83DB007C  lwz r30, 0x7c(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A3478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A347C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3480: 4BBD09B9  bl 0x82173e38
	ctx.lr = 0x825A3484;
	sub_82173E38(ctx, base);
	// 825A3484: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A3488: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A348C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A3490: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A3494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825A3498: 4E800421  bctrl
	ctx.lr = 0x825A349C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A349C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A34A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A34A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A34A8: 4099009C  ble cr6, 0x825a3544
	if !ctx.cr[6].gt {
	pc = 0x825A3544; continue 'dispatch;
	}
	// 825A34AC: 3BBC0074  addi r29, r28, 0x74
	ctx.r[29].s64 = ctx.r[28].s64 + 116;
	// 825A34B0: 7F1ED000  cmpw cr6, r30, r26
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825A34B4: 419A007C  beq cr6, 0x825a3530
	if ctx.cr[6].eq {
	pc = 0x825A3530; continue 'dispatch;
	}
	// 825A34B8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A34BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A34C0: 419A0070  beq cr6, 0x825a3530
	if ctx.cr[6].eq {
	pc = 0x825A3530; continue 'dispatch;
	}
	// 825A34C4: 4BBD0975  bl 0x82173e38
	ctx.lr = 0x825A34C8;
	sub_82173E38(ctx, base);
	// 825A34C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A34CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A34D0: 419A0018  beq cr6, 0x825a34e8
	if ctx.cr[6].eq {
	pc = 0x825A34E8; continue 'dispatch;
	}
	// 825A34D4: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A34D8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A34DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A34E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A34E4: 409A0008  bne cr6, 0x825a34ec
	if !ctx.cr[6].eq {
	pc = 0x825A34EC; continue 'dispatch;
	}
	// 825A34E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A34EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A34F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A34F4: 419A003C  beq cr6, 0x825a3530
	if ctx.cr[6].eq {
	pc = 0x825A3530; continue 'dispatch;
	}
	// 825A34F8: 807B007C  lwz r3, 0x7c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A34FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A3500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A3504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3508: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A350C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A3510: 4E800421  bctrl
	ctx.lr = 0x825A3514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A3514: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A3518: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A351C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825A3520: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3524: 81090098  lwz r8, 0x98(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A3528: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825A352C: 4E800421  bctrl
	ctx.lr = 0x825A3530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A3530: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3534: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825A3538: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825A353C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A3540: 4198FF70  blt cr6, 0x825a34b0
	if ctx.cr[6].lt {
	pc = 0x825A34B0; continue 'dispatch;
	}
	// 825A3544: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A3548: 48705F08  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3550 size=532
    let mut pc: u32 = 0x825A3550;
    'dispatch: loop {
        match pc {
            0x825A3550 => {
    //   block [0x825A3550..0x825A3764)
	// 825A3550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A3554: 48705EB5  bl 0x82ca9408
	ctx.lr = 0x825A3558;
	sub_82CA93D0(ctx, base);
	// 825A3558: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825A355C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3560: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A3564: 3BDC00E0  addi r30, r28, 0xe0
	ctx.r[30].s64 = ctx.r[28].s64 + 224;
	// 825A3568: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A356C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3570: 419A0020  beq cr6, 0x825a3590
	if ctx.cr[6].eq {
	pc = 0x825A3590; continue 'dispatch;
	}
	// 825A3574: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3578: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A357C: 419A000C  beq cr6, 0x825a3588
	if ctx.cr[6].eq {
	pc = 0x825A3588; continue 'dispatch;
	}
	// 825A3580: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A3584: 48000010  b 0x825a3594
	pc = 0x825A3594; continue 'dispatch;
	// 825A3588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A358C: 4BBF08AD  bl 0x82193e38
	ctx.lr = 0x825A3590;
	sub_82193E38(ctx, base);
	// 825A3590: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A3594: 4BBFFF2D  bl 0x821a34c0
	ctx.lr = 0x825A3598;
	sub_821A34C0(ctx, base);
	// 825A3598: 817C00EC  lwz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 825A359C: 3BFC00E8  addi r31, r28, 0xe8
	ctx.r[31].s64 = ctx.r[28].s64 + 232;
	// 825A35A0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825A35A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A35A8: 419A008C  beq cr6, 0x825a3634
	if ctx.cr[6].eq {
	pc = 0x825A3634; continue 'dispatch;
	}
	// 825A35AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A35B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A35B4: 419A00AC  beq cr6, 0x825a3660
	if ctx.cr[6].eq {
	pc = 0x825A3660; continue 'dispatch;
	}
	// 825A35B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A35BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A35C0: 419A0074  beq cr6, 0x825a3634
	if ctx.cr[6].eq {
	pc = 0x825A3634; continue 'dispatch;
	}
	// 825A35C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A35C8: 4BBD0871  bl 0x82173e38
	ctx.lr = 0x825A35CC;
	sub_82173E38(ctx, base);
	// 825A35CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A35D0: 419A0018  beq cr6, 0x825a35e8
	if ctx.cr[6].eq {
	pc = 0x825A35E8; continue 'dispatch;
	}
	// 825A35D4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A35D8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A35DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A35E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A35E4: 409A0008  bne cr6, 0x825a35ec
	if !ctx.cr[6].eq {
	pc = 0x825A35EC; continue 'dispatch;
	}
	// 825A35E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A35EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A35F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A35F4: 409A0040  bne cr6, 0x825a3634
	if !ctx.cr[6].eq {
	pc = 0x825A3634; continue 'dispatch;
	}
	// 825A35F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A35FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A3600: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A3604: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A3608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A360C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A3610: 4BBF0829  bl 0x82193e38
	ctx.lr = 0x825A3614;
	sub_82193E38(ctx, base);
	// 825A3614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A361C: 4BF2E8AD  bl 0x824d1ec8
	ctx.lr = 0x825A3620;
	sub_824D1EC8(ctx, base);
	// 825A3620: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A3624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A3628: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A362C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A3630: 4BBF0809  bl 0x82193e38
	ctx.lr = 0x825A3634;
	sub_82193E38(ctx, base);
	// 825A3634: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 825A3638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A363C: 419A0060  beq cr6, 0x825a369c
	if ctx.cr[6].eq {
	pc = 0x825A369C; continue 'dispatch;
	}
	// 825A3640: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A3644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3648: 419A0028  beq cr6, 0x825a3670
	if ctx.cr[6].eq {
	pc = 0x825A3670; continue 'dispatch;
	}
	// 825A364C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A3654: 419A0014  beq cr6, 0x825a3668
	if ctx.cr[6].eq {
	pc = 0x825A3668; continue 'dispatch;
	}
	// 825A3658: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A365C: 48000018  b 0x825a3674
	pc = 0x825A3674; continue 'dispatch;
	// 825A3660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3664: 4BFFFFCC  b 0x825a3630
	pc = 0x825A3630; continue 'dispatch;
	// 825A3668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A366C: 4BBF07CD  bl 0x82193e38
	ctx.lr = 0x825A3670;
	sub_82193E38(ctx, base);
	// 825A3670: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A3674: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A3678: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A367C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3680: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A3684: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A3688: 4E800421  bctrl
	ctx.lr = 0x825A368C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A368C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825A3690: 390000D0  li r8, 0xd0
	ctx.r[8].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3768 size=120
    let mut pc: u32 = 0x825A3768;
    'dispatch: loop {
        match pc {
            0x825A3768 => {
    //   block [0x825A3768..0x825A37E0)
	// 825A3768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A376C: 48705C9D  bl 0x82ca9408
	ctx.lr = 0x825A3770;
	sub_82CA93D0(ctx, base);
	// 825A3770: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A3774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A3778: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A377C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 825A3780: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A3788: 40990044  ble cr6, 0x825a37cc
	if !ctx.cr[6].gt {
	pc = 0x825A37CC; continue 'dispatch;
	}
	// 825A378C: 3BFE0074  addi r31, r30, 0x74
	ctx.r[31].s64 = ctx.r[30].s64 + 116;
	// 825A3790: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A3798: 419A0020  beq cr6, 0x825a37b8
	if ctx.cr[6].eq {
	pc = 0x825A37B8; continue 'dispatch;
	}
	// 825A379C: 48002EFD  bl 0x825a6698
	ctx.lr = 0x825A37A0;
	sub_825A6698(ctx, base);
	// 825A37A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A37A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A37A8: 419A000C  beq cr6, 0x825a37b4
	if ctx.cr[6].eq {
	pc = 0x825A37B4; continue 'dispatch;
	}
	// 825A37AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A37B0: 48000141  bl 0x825a38f0
	ctx.lr = 0x825A37B4;
	sub_825A38F0(ctx, base);
	// 825A37B4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A37B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A37BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825A37C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825A37C4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A37C8: 4198FFC8  blt cr6, 0x825a3790
	if ctx.cr[6].lt {
	pc = 0x825A3790; continue 'dispatch;
	}
	// 825A37CC: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A37D0: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825A37D4: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825A37D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A37DC: 48705C7C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A37E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A37E0 size=164
    let mut pc: u32 = 0x825A37E0;
    'dispatch: loop {
        match pc {
            0x825A37E0 => {
    //   block [0x825A37E0..0x825A3884)
	// 825A37E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A37E4: 48705C25  bl 0x82ca9408
	ctx.lr = 0x825A37E8;
	sub_82CA93D0(ctx, base);
	// 825A37E8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A3888 size=100
    let mut pc: u32 = 0x825A3888;
    'dispatch: loop {
        match pc {
            0x825A3888 => {
    //   block [0x825A3888..0x825A38EC)
	// 825A3888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A388C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A3890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A3894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A3898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A389C: 3964001D  addi r11, r4, 0x1d
	ctx.r[11].s64 = ctx.r[4].s64 + 29;
	// 825A38A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A38A4: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825A38A8: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A38AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A38B0: 419A0024  beq cr6, 0x825a38d4
	if ctx.cr[6].eq {
	pc = 0x825A38D4; continue 'dispatch;
	}
	// 825A38B4: 48002DE5  bl 0x825a6698
	ctx.lr = 0x825A38B8;
	sub_825A6698(ctx, base);
	// 825A38B8: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825A38BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A38C0: 419A000C  beq cr6, 0x825a38cc
	if ctx.cr[6].eq {
	pc = 0x825A38CC; continue 'dispatch;
	}
	// 825A38C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A38C8: 48000029  bl 0x825a38f0
	ctx.lr = 0x825A38CC;
	sub_825A38F0(ctx, base);
	// 825A38CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A38D0: 7D7FF12E  stwx r11, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 825A38D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A38D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A38DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A38E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A38E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A38E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A38F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A38F0 size=200
    let mut pc: u32 = 0x825A38F0;
    'dispatch: loop {
        match pc {
            0x825A38F0 => {
    //   block [0x825A38F0..0x825A39B8)
	// 825A38F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A38F4: 48705B11  bl 0x82ca9404
	ctx.lr = 0x825A38F8;
	sub_82CA93D0(ctx, base);
	// 825A38F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A38FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A3900: 387E0048  addi r3, r30, 0x48
	ctx.r[3].s64 = ctx.r[30].s64 + 72;
	// 825A3904: 4BC14215  bl 0x821b7b18
	ctx.lr = 0x825A3908;
	sub_821B7B18(ctx, base);
	// 825A3908: 3BFE0040  addi r31, r30, 0x40
	ctx.r[31].s64 = ctx.r[30].s64 + 64;
	// 825A390C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A3910: 4BC14209  bl 0x821b7b18
	ctx.lr = 0x825A3914;
	sub_821B7B18(ctx, base);
	// 825A3914: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A3918: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 825A391C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A3920: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 825A3924: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 825A3928: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A392C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A3930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A3934: 419A0034  beq cr6, 0x825a3968
	if ctx.cr[6].eq {
	pc = 0x825A3968; continue 'dispatch;
	}
	// 825A3938: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A393C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825A3940: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825A3944: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A3948: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A394C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A3950: 409A0014  bne cr6, 0x825a3964
	if !ctx.cr[6].eq {
	pc = 0x825A3964; continue 'dispatch;
	}
	// 825A3954: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A3958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A395C: 409A0008  bne cr6, 0x825a3964
	if !ctx.cr[6].eq {
	pc = 0x825A3964; continue 'dispatch;
	}
	// 825A3960: 4BC783D9  bl 0x8221bd38
	ctx.lr = 0x825A3964;
	sub_8221BD38(ctx, base);
	// 825A3964: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A3968: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825A396C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A3970: 4080FFB4  bge 0x825a3924
	if !ctx.cr[0].lt {
	pc = 0x825A3924; continue 'dispatch;
	}
	// 825A3974: 939E0010  stw r28, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 825A3978: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825A397C: 4BBF04BD  bl 0x82193e38
	ctx.lr = 0x825A3980;
	sub_82193E38(ctx, base);
	// 825A3980: 93BE0014  stw r29, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 825A3984: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825A3988: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825A398C: 4BBF04AD  bl 0x82193e38
	ctx.lr = 0x825A3990;
	sub_82193E38(ctx, base);
	// 825A3990: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 825A3994: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A3998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A399C: 4BBF049D  bl 0x82193e38
	ctx.lr = 0x825A39A0;
	sub_82193E38(ctx, base);
	// 825A39A0: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825A39A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A39A8: 4BC78391  bl 0x8221bd38
	ctx.lr = 0x825A39AC;
	sub_8221BD38(ctx, base);
	// 825A39AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A39B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A39B4: 48705AA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A39B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A39B8 size=248
    let mut pc: u32 = 0x825A39B8;
    'dispatch: loop {
        match pc {
            0x825A39B8 => {
    //   block [0x825A39B8..0x825A3AB0)
	// 825A39B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A39BC: 48705A51  bl 0x82ca940c
	ctx.lr = 0x825A39C0;
	sub_82CA93D0(ctx, base);
	// 825A39C0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A3AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A3AB0 size=1532
    let mut pc: u32 = 0x825A3AB0;
    'dispatch: loop {
        match pc {
            0x825A3AB0 => {
    //   block [0x825A3AB0..0x825A40AC)
	// 825A3AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A3AB4: 48705921  bl 0x82ca93d4
	ctx.lr = 0x825A3AB8;
	sub_82CA93D0(ctx, base);
	// 825A3AB8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 825A3ABC: 4870A215  bl 0x82cadcd0
	ctx.lr = 0x825A3AC0;
	sub_82CADCA0(ctx, base);
	// 825A3AC0: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A40B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A40B0 size=716
    let mut pc: u32 = 0x825A40B0;
    'dispatch: loop {
        match pc {
            0x825A40B0 => {
    //   block [0x825A40B0..0x825A437C)
	// 825A40B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A40B4: 48705351  bl 0x82ca9404
	ctx.lr = 0x825A40B8;
	sub_82CA93D0(ctx, base);
	// 825A40B8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A40BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A40C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A40C4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825A40C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A40CC: 409A02A4  bne cr6, 0x825a4370
	if !ctx.cr[6].eq {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A40D0: 897F0047  lbz r11, 0x47(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(71 as u32) ) } as u64;
	// 825A40D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A40D8: 409A0250  bne cr6, 0x825a4328
	if !ctx.cr[6].eq {
	pc = 0x825A4328; continue 'dispatch;
	}
	// 825A40DC: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 825A40E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A40E4: 409A0140  bne cr6, 0x825a4224
	if !ctx.cr[6].eq {
	pc = 0x825A4224; continue 'dispatch;
	}
	// 825A40E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A40EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A40F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A40F4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825A40F8: 995F0045  stb r10, 0x45(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(69 as u32), ctx.r[10].u8 ) };
	// 825A40FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A4100: 40990040  ble cr6, 0x825a4140
	if !ctx.cr[6].gt {
	pc = 0x825A4140; continue 'dispatch;
	}
	// 825A4104: 395F0074  addi r10, r31, 0x74
	ctx.r[10].s64 = ctx.r[31].s64 + 116;
	// 825A4108: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A410C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A4110: 419A001C  beq cr6, 0x825a412c
	if ctx.cr[6].eq {
	pc = 0x825A412C; continue 'dispatch;
	}
	// 825A4114: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A4118: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825A411C: 419A0010  beq cr6, 0x825a412c
	if ctx.cr[6].eq {
	pc = 0x825A412C; continue 'dispatch;
	}
	// 825A4120: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825A4124: 419A0008  beq cr6, 0x825a412c
	if ctx.cr[6].eq {
	pc = 0x825A412C; continue 'dispatch;
	}
	// 825A4128: 9BBF0045  stb r29, 0x45(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(69 as u32), ctx.r[29].u8 ) };
	// 825A412C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4130: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825A4134: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825A4138: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A413C: 4198FFCC  blt cr6, 0x825a4108
	if ctx.cr[6].lt {
	pc = 0x825A4108; continue 'dispatch;
	}
	// 825A4140: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 825A4144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A4148: 419A0228  beq cr6, 0x825a4370
	if ctx.cr[6].eq {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A414C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A4150: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825A4154: 394B0120  addi r10, r11, 0x120
	ctx.r[10].s64 = ctx.r[11].s64 + 288;
	// 825A4158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A415C: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 825A4160: C3EAB530  lfs f31, -0x4ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19152 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A4164: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825A4168: 4BBCFCD1  bl 0x82173e38
	ctx.lr = 0x825A416C;
	sub_82173E38(ctx, base);
	// 825A416C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A4170: 419A0200  beq cr6, 0x825a4370
	if ctx.cr[6].eq {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A4174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A4178: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825A417C: 4BBCFCBD  bl 0x82173e38
	ctx.lr = 0x825A4180;
	sub_82173E38(ctx, base);
	// 825A4180: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A4184: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825A4188: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A418C: 409A0034  bne cr6, 0x825a41c0
	if !ctx.cr[6].eq {
	pc = 0x825A41C0; continue 'dispatch;
	}
	// 825A4190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A4194: 4BBCFCA5  bl 0x82173e38
	ctx.lr = 0x825A4198;
	sub_82173E38(ctx, base);
	// 825A4198: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A419C: 556A77FE  rlwinm r10, r11, 0xe, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 825A41A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A41A4: 409A001C  bne cr6, 0x825a41c0
	if !ctx.cr[6].eq {
	pc = 0x825A41C0; continue 'dispatch;
	}
	// 825A41A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A41AC: 4BBCFC8D  bl 0x82173e38
	ctx.lr = 0x825A41B0;
	sub_82173E38(ctx, base);
	// 825A41B0: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A41B4: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825A41B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A41BC: 419A0008  beq cr6, 0x825a41c4
	if ctx.cr[6].eq {
	pc = 0x825A41C4; continue 'dispatch;
	}
	// 825A41C0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 825A41C4: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 825A41C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A41CC: 419A01A4  beq cr6, 0x825a4370
	if ctx.cr[6].eq {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A41D0: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A41D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A41D8: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A41DC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825A41E0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825A41E4: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 825A41E8: 4BBCFC51  bl 0x82173e38
	ctx.lr = 0x825A41EC;
	sub_82173E38(ctx, base);
	// 825A41EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A41F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A41F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A41F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825A41FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825A4200: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825A4204: 48001BD5  bl 0x825a5dd8
	ctx.lr = 0x825A4208;
	sub_825A5DD8(ctx, base);
	// 825A4208: C1BC0000  lfs f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A420C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 825A4210: 40980160  bge cr6, 0x825a4370
	if !ctx.cr[6].lt {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A4214: D3FC0000  stfs f31, 0(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A4218: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A421C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A4220: 48705234  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 825A4224: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A4228: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A422C: 3B8B0120  addi r28, r11, 0x120
	ctx.r[28].s64 = ctx.r[11].s64 + 288;
	// 825A4230: C3FC9364  lfs f31, -0x6c9c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-27804 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A4234: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A4238: 40990138  ble cr6, 0x825a4370
	if !ctx.cr[6].gt {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A423C: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825A4240: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A4244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A4248: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 825A424C: 4BBCFBED  bl 0x82173e38
	ctx.lr = 0x825A4250;
	sub_82173E38(ctx, base);
	// 825A4250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A4254: 419A0074  beq cr6, 0x825a42c8
	if ctx.cr[6].eq {
	pc = 0x825A42C8; continue 'dispatch;
	}
	// 825A4258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A425C: 4BBCFBDD  bl 0x82173e38
	ctx.lr = 0x825A4260;
	sub_82173E38(ctx, base);
	// 825A4260: 480589D1  bl 0x825fcc30
	ctx.lr = 0x825A4264;
	sub_825FCC30(ctx, base);
	// 825A4264: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A4268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A426C: 419A005C  beq cr6, 0x825a42c8
	if ctx.cr[6].eq {
	pc = 0x825A42C8; continue 'dispatch;
	}
	// 825A4270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A4274: 4BBCFBC5  bl 0x82173e38
	ctx.lr = 0x825A4278;
	sub_82173E38(ctx, base);
	// 825A4278: 4BBFF249  bl 0x821a34c0
	ctx.lr = 0x825A427C;
	sub_821A34C0(ctx, base);
	// 825A427C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825A4280: C9BC0000  lfd f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 825A4284: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A4288: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A428C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A4290: C98A9660  lfd f12, -0x69a0(r10)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825A4294: FDAD6024  fdiv f13, f13, f12
	ctx.f[13].f64 = ctx.f[13].f64 / ctx.f[12].f64;
	// 825A4298: FD810372  fmul f12, f1, f13
	ctx.f[12].f64 = ctx.f[1].f64 * ctx.f[13].f64;
	// 825A429C: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825A42A0: 4099001C  ble cr6, 0x825a42bc
	if !ctx.cr[6].gt {
	pc = 0x825A42BC; continue 'dispatch;
	}
	// 825A42A4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A42A8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825A42AC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A42B0: 4199000C  bgt cr6, 0x825a42bc
	if ctx.cr[6].gt {
	pc = 0x825A42BC; continue 'dispatch;
	}
	// 825A42B4: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825A42B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A42BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A42C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A42C4: 419A0008  beq cr6, 0x825a42cc
	if ctx.cr[6].eq {
	pc = 0x825A42CC; continue 'dispatch;
	}
	// 825A42C8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825A42CC: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 825A42D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A42D4: 419A009C  beq cr6, 0x825a4370
	if ctx.cr[6].eq {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A42D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A42DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A42E0: 40990090  ble cr6, 0x825a4370
	if !ctx.cr[6].gt {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A42E4: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 825A42E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A42EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A42F0: 419A0018  beq cr6, 0x825a4308
	if ctx.cr[6].eq {
	pc = 0x825A4308; continue 'dispatch;
	}
	// 825A42F4: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A42F8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 825A42FC: 419A000C  beq cr6, 0x825a4308
	if ctx.cr[6].eq {
	pc = 0x825A4308; continue 'dispatch;
	}
	// 825A4300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A4304: 480024DD  bl 0x825a67e0
	ctx.lr = 0x825A4308;
	sub_825A67E0(ctx, base);
	// 825A4308: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A430C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825A4310: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825A4314: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A4318: 4198FFD0  blt cr6, 0x825a42e8
	if ctx.cr[6].lt {
	pc = 0x825A42E8; continue 'dispatch;
	}
	// 825A431C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A4320: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A4324: 48705130  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 825A4328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A432C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A4330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A4334: 4099003C  ble cr6, 0x825a4370
	if !ctx.cr[6].gt {
	pc = 0x825A4370; continue 'dispatch;
	}
	// 825A4338: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 825A433C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A4344: 419A0018  beq cr6, 0x825a435c
	if ctx.cr[6].eq {
	pc = 0x825A435C; continue 'dispatch;
	}
	// 825A4348: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A434C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825A4350: 409A000C  bne cr6, 0x825a435c
	if !ctx.cr[6].eq {
	pc = 0x825A435C; continue 'dispatch;
	}
	// 825A4354: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A4358: 48002489  bl 0x825a67e0
	ctx.lr = 0x825A435C;
	sub_825A67E0(ctx, base);
	// 825A435C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4360: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825A4364: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825A4368: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A436C: 4198FFD0  blt cr6, 0x825a433c
	if ctx.cr[6].lt {
	pc = 0x825A433C; continue 'dispatch;
	}
	// 825A4370: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A4374: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A4378: 487050DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A4380 size=1164
    let mut pc: u32 = 0x825A4380;
    'dispatch: loop {
        match pc {
            0x825A4380 => {
    //   block [0x825A4380..0x825A480C)
	// 825A4380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4384: 48705071  bl 0x82ca93f4
	ctx.lr = 0x825A4388;
	sub_82CA93D0(ctx, base);
	// 825A4388: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 825A438C: 4870994D  bl 0x82cadcd8
	ctx.lr = 0x825A4390;
	sub_82CADCA0(ctx, base);
	// 825A4390: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A4810 size=112
    let mut pc: u32 = 0x825A4810;
    'dispatch: loop {
        match pc {
            0x825A4810 => {
    //   block [0x825A4810..0x825A4880)
	// 825A4810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A4818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A481C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A4820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A4824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A4828: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A482C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A4830: 419A0018  beq cr6, 0x825a4848
	if ctx.cr[6].eq {
	pc = 0x825A4848; continue 'dispatch;
	}
	// 825A4834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4838: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A483C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4840: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A4844: 4E800421  bctrl
	ctx.lr = 0x825A4848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A4848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A484C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A4850: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 825A4854: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825A4858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A485C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A4860: 4BBEF5D9  bl 0x82193e38
	ctx.lr = 0x825A4864;
	sub_82193E38(ctx, base);
	// 825A4864: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A4868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A486C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A4870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A4874: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A4878: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A487C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A4880 size=800
    let mut pc: u32 = 0x825A4880;
    'dispatch: loop {
        match pc {
            0x825A4880 => {
    //   block [0x825A4880..0x825A4BA0)
	// 825A4880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4884: 48704B79  bl 0x82ca93fc
	ctx.lr = 0x825A4888;
	sub_82CA93D0(ctx, base);
	// 825A4888: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825A488C: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A4BA0 size=220
    let mut pc: u32 = 0x825A4BA0;
    'dispatch: loop {
        match pc {
            0x825A4BA0 => {
    //   block [0x825A4BA0..0x825A4C7C)
	// 825A4BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4BA4: 48704861  bl 0x82ca9404
	ctx.lr = 0x825A4BA8;
	sub_82CA93D0(ctx, base);
	// 825A4BA8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 825A4BAC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A4BB0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A4C80 size=20
    let mut pc: u32 = 0x825A4C80;
    'dispatch: loop {
        match pc {
            0x825A4C80 => {
    //   block [0x825A4C80..0x825A4C94)
	// 825A4C80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825A4C84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A4C88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4C8C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A4C90: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4C94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A4C94 size=52
    let mut pc: u32 = 0x825A4C94;
    'dispatch: loop {
        match pc {
            0x825A4C94 => {
    //   block [0x825A4C94..0x825A4CC8)
	// 825A4C94: 396B0074  addi r11, r11, 0x74
	ctx.r[11].s64 = ctx.r[11].s64 + 116;
	// 825A4C98: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 825A4C9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A4CA4: 419A0014  beq cr6, 0x825a4cb8
	if ctx.cr[6].eq {
	pc = 0x825A4CB8; continue 'dispatch;
	}
	// 825A4CA8: 894A009B  lbz r10, 0x9b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(155 as u32) ) } as u64;
	// 825A4CAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A4CB0: 419A0008  beq cr6, 0x825a4cb8
	if ctx.cr[6].eq {
	pc = 0x825A4CB8; continue 'dispatch;
	}
	// 825A4CB4: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 825A4CB8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825A4CBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A4CC0: 4082FFDC  bne 0x825a4c9c
	if !ctx.cr[0].eq {
	pc = 0x825A4C9C; continue 'dispatch;
	}
	// 825A4CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A4CC8 size=568
    let mut pc: u32 = 0x825A4CC8;
    'dispatch: loop {
        match pc {
            0x825A4CC8 => {
    //   block [0x825A4CC8..0x825A4F00)
	// 825A4CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4CCC: 48704739  bl 0x82ca9404
	ctx.lr = 0x825A4CD0;
	sub_82CA93D0(ctx, base);
	// 825A4CD0: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 825A4CD4: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 825A4CD8: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A4CDC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A4CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A4CE4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A4CE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A4CEC: 40990024  ble cr6, 0x825a4d10
	if !ctx.cr[6].gt {
	pc = 0x825A4D10; continue 'dispatch;
	}
	// 825A4CF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825A4CF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A4CF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A4CFC: 419A0014  beq cr6, 0x825a4d10
	if ctx.cr[6].eq {
	pc = 0x825A4D10; continue 'dispatch;
	}
	// 825A4D00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825A4D04: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 825A4D08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825A4D0C: 4200FFF8  bdnz 0x825a4d04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825A4D04; continue 'dispatch;
	}
	// 825A4D10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A4D14: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A4D18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A4D1C: 409901D0  ble cr6, 0x825a4eec
	if !ctx.cr[6].gt {
	pc = 0x825A4EEC; continue 'dispatch;
	}
	// 825A4D20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A4D24: 3B9F00D0  addi r28, r31, 0xd0
	ctx.r[28].s64 = ctx.r[31].s64 + 208;
	// 825A4D28: 394BBC58  addi r10, r11, -0x43a8
	ctx.r[10].s64 = ctx.r[11].s64 + -17320;
	// 825A4D2C: 3BA00110  li r29, 0x110
	ctx.r[29].s64 = 272;
	// 825A4D30: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825A4D34: C3ABBC58  lfs f29, -0x43a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17320 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825A4D38: C3EAD82C  lfs f31, -0x27d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10196 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A4D3C: C3CA1970  lfs f30, 0x1970(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6512 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825A4D40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825A4D44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A4D48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A4D4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A4D50: 480001B1  bl 0x825a4f00
	ctx.lr = 0x825A4D54;
	sub_825A4F00(ctx, base);
	// 825A4D54: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825A4D58: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A4F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A4F00 size=376
    let mut pc: u32 = 0x825A4F00;
    'dispatch: loop {
        match pc {
            0x825A4F00 => {
    //   block [0x825A4F00..0x825A5078)
	// 825A4F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A4F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A4F08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A4F0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A4F10: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A4F14: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 825A4F18: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825A4F1C: 89040070  lbz r8, 0x70(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) } as u64;
	// 825A4F20: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825A4F24: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 825A4F28: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825A4F2C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825A4F30: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 825A4F34: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825A4F38: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 825A4F3C: C0099044  lfs f0, -0x6fbc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A4F40: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825A4F44: C1240054  lfs f9, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825A4F48: FD006818  frsp f8, f13
	ctx.f[8].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825A4F4C: D1210050  stfs f9, 0x50(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A4F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A4F54: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825A4F58: ECE05024  fdivs f7, f0, f10
	ctx.f[7].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 825A4F5C: ED270232  fmuls f9, f7, f8
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 825A4F60: 419A000C  beq cr6, 0x825a4f6c
	if ctx.cr[6].eq {
	pc = 0x825A4F6C; continue 'dispatch;
	}
	// 825A4F64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A4F68: 480516B9  bl 0x825f6620
	ctx.lr = 0x825A4F6C;
	sub_825F6620(ctx, base);
	// 825A4F6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A4F70: C144003C  lfs f10, 0x3c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825A4F74: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825A4F78: C1010050  lfs f8, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825A4F7C: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 825A4F80: ECE8482A  fadds f7, f8, f9
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64;
	// 825A4F84: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 825A4F88: C0A40058  lfs f5, 0x58(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 825A4F8C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825A4F90: C0C40038  lfs f6, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825A4F94: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A4F98: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825A4F9C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825A4FA0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5078 size=752
    let mut pc: u32 = 0x825A5078;
    'dispatch: loop {
        match pc {
            0x825A5078 => {
    //   block [0x825A5078..0x825A5368)
	// 825A5078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A507C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A5080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A5084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A5088: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A508C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A5090: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825A5094: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5098: 41980264  blt cr6, 0x825a52fc
	if ctx.cr[6].lt {
	pc = 0x825A52FC; continue 'dispatch;
	}
	// 825A509C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A50A0: 3BEBB480  addi r31, r11, -0x4b80
	ctx.r[31].s64 = ctx.r[11].s64 + -19328;
	// 825A50A4: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 825A50A8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825A50AC: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825A50B0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825A50B4: C01FE010  lfs f0, -0x1ff0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A50B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825A50BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A50C0: 40980008  bge cr6, 0x825a50c8
	if !ctx.cr[6].lt {
	pc = 0x825A50C8; continue 'dispatch;
	}
	// 825A50C4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 825A50C8: 89640047  lbz r11, 0x47(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(71 as u32) ) } as u64;
	// 825A50CC: C01FE004  lfs f0, -0x1ffc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A50D0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825A50D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A50D8: 409A0130  bne cr6, 0x825a5208
	if !ctx.cr[6].eq {
	pc = 0x825A5208; continue 'dispatch;
	}
	// 825A50DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825A50E0: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 825A50E4: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825A50E8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825A50EC: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 825A50F0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A50F4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825A50F8: C19F21B0  lfs f12, 0x21b0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A50FC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 825A5100: 7D264378  or r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 825A5104: 38EB0E68  addi r7, r11, 0xe68
	ctx.r[7].s64 = ctx.r[11].s64 + 3688;
	// 825A5108: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A5368 size=160
    let mut pc: u32 = 0x825A5368;
    'dispatch: loop {
        match pc {
            0x825A5368 => {
    //   block [0x825A5368..0x825A5408)
	// 825A5368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A536C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A5370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A5374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A5378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A537C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A5380: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825A5384: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A5388: 4BFFFCF1  bl 0x825a5078
	ctx.lr = 0x825A538C;
	sub_825A5078(ctx, base);
	// 825A538C: 396000B0  li r11, 0xb0
	ctx.r[11].s64 = 176;
	// 825A5390: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825A5394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A5408 size=84
    let mut pc: u32 = 0x825A5408;
    'dispatch: loop {
        match pc {
            0x825A5408 => {
    //   block [0x825A5408..0x825A545C)
	// 825A5408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A540C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A5410: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5414: 386300E0  addi r3, r3, 0xe0
	ctx.r[3].s64 = ctx.r[3].s64 + 224;
	// 825A5418: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A541C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5420: 419A0028  beq cr6, 0x825a5448
	if ctx.cr[6].eq {
	pc = 0x825A5448; continue 'dispatch;
	}
	// 825A5424: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5428: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A542C: 419A0018  beq cr6, 0x825a5444
	if ctx.cr[6].eq {
	pc = 0x825A5444; continue 'dispatch;
	}
	// 825A5430: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A5434: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A5438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A543C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A5440: 4E800020  blr
	return;
	// 825A5444: 4BBEE9F5  bl 0x82193e38
	ctx.lr = 0x825A5448;
	sub_82193E38(ctx, base);
	// 825A5448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825A544C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A5450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A5454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A5458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5460 size=412
    let mut pc: u32 = 0x825A5460;
    'dispatch: loop {
        match pc {
            0x825A5460 => {
    //   block [0x825A5460..0x825A551C)
	// 825A5460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A5464: 48703F8D  bl 0x82ca93f0
	ctx.lr = 0x825A5468;
	sub_82CA93D0(ctx, base);
	// 825A5468: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825A546C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5470: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825A5474: 89770044  lbz r11, 0x44(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(68 as u32) ) } as u64;
	// 825A5478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A547C: 419A0174  beq cr6, 0x825a55f0
	if ctx.cr[6].eq {
	pc = 0x825A55F0; continue 'dispatch;
	}
	// 825A5480: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5484: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825A5488: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 825A548C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A5490: 4099014C  ble cr6, 0x825a55dc
	if !ctx.cr[6].gt {
	pc = 0x825A55DC; continue 'dispatch;
	}
	// 825A5494: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5498: 3BB70074  addi r29, r23, 0x74
	ctx.r[29].s64 = ctx.r[23].s64 + 116;
	// 825A549C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 825A54A0: 3B000007  li r24, 7
	ctx.r[24].s64 = 7;
	// 825A54A4: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 825A54A8: C3EBD5C8  lfs f31, -0x2a38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A54AC: 3B8BD5C8  addi r28, r11, -0x2a38
	ctx.r[28].s64 = ctx.r[11].s64 + -10808;
	// 825A54B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A54B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A54B8: 419A0110  beq cr6, 0x825a55c8
	if ctx.cr[6].eq {
	pc = 0x825A55C8; continue 'dispatch;
	}
	// 825A54BC: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A54C0: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 825A54C4: 419A0104  beq cr6, 0x825a55c8
	if ctx.cr[6].eq {
	pc = 0x825A55C8; continue 'dispatch;
	}
	// 825A54C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A54CC: 9ACB009B  stb r22, 0x9b(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(155 as u32), ctx.r[22].u8 ) };
	// 825A54D0: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A54D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A54D8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825A54DC: 419900C4  bgt cr6, 0x825a55a0
	if ctx.cr[6].gt {
	pc = 0x825A55A0; continue 'dispatch;
	}
	// 825A54E0: 3D80825A  lis r12, -0x7da6
	ctx.r[12].s64 = -2108030976;
	// 825A54E4: 398C54F8  addi r12, r12, 0x54f8
	ctx.r[12].s64 = ctx.r[12].s64 + 21752;
	// 825A54E8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825A54EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825A54F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825A54F4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825A551C; continue 'dispatch;
		},
		1 => {
	pc = 0x825A55A0; continue 'dispatch;
		},
		2 => {
	pc = 0x825A55A0; continue 'dispatch;
		},
		3 => {
	pc = 0x825A5544; continue 'dispatch;
		},
		4 => {
	pc = 0x825A55A0; continue 'dispatch;
		},
		5 => {
	pc = 0x825A5580; continue 'dispatch;
		},
		6 => {
	pc = 0x825A5594; continue 'dispatch;
		},
		7 => {
	pc = 0x825A553C; continue 'dispatch;
		},
		8 => {
	pc = 0x825A55A0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825A54F8: 825A551C  lwz r18, 0x551c(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21788 as u32) ) } as u64;
	// 825A54FC: 825A55A0  lwz r18, 0x55a0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21920 as u32) ) } as u64;
	// 825A5500: 825A55A0  lwz r18, 0x55a0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21920 as u32) ) } as u64;
	// 825A5504: 825A5544  lwz r18, 0x5544(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21828 as u32) ) } as u64;
	// 825A5508: 825A55A0  lwz r18, 0x55a0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21920 as u32) ) } as u64;
	// 825A550C: 825A5580  lwz r18, 0x5580(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21888 as u32) ) } as u64;
	// 825A5510: 825A5594  lwz r18, 0x5594(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21908 as u32) ) } as u64;
	// 825A5514: 825A553C  lwz r18, 0x553c(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21820 as u32) ) } as u64;
	// 825A5518: 825A55A0  lwz r18, 0x55a0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(21920 as u32) ) } as u64;
            }
            0x825A551C => {
    //   block [0x825A551C..0x825A553C)
	// 825A551C: C03CBEBC  lfs f1, -0x4144(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A5520: D03F0168  stfs f1, 0x168(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 825A5524: D03F016C  stfs f1, 0x16c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 825A5528: D03F018C  stfs f1, 0x18c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 825A552C: D03F0190  stfs f1, 0x190(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825A5530: D03F01B0  stfs f1, 0x1b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 825A5534: D03F01B4  stfs f1, 0x1b4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 825A5538: 4800006C  b 0x825a55a4
	pc = 0x825A55A4; continue 'dispatch;
            }
            0x825A553C => {
    //   block [0x825A553C..0x825A5544)
	// 825A553C: 9B7F009B  stb r27, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[27].u8 ) };
	// 825A5540: 48000060  b 0x825a55a0
	pc = 0x825A55A0; continue 'dispatch;
            }
            0x825A5544 => {
    //   block [0x825A5544..0x825A5580)
	// 825A5544: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825A5548: 4BBCE8F1  bl 0x82173e38
	ctx.lr = 0x825A554C;
	sub_82173E38(ctx, base);
	// 825A554C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A5550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5554: 4800604D  bl 0x825ab5a0
	ctx.lr = 0x825A5558;
	sub_825AB5A0(ctx, base);
	// 825A5558: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A555C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A5560: 419A0040  beq cr6, 0x825a55a0
	if ctx.cr[6].eq {
	pc = 0x825A55A0; continue 'dispatch;
	}
	// 825A5564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5568: 4BBCE8D1  bl 0x82173e38
	ctx.lr = 0x825A556C;
	sub_82173E38(ctx, base);
	// 825A556C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A5570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A5574: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A5578: 482B14D9  bl 0x82856a50
	ctx.lr = 0x825A557C;
	sub_82856A50(ctx, base);
	// 825A557C: 48000024  b 0x825a55a0
	pc = 0x825A55A0; continue 'dispatch;
            }
            0x825A5580 => {
    //   block [0x825A5580..0x825A5594)
	// 825A5580: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825A5584: C03CBEBC  lfs f1, -0x4144(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A5588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A558C: 48003685  bl 0x825a8c10
	ctx.lr = 0x825A5590;
	sub_825A8C10(ctx, base);
	// 825A5590: 48000010  b 0x825a55a0
	pc = 0x825A55A0; continue 'dispatch;
            }
            0x825A5594 => {
    //   block [0x825A5594..0x825A55A0)
	// 825A5594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A5598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A559C: 4800129D  bl 0x825a6838
	ctx.lr = 0x825A55A0;
	sub_825A6838(ctx, base);
	pc = 0x825A55A0; continue 'dispatch;
            }
            0x825A55A0 => {
    //   block [0x825A55A0..0x825A55FC)
	// 825A55A0: C03CBEBC  lfs f1, -0x4144(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A55A4: D3FF0064  stfs f31, 0x64(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A55A8: 931F0054  stw r24, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825A55AC: D3FF0068  stfs f31, 0x68(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A55B0: 9B7F0098  stb r27, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[27].u8 ) };
	// 825A55B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A55B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A55BC: 48002D55  bl 0x825a8310
	ctx.lr = 0x825A55C0;
	sub_825A8310(ctx, base);
	// 825A55C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A55C4: 932B0090  stw r25, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[25].u32 ) };
	// 825A55C8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A55CC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 825A55D0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825A55D4: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825A55D8: 4198FED8  blt cr6, 0x825a54b0
	if ctx.cr[6].lt {
	pc = 0x825A54B0; continue 'dispatch;
	}
	// 825A55DC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825A55E0: 4BFFF6A1  bl 0x825a4c80
	ctx.lr = 0x825A55E4;
	sub_825A4C80(ctx, base);
	// 825A55E4: 90770004  stw r3, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825A55E8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825A55EC: 4BFFF6DD  bl 0x825a4cc8
	ctx.lr = 0x825A55F0;
	sub_825A4CC8(ctx, base);
	// 825A55F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A55F4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825A55F8: 48703E48  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5600 size=440
    let mut pc: u32 = 0x825A5600;
    'dispatch: loop {
        match pc {
            0x825A5600 => {
    //   block [0x825A5600..0x825A57B8)
	// 825A5600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A5604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A5608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A560C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A5610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A5618: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 825A561C: 895F0049  lbz r10, 0x49(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 825A5620: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825A5624: 419A017C  beq cr6, 0x825a57a0
	if ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A5628: 989F0049  stb r4, 0x49(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(73 as u32), ctx.r[4].u8 ) };
	// 825A562C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5630: 419A0010  beq cr6, 0x825a5640
	if ctx.cr[6].eq {
	pc = 0x825A5640; continue 'dispatch;
	}
	// 825A5634: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5638: C00BD58C  lfs f0, -0x2a74(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A563C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 825A5640: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825A5644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5648: 419A0158  beq cr6, 0x825a57a0
	if ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A564C: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 825A5650: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A5654: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A5658: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A565C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A5660: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A5664: 419A0014  beq cr6, 0x825a5678
	if ctx.cr[6].eq {
	pc = 0x825A5678; continue 'dispatch;
	}
	// 825A5668: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 825A566C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5670: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5674: 409A0008  bne cr6, 0x825a567c
	if !ctx.cr[6].eq {
	pc = 0x825A567C; continue 'dispatch;
	}
	// 825A5678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A567C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A5680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5684: 419A011C  beq cr6, 0x825a57a0
	if ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A5688: 816A011C  lwz r11, 0x11c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(284 as u32) ) } as u64;
	// 825A568C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825A5690: 409A0110  bne cr6, 0x825a57a0
	if !ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A5694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5698: 4BFFFD71  bl 0x825a5408
	ctx.lr = 0x825A569C;
	sub_825A5408(ctx, base);
	// 825A569C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A56A0: 419A0018  beq cr6, 0x825a56b8
	if ctx.cr[6].eq {
	pc = 0x825A56B8; continue 'dispatch;
	}
	// 825A56A4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A56A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A56AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A56B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A56B4: 409A0008  bne cr6, 0x825a56bc
	if !ctx.cr[6].eq {
	pc = 0x825A56BC; continue 'dispatch;
	}
	// 825A56B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A56BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A56C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A56C4: 419A00DC  beq cr6, 0x825a57a0
	if ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A56C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A56CC: 4BFFFD3D  bl 0x825a5408
	ctx.lr = 0x825A56D0;
	sub_825A5408(ctx, base);
	// 825A56D0: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825A56D4: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 825A56D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A56DC: 419A0078  beq cr6, 0x825a5754
	if ctx.cr[6].eq {
	pc = 0x825A5754; continue 'dispatch;
	}
	// 825A56E0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A56E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A56E8: 409A0064  bne cr6, 0x825a574c
	if !ctx.cr[6].eq {
	pc = 0x825A574C; continue 'dispatch;
	}
	// 825A56EC: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A56F0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A56F4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825A56F8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A56FC: 40810050  ble 0x825a574c
	if !ctx.cr[0].gt {
	pc = 0x825A574C; continue 'dispatch;
	}
	// 825A5700: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A5704: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A5708: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A570C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5710: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 825A5714: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A5718: 41980008  blt cr6, 0x825a5720
	if ctx.cr[6].lt {
	pc = 0x825A5720; continue 'dispatch;
	}
	// 825A571C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825A5720: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A5724: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A5728: 419A0014  beq cr6, 0x825a573c
	if ctx.cr[6].eq {
	pc = 0x825A573C; continue 'dispatch;
	}
	// 825A572C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A5730: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A5734: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A5738: 4800000C  b 0x825a5744
	pc = 0x825A5744; continue 'dispatch;
	// 825A573C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A5740: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A5744: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A5748: 4199FFB8  bgt cr6, 0x825a5700
	if ctx.cr[6].gt {
	pc = 0x825A5700; continue 'dispatch;
	}
	// 825A574C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5750: 48000008  b 0x825a5758
	pc = 0x825A5758; continue 'dispatch;
	// 825A5754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A5758: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A575C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5760: 419A0040  beq cr6, 0x825a57a0
	if ctx.cr[6].eq {
	pc = 0x825A57A0; continue 'dispatch;
	}
	// 825A5764: 895F0049  lbz r10, 0x49(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 825A5768: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825A576C: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A5770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5774: 3909618C  addi r8, r9, 0x618c
	ctx.r[8].s64 = ctx.r[9].s64 + 24972;
	// 825A5778: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825A577C: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 825A5780: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A5784: 83E7008C  lwz r31, 0x8c(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A5788: 4BFFFC81  bl 0x825a5408
	ctx.lr = 0x825A578C;
	sub_825A5408(ctx, base);
	// 825A578C: 4BC0CC05  bl 0x821b2390
	ctx.lr = 0x825A5790;
	sub_821B2390(ctx, base);
	// 825A5790: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825A5794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A5798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A579C: 48007295  bl 0x825aca30
	ctx.lr = 0x825A57A0;
	sub_825ACA30(ctx, base);
	// 825A57A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A57A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A57A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A57AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A57B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A57B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A57B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A57B8 size=968
    let mut pc: u32 = 0x825A57B8;
    'dispatch: loop {
        match pc {
            0x825A57B8 => {
    //   block [0x825A57B8..0x825A5B80)
	// 825A57B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A57BC: 48703C45  bl 0x82ca9400
	ctx.lr = 0x825A57C0;
	sub_82CA93D0(ctx, base);
	// 825A57C0: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 825A57C4: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825A57C8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A57CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A57D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A57D4: 387E00E0  addi r3, r30, 0xe0
	ctx.r[3].s64 = ctx.r[30].s64 + 224;
	// 825A57D8: 817E00E4  lwz r11, 0xe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A57DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A57E0: 419A001C  beq cr6, 0x825a57fc
	if ctx.cr[6].eq {
	pc = 0x825A57FC; continue 'dispatch;
	}
	// 825A57E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A57E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A57EC: 419A000C  beq cr6, 0x825a57f8
	if ctx.cr[6].eq {
	pc = 0x825A57F8; continue 'dispatch;
	}
	// 825A57F0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A57F4: 4800000C  b 0x825a5800
	pc = 0x825A5800; continue 'dispatch;
	// 825A57F8: 4BBEE641  bl 0x82193e38
	ctx.lr = 0x825A57FC;
	sub_82193E38(ctx, base);
	// 825A57FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A5800: 4BBFDCC1  bl 0x821a34c0
	ctx.lr = 0x825A5804;
	sub_821A34C0(ctx, base);
	// 825A5804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5808: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825A580C: 893E0049  lbz r9, 0x49(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(73 as u32) ) } as u64;
	// 825A5810: 3B4BBC50  addi r26, r11, -0x43b0
	ctx.r[26].s64 = ctx.r[11].s64 + -17328;
	// 825A5814: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A5818: C9AA9660  lfd f13, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825A581C: C81A44D0  lfd f0, 0x44d0(r26)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(17616 as u32) ) };
	// 825A5820: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 825A5824: C3FAD834  lfs f31, -0x27cc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A5828: FDA10032  fmul f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825A582C: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825A5830: 419A0030  beq cr6, 0x825a5860
	if ctx.cr[6].eq {
	pc = 0x825A5860; continue 'dispatch;
	}
	// 825A5834: C01AD840  lfs f0, -0x27c0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5838: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A583C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825A5840: 40980048  bge cr6, 0x825a5888
	if !ctx.cr[6].lt {
	pc = 0x825A5888; continue 'dispatch;
	}
	// 825A5844: C1BAF830  lfs f13, -0x7d0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A5848: EDBE637A  fmadds f13, f30, f13, f12
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 825A584C: D1BE0038  stfs f13, 0x38(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 825A5850: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A5854: 40990034  ble cr6, 0x825a5888
	if !ctx.cr[6].gt {
	pc = 0x825A5888; continue 'dispatch;
	}
	// 825A5858: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 825A585C: 4800002C  b 0x825a5888
	pc = 0x825A5888; continue 'dispatch;
	// 825A5860: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5864: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A5868: 40990020  ble cr6, 0x825a5888
	if !ctx.cr[6].gt {
	pc = 0x825A5888; continue 'dispatch;
	}
	// 825A586C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 825A5870: C01AF830  lfs f0, -0x7d0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2000 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5874: ED9E683C  fnmsubs f12, f30, f0, f13
	ctx.f[12].f64 = -(((ctx.f[30].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A5878: D19E0038  stfs f12, 0x38(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 825A587C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 825A5880: 40980008  bge cr6, 0x825a5888
	if !ctx.cr[6].lt {
	pc = 0x825A5888; continue 'dispatch;
	}
	// 825A5884: D3FE0038  stfs f31, 0x38(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 825A5888: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825A588C: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A5890: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A5894: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A5898: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825A589C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A58A0: 419A0014  beq cr6, 0x825a58b4
	if ctx.cr[6].eq {
	pc = 0x825A58B4; continue 'dispatch;
	}
	// 825A58A4: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 825A58A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A58AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A58B0: 409A0008  bne cr6, 0x825a58b8
	if !ctx.cr[6].eq {
	pc = 0x825A58B8; continue 'dispatch;
	}
	// 825A58B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A58B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A58BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A58C0: 419A02B0  beq cr6, 0x825a5b70
	if ctx.cr[6].eq {
	pc = 0x825A5B70; continue 'dispatch;
	}
	// 825A58C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A58C8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 825A58CC: 4BFFFB3D  bl 0x825a5408
	ctx.lr = 0x825A58D0;
	sub_825A5408(ctx, base);
	// 825A58D0: 48055811  bl 0x825fb0e0
	ctx.lr = 0x825A58D4;
	sub_825FB0E0(ctx, base);
	// 825A58D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A58D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A58DC: 419A0018  beq cr6, 0x825a58f4
	if ctx.cr[6].eq {
	pc = 0x825A58F4; continue 'dispatch;
	}
	// 825A58E0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A58E4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A58E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A58EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A58F0: 409A0008  bne cr6, 0x825a58f8
	if !ctx.cr[6].eq {
	pc = 0x825A58F8; continue 'dispatch;
	}
	// 825A58F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A58F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A58FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5900: 419A0038  beq cr6, 0x825a5938
	if ctx.cr[6].eq {
	pc = 0x825A5938; continue 'dispatch;
	}
	// 825A5904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5908: 480572A9  bl 0x825fcbb0
	ctx.lr = 0x825A590C;
	sub_825FCBB0(ctx, base);
	// 825A590C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A5910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5914: 419A0024  beq cr6, 0x825a5938
	if ctx.cr[6].eq {
	pc = 0x825A5938; continue 'dispatch;
	}
	// 825A5918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A591C: 4BFFFAED  bl 0x825a5408
	ctx.lr = 0x825A5920;
	sub_825A5408(ctx, base);
	// 825A5920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A5924: 48057515  bl 0x825fce38
	ctx.lr = 0x825A5928;
	sub_825FCE38(ctx, base);
	// 825A5928: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A592C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5930: 409A0008  bne cr6, 0x825a5938
	if !ctx.cr[6].eq {
	pc = 0x825A5938; continue 'dispatch;
	}
	// 825A5934: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825A5938: C01E0034  lfs f0, 0x34(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A593C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A5940: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A5944: 4099001C  ble cr6, 0x825a5960
	if !ctx.cr[6].gt {
	pc = 0x825A5960; continue 'dispatch;
	}
	// 825A5948: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 825A594C: D01E0034  stfs f0, 0x34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 825A5950: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A5954: 4199000C  bgt cr6, 0x825a5960
	if ctx.cr[6].gt {
	pc = 0x825A5960; continue 'dispatch;
	}
	// 825A5958: D3FE0034  stfs f31, 0x34(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 825A595C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A5964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5968: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 825A596C: 419A01EC  beq cr6, 0x825a5b58
	if ctx.cr[6].eq {
	pc = 0x825A5B58; continue 'dispatch;
	}
	// 825A5970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5974: 409A01B8  bne cr6, 0x825a5b2c
	if !ctx.cr[6].eq {
	pc = 0x825A5B2C; continue 'dispatch;
	}
	// 825A5978: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 825A597C: C82B1228  lfd f1, 0x1228(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4648 as u32) ) };
	// 825A5980: 4BCF0089  bl 0x82295a08
	ctx.lr = 0x825A5984;
	sub_82295A08(ctx, base);
	// 825A5984: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825A5988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A598C: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825A5990: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 825A5994: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825A5998: 4BFFFA71  bl 0x825a5408
	ctx.lr = 0x825A599C;
	sub_825A5408(ctx, base);
	// 825A599C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825A59A0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825A59A4: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 825A59A8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A59AC: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A59B0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825A59B4: 4E800421  bctrl
	ctx.lr = 0x825A59B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825A59B8: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 825A59BC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825A59C0: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 825A59C4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825A59C8: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 825A59CC: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 825A59D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5B80 size=596
    let mut pc: u32 = 0x825A5B80;
    'dispatch: loop {
        match pc {
            0x825A5B80 => {
    //   block [0x825A5B80..0x825A5DD4)
	// 825A5B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A5B84: 48703881  bl 0x82ca9404
	ctx.lr = 0x825A5B88;
	sub_82CA93D0(ctx, base);
	// 825A5B88: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A5B8C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5B90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825A5B94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A5B98: 3BFC00E0  addi r31, r28, 0xe0
	ctx.r[31].s64 = ctx.r[28].s64 + 224;
	// 825A5B9C: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A5BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5BA4: 419A0020  beq cr6, 0x825a5bc4
	if ctx.cr[6].eq {
	pc = 0x825A5BC4; continue 'dispatch;
	}
	// 825A5BA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5BAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A5BB0: 419A000C  beq cr6, 0x825a5bbc
	if ctx.cr[6].eq {
	pc = 0x825A5BBC; continue 'dispatch;
	}
	// 825A5BB4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A5BB8: 48000010  b 0x825a5bc8
	pc = 0x825A5BC8; continue 'dispatch;
	// 825A5BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5BC0: 4BBEE279  bl 0x82193e38
	ctx.lr = 0x825A5BC4;
	sub_82193E38(ctx, base);
	// 825A5BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A5BC8: 4BBFD8F9  bl 0x821a34c0
	ctx.lr = 0x825A5BCC;
	sub_821A34C0(ctx, base);
	// 825A5BCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5BD0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825A5BD4: 93DC004C  stw r30, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 825A5BD8: 3BAB9484  addi r29, r11, -0x6b7c
	ctx.r[29].s64 = ctx.r[11].s64 + -27516;
	// 825A5BDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A5BE0: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 825A5BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5BE8: 813D6C9C  lwz r9, 0x6c9c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27804 as u32) ) } as u64;
	// 825A5BEC: C9AA9660  lfd f13, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825A5BF0: 811D6CA0  lwz r8, 0x6ca0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27808 as u32) ) } as u64;
	// 825A5BF4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A5BF8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825A5BFC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A5C00: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 825A5C04: FDA10032  fmul f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825A5C08: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825A5C0C: 419A0020  beq cr6, 0x825a5c2c
	if ctx.cr[6].eq {
	pc = 0x825A5C2C; continue 'dispatch;
	}
	// 825A5C10: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5C14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A5C18: 419A000C  beq cr6, 0x825a5c24
	if ctx.cr[6].eq {
	pc = 0x825A5C24; continue 'dispatch;
	}
	// 825A5C1C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A5C20: 48000010  b 0x825a5c30
	pc = 0x825A5C30; continue 'dispatch;
	// 825A5C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5C28: 4BBEE211  bl 0x82193e38
	ctx.lr = 0x825A5C2C;
	sub_82193E38(ctx, base);
	// 825A5C2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A5C30: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825A5C34: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825A5C38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A5C3C: 419A00F4  beq cr6, 0x825a5d30
	if ctx.cr[6].eq {
	pc = 0x825A5D30; continue 'dispatch;
	}
	// 825A5C40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A5C44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A5C48: 419A0024  beq cr6, 0x825a5c6c
	if ctx.cr[6].eq {
	pc = 0x825A5C6C; continue 'dispatch;
	}
	// 825A5C4C: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 825A5C50: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A5C54: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825A5C58: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A5C5C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A5C60: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825A5C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5C68: 480000CC  b 0x825a5d34
	pc = 0x825A5D34; continue 'dispatch;
	// 825A5C6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A5C70: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A5C74: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A5C78: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A5C7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A5C80: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A5C84: 40810054  ble 0x825a5cd8
	if !ctx.cr[0].gt {
	pc = 0x825A5CD8; continue 'dispatch;
	}
	// 825A5C88: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A5C8C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A5C90: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A5C94: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5C98: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 825A5C9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A5CA0: 41980008  blt cr6, 0x825a5ca8
	if ctx.cr[6].lt {
	pc = 0x825A5CA8; continue 'dispatch;
	}
	// 825A5CA4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825A5CA8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A5CAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A5CB0: 419A0014  beq cr6, 0x825a5cc4
	if ctx.cr[6].eq {
	pc = 0x825A5CC4; continue 'dispatch;
	}
	// 825A5CB4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A5CB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A5CBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A5CC0: 4800000C  b 0x825a5ccc
	pc = 0x825A5CCC; continue 'dispatch;
	// 825A5CC4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A5CC8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A5CCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A5CD0: 4199FFB8  bgt cr6, 0x825a5c88
	if ctx.cr[6].gt {
	pc = 0x825A5C88; continue 'dispatch;
	}
	// 825A5CD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A5CD8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A5CDC: 419A0040  beq cr6, 0x825a5d1c
	if ctx.cr[6].eq {
	pc = 0x825A5D1C; continue 'dispatch;
	}
	// 825A5CE0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5CE4: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 825A5CE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5CEC: 41990008  bgt cr6, 0x825a5cf4
	if ctx.cr[6].gt {
	pc = 0x825A5CF4; continue 'dispatch;
	}
	// 825A5CF0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A5CF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A5CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5CFC: 409A0020  bne cr6, 0x825a5d1c
	if !ctx.cr[6].eq {
	pc = 0x825A5D1C; continue 'dispatch;
	}
	// 825A5D00: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A5D04: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A5D08: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A5D0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A5D10: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825A5D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5D18: 4800001C  b 0x825a5d34
	pc = 0x825A5D34; continue 'dispatch;
	// 825A5D1C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A5D20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A5D24: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825A5D28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5D2C: 48000008  b 0x825a5d34
	pc = 0x825A5D34; continue 'dispatch;
	// 825A5D30: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A5D34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A5D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5D3C: 419A0010  beq cr6, 0x825a5d4c
	if ctx.cr[6].eq {
	pc = 0x825A5D4C; continue 'dispatch;
	}
	// 825A5D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A5D44: 4BF54A3D  bl 0x824fa780
	ctx.lr = 0x825A5D48;
	sub_824FA780(ctx, base);
	// 825A5D48: 907C004C  stw r3, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 825A5D4C: 817C004C  lwz r11, 0x4c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A5D50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A5D54: 419A0008  beq cr6, 0x825a5d5c
	if ctx.cr[6].eq {
	pc = 0x825A5D5C; continue 'dispatch;
	}
	// 825A5D58: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825A5D5C: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 825A5D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5D64: 419A0038  beq cr6, 0x825a5d9c
	if ctx.cr[6].eq {
	pc = 0x825A5D9C; continue 'dispatch;
	}
	// 825A5D68: C01D000C  lfs f0, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5D6C: C19C003C  lfs f12, 0x3c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A5D70: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825A5D74: 40980054  bge cr6, 0x825a5dc8
	if !ctx.cr[6].lt {
	pc = 0x825A5DC8; continue 'dispatch;
	}
	// 825A5D78: C1BD1FFC  lfs f13, 0x1ffc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A5D7C: EDBF637A  fmadds f13, f31, f13, f12
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 825A5D80: D1BC003C  stfs f13, 0x3c(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825A5D84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A5D88: 40990040  ble cr6, 0x825a5dc8
	if !ctx.cr[6].gt {
	pc = 0x825A5DC8; continue 'dispatch;
	}
	// 825A5D8C: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825A5D90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A5D94: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A5D98: 487036BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 825A5D9C: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A5DA0: C01C003C  lfs f0, 0x3c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5DA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825A5DA8: 40990020  ble cr6, 0x825a5dc8
	if !ctx.cr[6].gt {
	pc = 0x825A5DC8; continue 'dispatch;
	}
	// 825A5DAC: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 825A5DB0: C01D1FFC  lfs f0, 0x1ffc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5DB4: ED7F603C  fnmsubs f11, f31, f0, f12
	ctx.f[11].f64 = -(((ctx.f[31].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 825A5DB8: D17C003C  stfs f11, 0x3c(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825A5DBC: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 825A5DC0: 40980008  bge cr6, 0x825a5dc8
	if !ctx.cr[6].lt {
	pc = 0x825A5DC8; continue 'dispatch;
	}
	// 825A5DC4: D1BC003C  stfs f13, 0x3c(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825A5DC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A5DCC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A5DD0: 48703684  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5DD8 size=284
    let mut pc: u32 = 0x825A5DD8;
    'dispatch: loop {
        match pc {
            0x825A5DD8 => {
    //   block [0x825A5DD8..0x825A5EF4)
	// 825A5DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A5DDC: 4870362D  bl 0x82ca9408
	ctx.lr = 0x825A5DE0;
	sub_82CA93D0(ctx, base);
	// 825A5DE0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825A5DE4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5DE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825A5DEC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825A5DF0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825A5DF4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825A5DF8: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 825A5DFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825A5E00: 419A0018  beq cr6, 0x825a5e18
	if ctx.cr[6].eq {
	pc = 0x825A5E18; continue 'dispatch;
	}
	// 825A5E04: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A5E08: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A5E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5E10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A5E14: 409A0008  bne cr6, 0x825a5e1c
	if !ctx.cr[6].eq {
	pc = 0x825A5E1C; continue 'dispatch;
	}
	// 825A5E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A5E1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A5E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5E24: 419A00C4  beq cr6, 0x825a5ee8
	if ctx.cr[6].eq {
	pc = 0x825A5EE8; continue 'dispatch;
	}
	// 825A5E28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A5E2C: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A5E30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A5E34: 386B9484  addi r3, r11, -0x6b7c
	ctx.r[3].s64 = ctx.r[11].s64 + -27516;
	// 825A5E38: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A5E3C: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 825A5E40: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825A5E44: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A5E48: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825A5E4C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825A5E50: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825A5E54: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5E5C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825A5E60: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A5E64: 480062E5  bl 0x825ac148
	ctx.lr = 0x825A5E68;
	sub_825AC148(ctx, base);
	// 825A5E68: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A5E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A5E70: 419A0078  beq cr6, 0x825a5ee8
	if ctx.cr[6].eq {
	pc = 0x825A5EE8; continue 'dispatch;
	}
	// 825A5E74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A5E78: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825A5E7C: 409A0030  bne cr6, 0x825a5eac
	if !ctx.cr[6].eq {
	pc = 0x825A5EAC; continue 'dispatch;
	}
	// 825A5E80: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A5E84: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A5E88: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A5E8C: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825A5E90: ED400332  fmuls f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 825A5E94: ED2D02F2  fmuls f9, f13, f11
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 825A5E98: D15C0000  stfs f10, 0(r28)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A5E9C: D13D0000  stfs f9, 0(r29)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A5EA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A5EA4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825A5EA8: 487035B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 825A5EAC: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A5EB0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825A5EB4: 409A0030  bne cr6, 0x825a5ee4
	if !ctx.cr[6].eq {
	pc = 0x825A5EE4; continue 'dispatch;
	}
	// 825A5EB8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825A5EBC: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825A5EC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A5EC4: 419A0020  beq cr6, 0x825a5ee4
	if ctx.cr[6].eq {
	pc = 0x825A5EE4; continue 'dispatch;
	}
	// 825A5EC8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A5ECC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825A5ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A5ED4: 48054F0D  bl 0x825fade0
	ctx.lr = 0x825A5ED8;
	sub_825FADE0(ctx, base);
	// 825A5ED8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A5EDC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825A5EE0: 48703578  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 825A5EE4: D3FC0000  stfs f31, 0(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825A5EE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A5EEC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825A5EF0: 48703568  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A5EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A5EF8 size=668
    let mut pc: u32 = 0x825A5EF8;
    'dispatch: loop {
        match pc {
            0x825A5EF8 => {
    //   block [0x825A5EF8..0x825A6194)
	// 825A5EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A5EFC: 48703501  bl 0x82ca93fc
	ctx.lr = 0x825A5F00;
	sub_82CA93D0(ctx, base);
	// 825A5F00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A5F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A5F08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A5F0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A5F10: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 825A5F14: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825A5F18: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825A5F1C: 4BBEDF1D  bl 0x82193e38
	ctx.lr = 0x825A5F20;
	sub_82193E38(ctx, base);
	// 825A5F20: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825A5F24: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 825A5F28: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825A5F2C: 4BBEDF0D  bl 0x82193e38
	ctx.lr = 0x825A5F30;
	sub_82193E38(ctx, base);
	// 825A5F30: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 825A5F34: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 825A5F38: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825A5F3C: 4BBEDEFD  bl 0x82193e38
	ctx.lr = 0x825A5F40;
	sub_82193E38(ctx, base);
	// 825A5F40: 3F60820A  lis r27, -0x7df6
	ctx.r[27].s64 = -2113273856;
	// 825A5F44: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 825A5F48: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825A5F4C: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 825A5F50: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825A5F54: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 825A5F58: 3B5B92CC  addi r26, r27, -0x6d34
	ctx.r[26].s64 = ctx.r[27].s64 + -27956;
	// 825A5F5C: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 825A5F60: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 825A5F64: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 825A5F68: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 825A5F6C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 825A5F70: 390000C0  li r8, 0xc0
	ctx.r[8].s64 = 192;
	// 825A5F74: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 825A5F78: 38E000D0  li r7, 0xd0
	ctx.r[7].s64 = 208;
	// 825A5F7C: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 825A5F80: C19A01B8  lfs f12, 0x1b8(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A5F84: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 825A5F88: 38C000E0  li r6, 0xe0
	ctx.r[6].s64 = 224;
	// 825A5F8C: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 825A5F90: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 825A5F94: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 825A5F98: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 825A5F9C: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 825A5FA0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 825A5FA4: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 825A5FA8: D19F0064  stfs f12, 0x64(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A5FAC: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A5FB0: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A5FB4: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825A5FB8: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825A5FBC: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825A5FC0: D19F0070  stfs f12, 0x70(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A5FC4: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825A5FC8: D19F0074  stfs f12, 0x74(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A5FCC: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 825A5FD0: D19F0078  stfs f12, 0x78(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825A5FD4: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825A5FD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A5FDC: D19F007C  stfs f12, 0x7c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825A5FE0: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A5FE4: D19F0080  stfs f12, 0x80(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825A5FE8: 9BDF0098  stb r30, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u8 ) };
	// 825A5FEC: D19F0084  stfs f12, 0x84(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825A5FF0: 9BDF0099  stb r30, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[30].u8 ) };
	// 825A5FF4: D19F0088  stfs f12, 0x88(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825A5FF8: 9BDF009A  stb r30, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[30].u8 ) };
	// 825A5FFC: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825A6000: 997F009B  stb r11, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[11].u8 ) };
	// 825A6004: 9BDF009C  stb r30, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u8 ) };
	// 825A6008: 9BDF009D  stb r30, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[30].u8 ) };
	// 825A600C: 9BDF009E  stb r30, 0x9e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(158 as u32), ctx.r[30].u8 ) };
	// 825A6010: 997F009F  stb r11, 0x9f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(159 as u32), ctx.r[11].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A6198 size=524
    let mut pc: u32 = 0x825A6198;
    'dispatch: loop {
        match pc {
            0x825A6198 => {
    //   block [0x825A6198..0x825A63A4)
	// 825A6198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A619C: 48703269  bl 0x82ca9404
	ctx.lr = 0x825A61A0;
	sub_82CA93D0(ctx, base);
	// 825A61A0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A63A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A63A8 size=752
    let mut pc: u32 = 0x825A63A8;
    'dispatch: loop {
        match pc {
            0x825A63A8 => {
    //   block [0x825A63A8..0x825A6698)
	// 825A63A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A63AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A63B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A63B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A63B8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825A63BC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825A63C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A63C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A63C8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825A63CC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 825A63D0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A63D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A63D8: 419A008C  beq cr6, 0x825a6464
	if ctx.cr[6].eq {
	pc = 0x825A6464; continue 'dispatch;
	}
	// 825A63DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A63E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A63E4: 419A02A0  beq cr6, 0x825a6684
	if ctx.cr[6].eq {
	pc = 0x825A6684; continue 'dispatch;
	}
	// 825A63E8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A63EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A63F0: 419A0074  beq cr6, 0x825a6464
	if ctx.cr[6].eq {
	pc = 0x825A6464; continue 'dispatch;
	}
	// 825A63F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A63F8: 4BBCDA41  bl 0x82173e38
	ctx.lr = 0x825A63FC;
	sub_82173E38(ctx, base);
	// 825A63FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825A6400: 419A0018  beq cr6, 0x825a6418
	if ctx.cr[6].eq {
	pc = 0x825A6418; continue 'dispatch;
	}
	// 825A6404: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A6408: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A640C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A6410: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A6414: 409A0008  bne cr6, 0x825a641c
	if !ctx.cr[6].eq {
	pc = 0x825A641C; continue 'dispatch;
	}
	// 825A6418: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A641C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A6420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6424: 409A0040  bne cr6, 0x825a6464
	if !ctx.cr[6].eq {
	pc = 0x825A6464; continue 'dispatch;
	}
	// 825A6428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A642C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A6430: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A6434: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A6438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A643C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A6440: 4BBED9F9  bl 0x82193e38
	ctx.lr = 0x825A6444;
	sub_82193E38(ctx, base);
	// 825A6444: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A6448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A644C: 4BF2BA7D  bl 0x824d1ec8
	ctx.lr = 0x825A6450;
	sub_824D1EC8(ctx, base);
	// 825A6450: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A6454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6458: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A645C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A6460: 4BBED9D9  bl 0x82193e38
	ctx.lr = 0x825A6464;
	sub_82193E38(ctx, base);
	// 825A6464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6468: 48003E21  bl 0x825aa288
	ctx.lr = 0x825A646C;
	sub_825AA288(ctx, base);
	// 825A646C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825A6470: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 825A6474: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 825A6478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A647C: C3EA9484  lfs f31, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A6480: C9A99660  lfd f13, -0x69a0(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 825A6484: 80E86C9C  lwz r7, 0x6c9c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27804 as u32) ) } as u64;
	// 825A6488: 80C86CA0  lwz r6, 0x6ca0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27808 as u32) ) } as u64;
	// 825A648C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A6490: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 825A6494: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A6498: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 825A649C: FDA007B2  fmul f13, f0, f30
	ctx.f[13].f64 = ctx.f[0].f64 * ctx.f[30].f64;
	// 825A64A0: C01F0068  lfs f0, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A64A4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A64A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825A64AC: 4099001C  ble cr6, 0x825a64c8
	if !ctx.cr[6].gt {
	pc = 0x825A64C8; continue 'dispatch;
	}
	// 825A64B0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A64B4: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A64B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A64BC: 4199000C  bgt cr6, 0x825a64c8
	if ctx.cr[6].gt {
	pc = 0x825A64C8; continue 'dispatch;
	}
	// 825A64C0: D3FF0068  stfs f31, 0x68(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A64C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A64C8: 997F0098  stb r11, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 825A64CC: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A64D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A64D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A64D8: 4099001C  ble cr6, 0x825a64f4
	if !ctx.cr[6].gt {
	pc = 0x825A64F4; continue 'dispatch;
	}
	// 825A64DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825A64E0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A64E4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825A64E8: 4199000C  bgt cr6, 0x825a64f4
	if ctx.cr[6].gt {
	pc = 0x825A64F4; continue 'dispatch;
	}
	// 825A64EC: D3FF0074  stfs f31, 0x74(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A64F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A64F4: 997F0099  stb r11, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 825A64F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A64FC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A6500: 48001571  bl 0x825a7a70
	ctx.lr = 0x825A6504;
	sub_825A7A70(ctx, base);
	// 825A6504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6508: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A650C: 48004855  bl 0x825aad60
	ctx.lr = 0x825A6510;
	sub_825AAD60(ctx, base);
	// 825A6510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6514: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A6518: 48004941  bl 0x825aae58
	ctx.lr = 0x825A651C;
	sub_825AAE58(ctx, base);
	// 825A651C: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 825A6520: 40990010  ble cr6, 0x825a6530
	if !ctx.cr[6].gt {
	pc = 0x825A6530; continue 'dispatch;
	}
	// 825A6524: 387F01CC  addi r3, r31, 0x1cc
	ctx.r[3].s64 = ctx.r[31].s64 + 460;
	// 825A6528: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A652C: 4833BAA5  bl 0x828e1fd0
	ctx.lr = 0x825A6530;
	sub_828E1FD0(ctx, base);
	// 825A6530: 897F01EC  lbz r11, 0x1ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 825A6534: C01F01D0  lfs f0, 0x1d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A6538: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A653C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6540: 419A000C  beq cr6, 0x825a654c
	if ctx.cr[6].eq {
	pc = 0x825A654C; continue 'dispatch;
	}
	// 825A6544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6548: 480500D9  bl 0x825f6620
	ctx.lr = 0x825A654C;
	sub_825F6620(ctx, base);
	// 825A654C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6550: 4BBCD8E9  bl 0x82173e38
	ctx.lr = 0x825A6554;
	sub_82173E38(ctx, base);
	// 825A6554: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6558: 48052C11  bl 0x825f9168
	ctx.lr = 0x825A655C;
	sub_825F9168(ctx, base);
	// 825A655C: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 825A6560: 40990010  ble cr6, 0x825a6570
	if !ctx.cr[6].gt {
	pc = 0x825A6570; continue 'dispatch;
	}
	// 825A6564: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 825A6568: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A656C: 4833BA65  bl 0x828e1fd0
	ctx.lr = 0x825A6570;
	sub_828E1FD0(ctx, base);
	// 825A6570: 897F0210  lbz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 825A6574: C01F01F4  lfs f0, 0x1f4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A6578: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A657C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6580: 419A000C  beq cr6, 0x825a658c
	if ctx.cr[6].eq {
	pc = 0x825A658C; continue 'dispatch;
	}
	// 825A6584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6588: 48050099  bl 0x825f6620
	ctx.lr = 0x825A658C;
	sub_825F6620(ctx, base);
	// 825A658C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A6590: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A6594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6598: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A659C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825A65A0: 4BBCD899  bl 0x82173e38
	ctx.lr = 0x825A65A4;
	sub_82173E38(ctx, base);
	// 825A65A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A65A8: 48052A39  bl 0x825f8fe0
	ctx.lr = 0x825A65AC;
	sub_825F8FE0(ctx, base);
	// 825A65AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A65B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A65B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A65B8: 48000541  bl 0x825a6af8
	ctx.lr = 0x825A65BC;
	sub_825A6AF8(ctx, base);
	// 825A65BC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825A65C0: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 825A65C4: 4198FFEC  blt cr6, 0x825a65b0
	if ctx.cr[6].lt {
	pc = 0x825A65B0; continue 'dispatch;
	}
	// 825A65C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A65CC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825A65D0: 48004CF1  bl 0x825ab2c0
	ctx.lr = 0x825A65D4;
	sub_825AB2C0(ctx, base);
	// 825A65D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A65D8: 48000829  bl 0x825a6e00
	ctx.lr = 0x825A65DC;
	sub_825A6E00(ctx, base);
	// 825A65DC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A65E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A65E4: 419A002C  beq cr6, 0x825a6610
	if ctx.cr[6].eq {
	pc = 0x825A6610; continue 'dispatch;
	}
	// 825A65E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A65EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A65F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A65F4: 48000DDD  bl 0x825a73d0
	ctx.lr = 0x825A65F8;
	sub_825A73D0(ctx, base);
	// 825A65F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825A65FC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825A6600: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A6698 size=328
    let mut pc: u32 = 0x825A6698;
    'dispatch: loop {
        match pc {
            0x825A6698 => {
    //   block [0x825A6698..0x825A67E0)
	// 825A6698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A669C: 48702D6D  bl 0x82ca9408
	ctx.lr = 0x825A66A0;
	sub_82CA93D0(ctx, base);
	// 825A66A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A66A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A66A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A66AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A66B0: 807E0050  lwz r3, 0x50(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A66B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A66B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A66BC: 40990034  ble cr6, 0x825a66f0
	if !ctx.cr[6].gt {
	pc = 0x825A66F0; continue 'dispatch;
	}
	// 825A66C0: 39630074  addi r11, r3, 0x74
	ctx.r[11].s64 = ctx.r[3].s64 + 116;
	// 825A66C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A66C8: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825A66CC: 419A0018  beq cr6, 0x825a66e4
	if ctx.cr[6].eq {
	pc = 0x825A66E4; continue 'dispatch;
	}
	// 825A66D0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 825A66D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825A66D8: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825A66DC: 4198FFE8  blt cr6, 0x825a66c4
	if ctx.cr[6].lt {
	pc = 0x825A66C4; continue 'dispatch;
	}
	// 825A66E0: 48000010  b 0x825a66f0
	pc = 0x825A66F0; continue 'dispatch;
	// 825A66E4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825A66E8: 41980008  blt cr6, 0x825a66f0
	if ctx.cr[6].lt {
	pc = 0x825A66F0; continue 'dispatch;
	}
	// 825A66EC: 4BFFCCED  bl 0x825a33d8
	ctx.lr = 0x825A66F0;
	sub_825A33D8(ctx, base);
	// 825A66F0: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A66F4: 3BFE0040  addi r31, r30, 0x40
	ctx.r[31].s64 = ctx.r[30].s64 + 64;
	// 825A66F8: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 825A66FC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A6700: 419A0018  beq cr6, 0x825a6718
	if ctx.cr[6].eq {
	pc = 0x825A6718; continue 'dispatch;
	}
	// 825A6704: C03D92D4  lfs f1, -0x6d2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6708: 48C8B991  bl 0x83232098
	ctx.lr = 0x825A670C;
	sub_83232098(ctx, base);
	// 825A670C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6710: 4BC11409  bl 0x821b7b18
	ctx.lr = 0x825A6714;
	sub_821B7B18(ctx, base);
	// 825A6714: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A6718: 807E0048  lwz r3, 0x48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A671C: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 825A6720: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A6724: 419A0018  beq cr6, 0x825a673c
	if ctx.cr[6].eq {
	pc = 0x825A673C; continue 'dispatch;
	}
	// 825A6728: C03D92D4  lfs f1, -0x6d2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A672C: 48C8B96D  bl 0x83232098
	ctx.lr = 0x825A6730;
	sub_83232098(ctx, base);
	// 825A6730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6734: 4BC113E5  bl 0x821b7b18
	ctx.lr = 0x825A6738;
	sub_821B7B18(ctx, base);
	// 825A6738: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A673C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A6740: 48000BF1  bl 0x825a7330
	ctx.lr = 0x825A6744;
	sub_825A7330(ctx, base);
	// 825A6744: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825A6748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A674C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A6750: 48000301  bl 0x825a6a50
	ctx.lr = 0x825A6754;
	sub_825A6A50(ctx, base);
	// 825A6754: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825A6758: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 825A675C: 4198FFEC  blt cr6, 0x825a6748
	if ctx.cr[6].lt {
	pc = 0x825A6748; continue 'dispatch;
	}
	// 825A6760: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A6764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6768: 419A0060  beq cr6, 0x825a67c8
	if ctx.cr[6].eq {
	pc = 0x825A67C8; continue 'dispatch;
	}
	// 825A676C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6770: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A6774: 419A005C  beq cr6, 0x825a67d0
	if ctx.cr[6].eq {
	pc = 0x825A67D0; continue 'dispatch;
	}
	// 825A6778: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A677C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6780: 419A0048  beq cr6, 0x825a67c8
	if ctx.cr[6].eq {
	pc = 0x825A67C8; continue 'dispatch;
	}
	// 825A6784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A6788: 4BBCD6B1  bl 0x82173e38
	ctx.lr = 0x825A678C;
	sub_82173E38(ctx, base);
	// 825A678C: 4BDE709D  bl 0x8238d828
	ctx.lr = 0x825A6790;
	sub_8238D828(ctx, base);
	// 825A6790: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A6794: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825A6798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A679C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 825A67A0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825A67A4: 4BBED695  bl 0x82193e38
	ctx.lr = 0x825A67A8;
	sub_82193E38(ctx, base);
	// 825A67A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A67AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A67B0: 4BF2B719  bl 0x824d1ec8
	ctx.lr = 0x825A67B4;
	sub_824D1EC8(ctx, base);
	// 825A67B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825A67B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A67BC: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 825A67C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825A67C4: 4BBED675  bl 0x82193e38
	ctx.lr = 0x825A67C8;
	sub_82193E38(ctx, base);
	// 825A67C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A67CC: 48702C8C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 825A67D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A67D4: 4BBED665  bl 0x82193e38
	ctx.lr = 0x825A67D8;
	sub_82193E38(ctx, base);
	// 825A67D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825A67DC: 48702C7C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A67E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A67E0 size=84
    let mut pc: u32 = 0x825A67E0;
    'dispatch: loop {
        match pc {
            0x825A67E0 => {
    //   block [0x825A67E0..0x825A6834)
	// 825A67E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A67E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A67E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A67EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A67F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A67F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A67F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825A67FC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A6800: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 825A6804: 419A0018  beq cr6, 0x825a681c
	if ctx.cr[6].eq {
	pc = 0x825A681C; continue 'dispatch;
	}
	// 825A6808: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A680C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825A6810: C02BD5C8  lfs f1, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6814: 48000FCD  bl 0x825a77e0
	ctx.lr = 0x825A6818;
	sub_825A77E0(ctx, base);
	// 825A6818: 9BDF009C  stb r30, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u8 ) };
	// 825A681C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A6820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A6824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A6828: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A682C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A6830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A6838 size=16
    let mut pc: u32 = 0x825A6838;
    'dispatch: loop {
        match pc {
            0x825A6838 => {
    //   block [0x825A6838..0x825A6848)
	// 825A6838: 8943009E  lbz r10, 0x9e(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(158 as u32) ) } as u64;
	// 825A683C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 825A6840: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825A6844: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825A6848 size=100
    let mut pc: u32 = 0x825A6848;
    'dispatch: loop {
        match pc {
            0x825A6848 => {
    //   block [0x825A6848..0x825A68AC)
	// 825A6848: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A684C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825A6850: 9883009E  stb r4, 0x9e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(158 as u32), ctx.r[4].u8 ) };
	// 825A6854: 892B0044  lbz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825A6858: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A685C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A6860: 419A0080  beq cr6, 0x825a68e0
	if ctx.cr[6].eq {
		sub_825A68D4(ctx, base);
		return;
	}
	// 825A6864: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6868: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825A686C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825A6870: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A6874: 4099003C  ble cr6, 0x825a68b0
	if !ctx.cr[6].gt {
		sub_825A68AC(ctx, base);
		return;
	}
	// 825A6878: 394B0074  addi r10, r11, 0x74
	ctx.r[10].s64 = ctx.r[11].s64 + 116;
	// 825A687C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6880: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825A6884: 419A0010  beq cr6, 0x825a6894
	if ctx.cr[6].eq {
	pc = 0x825A6894; continue 'dispatch;
	}
	// 825A6888: 8908009E  lbz r8, 0x9e(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(158 as u32) ) } as u64;
	// 825A688C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825A6890: 409A001C  bne cr6, 0x825a68ac
	if !ctx.cr[6].eq {
		sub_825A68AC(ctx, base);
		return;
	}
	// 825A6894: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6898: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825A689C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825A68A0: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825A68A4: 4198FFD8  blt cr6, 0x825a687c
	if ctx.cr[6].lt {
	pc = 0x825A687C; continue 'dispatch;
	}
	// 825A68A8: 48000008  b 0x825a68b0
	sub_825A68AC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A68AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825A68AC size=40
    let mut pc: u32 = 0x825A68AC;
    'dispatch: loop {
        match pc {
            0x825A68AC => {
    //   block [0x825A68AC..0x825A68D4)
	// 825A68AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A68B0: 892B0048  lbz r9, 0x48(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A68B4: 54EA063E  clrlwi r10, r7, 0x18
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A68B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825A68BC: 419A0024  beq cr6, 0x825a68e0
	if ctx.cr[6].eq {
		sub_825A68D4(ctx, base);
		return;
	}
	// 825A68C0: 98EB0048  stb r7, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[7].u8 ) };
	// 825A68C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A68C8: 419A000C  beq cr6, 0x825a68d4
	if ctx.cr[6].eq {
		sub_825A68D4(ctx, base);
		return;
	}
	// 825A68CC: D00B0058  stfs f0, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825A68D0: 48000010  b 0x825a68e0
	sub_825A68D4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A68D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825A68D4 size=40
    let mut pc: u32 = 0x825A68D4;
    'dispatch: loop {
        match pc {
            0x825A68D4 => {
    //   block [0x825A68D4..0x825A68FC)
	// 825A68D4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 825A68D8: C1AA0EE4  lfs f13, 0xee4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3812 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A68DC: D1AB0058  stfs f13, 0x58(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825A68E0: 8963009E  lbz r11, 0x9e(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(158 as u32) ) } as u64;
	// 825A68E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A68E8: 409A000C  bne cr6, 0x825a68f4
	if !ctx.cr[6].eq {
	pc = 0x825A68F4; continue 'dispatch;
	}
	// 825A68EC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 825A68F0: C00B1020  lfs f0, 0x1020(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A68F4: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825A68F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A6900 size=332
    let mut pc: u32 = 0x825A6900;
    'dispatch: loop {
        match pc {
            0x825A6900 => {
    //   block [0x825A6900..0x825A6A4C)
	// 825A6900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6904: 48702B09  bl 0x82ca940c
	ctx.lr = 0x825A6908;
	sub_82CA93D0(ctx, base);
	// 825A6908: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A6A50 size=164
    let mut pc: u32 = 0x825A6A50;
    'dispatch: loop {
        match pc {
            0x825A6A50 => {
    //   block [0x825A6A50..0x825A6AF4)
	// 825A6A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A6A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A6A5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A6A60: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 825A6A64: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A6A68: 7FEB1A14  add r31, r11, r3
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825A6A6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A6A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6A74: 419A0064  beq cr6, 0x825a6ad8
	if ctx.cr[6].eq {
	pc = 0x825A6AD8; continue 'dispatch;
	}
	// 825A6A78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6A7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A6A80: 419A006C  beq cr6, 0x825a6aec
	if ctx.cr[6].eq {
	pc = 0x825A6AEC; continue 'dispatch;
	}
	// 825A6A84: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A6A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6A8C: 419A004C  beq cr6, 0x825a6ad8
	if ctx.cr[6].eq {
	pc = 0x825A6AD8; continue 'dispatch;
	}
	// 825A6A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6A94: 4BBCD3A5  bl 0x82173e38
	ctx.lr = 0x825A6A98;
	sub_82173E38(ctx, base);
	// 825A6A98: 48051821  bl 0x825f82b8
	ctx.lr = 0x825A6A9C;
	sub_825F82B8(ctx, base);
	// 825A6A9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A6AA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A6AA4: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A6AA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A6AAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6AB0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A6AB4: 4BBED385  bl 0x82193e38
	ctx.lr = 0x825A6AB8;
	sub_82193E38(ctx, base);
	// 825A6AB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A6ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6AC0: 4BF2B409  bl 0x824d1ec8
	ctx.lr = 0x825A6AC4;
	sub_824D1EC8(ctx, base);
	// 825A6AC4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A6AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6ACC: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A6AD0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A6AD4: 4BBED365  bl 0x82193e38
	ctx.lr = 0x825A6AD8;
	sub_82193E38(ctx, base);
	// 825A6AD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A6ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A6AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A6AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A6AE8: 4E800020  blr
	return;
	// 825A6AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6AF0: 4BFFFFE4  b 0x825a6ad4
	pc = 0x825A6AD4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A6AF8 size=252
    let mut pc: u32 = 0x825A6AF8;
    'dispatch: loop {
        match pc {
            0x825A6AF8 => {
    //   block [0x825A6AF8..0x825A6BF4)
	// 825A6AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A6B00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A6B04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A6B08: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A6BF8 size=436
    let mut pc: u32 = 0x825A6BF8;
    'dispatch: loop {
        match pc {
            0x825A6BF8 => {
    //   block [0x825A6BF8..0x825A6DAC)
	// 825A6BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6BFC: 48702809  bl 0x82ca9404
	ctx.lr = 0x825A6C00;
	sub_82CA93D0(ctx, base);
	// 825A6C00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A6C04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A6C08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A6C0C: 3BFB0040  addi r31, r27, 0x40
	ctx.r[31].s64 = ctx.r[27].s64 + 64;
	// 825A6C10: 807B0040  lwz r3, 0x40(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A6C14: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 825A6C18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A6C1C: 419A001C  beq cr6, 0x825a6c38
	if ctx.cr[6].eq {
	pc = 0x825A6C38; continue 'dispatch;
	}
	// 825A6C20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A6C24: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6C28: 48C8B471  bl 0x83232098
	ctx.lr = 0x825A6C2C;
	sub_83232098(ctx, base);
	// 825A6C2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6C30: 4BC10EE9  bl 0x821b7b18
	ctx.lr = 0x825A6C34;
	sub_821B7B18(ctx, base);
	// 825A6C34: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A6C38: 817B0050  lwz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A6C3C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825A6C40: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 825A6C44: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A6C48: 419A015C  beq cr6, 0x825a6da4
	if ctx.cr[6].eq {
	pc = 0x825A6DA4; continue 'dispatch;
	}
	// 825A6C4C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A6C50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825A6C54: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 825A6C58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A6C5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A6C60: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A6C64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A6C68: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A6C6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A6C70: 4082FFE8  bne 0x825a6c58
	if !ctx.cr[0].eq {
	pc = 0x825A6C58; continue 'dispatch;
	}
	// 825A6C74: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825A6C78: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825A6C7C: 38674E28  addi r3, r7, 0x4e28
	ctx.r[3].s64 = ctx.r[7].s64 + 20008;
	// 825A6C80: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825A6C84: 4BC4D0D5  bl 0x821f3d58
	ctx.lr = 0x825A6C88;
	sub_821F3D58(ctx, base);
	// 825A6C88: 80DB0050  lwz r6, 0x50(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A6C8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A6C90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A6C94: 80660094  lwz r3, 0x94(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(148 as u32) ) } as u64;
	// 825A6C98: 4BE09B21  bl 0x823b07b8
	ctx.lr = 0x825A6C9C;
	sub_823B07B8(ctx, base);
	// 825A6C9C: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A6CA0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825A6CA4: 419A0024  beq cr6, 0x825a6cc8
	if ctx.cr[6].eq {
	pc = 0x825A6CC8; continue 'dispatch;
	}
	// 825A6CA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A6CAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A6CB0: 4BC47E89  bl 0x821eeb38
	ctx.lr = 0x825A6CB4;
	sub_821EEB38(ctx, base);
	// 825A6CB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A6CB8: 4865CB39  bl 0x82c037f0
	ctx.lr = 0x825A6CBC;
	sub_82C037F0(ctx, base);
	// 825A6CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A6CC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A6CC4: 4BC6E115  bl 0x82214dd8
	ctx.lr = 0x825A6CC8;
	sub_82214DD8(ctx, base);
	// 825A6CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6CCC: 4BC6E10D  bl 0x82214dd8
	ctx.lr = 0x825A6CD0;
	sub_82214DD8(ctx, base);
	// 825A6CD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A6CD4: 419A00D0  beq cr6, 0x825a6da4
	if ctx.cr[6].eq {
	pc = 0x825A6DA4; continue 'dispatch;
	}
	// 825A6CD8: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 825A6CDC: 4BC7857D  bl 0x8221f258
	ctx.lr = 0x825A6CE0;
	sub_8221F258(ctx, base);
	// 825A6CE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A6CE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A6CE8: 419A0028  beq cr6, 0x825a6d10
	if ctx.cr[6].eq {
	pc = 0x825A6D10; continue 'dispatch;
	}
	// 825A6CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A6CF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A6CF4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825A6CF8: 48C890D1  bl 0x8322fdc8
	ctx.lr = 0x825A6CFC;
	sub_8322FDC8(ctx, base);
	// 825A6CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A6D00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A6D04: 48C8C5FD  bl 0x83233300
	ctx.lr = 0x825A6D08;
	sub_83233300(ctx, base);
	// 825A6D08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A6D0C: 48000008  b 0x825a6d14
	pc = 0x825A6D14; continue 'dispatch;
	// 825A6D10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A6D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6D18: 4BCCC341  bl 0x82273058
	ctx.lr = 0x825A6D1C;
	sub_82273058(ctx, base);
	// 825A6D1C: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 825A6D20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A6D24: 419A000C  beq cr6, 0x825a6d30
	if ctx.cr[6].eq {
	pc = 0x825A6D30; continue 'dispatch;
	}
	// 825A6D28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A6D2C: 4BC10DED  bl 0x821b7b18
	ctx.lr = 0x825A6D30;
	sub_821B7B18(ctx, base);
	// 825A6D30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6D34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A6D38: 419A006C  beq cr6, 0x825a6da4
	if ctx.cr[6].eq {
	pc = 0x825A6DA4; continue 'dispatch;
	}
	// 825A6D3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A6D40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6D48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825A6D4C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825A6D50: 419A0020  beq cr6, 0x825a6d70
	if ctx.cr[6].eq {
	pc = 0x825A6D70; continue 'dispatch;
	}
	// 825A6D54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A6D58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A6D5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A6D60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A6D64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A6D68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A6D6C: 4082FFE8  bne 0x825a6d54
	if !ctx.cr[0].eq {
	pc = 0x825A6D54; continue 'dispatch;
	}
	// 825A6D70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825A6D74: 48C8E005  bl 0x83234d78
	ctx.lr = 0x825A6D78;
	sub_83234D78(ctx, base);
	// 825A6D78: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A6D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A6D80: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A6D84: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A6D88: 806A0058  lwz r3, 0x58(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A6D8C: 4BD11935  bl 0x822b86c0
	ctx.lr = 0x825A6D90;
	sub_822B86C0(ctx, base);
	// 825A6D90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A6D94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A6D98: 48C8AF69  bl 0x83231d00
	ctx.lr = 0x825A6D9C;
	sub_83231D00(ctx, base);
	// 825A6D9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A6DA0: 48000061  bl 0x825a6e00
	ctx.lr = 0x825A6DA4;
	sub_825A6E00(ctx, base);
	// 825A6DA4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A6DA8: 487026AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A6DB0 size=80
    let mut pc: u32 = 0x825A6DB0;
    'dispatch: loop {
        match pc {
            0x825A6DB0 => {
    //   block [0x825A6DB0..0x825A6E00)
	// 825A6DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A6DB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A6DBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A6DC0: 3BE30040  addi r31, r3, 0x40
	ctx.r[31].s64 = ctx.r[3].s64 + 64;
	// 825A6DC4: 80630040  lwz r3, 0x40(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A6DC8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A6DCC: 419A0020  beq cr6, 0x825a6dec
	if ctx.cr[6].eq {
	pc = 0x825A6DEC; continue 'dispatch;
	}
	// 825A6DD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A6DD4: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6DD8: 48C8B2C1  bl 0x83232098
	ctx.lr = 0x825A6DDC;
	sub_83232098(ctx, base);
	// 825A6DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6DE0: 4BC10D39  bl 0x821b7b18
	ctx.lr = 0x825A6DE4;
	sub_821B7B18(ctx, base);
	// 825A6DE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A6DE8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A6DEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A6DF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A6DF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A6DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A6DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A6E00 size=432
    let mut pc: u32 = 0x825A6E00;
    'dispatch: loop {
        match pc {
            0x825A6E00 => {
    //   block [0x825A6E00..0x825A6FB0)
	// 825A6E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6E04: 48702601  bl 0x82ca9404
	ctx.lr = 0x825A6E08;
	sub_82CA93D0(ctx, base);
	// 825A6E08: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A6E0C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A6E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A6E14: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825A6E18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A6E1C: 419A0188  beq cr6, 0x825a6fa4
	if ctx.cr[6].eq {
	pc = 0x825A6FA4; continue 'dispatch;
	}
	// 825A6E20: 897F01EC  lbz r11, 0x1ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 825A6E24: C01F01D0  lfs f0, 0x1d0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A6E28: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A6E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A6E30: 419A000C  beq cr6, 0x825a6e3c
	if ctx.cr[6].eq {
	pc = 0x825A6E3C; continue 'dispatch;
	}
	// 825A6E34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A6E38: 4804F7E9  bl 0x825f6620
	ctx.lr = 0x825A6E3C;
	sub_825F6620(ctx, base);
	// 825A6E3C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825A6E40: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825A6E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6E48: 48004EC1  bl 0x825abd08
	ctx.lr = 0x825A6E4C;
	sub_825ABD08(ctx, base);
	// 825A6E4C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825A6E50: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825A6E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A6FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A6FB0 size=480
    let mut pc: u32 = 0x825A6FB0;
    'dispatch: loop {
        match pc {
            0x825A6FB0 => {
    //   block [0x825A6FB0..0x825A7190)
	// 825A6FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A6FB4: 48702451  bl 0x82ca9404
	ctx.lr = 0x825A6FB8;
	sub_82CA93D0(ctx, base);
	// 825A6FB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A6FBC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A6FC0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A6FC4: 3BFB0048  addi r31, r27, 0x48
	ctx.r[31].s64 = ctx.r[27].s64 + 72;
	// 825A6FC8: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A6FCC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825A6FD0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A6FD4: 419A001C  beq cr6, 0x825a6ff0
	if ctx.cr[6].eq {
	pc = 0x825A6FF0; continue 'dispatch;
	}
	// 825A6FD8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A6FDC: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A6FE0: 48C8B0B9  bl 0x83232098
	ctx.lr = 0x825A6FE4;
	sub_83232098(ctx, base);
	// 825A6FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A6FE8: 4BC10B31  bl 0x821b7b18
	ctx.lr = 0x825A6FEC;
	sub_821B7B18(ctx, base);
	// 825A6FEC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825A6FF0: 817B0050  lwz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A6FF4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825A6FF8: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 825A6FFC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825A7000: 419A0188  beq cr6, 0x825a7188
	if ctx.cr[6].eq {
	pc = 0x825A7188; continue 'dispatch;
	}
	// 825A7004: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A7008: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825A700C: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 825A7010: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A7014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A7018: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A701C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A7020: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A7024: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A7028: 4082FFE8  bne 0x825a7010
	if !ctx.cr[0].eq {
	pc = 0x825A7010; continue 'dispatch;
	}
	// 825A702C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825A7030: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825A7034: 38674E40  addi r3, r7, 0x4e40
	ctx.r[3].s64 = ctx.r[7].s64 + 20032;
	// 825A7038: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825A703C: 4BC4CD1D  bl 0x821f3d58
	ctx.lr = 0x825A7040;
	sub_821F3D58(ctx, base);
	// 825A7040: 80DB0050  lwz r6, 0x50(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A7044: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A7048: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A704C: 80660094  lwz r3, 0x94(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(148 as u32) ) } as u64;
	// 825A7050: 4BE09769  bl 0x823b07b8
	ctx.lr = 0x825A7054;
	sub_823B07B8(ctx, base);
	// 825A7054: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A7058: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825A705C: 419A0024  beq cr6, 0x825a7080
	if ctx.cr[6].eq {
	pc = 0x825A7080; continue 'dispatch;
	}
	// 825A7060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A7064: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A7068: 4BC47AD1  bl 0x821eeb38
	ctx.lr = 0x825A706C;
	sub_821EEB38(ctx, base);
	// 825A706C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A7070: 4865C781  bl 0x82c037f0
	ctx.lr = 0x825A7074;
	sub_82C037F0(ctx, base);
	// 825A7074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A7078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A707C: 4BC6DD5D  bl 0x82214dd8
	ctx.lr = 0x825A7080;
	sub_82214DD8(ctx, base);
	// 825A7080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A7084: 4BC6DD55  bl 0x82214dd8
	ctx.lr = 0x825A7088;
	sub_82214DD8(ctx, base);
	// 825A7088: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A708C: 419A00FC  beq cr6, 0x825a7188
	if ctx.cr[6].eq {
	pc = 0x825A7188; continue 'dispatch;
	}
	// 825A7090: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 825A7094: 4BC781C5  bl 0x8221f258
	ctx.lr = 0x825A7098;
	sub_8221F258(ctx, base);
	// 825A7098: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A709C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A70A0: 419A0028  beq cr6, 0x825a70c8
	if ctx.cr[6].eq {
	pc = 0x825A70C8; continue 'dispatch;
	}
	// 825A70A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825A70A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825A70AC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825A70B0: 48C88D19  bl 0x8322fdc8
	ctx.lr = 0x825A70B4;
	sub_8322FDC8(ctx, base);
	// 825A70B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A70B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A70BC: 48C8C245  bl 0x83233300
	ctx.lr = 0x825A70C0;
	sub_83233300(ctx, base);
	// 825A70C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A70C4: 48000008  b 0x825a70cc
	pc = 0x825A70CC; continue 'dispatch;
	// 825A70C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A70CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A70D0: 4BCCBF89  bl 0x82273058
	ctx.lr = 0x825A70D4;
	sub_82273058(ctx, base);
	// 825A70D4: 578B07FE  clrlwi r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 825A70D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A70DC: 419A000C  beq cr6, 0x825a70e8
	if ctx.cr[6].eq {
	pc = 0x825A70E8; continue 'dispatch;
	}
	// 825A70E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825A70E4: 4BC10A35  bl 0x821b7b18
	ctx.lr = 0x825A70E8;
	sub_821B7B18(ctx, base);
	// 825A70E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A70EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A70F0: 419A0098  beq cr6, 0x825a7188
	if ctx.cr[6].eq {
	pc = 0x825A7188; continue 'dispatch;
	}
	// 825A70F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A70F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A70FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A7100: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825A7104: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825A7108: 419A0020  beq cr6, 0x825a7128
	if ctx.cr[6].eq {
	pc = 0x825A7128; continue 'dispatch;
	}
	// 825A710C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A7110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A7114: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A7118: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A711C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A7120: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A7124: 4082FFE8  bne 0x825a710c
	if !ctx.cr[0].eq {
	pc = 0x825A710C; continue 'dispatch;
	}
	// 825A7128: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A712C: 48C8DC4D  bl 0x83234d78
	ctx.lr = 0x825A7130;
	sub_83234D78(ctx, base);
	// 825A7130: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A7134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A7138: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825A713C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A7140: 806A0058  lwz r3, 0x58(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825A7144: 4BD1157D  bl 0x822b86c0
	ctx.lr = 0x825A7148;
	sub_822B86C0(ctx, base);
	// 825A7148: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825A714C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A7150: 48C8ABB1  bl 0x83231d00
	ctx.lr = 0x825A7154;
	sub_83231D00(ctx, base);
	// 825A7154: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A7158: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825A715C: 419A002C  beq cr6, 0x825a7188
	if ctx.cr[6].eq {
	pc = 0x825A7188; continue 'dispatch;
	}
	// 825A7160: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825A7164: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825A7168: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825A716C: 48000265  bl 0x825a73d0
	ctx.lr = 0x825A7170;
	sub_825A73D0(ctx, base);
	// 825A7170: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825A7174: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825A7178: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A7190 size=80
    let mut pc: u32 = 0x825A7190;
    'dispatch: loop {
        match pc {
            0x825A7190 => {
    //   block [0x825A7190..0x825A71E0)
	// 825A7190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A7198: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A719C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A71A0: 3BE30048  addi r31, r3, 0x48
	ctx.r[31].s64 = ctx.r[3].s64 + 72;
	// 825A71A4: 80630048  lwz r3, 0x48(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A71A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825A71AC: 419A0020  beq cr6, 0x825a71cc
	if ctx.cr[6].eq {
	pc = 0x825A71CC; continue 'dispatch;
	}
	// 825A71B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A71B4: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A71B8: 48C8AEE1  bl 0x83232098
	ctx.lr = 0x825A71BC;
	sub_83232098(ctx, base);
	// 825A71BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A71C0: 4BC10959  bl 0x821b7b18
	ctx.lr = 0x825A71C4;
	sub_821B7B18(ctx, base);
	// 825A71C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A71C8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825A71CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825A71D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A71D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A71D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A71DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A71E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A71E0 size=336
    let mut pc: u32 = 0x825A71E0;
    'dispatch: loop {
        match pc {
            0x825A71E0 => {
    //   block [0x825A71E0..0x825A7330)
	// 825A71E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A71E4: 48702229  bl 0x82ca940c
	ctx.lr = 0x825A71E8;
	sub_82CA93D0(ctx, base);
	// 825A71E8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A7330 size=156
    let mut pc: u32 = 0x825A7330;
    'dispatch: loop {
        match pc {
            0x825A7330 => {
    //   block [0x825A7330..0x825A73CC)
	// 825A7330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A7338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A733C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A7340: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825A7344: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 825A7348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A734C: 419A0064  beq cr6, 0x825a73b0
	if ctx.cr[6].eq {
	pc = 0x825A73B0; continue 'dispatch;
	}
	// 825A7350: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A7354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A7358: 419A006C  beq cr6, 0x825a73c4
	if ctx.cr[6].eq {
	pc = 0x825A73C4; continue 'dispatch;
	}
	// 825A735C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A7360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A7364: 419A004C  beq cr6, 0x825a73b0
	if ctx.cr[6].eq {
	pc = 0x825A73B0; continue 'dispatch;
	}
	// 825A7368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A736C: 4BBCCACD  bl 0x82173e38
	ctx.lr = 0x825A7370;
	sub_82173E38(ctx, base);
	// 825A7370: 48050F49  bl 0x825f82b8
	ctx.lr = 0x825A7374;
	sub_825F82B8(ctx, base);
	// 825A7374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825A7378: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A737C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825A7380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A7384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A7388: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825A738C: 4BBECAAD  bl 0x82193e38
	ctx.lr = 0x825A7390;
	sub_82193E38(ctx, base);
	// 825A7390: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A7394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7398: 4BF2AB31  bl 0x824d1ec8
	ctx.lr = 0x825A739C;
	sub_824D1EC8(ctx, base);
	// 825A739C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825A73A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A73A4: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 825A73A8: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825A73AC: 4BBECA8D  bl 0x82193e38
	ctx.lr = 0x825A73B0;
	sub_82193E38(ctx, base);
	// 825A73B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A73B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A73B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A73BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A73C0: 4E800020  blr
	return;
	// 825A73C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A73C8: 4BFFFFE4  b 0x825a73ac
	pc = 0x825A73AC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A73D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A73D0 size=652
    let mut pc: u32 = 0x825A73D0;
    'dispatch: loop {
        match pc {
            0x825A73D0 => {
    //   block [0x825A73D0..0x825A765C)
	// 825A73D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A73D4: 48702035  bl 0x82ca9408
	ctx.lr = 0x825A73D8;
	sub_82CA93D0(ctx, base);
	// 825A73D8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A73DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A73E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825A73E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825A73E8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825A73EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A73F0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 825A73F4: 419A001C  beq cr6, 0x825a7410
	if ctx.cr[6].eq {
	pc = 0x825A7410; continue 'dispatch;
	}
	// 825A73F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A73FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A7400: 419A000C  beq cr6, 0x825a740c
	if ctx.cr[6].eq {
	pc = 0x825A740C; continue 'dispatch;
	}
	// 825A7404: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A7408: 4800000C  b 0x825a7414
	pc = 0x825A7414; continue 'dispatch;
	// 825A740C: 4BBECA2D  bl 0x82193e38
	ctx.lr = 0x825A7410;
	sub_82193E38(ctx, base);
	// 825A7410: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A7414: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825A7418: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825A741C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825A7420: 419A00F4  beq cr6, 0x825a7514
	if ctx.cr[6].eq {
	pc = 0x825A7514; continue 'dispatch;
	}
	// 825A7424: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A7428: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A742C: 419A0024  beq cr6, 0x825a7450
	if ctx.cr[6].eq {
	pc = 0x825A7450; continue 'dispatch;
	}
	// 825A7430: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825A7434: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A7438: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825A743C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A7440: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A7444: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A7448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A744C: 480000CC  b 0x825a7518
	pc = 0x825A7518; continue 'dispatch;
	// 825A7450: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A7454: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A7458: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825A745C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A7460: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A7464: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A7468: 40810054  ble 0x825a74bc
	if !ctx.cr[0].gt {
	pc = 0x825A74BC; continue 'dispatch;
	}
	// 825A746C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A7470: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A7474: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A7478: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A747C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825A7480: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A7484: 41980008  blt cr6, 0x825a748c
	if ctx.cr[6].lt {
	pc = 0x825A748C; continue 'dispatch;
	}
	// 825A7488: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825A748C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A7490: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A7494: 419A0014  beq cr6, 0x825a74a8
	if ctx.cr[6].eq {
	pc = 0x825A74A8; continue 'dispatch;
	}
	// 825A7498: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A749C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A74A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A74A4: 4800000C  b 0x825a74b0
	pc = 0x825A74B0; continue 'dispatch;
	// 825A74A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A74AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A74B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A74B4: 4199FFB8  bgt cr6, 0x825a746c
	if ctx.cr[6].gt {
	pc = 0x825A746C; continue 'dispatch;
	}
	// 825A74B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A74BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A74C0: 419A0040  beq cr6, 0x825a7500
	if ctx.cr[6].eq {
	pc = 0x825A7500; continue 'dispatch;
	}
	// 825A74C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A74C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825A74CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A74D0: 41990008  bgt cr6, 0x825a74d8
	if ctx.cr[6].gt {
	pc = 0x825A74D8; continue 'dispatch;
	}
	// 825A74D4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A74D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A74DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A74E0: 409A0020  bne cr6, 0x825a7500
	if !ctx.cr[6].eq {
	pc = 0x825A7500; continue 'dispatch;
	}
	// 825A74E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A74E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A74EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A74F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A74F4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A74FC: 4800001C  b 0x825a7518
	pc = 0x825A7518; continue 'dispatch;
	// 825A7500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A7504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A7508: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A750C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A7510: 48000008  b 0x825a7518
	pc = 0x825A7518; continue 'dispatch;
	// 825A7514: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825A7518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A751C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A7520: 419A0130  beq cr6, 0x825a7650
	if ctx.cr[6].eq {
	pc = 0x825A7650; continue 'dispatch;
	}
	// 825A7524: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825A7528: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 825A752C: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 825A7530: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 825A7534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825A7538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A753C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825A7540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825A7544: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825A7548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825A754C: 4082FFE8  bne 0x825a7534
	if !ctx.cr[0].eq {
	pc = 0x825A7534; continue 'dispatch;
	}
	// 825A7550: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 825A7554: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 825A7558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A755C: 93C100D0  stw r30, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 825A7560: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A7564: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825A7568: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 825A756C: 392B9160  addi r9, r11, -0x6ea0
	ctx.r[9].s64 = ctx.r[11].s64 + -28320;
	// 825A7570: C0069490  lfs f0, -0x6b70(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A7574: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825A7578: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A7660 size=380
    //   switch @ 0x825A7704: r11 with 9 label(s)
    //       case  0  0x825A772C
    //       case  1  0x825A778C
    //       case  2  0x825A778C
    //       case  3  0x825A7750
    //       case  4  0x825A778C
    //       case  5  0x825A77BC
    //       case  6  0x825A77CC
    //       case  7  0x825A7748
    //       case  8  0x825A778C
    let mut pc: u32 = 0x825A7660;
    'dispatch: loop {
        match pc {
            0x825A7660 => {
    //   block [0x825A7660..0x825A772C)
	// 825A7660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7664: 48701DA5  bl 0x82ca9408
	ctx.lr = 0x825A7668;
	sub_82CA93D0(ctx, base);
	// 825A7668: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825A766C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A7670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A7674: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825A7678: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 825A767C: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 825A7680: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825A7684: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A7688: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 825A768C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x825A772C; continue 'dispatch;
            }
            0x825A772C => {
    //   block [0x825A772C..0x825A7748)
	// 825A772C: D03F0168  stfs f1, 0x168(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 825A7730: D03F016C  stfs f1, 0x16c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 825A7734: D03F018C  stfs f1, 0x18c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 825A7738: D03F0190  stfs f1, 0x190(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825A773C: D03F01B0  stfs f1, 0x1b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 825A7740: D03F01B4  stfs f1, 0x1b4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 825A7744: 48000048  b 0x825a778c
	pc = 0x825A778C; continue 'dispatch;
            }
            0x825A7748 => {
    //   block [0x825A7748..0x825A7750)
	// 825A7748: 9B9F009B  stb r28, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[28].u8 ) };
	// 825A774C: 48000040  b 0x825a778c
	pc = 0x825A778C; continue 'dispatch;
            }
            0x825A7750 => {
    //   block [0x825A7750..0x825A778C)
	// 825A7750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A7754: 4BBCC6E5  bl 0x82173e38
	ctx.lr = 0x825A7758;
	sub_82173E38(ctx, base);
	// 825A7758: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A775C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7760: 48003E41  bl 0x825ab5a0
	ctx.lr = 0x825A7764;
	sub_825AB5A0(ctx, base);
	// 825A7764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A7768: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A776C: 419A001C  beq cr6, 0x825a7788
	if ctx.cr[6].eq {
	pc = 0x825A7788; continue 'dispatch;
	}
	// 825A7770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7774: 4BBCC6C5  bl 0x82173e38
	ctx.lr = 0x825A7778;
	sub_82173E38(ctx, base);
	// 825A7778: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A777C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A7780: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7784: 482AF2CD  bl 0x82856a50
	ctx.lr = 0x825A7788;
	sub_82856A50(ctx, base);
	// 825A7788: C03DBEBC  lfs f1, -0x4144(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x825A778C; continue 'dispatch;
            }
            0x825A778C => {
    //   block [0x825A778C..0x825A77BC)
	// 825A778C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 825A7790: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A7794: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A7798: 9B9F0098  stb r28, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u8 ) };
	// 825A779C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A77A0: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825A77A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A77A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A77AC: 48001465  bl 0x825a8c10
	ctx.lr = 0x825A77B0;
	sub_825A8C10(ctx, base);
	// 825A77B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A77B4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825A77B8: 48701CA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A77BC => {
    //   block [0x825A77BC..0x825A77CC)
	// 825A77BC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825A77C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A77C4: 4800144D  bl 0x825a8c10
	ctx.lr = 0x825A77C8;
	sub_825A8C10(ctx, base);
	// 825A77C8: 4BFFFFC0  b 0x825a7788
	pc = 0x825A7788; continue 'dispatch;
            }
            0x825A77CC => {
    //   block [0x825A77CC..0x825A77DC)
	// 825A77CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A77D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A77D4: 4BFFF065  bl 0x825a6838
	ctx.lr = 0x825A77D8;
	sub_825A6838(ctx, base);
	// 825A77D8: 4BFFFFB4  b 0x825a778c
	pc = 0x825A778C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A77E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A77E0 size=652
    let mut pc: u32 = 0x825A77E0;
    'dispatch: loop {
        match pc {
            0x825A77E0 => {
    //   block [0x825A77E0..0x825A7850)
	// 825A77E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A77E4: 48701C21  bl 0x82ca9404
	ctx.lr = 0x825A77E8;
	sub_82CA93D0(ctx, base);
	// 825A77E8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A77EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A77F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A77F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825A77F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A77FC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825A7800: 3BCBD5C8  addi r30, r11, -0x2a38
	ctx.r[30].s64 = ctx.r[11].s64 + -10808;
	// 825A7804: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825A7808: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A780C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825A7810: 419900C4  bgt cr6, 0x825a78d4
	if ctx.cr[6].gt {
	pc = 0x825A78D4; continue 'dispatch;
	}
	// 825A7814: 3D80825A  lis r12, -0x7da6
	ctx.r[12].s64 = -2108030976;
	// 825A7818: 398C782C  addi r12, r12, 0x782c
	ctx.r[12].s64 = ctx.r[12].s64 + 30764;
	// 825A781C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825A7820: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825A7824: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825A7828: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825A7850; continue 'dispatch;
		},
		1 => {
	pc = 0x825A78D4; continue 'dispatch;
		},
		2 => {
	pc = 0x825A78D4; continue 'dispatch;
		},
		3 => {
	pc = 0x825A7878; continue 'dispatch;
		},
		4 => {
	pc = 0x825A78D4; continue 'dispatch;
		},
		5 => {
	pc = 0x825A78B4; continue 'dispatch;
		},
		6 => {
	pc = 0x825A78C8; continue 'dispatch;
		},
		7 => {
	pc = 0x825A7870; continue 'dispatch;
		},
		8 => {
	pc = 0x825A78D4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825A782C: 825A7850  lwz r18, 0x7850(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30800 as u32) ) } as u64;
	// 825A7830: 825A78D4  lwz r18, 0x78d4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30932 as u32) ) } as u64;
	// 825A7834: 825A78D4  lwz r18, 0x78d4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30932 as u32) ) } as u64;
	// 825A7838: 825A7878  lwz r18, 0x7878(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30840 as u32) ) } as u64;
	// 825A783C: 825A78D4  lwz r18, 0x78d4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30932 as u32) ) } as u64;
	// 825A7840: 825A78B4  lwz r18, 0x78b4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30900 as u32) ) } as u64;
	// 825A7844: 825A78C8  lwz r18, 0x78c8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30920 as u32) ) } as u64;
	// 825A7848: 825A7870  lwz r18, 0x7870(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30832 as u32) ) } as u64;
	// 825A784C: 825A78D4  lwz r18, 0x78d4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(30932 as u32) ) } as u64;
            }
            0x825A7850 => {
    //   block [0x825A7850..0x825A7870)
	// 825A7850: C03EBEBC  lfs f1, -0x4144(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A7854: D03F0168  stfs f1, 0x168(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 825A7858: D03F016C  stfs f1, 0x16c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 825A785C: D03F018C  stfs f1, 0x18c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 825A7860: D03F0190  stfs f1, 0x190(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825A7864: D03F01B0  stfs f1, 0x1b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 825A7868: D03F01B4  stfs f1, 0x1b4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 825A786C: 4800006C  b 0x825a78d8
	pc = 0x825A78D8; continue 'dispatch;
            }
            0x825A7870 => {
    //   block [0x825A7870..0x825A7878)
	// 825A7870: 9B9F009B  stb r28, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[28].u8 ) };
	// 825A7874: 48000060  b 0x825a78d4
	pc = 0x825A78D4; continue 'dispatch;
            }
            0x825A7878 => {
    //   block [0x825A7878..0x825A78B4)
	// 825A7878: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825A787C: 4BBCC5BD  bl 0x82173e38
	ctx.lr = 0x825A7880;
	sub_82173E38(ctx, base);
	// 825A7880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A7884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7888: 48003D19  bl 0x825ab5a0
	ctx.lr = 0x825A788C;
	sub_825AB5A0(ctx, base);
	// 825A788C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825A7890: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825A7894: 419A0040  beq cr6, 0x825a78d4
	if ctx.cr[6].eq {
	pc = 0x825A78D4; continue 'dispatch;
	}
	// 825A7898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A789C: 4BBCC59D  bl 0x82173e38
	ctx.lr = 0x825A78A0;
	sub_82173E38(ctx, base);
	// 825A78A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A78A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825A78A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A78AC: 482AF1A5  bl 0x82856a50
	ctx.lr = 0x825A78B0;
	sub_82856A50(ctx, base);
	// 825A78B0: 48000024  b 0x825a78d4
	pc = 0x825A78D4; continue 'dispatch;
            }
            0x825A78B4 => {
    //   block [0x825A78B4..0x825A78C8)
	// 825A78B4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825A78B8: C03EBEBC  lfs f1, -0x4144(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A78BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A78C0: 48001351  bl 0x825a8c10
	ctx.lr = 0x825A78C4;
	sub_825A8C10(ctx, base);
	// 825A78C4: 48000010  b 0x825a78d4
	pc = 0x825A78D4; continue 'dispatch;
            }
            0x825A78C8 => {
    //   block [0x825A78C8..0x825A78D4)
	// 825A78C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A78CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A78D0: 4BFFEF69  bl 0x825a6838
	ctx.lr = 0x825A78D4;
	sub_825A6838(ctx, base);
	pc = 0x825A78D4; continue 'dispatch;
            }
            0x825A78D4 => {
    //   block [0x825A78D4..0x825A792C)
	// 825A78D4: C03EBEBC  lfs f1, -0x4144(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A78D8: D3FF0064  stfs f31, 0x64(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A78DC: 937F0054  stw r27, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825A78E0: D3FF0068  stfs f31, 0x68(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A78E4: 9B9F0098  stb r28, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u8 ) };
	// 825A78E8: 2B1B0008  cmplwi cr6, r27, 8
	ctx.cr[6].compare_u32(ctx.r[27].u32, 8 as u32, &mut ctx.xer);
	// 825A78EC: 41990174  bgt cr6, 0x825a7a60
	if ctx.cr[6].gt {
	pc = 0x825A7A60; continue 'dispatch;
	}
	// 825A78F0: 3D80825A  lis r12, -0x7da6
	ctx.r[12].s64 = -2108030976;
	// 825A78F4: 398C7908  addi r12, r12, 0x7908
	ctx.r[12].s64 = ctx.r[12].s64 + 30984;
	// 825A78F8: 5760103A  slwi r0, r27, 2
	ctx.r[0].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825A78FC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825A7900: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825A7904: 4E800420  bctr
	match ctx.r[27].u64 {
		0 => {
	pc = 0x825A792C; continue 'dispatch;
		},
		1 => {
	pc = 0x825A7948; continue 'dispatch;
		},
		2 => {
	pc = 0x825A79C8; continue 'dispatch;
		},
		3 => {
	pc = 0x825A79E0; continue 'dispatch;
		},
		4 => {
	pc = 0x825A7A60; continue 'dispatch;
		},
		5 => {
	pc = 0x825A79F8; continue 'dispatch;
		},
		6 => {
	pc = 0x825A7A10; continue 'dispatch;
		},
		7 => {
	pc = 0x825A7998; continue 'dispatch;
		},
		8 => {
	pc = 0x825A79B0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825A7908: 825A792C  lwz r18, 0x792c(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31020 as u32) ) } as u64;
	// 825A790C: 825A7948  lwz r18, 0x7948(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31048 as u32) ) } as u64;
	// 825A7910: 825A79C8  lwz r18, 0x79c8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31176 as u32) ) } as u64;
	// 825A7914: 825A79E0  lwz r18, 0x79e0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31200 as u32) ) } as u64;
	// 825A7918: 825A7A60  lwz r18, 0x7a60(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31328 as u32) ) } as u64;
	// 825A791C: 825A79F8  lwz r18, 0x79f8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31224 as u32) ) } as u64;
	// 825A7920: 825A7A10  lwz r18, 0x7a10(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31248 as u32) ) } as u64;
	// 825A7924: 825A7998  lwz r18, 0x7998(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31128 as u32) ) } as u64;
	// 825A7928: 825A79B0  lwz r18, 0x79b0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31152 as u32) ) } as u64;
            }
            0x825A792C => {
    //   block [0x825A792C..0x825A7948)
	// 825A792C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A7930: D03F0078  stfs f1, 0x78(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825A7934: 997F009D  stb r11, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[11].u8 ) };
	// 825A7938: 997F009B  stb r11, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[11].u8 ) };
	// 825A793C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A7940: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A7944: 48701B10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A7948 => {
    //   block [0x825A7948..0x825A7998)
	// 825A7948: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A794C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7950: 48003271  bl 0x825aabc0
	ctx.lr = 0x825A7954;
	sub_825AABC0(ctx, base);
	// 825A7954: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A7958: C01E0074  lfs f0, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A795C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 825A7960: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A7964: C1BEBEBC  lfs f13, -0x4144(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A7968: C189002C  lfs f12, 0x2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A796C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825A7970: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825A7974: D17F0070  stfs f11, 0x70(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A7978: D17F0074  stfs f11, 0x74(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A797C: 995F009A  stb r10, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[10].u8 ) };
	// 825A7980: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825A7984: 9B9F0099  stb r28, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[28].u8 ) };
	// 825A7988: 9B9F009B  stb r28, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[28].u8 ) };
	// 825A798C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A7990: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A7994: 48701AC0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A7998 => {
    //   block [0x825A7998..0x825A79B0)
	// 825A7998: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A799C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A79A0: 48000971  bl 0x825a8310
	ctx.lr = 0x825A79A4;
	sub_825A8310(ctx, base);
	// 825A79A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A79A8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A79AC: 48701AA8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A79B0 => {
    //   block [0x825A79B0..0x825A79C8)
	// 825A79B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A79B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A79B8: 48000B71  bl 0x825a8528
	ctx.lr = 0x825A79BC;
	sub_825A8528(ctx, base);
	// 825A79BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A79C0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A79C4: 48701A90  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A79C8 => {
    //   block [0x825A79C8..0x825A79E0)
	// 825A79C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A79CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A79D0: 48000CF1  bl 0x825a86c0
	ctx.lr = 0x825A79D4;
	sub_825A86C0(ctx, base);
	// 825A79D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A79D8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A79DC: 48701A78  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A79E0 => {
    //   block [0x825A79E0..0x825A79F8)
	// 825A79E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A79E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A79E8: 48000F51  bl 0x825a8938
	ctx.lr = 0x825A79EC;
	sub_825A8938(ctx, base);
	// 825A79EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A79F0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A79F4: 48701A60  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A79F8 => {
    //   block [0x825A79F8..0x825A7A10)
	// 825A79F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825A79FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7A00: 48001211  bl 0x825a8c10
	ctx.lr = 0x825A7A04;
	sub_825A8C10(ctx, base);
	// 825A7A04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A7A08: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A7A0C: 48701A48  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825A7A10 => {
    //   block [0x825A7A10..0x825A7A60)
	// 825A7A10: C01EBD04  lfs f0, -0x42fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A7A14: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A7A18: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825A7A1C: 40980008  bge cr6, 0x825a7a24
	if !ctx.cr[6].lt {
	pc = 0x825A7A24; continue 'dispatch;
	}
	// 825A7A20: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825A7A24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A7A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7A2C: 48003195  bl 0x825aabc0
	ctx.lr = 0x825A7A30;
	sub_825AABC0(ctx, base);
	// 825A7A30: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825A7A34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A7A38: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A7A3C: C1BEBEBC  lfs f13, -0x4144(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A7A40: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825A7A44: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A7A48: 995F009A  stb r10, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[10].u8 ) };
	// 825A7A4C: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A7A50: 9B9F0099  stb r28, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[28].u8 ) };
	// 825A7A54: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825A7A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7A5C: 4BFFF555  bl 0x825a6fb0
	ctx.lr = 0x825A7A60;
	sub_825A6FB0(ctx, base);
	pc = 0x825A7A60; continue 'dispatch;
            }
            0x825A7A60 => {
    //   block [0x825A7A60..0x825A7A6C)
	// 825A7A60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A7A64: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A7A68: 487019EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A7A70 size=428
    let mut pc: u32 = 0x825A7A70;
    'dispatch: loop {
        match pc {
            0x825A7A70 => {
    //   block [0x825A7A70..0x825A7AD0)
	// 825A7A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A7A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A7A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A7A80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A7A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A7A88: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A7A8C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825A7A90: 41990174  bgt cr6, 0x825a7c04
	if ctx.cr[6].gt {
	pc = 0x825A7C04; continue 'dispatch;
	}
	// 825A7A94: 3D80825A  lis r12, -0x7da6
	ctx.r[12].s64 = -2108030976;
	// 825A7A98: 398C7AAC  addi r12, r12, 0x7aac
	ctx.r[12].s64 = ctx.r[12].s64 + 31404;
	// 825A7A9C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825A7AA0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825A7AA4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825A7AA8: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825A7AD0; continue 'dispatch;
		},
		1 => {
	pc = 0x825A7AE0; continue 'dispatch;
		},
		2 => {
	pc = 0x825A7B18; continue 'dispatch;
		},
		3 => {
	pc = 0x825A7B28; continue 'dispatch;
		},
		4 => {
	pc = 0x825A7BB4; continue 'dispatch;
		},
		5 => {
	pc = 0x825A7BE8; continue 'dispatch;
		},
		6 => {
	pc = 0x825A7BF8; continue 'dispatch;
		},
		7 => {
	pc = 0x825A7AF0; continue 'dispatch;
		},
		8 => {
	pc = 0x825A7B00; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825A7AAC: 825A7AD0  lwz r18, 0x7ad0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31440 as u32) ) } as u64;
	// 825A7AB0: 825A7AE0  lwz r18, 0x7ae0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31456 as u32) ) } as u64;
	// 825A7AB4: 825A7B18  lwz r18, 0x7b18(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31512 as u32) ) } as u64;
	// 825A7AB8: 825A7B28  lwz r18, 0x7b28(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31528 as u32) ) } as u64;
	// 825A7ABC: 825A7BB4  lwz r18, 0x7bb4(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31668 as u32) ) } as u64;
	// 825A7AC0: 825A7BE8  lwz r18, 0x7be8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31720 as u32) ) } as u64;
	// 825A7AC4: 825A7BF8  lwz r18, 0x7bf8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31736 as u32) ) } as u64;
	// 825A7AC8: 825A7AF0  lwz r18, 0x7af0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31472 as u32) ) } as u64;
	// 825A7ACC: 825A7B00  lwz r18, 0x7b00(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31488 as u32) ) } as u64;
            }
            0x825A7AD0 => {
    //   block [0x825A7AD0..0x825A7AE0)
	// 825A7AD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7AD8: 48000149  bl 0x825a7c20
	ctx.lr = 0x825A7ADC;
	sub_825A7C20(ctx, base);
	// 825A7ADC: 48000128  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7AE0 => {
    //   block [0x825A7AE0..0x825A7AF0)
	// 825A7AE0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7AE8: 480003A1  bl 0x825a7e88
	ctx.lr = 0x825A7AEC;
	sub_825A7E88(ctx, base);
	// 825A7AEC: 48000118  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7AF0 => {
    //   block [0x825A7AF0..0x825A7B00)
	// 825A7AF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7AF8: 48000819  bl 0x825a8310
	ctx.lr = 0x825A7AFC;
	sub_825A8310(ctx, base);
	// 825A7AFC: 48000108  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7B00 => {
    //   block [0x825A7B00..0x825A7B18)
	// 825A7B00: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A7B04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A7B08: 419A00FC  beq cr6, 0x825a7c04
	if ctx.cr[6].eq {
	pc = 0x825A7C04; continue 'dispatch;
	}
	// 825A7B0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A7B10: 997F009C  stb r11, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 825A7B14: 480000F0  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7B18 => {
    //   block [0x825A7B18..0x825A7B28)
	// 825A7B18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7B20: 48000BA1  bl 0x825a86c0
	ctx.lr = 0x825A7B24;
	sub_825A86C0(ctx, base);
	// 825A7B24: 480000E0  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7B28 => {
    //   block [0x825A7B28..0x825A7BB4)
	// 825A7B28: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A7B2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A7B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7B34: 48002C2D  bl 0x825aa760
	ctx.lr = 0x825A7B38;
	sub_825AA760(ctx, base);
	// 825A7B38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825A7B3C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825A7B40: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 825A7B44: 39000230  li r8, 0x230
	ctx.r[8].s64 = 560;
	// 825A7B48: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	pc = 0x825A7BB4; continue 'dispatch;
            }
            0x825A7BB4 => {
    //   block [0x825A7BB4..0x825A7BE8)
	// 825A7BB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825A7BB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825A7BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7BC0: 48002BA1  bl 0x825aa760
	ctx.lr = 0x825A7BC4;
	sub_825AA760(ctx, base);
	// 825A7BC4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825A7BC8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825A7BCC: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 825A7BD0: 39000230  li r8, 0x230
	ctx.r[8].s64 = 560;
	pc = 0x825A7BE8; continue 'dispatch;
            }
            0x825A7BE8 => {
    //   block [0x825A7BE8..0x825A7BF8)
	// 825A7BE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7BF0: 48001021  bl 0x825a8c10
	ctx.lr = 0x825A7BF4;
	sub_825A8C10(ctx, base);
	// 825A7BF4: 48000010  b 0x825a7c04
	pc = 0x825A7C04; continue 'dispatch;
            }
            0x825A7BF8 => {
    //   block [0x825A7BF8..0x825A7C1C)
	// 825A7BF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825A7BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A7C00: 48001701  bl 0x825a9300
	ctx.lr = 0x825A7C04;
	sub_825A9300(ctx, base);
	// 825A7C04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825A7C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A7C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A7C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825A7C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A7C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A7C20 size=612
    let mut pc: u32 = 0x825A7C20;
    'dispatch: loop {
        match pc {
            0x825A7C20 => {
    //   block [0x825A7C20..0x825A7E84)
	// 825A7C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7C24: 487017D5  bl 0x82ca93f8
	ctx.lr = 0x825A7C28;
	sub_82CA93D0(ctx, base);
	// 825A7C28: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A7E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825A7E88 size=1156
    //   switch @ 0x825A7EE4: r11 with 4 label(s)
    //       case  0  0x825A7EF8
    //       case  1  0x825A80B4
    //       case  2  0x825A8160
    //       case  3  0x825A8204
    let mut pc: u32 = 0x825A7E88;
    'dispatch: loop {
        match pc {
            0x825A7E88 => {
    //   block [0x825A7E88..0x825A7EF8)
	// 825A7E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A7E8C: 4870157D  bl 0x82ca9408
	ctx.lr = 0x825A7E90;
	sub_82CA93D0(ctx, base);
	// 825A7E90: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825A7E94: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
	pc = 0x825A7EF8; continue 'dispatch;
            }
            0x825A7EF8 => {
    //   block [0x825A7EF8..0x825A80B4)
	// 825A7EF8: 895F009A  lbz r10, 0x9a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(154 as u32) ) } as u64;
	// 825A7EFC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825A7F00: 9BBF009A  stb r29, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[29].u8 ) };
	// 825A7F04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A7F08: 419A010C  beq cr6, 0x825a8014
	if ctx.cr[6].eq {
	pc = 0x825A8014; continue 'dispatch;
	}
	// 825A7F0C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825A7F10: 397F0220  addi r11, r31, 0x220
	ctx.r[11].s64 = ctx.r[31].s64 + 544;
	// 825A7F14: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825A7F18: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 825A7F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825A7F20: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	pc = 0x825A80B4; continue 'dispatch;
            }
            0x825A80B4 => {
    //   block [0x825A80B4..0x825A8160)
	// 825A80B4: 895F009A  lbz r10, 0x9a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(154 as u32) ) } as u64;
	// 825A80B8: 9BBF009A  stb r29, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[29].u8 ) };
	// 825A80BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A80C0: 419A0074  beq cr6, 0x825a8134
	if ctx.cr[6].eq {
	pc = 0x825A8134; continue 'dispatch;
	}
	// 825A80C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825A80C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825A80CC: 388B4E6C  addi r4, r11, 0x4e6c
	ctx.r[4].s64 = ctx.r[11].s64 + 20076;
	// 825A80D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A80D4: 4BC84DFD  bl 0x8222ced0
	ctx.lr = 0x825A80D8;
	sub_8222CED0(ctx, base);
	// 825A80D8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825A80DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A80E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A80E4: 4BFFE81D  bl 0x825a6900
	ctx.lr = 0x825A80E8;
	sub_825A6900(ctx, base);
	// 825A80E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A80EC: 4BC6CCED  bl 0x82214dd8
	ctx.lr = 0x825A80F0;
	sub_82214DD8(ctx, base);
	// 825A80F0: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A80F4: C01EBD10  lfs f0, -0x42f0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A80F8: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A80FC: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 825A8100: C1BEE1E0  lfs f13, -0x1e20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-7712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A8104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A8108: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 825A810C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825A8110: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 825A8114: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825A8118: C129002C  lfs f9, 0x2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825A811C: 9BBF0099  stb r29, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[29].u8 ) };
	// 825A8120: ED0A683A  fmadds f8, f10, f0, f13
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 825A8124: ECE80272  fmuls f7, f8, f9
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 825A8128: D0FF0070  stfs f7, 0x70(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A812C: D0FF0074  stfs f7, 0x74(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A8130: 4BFFEC81  bl 0x825a6db0
	ctx.lr = 0x825A8134;
	sub_825A6DB0(ctx, base);
	// 825A8134: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 825A8138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A813C: 419A0104  beq cr6, 0x825a8240
	if ctx.cr[6].eq {
	pc = 0x825A8240; continue 'dispatch;
	}
	// 825A8140: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 825A8144: D3FF0070  stfs f31, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A8148: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825A814C: D3FF0074  stfs f31, 0x74(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A8150: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825A8154: 995F009A  stb r10, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[10].u8 ) };
	// 825A8158: 9BBF0099  stb r29, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[29].u8 ) };
	// 825A815C: 480000E4  b 0x825a8240
	pc = 0x825A8240; continue 'dispatch;
            }
            0x825A8160 => {
    //   block [0x825A8160..0x825A8204)
	// 825A8160: 895F009A  lbz r10, 0x9a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(154 as u32) ) } as u64;
	// 825A8164: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825A8168: 9BBF009A  stb r29, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[29].u8 ) };
	// 825A816C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A8170: 419A006C  beq cr6, 0x825a81dc
	if ctx.cr[6].eq {
	pc = 0x825A81DC; continue 'dispatch;
	}
	// 825A8174: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825A8178: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825A817C: 419A000C  beq cr6, 0x825a8188
	if ctx.cr[6].eq {
	pc = 0x825A8188; continue 'dispatch;
	}
	// 825A8180: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825A8184: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825A8188: 9B9F009F  stb r28, 0x9f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(159 as u32), ctx.r[28].u8 ) };
	// 825A818C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A8190: 48001C51  bl 0x825a9de0
	ctx.lr = 0x825A8194;
	sub_825A9DE0(ctx, base);
	// 825A8194: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A8198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A819C: 48001F4D  bl 0x825aa0e8
	ctx.lr = 0x825A81A0;
	sub_825AA0E8(ctx, base);
	// 825A81A0: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A81A4: C01EBEBC  lfs f0, -0x4144(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A81A8: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A81AC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 825A81B0: C1BEBD0C  lfs f13, -0x42f4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825A81B4: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 825A81B8: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825A81BC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 825A81C0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825A81C4: C18A002C  lfs f12, 0x2c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825A81C8: 9BBF0099  stb r29, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[29].u8 ) };
	// 825A81CC: ED09683A  fmadds f8, f9, f0, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 825A81D0: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 825A81D4: D0FF0070  stfs f7, 0x70(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A81D8: D0FF0074  stfs f7, 0x74(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A81DC: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 825A81E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A81E4: 419A005C  beq cr6, 0x825a8240
	if ctx.cr[6].eq {
	pc = 0x825A8240; continue 'dispatch;
	}
	// 825A81E8: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 825A81EC: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A81F0: D3FF0074  stfs f31, 0x74(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A81F4: 9B9F009A  stb r28, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[28].u8 ) };
	// 825A81F8: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825A81FC: 9BBF0099  stb r29, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[29].u8 ) };
	// 825A8200: 48000040  b 0x825a8240
	pc = 0x825A8240; continue 'dispatch;
            }
            0x825A8204 => {
    //   block [0x825A8204..0x825A830C)
	// 825A8204: 895F009A  lbz r10, 0x9a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(154 as u32) ) } as u64;
	// 825A8208: 9BBF009A  stb r29, 0x9a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(154 as u32), ctx.r[29].u8 ) };
	// 825A820C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A8210: 419A0014  beq cr6, 0x825a8224
	if ctx.cr[6].eq {
	pc = 0x825A8224; continue 'dispatch;
	}
	// 825A8214: C01EBD04  lfs f0, -0x42fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A8218: 9BBF0099  stb r29, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[29].u8 ) };
	// 825A821C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825A8220: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825A8224: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 825A8228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A822C: 419A0014  beq cr6, 0x825a8240
	if ctx.cr[6].eq {
	pc = 0x825A8240; continue 'dispatch;
	}
	// 825A8230: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825A8234: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A8238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A823C: 4BFFF5A5  bl 0x825a77e0
	ctx.lr = 0x825A8240;
	sub_825A77E0(ctx, base);
	// 825A8240: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 825A8244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825A8248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A824C: 4800171D  bl 0x825a9968
	ctx.lr = 0x825A8250;
	sub_825A9968(ctx, base);
	// 825A8250: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A8254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A8258: 419A00A0  beq cr6, 0x825a82f8
	if ctx.cr[6].eq {
	pc = 0x825A82F8; continue 'dispatch;
	}
	// 825A825C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A8260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A8264: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A8268: 419A0024  beq cr6, 0x825a828c
	if ctx.cr[6].eq {
	pc = 0x825A828C; continue 'dispatch;
	}
	// 825A826C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825A8270: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A8274: 4BFFF56D  bl 0x825a77e0
	ctx.lr = 0x825A8278;
	sub_825A77E0(ctx, base);
	// 825A8278: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825A827C: 3800FFC0  li r0, -0x40
	ctx.r[0].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A8310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A8310 size=532
    let mut pc: u32 = 0x825A8310;
    'dispatch: loop {
        match pc {
            0x825A8310 => {
    //   block [0x825A8310..0x825A8524)
	// 825A8310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A8314: 487010F9  bl 0x82ca940c
	ctx.lr = 0x825A8318;
	sub_82CA93D0(ctx, base);
	// 825A8318: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 825A831C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825A8320: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A8324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A8328: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825A832C: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 825A8330: 41980158  blt cr6, 0x825a8488
	if ctx.cr[6].lt {
	pc = 0x825A8488; continue 'dispatch;
	}
	// 825A8334: 419A0024  beq cr6, 0x825a8358
	if ctx.cr[6].eq {
	pc = 0x825A8358; continue 'dispatch;
	}
	// 825A8338: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 825A833C: 409801D8  bge cr6, 0x825a8514
	if !ctx.cr[6].lt {
	pc = 0x825A8514; continue 'dispatch;
	}
	// 825A8340: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A8344: 997F009B  stb r11, 0x9b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(155 as u32), ctx.r[11].u8 ) };
	// 825A8348: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A834C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825A8350: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825A8354: 48701108  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 825A8358: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A835C: 83BF0050  lwz r29, 0x50(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A8360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825A8364: 80BF0090  lwz r5, 0x90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A8368: 3BCB0120  addi r30, r11, 0x120
	ctx.r[30].s64 = ctx.r[11].s64 + 288;
	// 825A836C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825A8370: C3FE9364  lfs f31, -0x6c9c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27804 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A8374: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A8378: 4BFFCB89  bl 0x825a4f00
	ctx.lr = 0x825A837C;
	sub_825A4F00(ctx, base);
	// 825A837C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825A8380: 392000D0  li r9, 0xd0
	ctx.r[9].s64 = 208;
	// 825A8384: 39000110  li r8, 0x110
	ctx.r[8].s64 = 272;
	// 825A8388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A8528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A8528 size=408
    let mut pc: u32 = 0x825A8528;
    'dispatch: loop {
        match pc {
            0x825A8528 => {
    //   block [0x825A8528..0x825A86C0)
	// 825A8528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A852C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A8530: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A8534: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A8538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A853C: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 825A8540: 41980030  blt cr6, 0x825a8570
	if ctx.cr[6].lt {
	pc = 0x825A8570; continue 'dispatch;
	}
	// 825A8544: 409A0168  bne cr6, 0x825a86ac
	if !ctx.cr[6].eq {
	pc = 0x825A86AC; continue 'dispatch;
	}
	// 825A8548: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 825A854C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A8550: 419A015C  beq cr6, 0x825a86ac
	if ctx.cr[6].eq {
	pc = 0x825A86AC; continue 'dispatch;
	}
	// 825A8554: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A8558: 997F009C  stb r11, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 825A855C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825A8560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825A8564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825A8568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825A856C: 4E800020  blr
	return;
	// 825A8570: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825A8574: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 825A8578: 419A000C  beq cr6, 0x825a8584
	if ctx.cr[6].eq {
	pc = 0x825A8584; continue 'dispatch;
	}
	// 825A857C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 825A8580: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825A8584: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A8588: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825A858C: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 825A8590: 989F0098  stb r4, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[4].u8 ) };
	// 825A8594: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 825A8598: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825A859C: C04B9484  lfs f2, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825A85A0: C02A413C  lfs f1, 0x413c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A85A4: C0CA3710  lfs f6, 0x3710(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 825A85A8: D03F0064  stfs f1, 0x64(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A85AC: D03F0068  stfs f1, 0x68(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825A85B0: 909F01F0  stw r4, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[4].u32 ) };
	// 825A85B4: D0DF0200  stfs f6, 0x200(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 825A85B8: 48339BC9  bl 0x828e2180
	ctx.lr = 0x825A85BC;
	sub_828E2180(ctx, base);
	// 825A85BC: 387F01CC  addi r3, r31, 0x1cc
	ctx.r[3].s64 = ctx.r[31].s64 + 460;
	// 825A85C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825A85C4: C03F0064  lfs f1, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A85C8: 909F01CC  stw r4, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[4].u32 ) };
	// 825A85CC: D0DF01DC  stfs f6, 0x1dc(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 825A85D0: 48339BB1  bl 0x828e2180
	ctx.lr = 0x825A85D4;
	sub_828E2180(ctx, base);
	// 825A85D4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825A85D8: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 825A85DC: 397F0100  addi r11, r31, 0x100
	ctx.r[11].s64 = ctx.r[31].s64 + 256;
	// 825A85E0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 825A85E4: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 825A85E8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825A85EC: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 825A85F0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A86C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A86C0 size=628
    let mut pc: u32 = 0x825A86C0;
    'dispatch: loop {
        match pc {
            0x825A86C0 => {
    //   block [0x825A86C0..0x825A8934)
	// 825A86C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A86C4: 48700D41  bl 0x82ca9404
	ctx.lr = 0x825A86C8;
	sub_82CA93D0(ctx, base);
	// 825A86C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A86CC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A86D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A86D4: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 825A86D8: 41980130  blt cr6, 0x825a8808
	if ctx.cr[6].lt {
	pc = 0x825A8808; continue 'dispatch;
	}
	// 825A86DC: 409A024C  bne cr6, 0x825a8928
	if !ctx.cr[6].eq {
	pc = 0x825A8928; continue 'dispatch;
	}
	// 825A86E0: 39600110  li r11, 0x110
	ctx.r[11].s64 = 272;
	// 825A86E4: 394000B0  li r10, 0xb0
	ctx.r[10].s64 = 176;
	// 825A86E8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825A86EC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825A86F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A8938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A8938 size=724
    let mut pc: u32 = 0x825A8938;
    'dispatch: loop {
        match pc {
            0x825A8938 => {
    //   block [0x825A8938..0x825A8C0C)
	// 825A8938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A893C: 48700ACD  bl 0x82ca9408
	ctx.lr = 0x825A8940;
	sub_82CA93D0(ctx, base);
	// 825A8940: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825A8944: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A8C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A8C10 size=1772
    let mut pc: u32 = 0x825A8C10;
    'dispatch: loop {
        match pc {
            0x825A8C10 => {
    //   block [0x825A8C10..0x825A92FC)
	// 825A8C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A8C14: 487007D1  bl 0x82ca93e4
	ctx.lr = 0x825A8C18;
	sub_82CA93D0(ctx, base);
	// 825A8C18: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 825A8C1C: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 825A8C20: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825A9300 size=1068
    let mut pc: u32 = 0x825A9300;
    'dispatch: loop {
        match pc {
            0x825A9300 => {
    //   block [0x825A9300..0x825A972C)
	// 825A9300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A9304: 487000E9  bl 0x82ca93ec
	ctx.lr = 0x825A9308;
	sub_82CA93D0(ctx, base);
	// 825A9308: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 825A930C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825A9310: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A9730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A9730 size=220
    let mut pc: u32 = 0x825A9730;
    'dispatch: loop {
        match pc {
            0x825A9730 => {
    //   block [0x825A9730..0x825A980C)
	// 825A9730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A9734: 486FFCD1  bl 0x82ca9404
	ctx.lr = 0x825A9738;
	sub_82CA93D0(ctx, base);
	// 825A9738: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825A973C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A9740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825A9744: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825A9748: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 825A974C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A9750: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A9754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9758: 419A0030  beq cr6, 0x825a9788
	if ctx.cr[6].eq {
	pc = 0x825A9788; continue 'dispatch;
	}
	// 825A975C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A9760: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9764: 419A009C  beq cr6, 0x825a9800
	if ctx.cr[6].eq {
	pc = 0x825A9800; continue 'dispatch;
	}
	// 825A9768: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A976C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9770: 419A0018  beq cr6, 0x825a9788
	if ctx.cr[6].eq {
	pc = 0x825A9788; continue 'dispatch;
	}
	// 825A9774: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A9778: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A977C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A9780: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9784: 409A0008  bne cr6, 0x825a978c
	if !ctx.cr[6].eq {
	pc = 0x825A978C; continue 'dispatch;
	}
	// 825A9788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A978C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A9790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9794: 419A005C  beq cr6, 0x825a97f0
	if ctx.cr[6].eq {
	pc = 0x825A97F0; continue 'dispatch;
	}
	// 825A9798: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A979C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825A97A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A97A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A97A8: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 825A97AC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825A97B0: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 825A97B4: 890B0047  lbz r8, 0x47(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 825A97B8: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A97BC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825A97C0: 7D1B0034  cntlzw r27, r8
	ctx.r[27].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 825A97C4: 4BBCA675  bl 0x82173e38
	ctx.lr = 0x825A97C8;
	sub_82173E38(ctx, base);
	// 825A97C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825A97CC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A97D0: 5765DFFE  rlwinm r5, r27, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[27].u32 as u64 & 0x0000001Fu64;
	// 825A97D4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825A97D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825A97DC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825A97E0: 4BFFC5F9  bl 0x825a5dd8
	ctx.lr = 0x825A97E4;
	sub_825A5DD8(ctx, base);
	// 825A97E4: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825A97E8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 825A97EC: 40980008  bge cr6, 0x825a97f4
	if !ctx.cr[6].lt {
	pc = 0x825A97F4; continue 'dispatch;
	}
	// 825A97F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825A97F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825A97F8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825A97FC: 486FFC58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 825A9800: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825A9804: 4BBEA635  bl 0x82193e38
	ctx.lr = 0x825A9808;
	sub_82193E38(ctx, base);
	// 825A9808: 4BFFFF80  b 0x825a9788
	pc = 0x825A9788; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A9810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A9810 size=340
    let mut pc: u32 = 0x825A9810;
    'dispatch: loop {
        match pc {
            0x825A9810 => {
    //   block [0x825A9810..0x825A9964)
	// 825A9810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A9814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825A9818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825A981C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825A9820: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A9824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825A9828: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825A982C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A9830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9834: 419A0030  beq cr6, 0x825a9864
	if ctx.cr[6].eq {
	pc = 0x825A9864; continue 'dispatch;
	}
	// 825A9838: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A983C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9840: 419A00B8  beq cr6, 0x825a98f8
	if ctx.cr[6].eq {
	pc = 0x825A98F8; continue 'dispatch;
	}
	// 825A9844: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A9848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A984C: 419A0018  beq cr6, 0x825a9864
	if ctx.cr[6].eq {
	pc = 0x825A9864; continue 'dispatch;
	}
	// 825A9850: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A9854: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825A9858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A985C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9860: 409A0008  bne cr6, 0x825a9868
	if !ctx.cr[6].eq {
	pc = 0x825A9868; continue 'dispatch;
	}
	// 825A9864: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825A9868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A986C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9870: 419A00DC  beq cr6, 0x825a994c
	if ctx.cr[6].eq {
	pc = 0x825A994C; continue 'dispatch;
	}
	// 825A9874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A9878: 4BBCA5C1  bl 0x82173e38
	ctx.lr = 0x825A987C;
	sub_82173E38(ctx, base);
	// 825A987C: 480533B5  bl 0x825fcc30
	ctx.lr = 0x825A9880;
	sub_825FCC30(ctx, base);
	// 825A9880: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825A9884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9888: 409A00C4  bne cr6, 0x825a994c
	if !ctx.cr[6].eq {
	pc = 0x825A994C; continue 'dispatch;
	}
	// 825A988C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825A9890: 4BBCA5A9  bl 0x82173e38
	ctx.lr = 0x825A9894;
	sub_82173E38(ctx, base);
	// 825A9894: 480542AD  bl 0x825fdb40
	ctx.lr = 0x825A9898;
	sub_825FDB40(ctx, base);
	// 825A9898: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825A989C: 419A0068  beq cr6, 0x825a9904
	if ctx.cr[6].eq {
	pc = 0x825A9904; continue 'dispatch;
	}
	// 825A98A0: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 825A98A4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825A98A8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825A98AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825A9968 size=1144
    let mut pc: u32 = 0x825A9968;
    'dispatch: loop {
        match pc {
            0x825A9968 => {
    //   block [0x825A9968..0x825A9DE0)
	// 825A9968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A996C: 486FFA85  bl 0x82ca93f0
	ctx.lr = 0x825A9970;
	sub_82CA93D0(ctx, base);
	// 825A9970: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825A9974: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 825A9978: 48A5D05D  bl 0x830069d4
	ctx.lr = 0x825A997C;
	sub_83006760(ctx, base);
	// 825A997C: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A9980: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825A9984: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825A9988: 3B8BB730  addi r28, r11, -0x48d0
	ctx.r[28].s64 = ctx.r[11].s64 + -18640;
	// 825A998C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825A9990: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825A9994: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 825A9998: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 825A999C: C01C148C  lfs f0, 0x148c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825A99A0: C3FCDBA4  lfs f31, -0x245c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A99A4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825A99A8: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825A99AC: 419A0008  beq cr6, 0x825a99b4
	if ctx.cr[6].eq {
	pc = 0x825A99B4; continue 'dispatch;
	}
	// 825A99B0: 9AF90000  stb r23, 0(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 825A99B4: 817B0050  lwz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A99B8: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 825A99BC: 816B00E4  lwz r11, 0xe4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 825A99C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A99C4: 419A0020  beq cr6, 0x825a99e4
	if ctx.cr[6].eq {
	pc = 0x825A99E4; continue 'dispatch;
	}
	// 825A99C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A99CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A99D0: 419A000C  beq cr6, 0x825a99dc
	if ctx.cr[6].eq {
	pc = 0x825A99DC; continue 'dispatch;
	}
	// 825A99D4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825A99D8: 48000010  b 0x825a99e8
	pc = 0x825A99E8; continue 'dispatch;
	// 825A99DC: 4BBEA45D  bl 0x82193e38
	ctx.lr = 0x825A99E0;
	sub_82193E38(ctx, base);
	// 825A99E0: C3FCDBA4  lfs f31, -0x245c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825A99E4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825A99E8: 4BBF9AD9  bl 0x821a34c0
	ctx.lr = 0x825A99EC;
	sub_821A34C0(ctx, base);
	// 825A99EC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825A99F0: C81C49F0  lfd f0, 0x49f0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(18928 as u32) ) };
	// 825A99F4: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 825A99F8: 39200120  li r9, 0x120
	ctx.r[9].s64 = 288;
	// 825A99FC: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 825A9A00: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825A9A04: C9AB9660  lfd f13, -0x69a0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 825A9A08: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 825A9A0C: FDA06824  fdiv f13, f0, f13
	ctx.f[13].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 825A9A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825A9DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825A9DE0 size=772
    let mut pc: u32 = 0x825A9DE0;
    'dispatch: loop {
        match pc {
            0x825A9DE0 => {
    //   block [0x825A9DE0..0x825AA0E4)
	// 825A9DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825A9DE4: 486FF611  bl 0x82ca93f4
	ctx.lr = 0x825A9DE8;
	sub_82CA93D0(ctx, base);
	// 825A9DE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825A9DEC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825A9DF0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825A9DF4: 38770008  addi r3, r23, 8
	ctx.r[3].s64 = ctx.r[23].s64 + 8;
	// 825A9DF8: 91770094  stw r11, 0x94(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825A9DFC: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 825A9E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9E04: 419A02D8  beq cr6, 0x825aa0dc
	if ctx.cr[6].eq {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9E08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A9E0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9E10: 419A0058  beq cr6, 0x825a9e68
	if ctx.cr[6].eq {
	pc = 0x825A9E68; continue 'dispatch;
	}
	// 825A9E14: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825A9E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9E1C: 419A02C0  beq cr6, 0x825aa0dc
	if ctx.cr[6].eq {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9E20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825A9E24: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825A9E28: 4BBCA011  bl 0x82173e38
	ctx.lr = 0x825A9E2C;
	sub_82173E38(ctx, base);
	// 825A9E2C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 825A9E30: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 825A9E34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9E38: 419A0100  beq cr6, 0x825a9f38
	if ctx.cr[6].eq {
	pc = 0x825A9F38; continue 'dispatch;
	}
	// 825A9E3C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825A9E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9E44: 419A0030  beq cr6, 0x825a9e74
	if ctx.cr[6].eq {
	pc = 0x825A9E74; continue 'dispatch;
	}
	// 825A9E48: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 825A9E4C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A9E50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825A9E54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825A9E58: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A9E5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A9E60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A9E64: 480000D8  b 0x825a9f3c
	pc = 0x825A9F3C; continue 'dispatch;
	// 825A9E68: 4BBE9FD1  bl 0x82193e38
	ctx.lr = 0x825A9E6C;
	sub_82193E38(ctx, base);
	// 825A9E6C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825A9E70: 486FF5D4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 825A9E74: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825A9E78: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825A9E7C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825A9E80: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825A9E84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A9E88: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A9E8C: 40810054  ble 0x825a9ee0
	if !ctx.cr[0].gt {
	pc = 0x825A9EE0; continue 'dispatch;
	}
	// 825A9E90: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825A9E94: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825A9E98: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825A9E9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A9EA0: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 825A9EA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825A9EA8: 41980008  blt cr6, 0x825a9eb0
	if ctx.cr[6].lt {
	pc = 0x825A9EB0; continue 'dispatch;
	}
	// 825A9EAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825A9EB0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825A9EB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825A9EB8: 419A0014  beq cr6, 0x825a9ecc
	if ctx.cr[6].eq {
	pc = 0x825A9ECC; continue 'dispatch;
	}
	// 825A9EBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A9EC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825A9EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825A9EC8: 4800000C  b 0x825a9ed4
	pc = 0x825A9ED4; continue 'dispatch;
	// 825A9ECC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825A9ED0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825A9ED4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825A9ED8: 4199FFB8  bgt cr6, 0x825a9e90
	if ctx.cr[6].gt {
	pc = 0x825A9E90; continue 'dispatch;
	}
	// 825A9EDC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825A9EE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825A9EE4: 419A0040  beq cr6, 0x825a9f24
	if ctx.cr[6].eq {
	pc = 0x825A9F24; continue 'dispatch;
	}
	// 825A9EE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825A9EEC: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 825A9EF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A9EF4: 41990008  bgt cr6, 0x825a9efc
	if ctx.cr[6].gt {
	pc = 0x825A9EFC; continue 'dispatch;
	}
	// 825A9EF8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A9EFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A9F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9F04: 409A0020  bne cr6, 0x825a9f24
	if !ctx.cr[6].eq {
	pc = 0x825A9F24; continue 'dispatch;
	}
	// 825A9F08: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825A9F0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825A9F10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825A9F14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A9F18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A9F1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A9F20: 4800001C  b 0x825a9f3c
	pc = 0x825A9F3C; continue 'dispatch;
	// 825A9F24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825A9F28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A9F2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825A9F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825A9F34: 48000008  b 0x825a9f3c
	pc = 0x825A9F3C; continue 'dispatch;
	// 825A9F38: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825A9F3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825A9F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9F44: 419A0198  beq cr6, 0x825aa0dc
	if ctx.cr[6].eq {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9F48: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825A9F4C: 3B7F002C  addi r27, r31, 0x2c
	ctx.r[27].s64 = ctx.r[31].s64 + 44;
	// 825A9F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9F54: 419A0188  beq cr6, 0x825aa0dc
	if ctx.cr[6].eq {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9F58: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A9F5C: 3B00002C  li r24, 0x2c
	ctx.r[24].s64 = 44;
	// 825A9F60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825A9F64: 7F29C3D7  divw. r25, r9, r24
	ctx.r[25].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 825A9F68: 40810174  ble 0x825aa0dc
	if !ctx.cr[0].gt {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9F6C: 81770050  lwz r11, 0x50(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A9F70: 894B0047  lbz r10, 0x47(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 825A9F74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825A9F78: 409A001C  bne cr6, 0x825a9f94
	if !ctx.cr[6].eq {
	pc = 0x825A9F94; continue 'dispatch;
	}
	// 825A9F7C: 81770090  lwz r11, 0x90(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(144 as u32) ) } as u64;
	// 825A9F80: 7D4BCBD6  divw r10, r11, r25
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[25].s32;
	// 825A9F84: 7D2AC9D6  mullw r9, r10, r25
	ctx.r[9].s64 = (ctx.r[10].s32 as i64) * (ctx.r[25].s32 as i64);
	// 825A9F88: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825A9F8C: 91170094  stw r8, 0x94(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 825A9F90: 48000008  b 0x825a9f98
	pc = 0x825A9F98; continue 'dispatch;
	// 825A9F94: 93B70094  stw r29, 0x94(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 825A9F98: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 825A9F9C: 40990140  ble cr6, 0x825aa0dc
	if !ctx.cr[6].gt {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825A9FA0: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825A9FA4: 81770094  lwz r11, 0x94(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(148 as u32) ) } as u64;
	// 825A9FA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825A9FAC: 419A0018  beq cr6, 0x825a9fc4
	if ctx.cr[6].eq {
	pc = 0x825A9FC4; continue 'dispatch;
	}
	// 825A9FB0: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825A9FB4: 7D3E5050  subf r9, r30, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 825A9FB8: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 825A9FBC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825A9FC0: 41980008  blt cr6, 0x825a9fc8
	if ctx.cr[6].lt {
	pc = 0x825A9FC8; continue 'dispatch;
	}
	// 825A9FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825A9FC8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825A9FCC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825A9FD0: 3B4A4EEC  addi r26, r10, 0x4eec
	ctx.r[26].s64 = ctx.r[10].s64 + 20204;
	// 825A9FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825A9FD8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825A9FDC: 1FEB002C  mulli r31, r11, 0x2c
	ctx.r[31].s64 = ctx.r[11].s64 * 44;
	// 825A9FE0: 4BC82EF1  bl 0x8222ced0
	ctx.lr = 0x825A9FE4;
	sub_8222CED0(ctx, base);
	// 825A9FE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825A9FE8: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 825A9FEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825A9FF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825A9FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825A9FF8: 419A0008  beq cr6, 0x825aa000
	if ctx.cr[6].eq {
	pc = 0x825AA000; continue 'dispatch;
	}
	// 825A9FFC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA000: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825AA004: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AA008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA00C: 419A0008  beq cr6, 0x825aa014
	if ctx.cr[6].eq {
	pc = 0x825AA014; continue 'dispatch;
	}
	// 825AA010: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA014: 4BC3C7B5  bl 0x821e67c8
	ctx.lr = 0x825AA018;
	sub_821E67C8(ctx, base);
	// 825AA018: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 825AA01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AA020: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825AA024: 695F0001  xori r31, r10, 1
	ctx.r[31].u64 = ctx.r[10].u64 ^ 1;
	// 825AA028: 4BC6ADB1  bl 0x82214dd8
	ctx.lr = 0x825AA02C;
	sub_82214DD8(ctx, base);
	// 825AA02C: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 825AA030: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AA034: 419A00A8  beq cr6, 0x825aa0dc
	if ctx.cr[6].eq {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825AA038: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 825AA03C: 93B70094  stw r29, 0x94(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 825AA040: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 825AA044: 40990098  ble cr6, 0x825aa0dc
	if !ctx.cr[6].gt {
	pc = 0x825AA0DC; continue 'dispatch;
	}
	// 825AA048: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AA04C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AA050: 419A0018  beq cr6, 0x825aa068
	if ctx.cr[6].eq {
	pc = 0x825AA068; continue 'dispatch;
	}
	// 825AA054: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AA058: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825AA05C: 7D2AC3D6  divw r9, r10, r24
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 825AA060: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825AA064: 41980008  blt cr6, 0x825aa06c
	if ctx.cr[6].lt {
	pc = 0x825AA06C; continue 'dispatch;
	}
	// 825AA068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AA06C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825AA070: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AA074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AA078: 4BC82E59  bl 0x8222ced0
	ctx.lr = 0x825AA07C;
	sub_8222CED0(ctx, base);
	// 825AA07C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AA080: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825AA084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA088: 419A0008  beq cr6, 0x825aa090
	if ctx.cr[6].eq {
	pc = 0x825AA090; continue 'dispatch;
	}
	// 825AA08C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA090: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825AA094: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AA098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA09C: 419A0008  beq cr6, 0x825aa0a4
	if ctx.cr[6].eq {
	pc = 0x825AA0A4; continue 'dispatch;
	}
	// 825AA0A0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA0A4: 4BC3C725  bl 0x821e67c8
	ctx.lr = 0x825AA0A8;
	sub_821E67C8(ctx, base);
	// 825AA0A8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 825AA0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AA0B0: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825AA0B4: 4BC6AD25  bl 0x82214dd8
	ctx.lr = 0x825AA0B8;
	sub_82214DD8(ctx, base);
	// 825AA0B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AA0BC: 409A001C  bne cr6, 0x825aa0d8
	if !ctx.cr[6].eq {
	pc = 0x825AA0D8; continue 'dispatch;
	}
	// 825AA0C0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825AA0C4: 3BBD002C  addi r29, r29, 0x2c
	ctx.r[29].s64 = ctx.r[29].s64 + 44;
	// 825AA0C8: 7F1EC800  cmpw cr6, r30, r25
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[25].s32, &mut ctx.xer);
	// 825AA0CC: 4198FF7C  blt cr6, 0x825aa048
	if ctx.cr[6].lt {
	pc = 0x825AA048; continue 'dispatch;
	}
	// 825AA0D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AA0D4: 486FF370  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 825AA0D8: 93D70094  stw r30, 0x94(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 825AA0DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AA0E0: 486FF364  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AA0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AA0E8 size=416
    let mut pc: u32 = 0x825AA0E8;
    'dispatch: loop {
        match pc {
            0x825AA0E8 => {
    //   block [0x825AA0E8..0x825AA288)
	// 825AA0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AA0EC: 486FF321  bl 0x82ca940c
	ctx.lr = 0x825AA0F0;
	sub_82CA93D0(ctx, base);
	// 825AA0F0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AA288 size=536
    let mut pc: u32 = 0x825AA288;
    'dispatch: loop {
        match pc {
            0x825AA288 => {
    //   block [0x825AA288..0x825AA4A0)
	// 825AA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AA28C: 486FF181  bl 0x82ca940c
	ctx.lr = 0x825AA290;
	sub_82CA93D0(ctx, base);
	// 825AA290: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AA294: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AA298: 897D009F  lbz r11, 0x9f(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(159 as u32) ) } as u64;
	// 825AA29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA2A0: 419A01F8  beq cr6, 0x825aa498
	if ctx.cr[6].eq {
	pc = 0x825AA498; continue 'dispatch;
	}
	// 825AA2A4: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 825AA2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AA2AC: 4BBC9B8D  bl 0x82173e38
	ctx.lr = 0x825AA2B0;
	sub_82173E38(ctx, base);
	// 825AA2B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AA2B4: 419A01E4  beq cr6, 0x825aa498
	if ctx.cr[6].eq {
	pc = 0x825AA498; continue 'dispatch;
	}
	// 825AA2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AA2BC: 4BBC9B7D  bl 0x82173e38
	ctx.lr = 0x825AA2C0;
	sub_82173E38(ctx, base);
	// 825AA2C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AA2C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AA2C8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AA2CC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA2D0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 825AA2D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825AA2D8: 4E800421  bctrl
	ctx.lr = 0x825AA2DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AA2DC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 825AA2E0: 3BDD00B0  addi r30, r29, 0xb0
	ctx.r[30].s64 = ctx.r[29].s64 + 176;
	// 825AA2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AA4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AA4A0 size=704
    let mut pc: u32 = 0x825AA4A0;
    'dispatch: loop {
        match pc {
            0x825AA4A0 => {
    //   block [0x825AA4A0..0x825AA760)
	// 825AA4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AA4A4: 486FEF69  bl 0x82ca940c
	ctx.lr = 0x825AA4A8;
	sub_82CA93D0(ctx, base);
	// 825AA4A8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AA760 size=780
    let mut pc: u32 = 0x825AA760;
    'dispatch: loop {
        match pc {
            0x825AA760 => {
    //   block [0x825AA760..0x825AAA6C)
	// 825AA760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AA764: 486FEC99  bl 0x82ca93fc
	ctx.lr = 0x825AA768;
	sub_82CA93D0(ctx, base);
	// 825AA768: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825AA76C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AA770: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AA774: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825AA778: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825AA77C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825AA780: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AA784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA788: 419A0030  beq cr6, 0x825aa7b8
	if ctx.cr[6].eq {
	pc = 0x825AA7B8; continue 'dispatch;
	}
	// 825AA78C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AA790: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AA794: 419A0158  beq cr6, 0x825aa8ec
	if ctx.cr[6].eq {
	pc = 0x825AA8EC; continue 'dispatch;
	}
	// 825AA798: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AA79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AA7A0: 419A0018  beq cr6, 0x825aa7b8
	if ctx.cr[6].eq {
	pc = 0x825AA7B8; continue 'dispatch;
	}
	// 825AA7A4: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AA7A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AA7AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AA7B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AA7B4: 409A0008  bne cr6, 0x825aa7bc
	if !ctx.cr[6].eq {
	pc = 0x825AA7BC; continue 'dispatch;
	}
	// 825AA7B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AA7BC: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AA7C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AA7C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AA7C8: 3B6B9490  addi r27, r11, -0x6b70
	ctx.r[27].s64 = ctx.r[11].s64 + -27504;
	// 825AA7CC: 419A0258  beq cr6, 0x825aaa24
	if ctx.cr[6].eq {
	pc = 0x825AAA24; continue 'dispatch;
	}
	// 825AA7D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825AA7D4: C3FB0000  lfs f31, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AA7D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AA7DC: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AA7E0: 3B9E00C0  addi r28, r30, 0xc0
	ctx.r[28].s64 = ctx.r[30].s64 + 192;
	// 825AA7E4: 392A9140  addi r9, r10, -0x6ec0
	ctx.r[9].s64 = ctx.r[10].s64 + -28352;
	// 825AA7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AAA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AAA70 size=332
    let mut pc: u32 = 0x825AAA70;
    'dispatch: loop {
        match pc {
            0x825AAA70 => {
    //   block [0x825AAA70..0x825AABBC)
	// 825AAA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AAA74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AAA78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AAA7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AAA80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AAA84: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 825AAA88: 48337841  bl 0x828e22c8
	ctx.lr = 0x825AAA8C;
	sub_828E22C8(ctx, base);
	// 825AAA8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AAA90: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AAA94: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 825AAA98: 395F01CC  addi r10, r31, 0x1cc
	ctx.r[10].s64 = ctx.r[31].s64 + 460;
	// 825AAA9C: 393F01F0  addi r9, r31, 0x1f0
	ctx.r[9].s64 = ctx.r[31].s64 + 496;
	// 825AAAA0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AAAA4: D01F0164  stfs f0, 0x164(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 825AAAA8: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 825AAAAC: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 825AAAB0: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 825AAAB4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825AAAB8: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 825AAABC: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825AAAC0: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 825AAAC4: D01F01AC  stfs f0, 0x1ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 825AAAC8: D01F01B0  stfs f0, 0x1b0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 825AAACC: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 825AAAD0: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 825AAAD4: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 825AAAD8: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 825AAADC: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 825AAAE0: D01F01DC  stfs f0, 0x1dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 825AAAE4: D01F01F4  stfs f0, 0x1f4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 825AAAE8: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 825AAAEC: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 825AAAF0: D01F0200  stfs f0, 0x200(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 825AAAF4: 991F01C8  stb r8, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[8].u8 ) };
	// 825AAAF8: C1AB4178  lfs f13, 0x4178(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AAAFC: D1BF0174  stfs f13, 0x174(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 825AAB00: D1BF0198  stfs f13, 0x198(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 825AAB04: D1BF01BC  stfs f13, 0x1bc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 825AAB08: C1AB3710  lfs f13, 0x3710(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AAB0C: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AAB10: 88E80044  lbz r7, 0x44(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AAB14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AAB18: 419A000C  beq cr6, 0x825aab24
	if ctx.cr[6].eq {
	pc = 0x825AAB24; continue 'dispatch;
	}
	// 825AAB1C: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 825AAB20: 48000008  b 0x825aab28
	pc = 0x825AAB28; continue 'dispatch;
	// 825AAB24: C14B21CC  lfs f10, 0x21cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8652 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825AAB28: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 825AAB2C: C18B2980  lfs f12, 0x2980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825AAB30: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825AAB34: D15F01D0  stfs f10, 0x1d0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 825AAB38: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AAB3C: D19F01E8  stfs f12, 0x1e8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 825AAB40: D17F01E0  stfs f11, 0x1e0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 825AAB44: 89480044  lbz r10, 0x44(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AAB48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AAB4C: 409A0008  bne cr6, 0x825aab54
	if !ctx.cr[6].eq {
	pc = 0x825AAB54; continue 'dispatch;
	}
	// 825AAB50: C1AB40E4  lfs f13, 0x40e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AAB54: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AAB58: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 825AAB5C: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 825AAB60: D1BF01F4  stfs f13, 0x1f4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 825AAB64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825AAB68: D19F020C  stfs f12, 0x20c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 825AAB6C: D17F0204  stfs f11, 0x204(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), tmp.u32 ) };
	// 825AAB70: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AAB74: C04BFE50  lfs f2, -0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AABC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AABC0 size=412
    let mut pc: u32 = 0x825AABC0;
    'dispatch: loop {
        match pc {
            0x825AABC0 => {
    //   block [0x825AABC0..0x825AAD5C)
	// 825AABC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AABC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AABC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AABCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AABD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AABD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AABD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AABDC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AABE0: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825AABE4: 419A0160  beq cr6, 0x825aad44
	if ctx.cr[6].eq {
	pc = 0x825AAD44; continue 'dispatch;
	}
	// 825AABE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825AABEC: 419800D0  blt cr6, 0x825aacbc
	if ctx.cr[6].lt {
	pc = 0x825AACBC; continue 'dispatch;
	}
	// 825AABF0: 409A0150  bne cr6, 0x825aad40
	if !ctx.cr[6].eq {
	pc = 0x825AAD40; continue 'dispatch;
	}
	// 825AABF4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825AABF8: 409A0148  bne cr6, 0x825aad40
	if !ctx.cr[6].eq {
	pc = 0x825AAD40; continue 'dispatch;
	}
	// 825AABFC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AAC00: 4BFFA809  bl 0x825a5408
	ctx.lr = 0x825AAC04;
	sub_825A5408(ctx, base);
	// 825AAC04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AAC08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AAC0C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AAC10: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AAC14: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 825AAC18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825AAC1C: 4E800421  bctrl
	ctx.lr = 0x825AAC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AAC20: 891F01C8  lbz r8, 0x1c8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 825AAC24: C01F01AC  lfs f0, 0x1ac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AAC28: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AAC2C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825AAC30: 419A000C  beq cr6, 0x825aac3c
	if ctx.cr[6].eq {
	pc = 0x825AAC3C; continue 'dispatch;
	}
	// 825AAC34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AAC38: 4804B9E9  bl 0x825f6620
	ctx.lr = 0x825AAC3C;
	sub_825F6620(ctx, base);
	// 825AAC3C: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 825AAC40: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AAC44: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AAC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AAC4C: 419A000C  beq cr6, 0x825aac58
	if ctx.cr[6].eq {
	pc = 0x825AAC58; continue 'dispatch;
	}
	// 825AAC50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AAC54: 4804B9CD  bl 0x825f6620
	ctx.lr = 0x825AAC58;
	sub_825F6620(ctx, base);
	// 825AAC58: 897F0180  lbz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 825AAC5C: C01F0164  lfs f0, 0x164(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AAC60: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825AAC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AAC68: 419A000C  beq cr6, 0x825aac74
	if ctx.cr[6].eq {
	pc = 0x825AAC74; continue 'dispatch;
	}
	// 825AAC6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AAC70: 4804B9B1  bl 0x825f6620
	ctx.lr = 0x825AAC74;
	sub_825F6620(ctx, base);
	// 825AAC74: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825AAC78: C0610050  lfs f3, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825AAC7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825AAC80: C0410054  lfs f2, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825AAC84: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AAD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AAD60 size=248
    let mut pc: u32 = 0x825AAD60;
    'dispatch: loop {
        match pc {
            0x825AAD60 => {
    //   block [0x825AAD60..0x825AAE58)
	// 825AAD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AAD64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AAD68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AAD6C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AAD70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AAD74: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AAD78: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825AAD7C: 419800C0  blt cr6, 0x825aae3c
	if ctx.cr[6].lt {
	pc = 0x825AAE3C; continue 'dispatch;
	}
	// 825AAD80: 409A00C4  bne cr6, 0x825aae44
	if !ctx.cr[6].eq {
	pc = 0x825AAE44; continue 'dispatch;
	}
	// 825AAD84: 38BF0160  addi r5, r31, 0x160
	ctx.r[5].s64 = ctx.r[31].s64 + 352;
	// 825AAD88: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825AAD8C: 48337245  bl 0x828e1fd0
	ctx.lr = 0x825AAD90;
	sub_828E1FD0(ctx, base);
	// 825AAD90: 38DF0184  addi r6, r31, 0x184
	ctx.r[6].s64 = ctx.r[31].s64 + 388;
	// 825AAD94: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825AAD98: 48337239  bl 0x828e1fd0
	ctx.lr = 0x825AAD9C;
	sub_828E1FD0(ctx, base);
	// 825AAD9C: 387F01A8  addi r3, r31, 0x1a8
	ctx.r[3].s64 = ctx.r[31].s64 + 424;
	// 825AADA0: 48337231  bl 0x828e1fd0
	ctx.lr = 0x825AADA4;
	sub_828E1FD0(ctx, base);
	// 825AADA4: 897F01C8  lbz r11, 0x1c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 825AADA8: C01F01AC  lfs f0, 0x1ac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AADAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AADB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AADB4: 419A000C  beq cr6, 0x825aadc0
	if ctx.cr[6].eq {
	pc = 0x825AADC0; continue 'dispatch;
	}
	// 825AADB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AADBC: 4804B865  bl 0x825f6620
	ctx.lr = 0x825AADC0;
	sub_825F6620(ctx, base);
	// 825AADC0: 89660020  lbz r11, 0x20(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AADC4: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AADC8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AADCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AADD0: 419A000C  beq cr6, 0x825aaddc
	if ctx.cr[6].eq {
	pc = 0x825AADDC; continue 'dispatch;
	}
	// 825AADD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AADD8: 4804B849  bl 0x825f6620
	ctx.lr = 0x825AADDC;
	sub_825F6620(ctx, base);
	// 825AADDC: 89650020  lbz r11, 0x20(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AADE0: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AADE4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825AADE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AADEC: 419A000C  beq cr6, 0x825aadf8
	if ctx.cr[6].eq {
	pc = 0x825AADF8; continue 'dispatch;
	}
	// 825AADF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AADF4: 4804B82D  bl 0x825f6620
	ctx.lr = 0x825AADF8;
	sub_825F6620(ctx, base);
	// 825AADF8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AADFC: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 825AAE00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AAE04: C0610050  lfs f3, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825AAE08: C0410054  lfs f2, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825AAE0C: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AAE58 size=748
    //   switch @ 0x825AAEEC: r11 with 7 label(s)
    //       case  0  0x825AAF0C
    //       case  1  0x825AAF2C
    //       case  2  0x825AAF0C
    //       case  3  0x825AAF44
    //       case  4  0x825AAF2C
    //       case  5  0x825AAF58
    //       case  6  0x825AAFA0
    let mut pc: u32 = 0x825AAE58;
    'dispatch: loop {
        match pc {
            0x825AAE58 => {
    //   block [0x825AAE58..0x825AAF0C)
	// 825AAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AAE5C: 486FE5AD  bl 0x82ca9408
	ctx.lr = 0x825AAE60;
	sub_82CA93D0(ctx, base);
	// 825AAE60: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825AAE64: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825AAE68: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825AAE6C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
	pc = 0x825AAF0C; continue 'dispatch;
            }
            0x825AAF0C => {
    //   block [0x825AAF0C..0x825AAF2C)
	// 825AAF0C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AAF10: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 825AAF14: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825AAF18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x825AAF2C; continue 'dispatch;
            }
            0x825AAF2C => {
    //   block [0x825AAF2C..0x825AAF44)
	// 825AAF2C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AAF30: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 825AAF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825AAF44; continue 'dispatch;
            }
            0x825AAF44 => {
    //   block [0x825AAF44..0x825AAF58)
	// 825AAF44: 396000B0  li r11, 0xb0
	ctx.r[11].s64 = 176;
	// 825AAF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825AAF58; continue 'dispatch;
            }
            0x825AAF58 => {
    //   block [0x825AAF58..0x825AAFA0)
	// 825AAF58: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AAF5C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825AAF60: 4BFFA4A9  bl 0x825a5408
	ctx.lr = 0x825AAF64;
	sub_825A5408(ctx, base);
	// 825AAF64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AAF68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825AAF6C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AAF70: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AAF74: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 825AAF78: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825AAF7C: 4E800421  bctrl
	ctx.lr = 0x825AAF80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AAF80: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 825AAF84: 38E000B0  li r7, 0xb0
	ctx.r[7].s64 = 176;
	// 825AAF88: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
            }
            0x825AAFA0 => {
    //   block [0x825AAFA0..0x825AB144)
	// 825AAFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AAFA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AAFA8: 48000229  bl 0x825ab1d0
	ctx.lr = 0x825AAFAC;
	sub_825AB1D0(ctx, base);
	// 825AAFAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AAFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AB148 size=136
    let mut pc: u32 = 0x825AB148;
    'dispatch: loop {
        match pc {
            0x825AB148 => {
    //   block [0x825AB148..0x825AB1D0)
	// 825AB148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AB150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AB154: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AB1D0 size=236
    let mut pc: u32 = 0x825AB1D0;
    'dispatch: loop {
        match pc {
            0x825AB1D0 => {
    //   block [0x825AB1D0..0x825AB2BC)
	// 825AB1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AB1D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AB1DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AB1E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB1E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AB1E8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 825AB1EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AB1F0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AB1F4: C00A1354  lfs f0, 0x1354(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AB1F8: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 825AB1FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AB200: 816B00E4  lwz r11, 0xe4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 825AB204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB208: 419A001C  beq cr6, 0x825ab224
	if ctx.cr[6].eq {
	pc = 0x825AB224; continue 'dispatch;
	}
	// 825AB20C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB210: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB214: 419A000C  beq cr6, 0x825ab220
	if ctx.cr[6].eq {
	pc = 0x825AB220; continue 'dispatch;
	}
	// 825AB218: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AB21C: 4800000C  b 0x825ab228
	pc = 0x825AB228; continue 'dispatch;
	// 825AB220: 4BBE8C19  bl 0x82193e38
	ctx.lr = 0x825AB224;
	sub_82193E38(ctx, base);
	// 825AB224: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AB228: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AB22C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AB230: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB234: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AB238: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AB23C: 4E800421  bctrl
	ctx.lr = 0x825AB240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AB240: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825AB244: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 825AB248: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 825AB24C: 4BC4A90D  bl 0x821f5b58
	ctx.lr = 0x825AB250;
	sub_821F5B58(ctx, base);
	// 825AB250: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825AB254: 38E00110  li r7, 0x110
	ctx.r[7].s64 = 272;
	// 825AB258: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825AB25C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 825AB260: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AB2C0 size=280
    let mut pc: u32 = 0x825AB2C0;
    'dispatch: loop {
        match pc {
            0x825AB2C0 => {
    //   block [0x825AB2C0..0x825AB3D8)
	// 825AB2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB2C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AB2C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AB2CC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825AB2D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB2D4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825AB2D8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825AB2DC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825AB2E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB2E4: 48000A25  bl 0x825abd08
	ctx.lr = 0x825AB2E8;
	sub_825ABD08(ctx, base);
	// 825AB2E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AB2EC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825AB2F0: C19F0084  lfs f12, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825AB2F4: C17F0088  lfs f11, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825AB2F8: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 825AB2FC: C80B0120  lfd f0, 0x120(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) };
	// 825AB300: C9AA9660  lfd f13, -0x69a0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825AB304: FD406824  fdiv f10, f0, f13
	ctx.f[10].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 825AB308: FD2A07F2  fmul f9, f10, f31
	ctx.f[9].f64 = ctx.f[10].f64 * ctx.f[31].f64;
	// 825AB30C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 825AB310: ECE862FA  fmadds f7, f8, f11, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 825AB314: D0FF0084  stfs f7, 0x84(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825AB318: 4804B2A9  bl 0x825f65c0
	ctx.lr = 0x825AB31C;
	sub_825F65C0(ctx, base);
	// 825AB31C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825AB320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AB324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AB3D8 size=272
    let mut pc: u32 = 0x825AB3D8;
    'dispatch: loop {
        match pc {
            0x825AB3D8 => {
    //   block [0x825AB3D8..0x825AB4E8)
	// 825AB3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AB3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AB3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AB3E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825AB3EC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB3F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AB3F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB3F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AB3FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AB400: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AB404: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AB408: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AB40C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AB410: 4804B109  bl 0x825f6518
	ctx.lr = 0x825AB414;
	sub_825F6518(ctx, base);
	// 825AB414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB418: C0610050  lfs f3, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825AB41C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825AB420: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825AB424: 48001B35  bl 0x825acf58
	ctx.lr = 0x825AB428;
	sub_825ACF58(ctx, base);
	// 825AB428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AB42C: C03F0084  lfs f1, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825AB430: 4BFF3271  bl 0x8259e6a0
	ctx.lr = 0x825AB434;
	sub_8259E6A0(ctx, base);
	// 825AB434: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AB438: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AB43C: 390A9060  addi r8, r10, -0x6fa0
	ctx.r[8].s64 = ctx.r[10].s64 + -28576;
	// 825AB440: 38E99160  addi r7, r9, -0x6ea0
	ctx.r[7].s64 = ctx.r[9].s64 + -28320;
	// 825AB444: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825AB448: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825AB44C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AB4E8 size=184
    let mut pc: u32 = 0x825AB4E8;
    'dispatch: loop {
        match pc {
            0x825AB4E8 => {
    //   block [0x825AB4E8..0x825AB5A0)
	// 825AB4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB4EC: 486FDF15  bl 0x82ca9400
	ctx.lr = 0x825AB4F0;
	sub_82CA93D0(ctx, base);
	// 825AB4F0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825AB4F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB4F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB4FC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825AB500: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AB504: 894B004A  lbz r10, 0x4a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(74 as u32) ) } as u64;
	// 825AB508: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB50C: 419A0074  beq cr6, 0x825ab580
	if ctx.cr[6].eq {
	pc = 0x825AB580; continue 'dispatch;
	}
	// 825AB510: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AB514: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AB518: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AB51C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825AB520: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AB524: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 825AB528: 88EB0047  lbz r7, 0x47(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 825AB52C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AB530: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AB534: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 825AB538: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825AB53C: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825AB540: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AB544: 7CFA0034  cntlzw r26, r7
	ctx.r[26].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 825AB548: 4BBC88F1  bl 0x82173e38
	ctx.lr = 0x825AB54C;
	sub_82173E38(ctx, base);
	// 825AB54C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AB550: 5745DFFE  rlwinm r5, r26, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[26].u32 as u64 & 0x0000001Fu64;
	// 825AB554: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AB558: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825AB55C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825AB560: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825AB564: 4BFFA875  bl 0x825a5dd8
	ctx.lr = 0x825AB568;
	sub_825A5DD8(ctx, base);
	// 825AB568: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AB56C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 825AB570: 40990010  ble cr6, 0x825ab580
	if !ctx.cr[6].gt {
	pc = 0x825AB580; continue 'dispatch;
	}
	// 825AB574: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB578: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825AB57C: 419A0014  beq cr6, 0x825ab590
	if ctx.cr[6].eq {
	pc = 0x825AB590; continue 'dispatch;
	}
	// 825AB580: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AB584: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AB588: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825AB58C: 486FDEC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 825AB590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB594: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AB598: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825AB59C: 486FDEB4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AB5A0 size=392
    let mut pc: u32 = 0x825AB5A0;
    'dispatch: loop {
        match pc {
            0x825AB5A0 => {
    //   block [0x825AB5A0..0x825AB728)
	// 825AB5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB5A4: 486FDE69  bl 0x82ca940c
	ctx.lr = 0x825AB5A8;
	sub_82CA93D0(ctx, base);
	// 825AB5A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB5AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AB5B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB5B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825AB5BC: 48000E2D  bl 0x825ac3e8
	ctx.lr = 0x825AB5C0;
	sub_825AC3E8(ctx, base);
	// 825AB5C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5C8: 419A0154  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB5D0: 4BFFFF19  bl 0x825ab4e8
	ctx.lr = 0x825AB5D4;
	sub_825AB4E8(ctx, base);
	// 825AB5D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5DC: 419A0140  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB5E0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AB5E4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825AB5E8: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 825AB5EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AB5F0: 419A00E8  beq cr6, 0x825ab6d8
	if ctx.cr[6].eq {
	pc = 0x825AB6D8; continue 'dispatch;
	}
	// 825AB5F4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AB5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5FC: 419A0020  beq cr6, 0x825ab61c
	if ctx.cr[6].eq {
	pc = 0x825AB61C; continue 'dispatch;
	}
	// 825AB600: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AB604: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB608: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AB60C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AB610: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB614: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB618: 480000C4  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
	// 825AB61C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB620: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AB624: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825AB628: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AB62C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB630: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB634: 40810054  ble 0x825ab688
	if !ctx.cr[0].gt {
	pc = 0x825AB688; continue 'dispatch;
	}
	// 825AB638: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AB63C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AB640: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AB644: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB648: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AB64C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AB650: 41980008  blt cr6, 0x825ab658
	if ctx.cr[6].lt {
	pc = 0x825AB658; continue 'dispatch;
	}
	// 825AB654: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825AB658: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AB65C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AB660: 419A0014  beq cr6, 0x825ab674
	if ctx.cr[6].eq {
	pc = 0x825AB674; continue 'dispatch;
	}
	// 825AB664: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AB668: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AB66C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AB670: 4800000C  b 0x825ab67c
	pc = 0x825AB67C; continue 'dispatch;
	// 825AB674: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AB678: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AB67C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB680: 4199FFB8  bgt cr6, 0x825ab638
	if ctx.cr[6].gt {
	pc = 0x825AB638; continue 'dispatch;
	}
	// 825AB684: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB688: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AB68C: 419A003C  beq cr6, 0x825ab6c8
	if ctx.cr[6].eq {
	pc = 0x825AB6C8; continue 'dispatch;
	}
	// 825AB690: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB694: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AB698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB69C: 41990008  bgt cr6, 0x825ab6a4
	if ctx.cr[6].gt {
	pc = 0x825AB6A4; continue 'dispatch;
	}
	// 825AB6A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825AB6A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB6AC: 409A001C  bne cr6, 0x825ab6c8
	if !ctx.cr[6].eq {
	pc = 0x825AB6C8; continue 'dispatch;
	}
	// 825AB6B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AB6B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB6B8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AB6BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB6C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB6C4: 48000018  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
	// 825AB6C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AB6CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB6D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB6D4: 48000008  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
	// 825AB6D8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825AB6DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825AB6E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB6E4: 419A0038  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB6E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AB6EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825AB6F0: 4BC49C31  bl 0x821f5320
	ctx.lr = 0x825AB6F4;
	sub_821F5320(ctx, base);
	// 825AB6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB6F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AB6FC: 419A0020  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB704: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB708: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AB70C: 4E800421  bctrl
	ctx.lr = 0x825AB710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AB710: 2F030030  cmpwi cr6, r3, 0x30
	ctx.cr[6].compare_i32(ctx.r[3].s32, 48, &mut ctx.xer);
	// 825AB714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB718: 419A0008  beq cr6, 0x825ab720
	if ctx.cr[6].eq {
	pc = 0x825AB720; continue 'dispatch;
	}
	// 825AB71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AB720: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AB724: 486FDD38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AB728 size=548
    let mut pc: u32 = 0x825AB728;
    'dispatch: loop {
        match pc {
            0x825AB728 => {
    //   block [0x825AB728..0x825AB94C)
	// 825AB728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB72C: 486FDCE1  bl 0x82ca940c
	ctx.lr = 0x825AB730;
	sub_82CA93D0(ctx, base);
	// 825AB730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB734: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AB738: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AB73C: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 825AB740: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AB744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB748: 419A0020  beq cr6, 0x825ab768
	if ctx.cr[6].eq {
	pc = 0x825AB768; continue 'dispatch;
	}
	// 825AB74C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB754: 419A000C  beq cr6, 0x825ab760
	if ctx.cr[6].eq {
	pc = 0x825AB760; continue 'dispatch;
	}
	// 825AB758: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825AB75C: 48000010  b 0x825ab76c
	pc = 0x825AB76C; continue 'dispatch;
	// 825AB760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB764: 4BBE86D5  bl 0x82193e38
	ctx.lr = 0x825AB768;
	sub_82193E38(ctx, base);
	// 825AB768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB76C: 48000C7D  bl 0x825ac3e8
	ctx.lr = 0x825AB770;
	sub_825AC3E8(ctx, base);
	// 825AB770: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB778: 419A01CC  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB77C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AB780: 4BFFFD69  bl 0x825ab4e8
	ctx.lr = 0x825AB784;
	sub_825AB4E8(ctx, base);
	// 825AB784: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB78C: 419A01B8  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB794: 4BBC86A5  bl 0x82173e38
	ctx.lr = 0x825AB798;
	sub_82173E38(ctx, base);
	// 825AB798: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AB79C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 825AB7A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB7A4: 419A00F4  beq cr6, 0x825ab898
	if ctx.cr[6].eq {
	pc = 0x825AB898; continue 'dispatch;
	}
	// 825AB7A8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AB7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB7B0: 419A0024  beq cr6, 0x825ab7d4
	if ctx.cr[6].eq {
	pc = 0x825AB7D4; continue 'dispatch;
	}
	// 825AB7B4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AB7B8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB7BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AB7C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AB7C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB7C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB7CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB7D0: 480000CC  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
	// 825AB7D4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB7D8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AB7DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AB7E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AB7E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB7E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB7EC: 40810054  ble 0x825ab840
	if !ctx.cr[0].gt {
	pc = 0x825AB840; continue 'dispatch;
	}
	// 825AB7F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AB7F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AB7F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AB7FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB800: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AB804: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AB808: 41980008  blt cr6, 0x825ab810
	if ctx.cr[6].lt {
	pc = 0x825AB810; continue 'dispatch;
	}
	// 825AB80C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825AB810: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AB814: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AB818: 419A0014  beq cr6, 0x825ab82c
	if ctx.cr[6].eq {
	pc = 0x825AB82C; continue 'dispatch;
	}
	// 825AB81C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AB820: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AB824: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AB828: 4800000C  b 0x825ab834
	pc = 0x825AB834; continue 'dispatch;
	// 825AB82C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AB830: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AB834: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB838: 4199FFB8  bgt cr6, 0x825ab7f0
	if ctx.cr[6].gt {
	pc = 0x825AB7F0; continue 'dispatch;
	}
	// 825AB83C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB840: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AB844: 419A0040  beq cr6, 0x825ab884
	if ctx.cr[6].eq {
	pc = 0x825AB884; continue 'dispatch;
	}
	// 825AB848: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB84C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AB850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB854: 41990008  bgt cr6, 0x825ab85c
	if ctx.cr[6].gt {
	pc = 0x825AB85C; continue 'dispatch;
	}
	// 825AB858: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825AB85C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB864: 409A0020  bne cr6, 0x825ab884
	if !ctx.cr[6].eq {
	pc = 0x825AB884; continue 'dispatch;
	}
	// 825AB868: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AB86C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AB870: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB874: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB878: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB87C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB880: 4800001C  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
	// 825AB884: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AB888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB88C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB890: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB894: 48000008  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
	// 825AB898: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825AB89C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB8A4: 419A0028  beq cr6, 0x825ab8cc
	if ctx.cr[6].eq {
	pc = 0x825AB8CC; continue 'dispatch;
	}
	// 825AB8A8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825AB8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB8B0: 4BC53D19  bl 0x821ff5c8
	ctx.lr = 0x825AB8B4;
	sub_821FF5C8(ctx, base);
	// 825AB8B4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB8B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB8BC: 409A0010  bne cr6, 0x825ab8cc
	if !ctx.cr[6].eq {
	pc = 0x825AB8CC; continue 'dispatch;
	}
	// 825AB8C0: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825AB8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB8C8: 4BE740E1  bl 0x8241f9a8
	ctx.lr = 0x825AB8CC;
	sub_8241F9A8(ctx, base);
	// 825AB8CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB8D0: 4BBC8569  bl 0x82173e38
	ctx.lr = 0x825AB8D4;
	sub_82173E38(ctx, base);
	// 825AB8D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AB8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AB8DC: 4BFFFCC5  bl 0x825ab5a0
	ctx.lr = 0x825AB8E0;
	sub_825AB5A0(ctx, base);
	// 825AB8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB8E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AB8E8: 419A005C  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB8EC: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 825AB8F0: 394000B0  li r10, 0xb0
	ctx.r[10].s64 = 176;
	// 825AB8F4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AB8F8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825AB8FC: 38E990C0  addi r7, r9, -0x6f40
	ctx.r[7].s64 = ctx.r[9].s64 + -28480;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AB950 size=952
    let mut pc: u32 = 0x825AB950;
    'dispatch: loop {
        match pc {
            0x825AB950 => {
    //   block [0x825AB950..0x825ABD08)
	// 825AB950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB954: 486FDAA5  bl 0x82ca93f8
	ctx.lr = 0x825AB958;
	sub_82CA93D0(ctx, base);
	// 825AB958: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825AB95C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ABD08 size=132
    let mut pc: u32 = 0x825ABD08;
    'dispatch: loop {
        match pc {
            0x825ABD08 => {
    //   block [0x825ABD08..0x825ABD8C)
	// 825ABD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABD0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ABD10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ABD14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ABD18: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ABD90 size=548
    let mut pc: u32 = 0x825ABD90;
    'dispatch: loop {
        match pc {
            0x825ABD90 => {
    //   block [0x825ABD90..0x825ABFB4)
	// 825ABD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABD94: 486FD661  bl 0x82ca93f4
	ctx.lr = 0x825ABD98;
	sub_82CA93D0(ctx, base);
	// 825ABD98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ABD9C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825ABDA0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825ABDA4: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 825ABDA8: 419A0018  beq cr6, 0x825abdc0
	if ctx.cr[6].eq {
	pc = 0x825ABDC0; continue 'dispatch;
	}
	// 825ABDAC: 89770090  lbz r11, 0x90(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(144 as u32) ) } as u64;
	// 825ABDB0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825ABDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ABDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABDBC: 409A0008  bne cr6, 0x825abdc4
	if !ctx.cr[6].eq {
	pc = 0x825ABDC4; continue 'dispatch;
	}
	// 825ABDC0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825ABDC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ABDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABDCC: 419A01E0  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABDD0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 825ABDD4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ABDD8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 825ABDDC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825ABDE0: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825ABDE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ABDE8: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825ABDEC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825ABDF0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ABDF4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ABDF8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABDFC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ABE00: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825ABE04: 4BF0617D  bl 0x824b1f80
	ctx.lr = 0x825ABE08;
	sub_824B1F80(ctx, base);
	// 825ABE08: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825ABE0C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABE10: 40990190  ble cr6, 0x825abfa0
	if !ctx.cr[6].gt {
	pc = 0x825ABFA0; continue 'dispatch;
	}
	// 825ABE14: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 825ABE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE1C: 419A0190  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABE20: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE24: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE28: 7D581671  srawi. r24, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825ABE2C: 40810174  ble 0x825abfa0
	if !ctx.cr[0].gt {
	pc = 0x825ABFA0; continue 'dispatch;
	}
	// 825ABE30: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 825ABE34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE38: 419A0018  beq cr6, 0x825abe50
	if ctx.cr[6].eq {
	pc = 0x825ABE50; continue 'dispatch;
	}
	// 825ABE3C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE40: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE44: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABE48: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABE4C: 41980008  blt cr6, 0x825abe54
	if ctx.cr[6].lt {
	pc = 0x825ABE54; continue 'dispatch;
	}
	// 825ABE50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825ABE54: 7C7A182E  lwzx r3, r26, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABE58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABE5C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825ABE60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825ABE64: 4E800421  bctrl
	ctx.lr = 0x825ABE68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ABE68: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825ABE6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABE70: 409A0030  bne cr6, 0x825abea0
	if !ctx.cr[6].eq {
	pc = 0x825ABEA0; continue 'dispatch;
	}
	// 825ABE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE78: 419A0018  beq cr6, 0x825abe90
	if ctx.cr[6].eq {
	pc = 0x825ABE90; continue 'dispatch;
	}
	// 825ABE7C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE80: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE84: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABE88: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABE8C: 41980008  blt cr6, 0x825abe94
	if ctx.cr[6].lt {
	pc = 0x825ABE94; continue 'dispatch;
	}
	// 825ABE90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825ABE94: 7D7A182E  lwzx r11, r26, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABE98: 83CB00C8  lwz r30, 0xc8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825ABE9C: 4800002C  b 0x825abec8
	pc = 0x825ABEC8; continue 'dispatch;
	// 825ABEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABEA4: 419A0018  beq cr6, 0x825abebc
	if ctx.cr[6].eq {
	pc = 0x825ABEBC; continue 'dispatch;
	}
	// 825ABEA8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABEAC: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABEB0: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABEB4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABEB8: 41980008  blt cr6, 0x825abec0
	if ctx.cr[6].lt {
	pc = 0x825ABEC0; continue 'dispatch;
	}
	// 825ABEBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825ABEC0: 7D7A182E  lwzx r11, r26, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABEC4: 83CB00E4  lwz r30, 0xe4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 825ABEC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825ABECC: 419A00C4  beq cr6, 0x825abf90
	if ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABED0: 897E0044  lbz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825ABED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABED8: 409A00B8  bne cr6, 0x825abf90
	if !ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABEDC: 815E00EC  lwz r10, 0xec(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 825ABEE0: 397E00E8  addi r11, r30, 0xe8
	ctx.r[11].s64 = ctx.r[30].s64 + 232;
	// 825ABEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABEE8: 419A0024  beq cr6, 0x825abf0c
	if ctx.cr[6].eq {
	pc = 0x825ABF0C; continue 'dispatch;
	}
	// 825ABEEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABEF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825ABEF4: 419A000C  beq cr6, 0x825abf00
	if ctx.cr[6].eq {
	pc = 0x825ABF00; continue 'dispatch;
	}
	// 825ABEF8: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ABEFC: 48000014  b 0x825abf10
	pc = 0x825ABF10; continue 'dispatch;
	// 825ABF00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825ABF04: 4BBE7F35  bl 0x82193e38
	ctx.lr = 0x825ABF08;
	sub_82193E38(ctx, base);
	// 825ABF08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABF0C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825ABF10: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 825ABF14: 409A007C  bne cr6, 0x825abf90
	if !ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABF18: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ABF1C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825ABF20: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825ABF24: 4099006C  ble cr6, 0x825abf90
	if !ctx.cr[6].gt {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABF28: 3BBE0074  addi r29, r30, 0x74
	ctx.r[29].s64 = ctx.r[30].s64 + 116;
	// 825ABF2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABF30: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 825ABF34: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825ABF38: 40980028  bge cr6, 0x825abf60
	if !ctx.cr[6].lt {
	pc = 0x825ABF60; continue 'dispatch;
	}
	// 825ABF3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABF40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABF44: 419A001C  beq cr6, 0x825abf60
	if ctx.cr[6].eq {
	pc = 0x825ABF60; continue 'dispatch;
	}
	// 825ABF48: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABF4C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825ABF50: 419A000C  beq cr6, 0x825abf5c
	if ctx.cr[6].eq {
	pc = 0x825ABF5C; continue 'dispatch;
	}
	// 825ABF54: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825ABF58: 409A0008  bne cr6, 0x825abf60
	if !ctx.cr[6].eq {
	pc = 0x825ABF60; continue 'dispatch;
	}
	// 825ABF5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ABF60: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825ABF64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABF68: 419A0014  beq cr6, 0x825abf7c
	if ctx.cr[6].eq {
	pc = 0x825ABF7C; continue 'dispatch;
	}
	// 825ABF6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ABF70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ABF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ABF78: 4BFF7221  bl 0x825a3198
	ctx.lr = 0x825ABF7C;
	sub_825A3198(ctx, base);
	// 825ABF7C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825ABF80: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825ABF84: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825ABF88: 4198FFA4  blt cr6, 0x825abf2c
	if ctx.cr[6].lt {
	pc = 0x825ABF2C; continue 'dispatch;
	}
	// 825ABF8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABF90: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825ABF94: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ABF98: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ABF9C: 4198FE98  blt cr6, 0x825abe34
	if ctx.cr[6].lt {
	pc = 0x825ABE34; continue 'dispatch;
	}
	// 825ABFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABFA4: 419A0008  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABFA8: 4BC6FD91  bl 0x8221bd38
	ctx.lr = 0x825ABFAC;
	sub_8221BD38(ctx, base);
	// 825ABFAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825ABFB0: 486FD494  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ABFB8 size=396
    let mut pc: u32 = 0x825ABFB8;
    'dispatch: loop {
        match pc {
            0x825ABFB8 => {
    //   block [0x825ABFB8..0x825AC144)
	// 825ABFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABFBC: 486FD44D  bl 0x82ca9408
	ctx.lr = 0x825ABFC0;
	sub_82CA93D0(ctx, base);
	// 825ABFC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ABFC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825ABFC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ABFCC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825ABFD0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825ABFD4: 419A0018  beq cr6, 0x825abfec
	if ctx.cr[6].eq {
	pc = 0x825ABFEC; continue 'dispatch;
	}
	// 825ABFD8: 89660090  lbz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 825ABFDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825ABFE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825ABFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABFE8: 409A0008  bne cr6, 0x825abff0
	if !ctx.cr[6].eq {
	pc = 0x825ABFF0; continue 'dispatch;
	}
	// 825ABFEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825ABFF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ABFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABFF8: 419A0144  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825ABFFC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825AC000: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC004: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825AC008: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AC00C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AC010: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825AC014: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC018: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC01C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC020: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC024: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC028: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC02C: 4BF05F55  bl 0x824b1f80
	ctx.lr = 0x825AC030;
	sub_824B1F80(ctx, base);
	// 825AC030: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC034: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC038: 409900F8  ble cr6, 0x825ac130
	if !ctx.cr[6].gt {
	pc = 0x825AC130; continue 'dispatch;
	}
	// 825AC03C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC040: 419A00FC  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825AC044: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC048: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC04C: 7D7D1671  srawi. r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825AC050: 408100E0  ble 0x825ac130
	if !ctx.cr[0].gt {
	pc = 0x825AC130; continue 'dispatch;
	}
	// 825AC054: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825AC058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC05C: 419A0014  beq cr6, 0x825ac070
	if ctx.cr[6].eq {
	pc = 0x825AC070; continue 'dispatch;
	}
	// 825AC060: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC064: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC068: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC06C: 41980008  blt cr6, 0x825ac074
	if ctx.cr[6].lt {
	pc = 0x825AC074; continue 'dispatch;
	}
	// 825AC070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC074: 7C7E182E  lwzx r3, r30, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC07C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825AC080: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC084: 4E800421  bctrl
	ctx.lr = 0x825AC088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC088: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC08C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC090: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC094: 409A002C  bne cr6, 0x825ac0c0
	if !ctx.cr[6].eq {
	pc = 0x825AC0C0; continue 'dispatch;
	}
	// 825AC098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC09C: 419A0014  beq cr6, 0x825ac0b0
	if ctx.cr[6].eq {
	pc = 0x825AC0B0; continue 'dispatch;
	}
	// 825AC0A0: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC0A4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC0A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC0AC: 41980008  blt cr6, 0x825ac0b4
	if ctx.cr[6].lt {
	pc = 0x825AC0B4; continue 'dispatch;
	}
	// 825AC0B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC0B4: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC0B8: 814B00C8  lwz r10, 0xc8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825AC0BC: 48000028  b 0x825ac0e4
	pc = 0x825AC0E4; continue 'dispatch;
	// 825AC0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC0C4: 419A0014  beq cr6, 0x825ac0d8
	if ctx.cr[6].eq {
	pc = 0x825AC0D8; continue 'dispatch;
	}
	// 825AC0C8: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC0CC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC0D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC0D4: 41980008  blt cr6, 0x825ac0dc
	if ctx.cr[6].lt {
	pc = 0x825AC0DC; continue 'dispatch;
	}
	// 825AC0D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC0DC: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC0E0: 814B00E4  lwz r10, 0xe4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 825AC0E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC0E8: 419A0038  beq cr6, 0x825ac120
	if ctx.cr[6].eq {
	pc = 0x825AC120; continue 'dispatch;
	}
	// 825AC0EC: 894A0044  lbz r10, 0x44(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC0F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC0F4: 409A002C  bne cr6, 0x825ac120
	if !ctx.cr[6].eq {
	pc = 0x825AC120; continue 'dispatch;
	}
	// 825AC0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC0FC: 419A0014  beq cr6, 0x825ac110
	if ctx.cr[6].eq {
	pc = 0x825AC110; continue 'dispatch;
	}
	// 825AC100: 7D434850  subf r10, r3, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC104: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825AC108: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC10C: 41980008  blt cr6, 0x825ac114
	if ctx.cr[6].lt {
	pc = 0x825AC114; continue 'dispatch;
	}
	// 825AC110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC114: 9B8B0048  stb r28, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[28].u8 ) };
	// 825AC118: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC11C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC120: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825AC124: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825AC128: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825AC12C: 4198FF2C  blt cr6, 0x825ac058
	if ctx.cr[6].lt {
	pc = 0x825AC058; continue 'dispatch;
	}
	// 825AC130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC134: 419A0008  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825AC138: 4BC6FC01  bl 0x8221bd38
	ctx.lr = 0x825AC13C;
	sub_8221BD38(ctx, base);
	// 825AC13C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AC140: 486FD318  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC148 size=280
    let mut pc: u32 = 0x825AC148;
    'dispatch: loop {
        match pc {
            0x825AC148 => {
    //   block [0x825AC148..0x825AC260)
	// 825AC148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC14C: 486FD2AD  bl 0x82ca93f8
	ctx.lr = 0x825AC150;
	sub_82CA93D0(ctx, base);
	// 825AC150: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825AC154: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC158: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825AC15C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825AC160: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC164: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825AC168: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825AC16C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825AC170: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825AC174: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825AC178: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 825AC17C: 4804EE1D  bl 0x825faf98
	ctx.lr = 0x825AC180;
	sub_825FAF98(ctx, base);
	// 825AC180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC184: 409A0008  bne cr6, 0x825ac18c
	if !ctx.cr[6].eq {
	pc = 0x825AC18C; continue 'dispatch;
	}
	// 825AC188: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825AC18C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 825AC190: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825AC194: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825AC198: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825AC19C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1A0: 48055249  bl 0x826013e8
	ctx.lr = 0x825AC1A4;
	sub_826013E8(ctx, base);
	// 825AC1A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC1A8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825AC1AC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 825AC1B0: 5729063E  clrlwi r9, r25, 0x18
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 825AC1B4: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AC1B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AC1BC: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1C0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AC1C4: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1C8: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1CC: 419A0084  beq cr6, 0x825ac250
	if ctx.cr[6].eq {
	pc = 0x825AC250; continue 'dispatch;
	}
	// 825AC1D0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC1D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AC1D8: 419A0078  beq cr6, 0x825ac250
	if ctx.cr[6].eq {
	pc = 0x825AC250; continue 'dispatch;
	}
	// 825AC1DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC1E0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC1E8: 48339FA9  bl 0x828e6190
	ctx.lr = 0x825AC1EC;
	sub_828E6190(ctx, base);
	// 825AC1EC: D03C0000  stfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC1F4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC1FC: 48339F2D  bl 0x828e6128
	ctx.lr = 0x825AC200;
	sub_828E6128(ctx, base);
	// 825AC200: D03B0000  stfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC204: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC208: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC210: 48339FF1  bl 0x828e6200
	ctx.lr = 0x825AC214;
	sub_828E6200(ctx, base);
	// 825AC214: D03D0000  stfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC218: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 825AC21C: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 825AC220: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 825AC224: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AC228: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825AC22C: 480511FD  bl 0x825fd428
	ctx.lr = 0x825AC230;
	sub_825FD428(ctx, base);
	// 825AC230: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC234: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825AC238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC23C: 419A0018  beq cr6, 0x825ac254
	if ctx.cr[6].eq {
	pc = 0x825AC254; continue 'dispatch;
	}
	// 825AC240: D3FD0000  stfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC244: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC248: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825AC24C: 486FD1FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825AC250: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825AC254: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC258: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825AC25C: 486FD1EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC260 size=132
    let mut pc: u32 = 0x825AC260;
    'dispatch: loop {
        match pc {
            0x825AC260 => {
    //   block [0x825AC260..0x825AC2E4)
	// 825AC260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC26C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC270: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825AC274: 11A1104A  vsubfp v13, v1, v2
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[13].f32[i] = ctx.v[1].f32[i] - ctx.v[2].f32[i];
	}
	// 825AC278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC27C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 825AC280: 392B90F0  addi r9, r11, -0x6f10
	ctx.r[9].s64 = ctx.r[11].s64 + -28432;
	// 825AC284: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AC2E8 size=252
    let mut pc: u32 = 0x825AC2E8;
    'dispatch: loop {
        match pc {
            0x825AC2E8 => {
    //   block [0x825AC2E8..0x825AC3E4)
	// 825AC2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC2F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC2F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825AC2F8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC3E8 size=172
    let mut pc: u32 = 0x825AC3E8;
    'dispatch: loop {
        match pc {
            0x825AC3E8 => {
    //   block [0x825AC3E8..0x825AC494)
	// 825AC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC404: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AC408: 419A0018  beq cr6, 0x825ac420
	if ctx.cr[6].eq {
	pc = 0x825AC420; continue 'dispatch;
	}
	// 825AC40C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AC410: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AC414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC41C: 409A0008  bne cr6, 0x825ac424
	if !ctx.cr[6].eq {
	pc = 0x825AC424; continue 'dispatch;
	}
	// 825AC420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AC424: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC42C: 419A0050  beq cr6, 0x825ac47c
	if ctx.cr[6].eq {
	pc = 0x825AC47C; continue 'dispatch;
	}
	// 825AC430: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AC438: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825AC43C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC440: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC444: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC448: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC44C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC450: 4BC86329  bl 0x82232778
	ctx.lr = 0x825AC454;
	sub_82232778(ctx, base);
	// 825AC454: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AC458: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC45C: 409A0014  bne cr6, 0x825ac470
	if !ctx.cr[6].eq {
	pc = 0x825AC470; continue 'dispatch;
	}
	// 825AC460: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 825AC464: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825AC468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC46C: 419A000C  beq cr6, 0x825ac478
	if ctx.cr[6].eq {
	pc = 0x825AC478; continue 'dispatch;
	}
	// 825AC470: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC474: 48000008  b 0x825ac47c
	pc = 0x825AC47C; continue 'dispatch;
	// 825AC478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC47C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC498 size=444
    let mut pc: u32 = 0x825AC498;
    'dispatch: loop {
        match pc {
            0x825AC498 => {
    //   block [0x825AC498..0x825AC654)
	// 825AC498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC49C: 486FCF69  bl 0x82ca9404
	ctx.lr = 0x825AC4A0;
	sub_82CA93D0(ctx, base);
	// 825AC4A0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825AC4A4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC4A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825AC4AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AC4B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825AC4B4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825AC4B8: C3EB923C  lfs f31, -0x6dc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28100 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AC4BC: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AC4C0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825AC4C4: 40990184  ble cr6, 0x825ac648
	if !ctx.cr[6].gt {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC4C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AC4CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC4D0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825AC4D4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825AC4D8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825AC4DC: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825AC4E0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825AC4E4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC4E8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC4EC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC4F0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC4F4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC4F8: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC4FC: 4BF05A85  bl 0x824b1f80
	ctx.lr = 0x825AC500;
	sub_824B1F80(ctx, base);
	// 825AC500: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC504: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC508: 40990134  ble cr6, 0x825ac63c
	if !ctx.cr[6].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC50C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825AC510: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825AC514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC518: 419A0130  beq cr6, 0x825ac648
	if ctx.cr[6].eq {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC51C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC520: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC524: 7D7C1671  srawi. r28, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825AC528: 40810114  ble 0x825ac63c
	if !ctx.cr[0].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC52C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC530: 419A0014  beq cr6, 0x825ac544
	if ctx.cr[6].eq {
	pc = 0x825AC544; continue 'dispatch;
	}
	// 825AC534: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC538: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC53C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC540: 41980008  blt cr6, 0x825ac548
	if ctx.cr[6].lt {
	pc = 0x825AC548; continue 'dispatch;
	}
	// 825AC544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC548: 7C7F182E  lwzx r3, r31, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC54C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC550: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825AC554: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC558: 4E800421  bctrl
	ctx.lr = 0x825AC55C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC55C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC560: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC564: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC568: 409A002C  bne cr6, 0x825ac594
	if !ctx.cr[6].eq {
	pc = 0x825AC594; continue 'dispatch;
	}
	// 825AC56C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC570: 419A0014  beq cr6, 0x825ac584
	if ctx.cr[6].eq {
	pc = 0x825AC584; continue 'dispatch;
	}
	// 825AC574: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC578: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC57C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC580: 41980008  blt cr6, 0x825ac588
	if ctx.cr[6].lt {
	pc = 0x825AC588; continue 'dispatch;
	}
	// 825AC584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC588: 7D7F182E  lwzx r11, r31, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC58C: 816B00C8  lwz r11, 0xc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825AC590: 48000028  b 0x825ac5b8
	pc = 0x825AC5B8; continue 'dispatch;
	// 825AC594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC598: 419A0014  beq cr6, 0x825ac5ac
	if ctx.cr[6].eq {
	pc = 0x825AC5AC; continue 'dispatch;
	}
	// 825AC59C: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC5A0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC5A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC5A8: 41980008  blt cr6, 0x825ac5b0
	if ctx.cr[6].lt {
	pc = 0x825AC5B0; continue 'dispatch;
	}
	// 825AC5AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AC5B0: 7D7F182E  lwzx r11, r31, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC5B4: 816B00E4  lwz r11, 0xe4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 825AC5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC5BC: 419A0028  beq cr6, 0x825ac5e4
	if ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5C0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825AC5C4: 419A0020  beq cr6, 0x825ac5e4
	if ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5C8: 892B0044  lbz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC5CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AC5D0: 409A0014  bne cr6, 0x825ac5e4
	if !ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5D4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC5D8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AC5DC: 40980008  bge cr6, 0x825ac5e4
	if !ctx.cr[6].lt {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AC5E4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825AC5E8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825AC5EC: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825AC5F0: 4198FF3C  blt cr6, 0x825ac52c
	if ctx.cr[6].lt {
	pc = 0x825AC52C; continue 'dispatch;
	}
	// 825AC5F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825AC5F8: 40990044  ble cr6, 0x825ac63c
	if !ctx.cr[6].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC5FC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825AC600: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825AC604: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825AC608: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825AC60C: 7D3D5850  subf r9, r29, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 825AC610: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 825AC614: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825AC618: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC61C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 825AC620: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825AC624: FD4B0024  fdiv f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 / ctx.f[0].f64;
	// 825AC628: FC005018  frsp f0, f10
	ctx.f[0].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825AC62C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825AC630: 4098000C  bge cr6, 0x825ac63c
	if !ctx.cr[6].lt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC634: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 825AC638: D01B0040  stfs f0, 0x40(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 825AC63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC640: 419A0008  beq cr6, 0x825ac648
	if ctx.cr[6].eq {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC644: 4BC6F6F5  bl 0x8221bd38
	ctx.lr = 0x825AC648;
	sub_8221BD38(ctx, base);
	// 825AC648: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC64C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825AC650: 486FCE04  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC658 size=328
    let mut pc: u32 = 0x825AC658;
    'dispatch: loop {
        match pc {
            0x825AC658 => {
    //   block [0x825AC658..0x825AC7A0)
	// 825AC658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC65C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC670: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC674: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AC678: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC67C: 41980014  blt cr6, 0x825ac690
	if ctx.cr[6].lt {
	pc = 0x825AC690; continue 'dispatch;
	}
	// 825AC680: 4BCEC0B9  bl 0x82298738
	ctx.lr = 0x825AC684;
	sub_82298738(ctx, base);
	// 825AC684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC68C: 409A0008  bne cr6, 0x825ac694
	if !ctx.cr[6].eq {
	pc = 0x825AC694; continue 'dispatch;
	}
	// 825AC690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AC694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC69C: 419A00E8  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC6A4: 4BD1AD85  bl 0x822c7428
	ctx.lr = 0x825AC6A8;
	sub_822C7428(ctx, base);
	// 825AC6A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC6AC: 419A00D8  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC6B0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC6B4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825AC6B8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC6BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC6C0: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 825AC6C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AC6C8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC6CC: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC6D0: 4081005C  ble 0x825ac72c
	if !ctx.cr[0].gt {
	pc = 0x825AC72C; continue 'dispatch;
	}
	// 825AC6D4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AC6D8: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC6DC: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AC6E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC6E4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825AC6E8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC6EC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825AC6F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AC6F4: 41980008  blt cr6, 0x825ac6fc
	if ctx.cr[6].lt {
	pc = 0x825AC6FC; continue 'dispatch;
	}
	// 825AC6F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825AC6FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AC700: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC704: 419A0014  beq cr6, 0x825ac718
	if ctx.cr[6].eq {
	pc = 0x825AC718; continue 'dispatch;
	}
	// 825AC708: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825AC70C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825AC710: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AC714: 4800000C  b 0x825ac720
	pc = 0x825AC720; continue 'dispatch;
	// 825AC718: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825AC71C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825AC720: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC724: 4199FFB0  bgt cr6, 0x825ac6d4
	if ctx.cr[6].gt {
	pc = 0x825AC6D4; continue 'dispatch;
	}
	// 825AC728: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC72C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AC730: 419A0034  beq cr6, 0x825ac764
	if ctx.cr[6].eq {
	pc = 0x825AC764; continue 'dispatch;
	}
	// 825AC734: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC738: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825AC73C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC740: 41990008  bgt cr6, 0x825ac748
	if ctx.cr[6].gt {
	pc = 0x825AC748; continue 'dispatch;
	}
	// 825AC744: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AC748: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC74C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC750: 409A0014  bne cr6, 0x825ac764
	if !ctx.cr[6].eq {
	pc = 0x825AC764; continue 'dispatch;
	}
	// 825AC754: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC758: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AC75C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC760: 48000008  b 0x825ac768
	pc = 0x825AC768; continue 'dispatch;
	// 825AC764: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AC768: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC76C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC770: 419A0014  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC778: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825AC77C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AC780: 48000008  b 0x825ac788
	pc = 0x825AC788; continue 'dispatch;
	// 825AC784: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC788: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC794: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC7A0 size=328
    let mut pc: u32 = 0x825AC7A0;
    'dispatch: loop {
        match pc {
            0x825AC7A0 => {
    //   block [0x825AC7A0..0x825AC8E8)
	// 825AC7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC7B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC7BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AC7C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC7C4: 41980014  blt cr6, 0x825ac7d8
	if ctx.cr[6].lt {
	pc = 0x825AC7D8; continue 'dispatch;
	}
	// 825AC7C8: 4BCEBF71  bl 0x82298738
	ctx.lr = 0x825AC7CC;
	sub_82298738(ctx, base);
	// 825AC7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC7D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC7D4: 409A0008  bne cr6, 0x825ac7dc
	if !ctx.cr[6].eq {
	pc = 0x825AC7DC; continue 'dispatch;
	}
	// 825AC7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AC7DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC7E4: 419A00E8  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC7EC: 4BD1AC3D  bl 0x822c7428
	ctx.lr = 0x825AC7F0;
	sub_822C7428(ctx, base);
	// 825AC7F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC7F4: 419A00D8  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC7F8: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC7FC: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825AC800: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC808: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 825AC80C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AC810: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC814: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC818: 4081005C  ble 0x825ac874
	if !ctx.cr[0].gt {
	pc = 0x825AC874; continue 'dispatch;
	}
	// 825AC81C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AC820: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC824: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AC828: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC82C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825AC830: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC834: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 825AC838: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AC83C: 41980008  blt cr6, 0x825ac844
	if ctx.cr[6].lt {
	pc = 0x825AC844; continue 'dispatch;
	}
	// 825AC840: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825AC844: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AC848: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC84C: 419A0014  beq cr6, 0x825ac860
	if ctx.cr[6].eq {
	pc = 0x825AC860; continue 'dispatch;
	}
	// 825AC850: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825AC854: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825AC858: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AC85C: 4800000C  b 0x825ac868
	pc = 0x825AC868; continue 'dispatch;
	// 825AC860: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825AC864: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825AC868: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC86C: 4199FFB0  bgt cr6, 0x825ac81c
	if ctx.cr[6].gt {
	pc = 0x825AC81C; continue 'dispatch;
	}
	// 825AC870: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC874: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AC878: 419A0034  beq cr6, 0x825ac8ac
	if ctx.cr[6].eq {
	pc = 0x825AC8AC; continue 'dispatch;
	}
	// 825AC87C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC880: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825AC884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC888: 41990008  bgt cr6, 0x825ac890
	if ctx.cr[6].gt {
	pc = 0x825AC890; continue 'dispatch;
	}
	// 825AC88C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AC890: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC898: 409A0014  bne cr6, 0x825ac8ac
	if !ctx.cr[6].eq {
	pc = 0x825AC8AC; continue 'dispatch;
	}
	// 825AC89C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC8A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AC8A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC8A8: 48000008  b 0x825ac8b0
	pc = 0x825AC8B0; continue 'dispatch;
	// 825AC8AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AC8B0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC8B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC8B8: 419A0014  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC8BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC8C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825AC8C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AC8C8: 48000008  b 0x825ac8d0
	pc = 0x825AC8D0; continue 'dispatch;
	// 825AC8CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC8D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC8D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC8D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC8DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC8E8 size=328
    let mut pc: u32 = 0x825AC8E8;
    'dispatch: loop {
        match pc {
            0x825AC8E8 => {
    //   block [0x825AC8E8..0x825ACA30)
	// 825AC8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC8EC: 486FCB21  bl 0x82ca940c
	ctx.lr = 0x825AC8F0;
	sub_82CA93D0(ctx, base);
	// 825AC8F0: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC8F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AC8F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AC8FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825AC900: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC908: 40990120  ble cr6, 0x825aca28
	if !ctx.cr[6].gt {
	pc = 0x825ACA28; continue 'dispatch;
	}
	// 825AC90C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC914: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC918: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC91C: 4E800421  bctrl
	ctx.lr = 0x825AC920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC920: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825AC924: B0610068  sth r3, 0x68(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u16 ) };
	// 825AC928: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825AC92C: 419A0010  beq cr6, 0x825ac93c
	if ctx.cr[6].eq {
	pc = 0x825AC93C; continue 'dispatch;
	}
	// 825AC930: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC934: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 825AC938: 48000010  b 0x825ac948
	pc = 0x825AC948; continue 'dispatch;
	// 825AC93C: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825AC940: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AC944: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825AC948: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825AC94C: 99410070  stb r10, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u8 ) };
	// 825AC950: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825AC954: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825AC958: 486DB689  bl 0x82c87fe0
	ctx.lr = 0x825AC95C;
	sub_82C87FE0(ctx, base);
	// 825AC95C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC960: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AC964: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825AC968: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825AC96C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825AC970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC974: 486DB62D  bl 0x82c87fa0
	ctx.lr = 0x825AC978;
	sub_82C87FA0(ctx, base);
	// 825AC978: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AC97C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC980: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825AC984: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825AC988: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825AC98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC990: 4BD5D1A9  bl 0x82309b38
	ctx.lr = 0x825AC994;
	sub_82309B38(ctx, base);
	// 825AC994: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC998: 889F0004  lbz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC99C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9A4: 80C70088  lwz r6, 0x88(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(136 as u32) ) } as u64;
	// 825AC9A8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825AC9AC: 4E800421  bctrl
	ctx.lr = 0x825AC9B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC9B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9B4: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825AC9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9BC: 4BDA21DD  bl 0x8234eb98
	ctx.lr = 0x825AC9C0;
	sub_8234EB98(ctx, base);
	// 825AC9C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9C4: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825AC9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9CC: 4BDA21CD  bl 0x8234eb98
	ctx.lr = 0x825AC9D0;
	sub_8234EB98(ctx, base);
	// 825AC9D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC9D4: E89F0030  ld r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 825AC9D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9E0: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC9E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC9E8: 4E800421  bctrl
	ctx.lr = 0x825AC9EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC9EC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC9F0: C03F0038  lfs f1, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825AC9F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9FC: 81090064  lwz r8, 0x64(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACA00: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825ACA04: 4E800421  bctrl
	ctx.lr = 0x825ACA08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACA08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ACA0C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825ACA10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ACA14: 4BD88A65  bl 0x82335478
	ctx.lr = 0x825ACA18;
	sub_82335478(ctx, base);
	// 825ACA18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ACA1C: 485EA45D  bl 0x82b96e78
	ctx.lr = 0x825ACA20;
	sub_82B96E78(ctx, base);
	// 825ACA20: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACA24: 485EA455  bl 0x82b96e78
	ctx.lr = 0x825ACA28;
	sub_82B96E78(ctx, base);
	// 825ACA28: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825ACA2C: 486FCA30  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ACA30 size=240
    let mut pc: u32 = 0x825ACA30;
    'dispatch: loop {
        match pc {
            0x825ACA30 => {
    //   block [0x825ACA30..0x825ACB20)
	// 825ACA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACA34: 486FC9D9  bl 0x82ca940c
	ctx.lr = 0x825ACA38;
	sub_82CA93D0(ctx, base);
	// 825ACA38: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACA3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ACA40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825ACA44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825ACA48: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACA50: 409900C8  ble cr6, 0x825acb18
	if !ctx.cr[6].gt {
	pc = 0x825ACB18; continue 'dispatch;
	}
	// 825ACA54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACA5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825ACA64: 4E800421  bctrl
	ctx.lr = 0x825ACA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACA68: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825ACA6C: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 825ACA70: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825ACA74: 419A0010  beq cr6, 0x825aca84
	if ctx.cr[6].eq {
	pc = 0x825ACA84; continue 'dispatch;
	}
	// 825ACA78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825ACA7C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825ACA80: 48000010  b 0x825aca90
	pc = 0x825ACA90; continue 'dispatch;
	// 825ACA84: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825ACA88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ACA8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825ACA90: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825ACA94: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825ACA98: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825ACA9C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACAA0: 486DB541  bl 0x82c87fe0
	ctx.lr = 0x825ACAA4;
	sub_82C87FE0(ctx, base);
	// 825ACAA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825ACAA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825ACAAC: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825ACAB0: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825ACAB4: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825ACAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACABC: 486DB4E5  bl 0x82c87fa0
	ctx.lr = 0x825ACAC0;
	sub_82C87FA0(ctx, base);
	// 825ACAC0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825ACAC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ACAC8: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825ACACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ACAD0: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825ACAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACAD8: 4BD5D061  bl 0x82309b38
	ctx.lr = 0x825ACADC;
	sub_82309B38(ctx, base);
	// 825ACADC: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACAE0: 889F0004  lbz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACAE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ACAE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACAEC: 80C70088  lwz r6, 0x88(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(136 as u32) ) } as u64;
	// 825ACAF0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825ACAF4: 4E800421  bctrl
	ctx.lr = 0x825ACAF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACAF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825ACAFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ACB00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ACB04: 4BD88975  bl 0x82335478
	ctx.lr = 0x825ACB08;
	sub_82335478(ctx, base);
	// 825ACB08: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825ACB0C: 485EA36D  bl 0x82b96e78
	ctx.lr = 0x825ACB10;
	sub_82B96E78(ctx, base);
	// 825ACB10: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACB14: 485EA365  bl 0x82b96e78
	ctx.lr = 0x825ACB18;
	sub_82B96E78(ctx, base);
	// 825ACB18: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825ACB1C: 486FC940  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ACB20 size=528
    let mut pc: u32 = 0x825ACB20;
    'dispatch: loop {
        match pc {
            0x825ACB20 => {
    //   block [0x825ACB20..0x825ACD30)
	// 825ACB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACB24: 486FC8AD  bl 0x82ca93d0
	ctx.lr = 0x825ACB28;
	sub_82CA93D0(ctx, base);
	// 825ACB28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACB2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825ACB34: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 825ACB38: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825ACB3C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825ACB40: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 825ACB44: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB48: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 825ACB4C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 825ACB50: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825ACB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ACB58: 81396C10  lwz r9, 0x6c10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACB5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACB60: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 825ACB64: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 825ACB68: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 825ACB6C: 93F96C10  stw r31, 0x6c10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 825ACB70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACB74: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB78: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 825ACB7C: 82890064  lwz r20, 0x64(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACB80: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825ACB84: 4BCB8EA5  bl 0x82265a28
	ctx.lr = 0x825ACB88;
	sub_82265A28(ctx, base);
	// 825ACB88: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACB8C: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 825ACB90: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACB94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825ACB98: 40990190  ble cr6, 0x825acd28
	if !ctx.cr[6].gt {
	pc = 0x825ACD28; continue 'dispatch;
	}
	// 825ACB9C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ACBA0: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 825ACBA4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825ACBA8: 39EBFFFF  addi r15, r11, -1
	ctx.r[15].s64 = ctx.r[11].s64 + -1;
	// 825ACBAC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825ACBB0: 39CAFFFF  addi r14, r10, -1
	ctx.r[14].s64 = ctx.r[10].s64 + -1;
	// 825ACBB4: 3A0BA2F8  addi r16, r11, -0x5d08
	ctx.r[16].s64 = ctx.r[11].s64 + -23816;
	// 825ACBB8: 39700004  addi r11, r16, 4
	ctx.r[11].s64 = ctx.r[16].s64 + 4;
	// 825ACBBC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACBC0: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACBC4: 7CF5582E  lwzx r7, r21, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ACBC8: 7D5B3E30  sraw r27, r10, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 825ACBCC: 7D0A3E30  sraw r10, r8, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 825ACBD0: 7DEB3E30  sraw r11, r15, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 825ACBD4: 3B0B0001  addi r24, r11, 1
	ctx.r[24].s64 = ctx.r[11].s64 + 1;
	// 825ACBD8: 7DCB3E30  sraw r11, r14, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 825ACBDC: 7E5BC051  subf. r18, r27, r24
	ctx.r[18].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 825ACBE0: 3A2B0001  addi r17, r11, 1
	ctx.r[17].s64 = ctx.r[11].s64 + 1;
	// 825ACBE4: 41820128  beq 0x825acd0c
	if ctx.cr[0].eq {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	// 825ACBE8: 7D6A8851  subf. r11, r10, r17
	ctx.r[11].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ACBEC: 41820120  beq 0x825acd0c
	if ctx.cr[0].eq {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	// 825ACBF0: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825ACBF4: 7F0A8800  cmpw cr6, r10, r17
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACBF8: 40980114  bge cr6, 0x825acd0c
	if !ctx.cr[6].lt {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	// 825ACBFC: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACC00: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ACC04: 81540018  lwz r10, 0x18(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(24 as u32) ) } as u64;
	// 825ACC08: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 825ACC0C: 7D4AAA14  add r10, r10, r21
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 825ACC10: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC14: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC18: 7D69B1D6  mullw r11, r9, r22
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[22].s32 as i64);
	// 825ACC1C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825ACC20: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ACC24: 7F4B5214  add r26, r11, r10
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825ACC28: 409800D0  bge cr6, 0x825accf8
	if !ctx.cr[6].lt {
	pc = 0x825ACCF8; continue 'dispatch;
	}
	// 825ACC2C: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 825ACC30: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC34: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACC38: 419A00B4  beq cr6, 0x825accec
	if ctx.cr[6].eq {
	pc = 0x825ACCEC; continue 'dispatch;
	}
	// 825ACC3C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC40: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ACC44: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825ACC48: 40980098  bge cr6, 0x825acce0
	if !ctx.cr[6].lt {
	pc = 0x825ACCE0; continue 'dispatch;
	}
	// 825ACC4C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 825ACC50: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACC5C: 4BC56985  bl 0x822035e0
	ctx.lr = 0x825ACC60;
	sub_822035E0(ctx, base);
	// 825ACC60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC68: 419A0074  beq cr6, 0x825accdc
	if ctx.cr[6].eq {
	pc = 0x825ACCDC; continue 'dispatch;
	}
	// 825ACC6C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACC74: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC78: 4BC526B9  bl 0x821ff330
	ctx.lr = 0x825ACC7C;
	sub_821FF330(ctx, base);
	// 825ACC7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC84: 419A0038  beq cr6, 0x825accbc
	if ctx.cr[6].eq {
	pc = 0x825ACCBC; continue 'dispatch;
	}
	// 825ACC88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACC8C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC90: 4BFF6D29  bl 0x825a39b8
	ctx.lr = 0x825ACC94;
	sub_825A39B8(ctx, base);
	// 825ACC94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC9C: 419A0020  beq cr6, 0x825accbc
	if ctx.cr[6].eq {
	pc = 0x825ACCBC; continue 'dispatch;
	}
	// 825ACCA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACCA4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACCA8: 4BF64091  bl 0x82510d38
	ctx.lr = 0x825ACCAC;
	sub_82510D38(ctx, base);
	// 825ACCAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACCB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACCB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ACCB8: 409A0008  bne cr6, 0x825accc0
	if !ctx.cr[6].eq {
	pc = 0x825ACCC0; continue 'dispatch;
	}
	// 825ACCBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ACCC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ACCC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACCC8: 419A0014  beq cr6, 0x825accdc
	if ctx.cr[6].eq {
	pc = 0x825ACCDC; continue 'dispatch;
	}
	// 825ACCCC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825ACCD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ACCD4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACCD8: 4859CA79  bl 0x82b49750
	ctx.lr = 0x825ACCDC;
	sub_82B49750(ctx, base);
	// 825ACCDC: 83F96C10  lwz r31, 0x6c10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACCE0: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACCE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACCE8: 409AFF54  bne cr6, 0x825acc3c
	if !ctx.cr[6].eq {
	pc = 0x825ACC3C; continue 'dispatch;
	}
	// 825ACCEC: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 825ACCF0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ACCF4: 4082FF3C  bne 0x825acc30
	if !ctx.cr[0].eq {
	pc = 0x825ACC30; continue 'dispatch;
	}
	// 825ACCF8: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825ACCFC: 7F168800  cmpw cr6, r22, r17
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACD00: 4198FEFC  blt cr6, 0x825acbfc
	if ctx.cr[6].lt {
	pc = 0x825ACBFC; continue 'dispatch;
	}
	// 825ACD04: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACD08: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACD0C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ACD10: 3A730014  addi r19, r19, 0x14
	ctx.r[19].s64 = ctx.r[19].s64 + 20;
	// 825ACD14: 3AB50010  addi r21, r21, 0x10
	ctx.r[21].s64 = ctx.r[21].s64 + 16;
	// 825ACD18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACD1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ACD20: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825ACD24: 4198FE94  blt cr6, 0x825acbb8
	if ctx.cr[6].lt {
	pc = 0x825ACBB8; continue 'dispatch;
	}
	// 825ACD28: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825ACD2C: 486FC6F4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ACD30 size=552
    let mut pc: u32 = 0x825ACD30;
    'dispatch: loop {
        match pc {
            0x825ACD30 => {
    //   block [0x825ACD30..0x825ACF58)
	// 825ACD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACD34: 486FC69D  bl 0x82ca93d0
	ctx.lr = 0x825ACD38;
	sub_82CA93D0(ctx, base);
	// 825ACD38: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACD3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD40: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825ACD44: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 825ACD48: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825ACD4C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825ACD50: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 825ACD54: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD58: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 825ACD5C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 825ACD60: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825ACD64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ACD68: 81396C10  lwz r9, 0x6c10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACD6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACD70: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 825ACD74: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 825ACD78: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 825ACD7C: 93F96C10  stw r31, 0x6c10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 825ACD80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACD84: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD88: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 825ACD8C: 82890064  lwz r20, 0x64(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACD90: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825ACD94: 4BCB8C95  bl 0x82265a28
	ctx.lr = 0x825ACD98;
	sub_82265A28(ctx, base);
	// 825ACD98: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACD9C: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 825ACDA0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACDA4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825ACDA8: 409901A8  ble cr6, 0x825acf50
	if !ctx.cr[6].gt {
	pc = 0x825ACF50; continue 'dispatch;
	}
	// 825ACDAC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ACDB0: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 825ACDB4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825ACDB8: 39EBFFFF  addi r15, r11, -1
	ctx.r[15].s64 = ctx.r[11].s64 + -1;
	// 825ACDBC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825ACDC0: 39CAFFFF  addi r14, r10, -1
	ctx.r[14].s64 = ctx.r[10].s64 + -1;
	// 825ACDC4: 3A0BA2F8  addi r16, r11, -0x5d08
	ctx.r[16].s64 = ctx.r[11].s64 + -23816;
	// 825ACDC8: 39700004  addi r11, r16, 4
	ctx.r[11].s64 = ctx.r[16].s64 + 4;
	// 825ACDCC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACDD0: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACDD4: 7CF5582E  lwzx r7, r21, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ACDD8: 7D5B3E30  sraw r27, r10, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 825ACDDC: 7D0A3E30  sraw r10, r8, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 825ACDE0: 7DEB3E30  sraw r11, r15, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 825ACDE4: 3B0B0001  addi r24, r11, 1
	ctx.r[24].s64 = ctx.r[11].s64 + 1;
	// 825ACDE8: 7DCB3E30  sraw r11, r14, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 825ACDEC: 7E5BC051  subf. r18, r27, r24
	ctx.r[18].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 825ACDF0: 3A2B0001  addi r17, r11, 1
	ctx.r[17].s64 = ctx.r[11].s64 + 1;
	// 825ACDF4: 41820140  beq 0x825acf34
	if ctx.cr[0].eq {
	pc = 0x825ACF34; continue 'dispatch;
	}
	// 825ACDF8: 7D6A8851  subf. r11, r10, r17
	ctx.r[11].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ACDFC: 41820138  beq 0x825acf34
	if ctx.cr[0].eq {
	pc = 0x825ACF34; continue 'dispatch;
	}
	// 825ACE00: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825ACE04: 7F0A8800  cmpw cr6, r10, r17
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACE08: 4098012C  bge cr6, 0x825acf34
	if !ctx.cr[6].lt {
	pc = 0x825ACF34; continue 'dispatch;
	}
	// 825ACE0C: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACE10: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ACE14: 81540018  lwz r10, 0x18(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(24 as u32) ) } as u64;
	// 825ACE18: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 825ACE1C: 7D4AAA14  add r10, r10, r21
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 825ACE20: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE24: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE28: 7D69B1D6  mullw r11, r9, r22
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[22].s32 as i64);
	// 825ACE2C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825ACE30: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ACE34: 7F4B5214  add r26, r11, r10
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825ACE38: 409800E8  bge cr6, 0x825acf20
	if !ctx.cr[6].lt {
	pc = 0x825ACF20; continue 'dispatch;
	}
	// 825ACE3C: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 825ACE40: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACE48: 419A00CC  beq cr6, 0x825acf14
	if ctx.cr[6].eq {
	pc = 0x825ACF14; continue 'dispatch;
	}
	// 825ACE4C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE50: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ACE54: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825ACE58: 409800B0  bge cr6, 0x825acf08
	if !ctx.cr[6].lt {
	pc = 0x825ACF08; continue 'dispatch;
	}
	// 825ACE5C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 825ACE60: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE64: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACE6C: 4BC56775  bl 0x822035e0
	ctx.lr = 0x825ACE70;
	sub_822035E0(ctx, base);
	// 825ACE70: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACE78: 419A008C  beq cr6, 0x825acf04
	if ctx.cr[6].eq {
	pc = 0x825ACF04; continue 'dispatch;
	}
	// 825ACE7C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE80: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE88: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825ACE8C: 419A0058  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACE90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACE94: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE98: 4BC52499  bl 0x821ff330
	ctx.lr = 0x825ACE9C;
	sub_821FF330(ctx, base);
	// 825ACE9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEA4: 419A0040  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACEA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACEAC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACEB0: 4BC53239  bl 0x822000e8
	ctx.lr = 0x825ACEB4;
	sub_822000E8(ctx, base);
	// 825ACEB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEBC: 419A0028  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACEC0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ACEC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACEC8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACECC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACED0: 48052C09  bl 0x825ffad8
	ctx.lr = 0x825ACED4;
	sub_825FFAD8(ctx, base);
	// 825ACED4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACED8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ACEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ACEE0: 409A0008  bne cr6, 0x825acee8
	if !ctx.cr[6].eq {
	pc = 0x825ACEE8; continue 'dispatch;
	}
	// 825ACEE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ACEE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ACEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEF0: 419A0014  beq cr6, 0x825acf04
	if ctx.cr[6].eq {
	pc = 0x825ACF04; continue 'dispatch;
	}
	// 825ACEF4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825ACEF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ACEFC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACF00: 4859C851  bl 0x82b49750
	ctx.lr = 0x825ACF04;
	sub_82B49750(ctx, base);
	// 825ACF04: 83F96C10  lwz r31, 0x6c10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACF08: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACF0C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACF10: 409AFF3C  bne cr6, 0x825ace4c
	if !ctx.cr[6].eq {
	pc = 0x825ACE4C; continue 'dispatch;
	}
	// 825ACF14: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 825ACF18: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ACF1C: 4082FF24  bne 0x825ace40
	if !ctx.cr[0].eq {
	pc = 0x825ACE40; continue 'dispatch;
	}
	// 825ACF20: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825ACF24: 7F168800  cmpw cr6, r22, r17
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACF28: 4198FEE4  blt cr6, 0x825ace0c
	if ctx.cr[6].lt {
	pc = 0x825ACE0C; continue 'dispatch;
	}
	// 825ACF2C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACF30: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACF34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ACF38: 3A730014  addi r19, r19, 0x14
	ctx.r[19].s64 = ctx.r[19].s64 + 20;
	// 825ACF3C: 3AB50010  addi r21, r21, 0x10
	ctx.r[21].s64 = ctx.r[21].s64 + 16;
	// 825ACF40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACF44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ACF48: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825ACF4C: 4198FE7C  blt cr6, 0x825acdc8
	if ctx.cr[6].lt {
	pc = 0x825ACDC8; continue 'dispatch;
	}
	// 825ACF50: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825ACF54: 486FC4CC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ACF58 size=296
    let mut pc: u32 = 0x825ACF58;
    'dispatch: loop {
        match pc {
            0x825ACF58 => {
    //   block [0x825ACF58..0x825AD080)
	// 825ACF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ACF60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ACF64: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825ACF68: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825ACF6C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACF70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ACF74: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 825ACF78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ACF7C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 825ACF80: 4BC07509  bl 0x821b4488
	ctx.lr = 0x825ACF84;
	sub_821B4488(ctx, base);
	// 825ACF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ACF88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825ACF8C: 4BFF1715  bl 0x8259e6a0
	ctx.lr = 0x825ACF90;
	sub_8259E6A0(ctx, base);
	// 825ACF90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACF94: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825ACF98: 4BF10C71  bl 0x824bdc08
	ctx.lr = 0x825ACF9C;
	sub_824BDC08(ctx, base);
	// 825ACF9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825ACFA0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825ACFA4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825ACFA8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825ACFAC: 38E99060  addi r7, r9, -0x6fa0
	ctx.r[7].s64 = ctx.r[9].s64 + -28576;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD080 size=1176
    let mut pc: u32 = 0x825AD080;
    'dispatch: loop {
        match pc {
            0x825AD080 => {
    //   block [0x825AD080..0x825AD518)
	// 825AD080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD084: 486FC369  bl 0x82ca93ec
	ctx.lr = 0x825AD088;
	sub_82CA93D0(ctx, base);
	// 825AD088: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD08C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AD090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD094: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825AD098: 392B20B4  addi r9, r11, 0x20b4
	ctx.r[9].s64 = ctx.r[11].s64 + 8372;
	// 825AD09C: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 825AD0A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AD0A4: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825AD0A8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD0AC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825AD0B0: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825AD0B4: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD0B8: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825AD0BC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825AD0C0: 4BC677D9  bl 0x82214898
	ctx.lr = 0x825AD0C4;
	sub_82214898(ctx, base);
	// 825AD0C4: 80F60000  lwz r7, 0(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD0C8: 90FE0010  stw r7, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825AD0CC: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD0D4: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AD0D8: 419A0020  beq cr6, 0x825ad0f8
	if ctx.cr[6].eq {
	pc = 0x825AD0F8; continue 'dispatch;
	}
	// 825AD0DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD0E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD0E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD0E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD0EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD0F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD0F4: 4082FFE8  bne 0x825ad0dc
	if !ctx.cr[0].eq {
	pc = 0x825AD0DC; continue 'dispatch;
	}
	// 825AD0F8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AD0FC: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 825AD100: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 825AD104: 3BBE0018  addi r29, r30, 0x18
	ctx.r[29].s64 = ctx.r[30].s64 + 24;
	// 825AD108: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 825AD10C: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 825AD110: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 825AD114: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 825AD118: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 825AD11C: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 825AD120: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD124: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD128: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD12C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD130: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD134: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD138: 4082FFE8  bne 0x825ad120
	if !ctx.cr[0].eq {
	pc = 0x825AD120; continue 'dispatch;
	}
	// 825AD13C: 93FE002C  stw r31, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 825AD140: 3B7E002C  addi r27, r30, 0x2c
	ctx.r[27].s64 = ctx.r[30].s64 + 44;
	// 825AD144: 93FE0030  stw r31, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 825AD148: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 825AD14C: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 825AD150: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 825AD154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD158: 7CC02028  lwarx r6, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 825AD15C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825AD160: 7CC0212D  stwcx. r6, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD164: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD168: 4082FFE8  bne 0x825ad150
	if !ctx.cr[0].eq {
	pc = 0x825AD150; continue 'dispatch;
	}
	// 825AD16C: 93FE0038  stw r31, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 825AD170: 3B5E0038  addi r26, r30, 0x38
	ctx.r[26].s64 = ctx.r[30].s64 + 56;
	// 825AD174: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 825AD178: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825AD17C: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 825AD180: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 825AD184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD188: 7C605028  lwarx r3, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 825AD18C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 825AD190: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD194: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD198: 4082FFE8  bne 0x825ad180
	if !ctx.cr[0].eq {
	pc = 0x825AD180; continue 'dispatch;
	}
	// 825AD19C: 93FE0044  stw r31, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[31].u32 ) };
	// 825AD1A0: 3B3E0044  addi r25, r30, 0x44
	ctx.r[25].s64 = ctx.r[30].s64 + 68;
	// 825AD1A4: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 825AD1A8: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 825AD1AC: 93FE004C  stw r31, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 825AD1B0: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825AD1B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1B8: 7D203028  lwarx r9, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825AD1BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825AD1C0: 7D20312D  stwcx. r9, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD1C4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1C8: 4082FFE8  bne 0x825ad1b0
	if !ctx.cr[0].eq {
	pc = 0x825AD1B0; continue 'dispatch;
	}
	// 825AD1CC: 93FE0050  stw r31, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AD1D0: 3B1E0050  addi r24, r30, 0x50
	ctx.r[24].s64 = ctx.r[30].s64 + 80;
	// 825AD1D4: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825AD1D8: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 825AD1DC: 93FE0058  stw r31, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825AD1E0: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 825AD1E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1E8: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 825AD1EC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 825AD1F0: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD1F4: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1F8: 4082FFE8  bne 0x825ad1e0
	if !ctx.cr[0].eq {
	pc = 0x825AD1E0; continue 'dispatch;
	}
	// 825AD1FC: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AD200: 3AFE005C  addi r23, r30, 0x5c
	ctx.r[23].s64 = ctx.r[30].s64 + 92;
	// 825AD204: 93FE0060  stw r31, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825AD208: 93FE0064  stw r31, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825AD20C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825AD210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD214: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825AD218: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825AD21C: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD220: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD224: 4082FFE8  bne 0x825ad20c
	if !ctx.cr[0].eq {
	pc = 0x825AD20C; continue 'dispatch;
	}
	// 825AD228: 9BFE0068  stb r31, 0x68(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[31].u8 ) };
	// 825AD22C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD230: 9BFE0069  stb r31, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[31].u8 ) };
	// 825AD234: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 825AD238: 9BFE006A  stb r31, 0x6a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(106 as u32), ctx.r[31].u8 ) };
	// 825AD23C: 38C94F68  addi r6, r9, 0x4f68
	ctx.r[6].s64 = ctx.r[9].s64 + 20328;
	// 825AD240: 9BFE006B  stb r31, 0x6b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(107 as u32), ctx.r[31].u8 ) };
	// 825AD244: 38A8F19C  addi r5, r8, -0xe64
	ctx.r[5].s64 = ctx.r[8].s64 + -3684;
	// 825AD248: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825AD24C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825AD250: 4BE00289  bl 0x823ad4d8
	ctx.lr = 0x825AD254;
	sub_823AD4D8(ctx, base);
	// 825AD254: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AD258: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AD25C: 419A0298  beq cr6, 0x825ad4f4
	if ctx.cr[6].eq {
	pc = 0x825AD4F4; continue 'dispatch;
	}
	// 825AD260: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825AD264: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825AD268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AD26C: 48001735  bl 0x825ae9a0
	ctx.lr = 0x825AD270;
	sub_825AE9A0(ctx, base);
	// 825AD270: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD274: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AD278: 4BBCE121  bl 0x8217b398
	ctx.lr = 0x825AD27C;
	sub_8217B398(ctx, base);
	// 825AD27C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AD280: 4BC0A899  bl 0x821b7b18
	ctx.lr = 0x825AD284;
	sub_821B7B18(ctx, base);
	// 825AD284: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD28C: 419A0008  beq cr6, 0x825ad294
	if ctx.cr[6].eq {
	pc = 0x825AD294; continue 'dispatch;
	}
	// 825AD290: 9BEB000C  stb r31, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u8 ) };
	// 825AD294: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD29C: 419A0080  beq cr6, 0x825ad31c
	if ctx.cr[6].eq {
	pc = 0x825AD31C; continue 'dispatch;
	}
	// 825AD2A0: 82AB0000  lwz r21, 0(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD2A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AD2A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD2AC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2B0: 4BC7BE59  bl 0x82229108
	ctx.lr = 0x825AD2B4;
	sub_82229108(ctx, base);
	// 825AD2B4: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AD2B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825AD2BC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2C0: 3BEBD7D8  addi r31, r11, -0x2828
	ctx.r[31].s64 = ctx.r[11].s64 + -10280;
	// 825AD2C4: 4BC7A5BD  bl 0x82227880
	ctx.lr = 0x825AD2C8;
	sub_82227880(ctx, base);
	// 825AD2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AD2CC: 3D408245  lis r10, -0x7dbb
	ctx.r[10].s64 = -2109407232;
	// 825AD2D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AD2D4: 388A1240  addi r4, r10, 0x1240
	ctx.r[4].s64 = ctx.r[10].s64 + 4672;
	// 825AD2D8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2DC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825AD2E0: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825AD2E4: 4BBED79D  bl 0x8219aa80
	ctx.lr = 0x825AD2E8;
	sub_8219AA80(ctx, base);
	// 825AD2E8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD2EC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825AD2F0: 3BE94F78  addi r31, r9, 0x4f78
	ctx.r[31].s64 = ctx.r[9].s64 + 20344;
	// 825AD2F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AD2F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AD2FC: 4BE21125  bl 0x823ce420
	ctx.lr = 0x825AD300;
	sub_823CE420(ctx, base);
	// 825AD300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AD304: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825AD308: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD30C: 484773BD  bl 0x82a246c8
	ctx.lr = 0x825AD310;
	sub_82A246C8(ctx, base);
	// 825AD310: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AD314: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825AD318: 91150008  stw r8, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825AD31C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD320: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD324: 38CB4F84  addi r6, r11, 0x4f84
	ctx.r[6].s64 = ctx.r[11].s64 + 20356;
	// 825AD328: 38AA4FA0  addi r5, r10, 0x4fa0
	ctx.r[5].s64 = ctx.r[10].s64 + 20384;
	// 825AD32C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD334: 4BEB606D  bl 0x824633a0
	ctx.lr = 0x825AD338;
	sub_824633A0(ctx, base);
	// 825AD338: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AD33C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AD340: 419A0014  beq cr6, 0x825ad354
	if ctx.cr[6].eq {
	pc = 0x825AD354; continue 'dispatch;
	}
	// 825AD344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD348: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD34C: 480017D5  bl 0x825aeb20
	ctx.lr = 0x825AD350;
	sub_825AEB20(ctx, base);
	// 825AD350: 987E006A  stb r3, 0x6a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(106 as u32), ctx.r[3].u8 ) };
	// 825AD354: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD358: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD35C: 38CB4FB0  addi r6, r11, 0x4fb0
	ctx.r[6].s64 = ctx.r[11].s64 + 20400;
	// 825AD360: 38AA4FC4  addi r5, r10, 0x4fc4
	ctx.r[5].s64 = ctx.r[10].s64 + 20420;
	// 825AD364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD368: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD36C: 4BEB6035  bl 0x824633a0
	ctx.lr = 0x825AD370;
	sub_824633A0(ctx, base);
	// 825AD370: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD374: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD378: 4BBED3E1  bl 0x8219a758
	ctx.lr = 0x825AD37C;
	sub_8219A758(ctx, base);
	// 825AD37C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD380: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825AD384: 38C94FCC  addi r6, r9, 0x4fcc
	ctx.r[6].s64 = ctx.r[9].s64 + 20428;
	// 825AD388: 38A84FE4  addi r5, r8, 0x4fe4
	ctx.r[5].s64 = ctx.r[8].s64 + 20452;
	// 825AD38C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD390: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825AD394: 4BEB600D  bl 0x824633a0
	ctx.lr = 0x825AD398;
	sub_824633A0(ctx, base);
	// 825AD398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD39C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AD3A0: 4BEB0691  bl 0x8245da30
	ctx.lr = 0x825AD3A4;
	sub_8245DA30(ctx, base);
	// 825AD3A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825AD3A8: 4BC67A31  bl 0x82214dd8
	ctx.lr = 0x825AD3AC;
	sub_82214DD8(ctx, base);
	// 825AD3AC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825AD3B0: 4BC0A769  bl 0x821b7b18
	ctx.lr = 0x825AD3B4;
	sub_821B7B18(ctx, base);
	// 825AD3B4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AD3B8: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 825AD3BC: 38C74FF0  addi r6, r7, 0x4ff0
	ctx.r[6].s64 = ctx.r[7].s64 + 20464;
	// 825AD3C0: 38A5A1B4  addi r5, r5, -0x5e4c
	ctx.r[5].s64 = ctx.r[5].s64 + -24140;
	// 825AD3C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD3C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825AD3CC: 4BEB5FD5  bl 0x824633a0
	ctx.lr = 0x825AD3D0;
	sub_824633A0(ctx, base);
	// 825AD3D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD3D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825AD3D8: 4BEB0659  bl 0x8245da30
	ctx.lr = 0x825AD3DC;
	sub_8245DA30(ctx, base);
	// 825AD3DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825AD3E0: 4BC679F9  bl 0x82214dd8
	ctx.lr = 0x825AD3E4;
	sub_82214DD8(ctx, base);
	// 825AD3E4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825AD3E8: 4BC0A731  bl 0x821b7b18
	ctx.lr = 0x825AD3EC;
	sub_821B7B18(ctx, base);
	// 825AD3EC: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AD3F0: 3C60820C  lis r3, -0x7df4
	ctx.r[3].s64 = -2113142784;
	// 825AD3F4: 38C45008  addi r6, r4, 0x5008
	ctx.r[6].s64 = ctx.r[4].s64 + 20488;
	// 825AD3F8: 38A35020  addi r5, r3, 0x5020
	ctx.r[5].s64 = ctx.r[3].s64 + 20512;
	// 825AD3FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD400: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825AD404: 4BEB5F9D  bl 0x824633a0
	ctx.lr = 0x825AD408;
	sub_824633A0(ctx, base);
	// 825AD408: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD40C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825AD410: 4BEB0621  bl 0x8245da30
	ctx.lr = 0x825AD414;
	sub_8245DA30(ctx, base);
	// 825AD414: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825AD418: 4BC679C1  bl 0x82214dd8
	ctx.lr = 0x825AD41C;
	sub_82214DD8(ctx, base);
	// 825AD41C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825AD420: 4BC0A6F9  bl 0x821b7b18
	ctx.lr = 0x825AD424;
	sub_821B7B18(ctx, base);
	// 825AD424: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD428: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD42C: 38CB502C  addi r6, r11, 0x502c
	ctx.r[6].s64 = ctx.r[11].s64 + 20524;
	// 825AD430: 38AA5040  addi r5, r10, 0x5040
	ctx.r[5].s64 = ctx.r[10].s64 + 20544;
	// 825AD434: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD438: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825AD43C: 4BEB5F65  bl 0x824633a0
	ctx.lr = 0x825AD440;
	sub_824633A0(ctx, base);
	// 825AD440: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD444: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825AD448: 4BEB05E9  bl 0x8245da30
	ctx.lr = 0x825AD44C;
	sub_8245DA30(ctx, base);
	// 825AD44C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825AD450: 4BC67989  bl 0x82214dd8
	ctx.lr = 0x825AD454;
	sub_82214DD8(ctx, base);
	// 825AD454: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825AD458: 4BC0A6C1  bl 0x821b7b18
	ctx.lr = 0x825AD45C;
	sub_821B7B18(ctx, base);
	// 825AD45C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD460: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825AD464: 38C95048  addi r6, r9, 0x5048
	ctx.r[6].s64 = ctx.r[9].s64 + 20552;
	// 825AD468: 38A85068  addi r5, r8, 0x5068
	ctx.r[5].s64 = ctx.r[8].s64 + 20584;
	// 825AD46C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD470: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825AD474: 4BEB5F2D  bl 0x824633a0
	ctx.lr = 0x825AD478;
	sub_824633A0(ctx, base);
	// 825AD478: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD47C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825AD480: 4BEB05B1  bl 0x8245da30
	ctx.lr = 0x825AD484;
	sub_8245DA30(ctx, base);
	// 825AD484: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825AD488: 4BC67951  bl 0x82214dd8
	ctx.lr = 0x825AD48C;
	sub_82214DD8(ctx, base);
	// 825AD48C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825AD490: 4BC0A689  bl 0x821b7b18
	ctx.lr = 0x825AD494;
	sub_821B7B18(ctx, base);
	// 825AD494: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AD498: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 825AD49C: 38C7507C  addi r6, r7, 0x507c
	ctx.r[6].s64 = ctx.r[7].s64 + 20604;
	// 825AD4A0: 38A57B08  addi r5, r5, 0x7b08
	ctx.r[5].s64 = ctx.r[5].s64 + 31496;
	// 825AD4A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD4A8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825AD4AC: 4BEB5EF5  bl 0x824633a0
	ctx.lr = 0x825AD4B0;
	sub_824633A0(ctx, base);
	// 825AD4B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD4B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825AD4B8: 4BEB0579  bl 0x8245da30
	ctx.lr = 0x825AD4BC;
	sub_8245DA30(ctx, base);
	// 825AD4BC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825AD4C0: 4BC67919  bl 0x82214dd8
	ctx.lr = 0x825AD4C4;
	sub_82214DD8(ctx, base);
	// 825AD4C4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825AD4C8: 4BC0A651  bl 0x821b7b18
	ctx.lr = 0x825AD4CC;
	sub_821B7B18(ctx, base);
	// 825AD4CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AD4D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AD4D4: 989E006B  stb r4, 0x6b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(107 as u32), ctx.r[4].u8 ) };
	// 825AD4D8: 4BC67901  bl 0x82214dd8
	ctx.lr = 0x825AD4DC;
	sub_82214DD8(ctx, base);
	// 825AD4DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD4E0: 4BC0A639  bl 0x821b7b18
	ctx.lr = 0x825AD4E4;
	sub_821B7B18(ctx, base);
	// 825AD4E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AD4E8: 4BC678F1  bl 0x82214dd8
	ctx.lr = 0x825AD4EC;
	sub_82214DD8(ctx, base);
	// 825AD4EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD4F0: 4BC0A629  bl 0x821b7b18
	ctx.lr = 0x825AD4F4;
	sub_821B7B18(ctx, base);
	// 825AD4F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825AD4F8: 4BC678E1  bl 0x82214dd8
	ctx.lr = 0x825AD4FC;
	sub_82214DD8(ctx, base);
	// 825AD4FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825AD500: 4BC0A619  bl 0x821b7b18
	ctx.lr = 0x825AD504;
	sub_821B7B18(ctx, base);
	// 825AD504: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825AD508: 4BC0A611  bl 0x821b7b18
	ctx.lr = 0x825AD50C;
	sub_821B7B18(ctx, base);
	// 825AD50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD510: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825AD514: 486FBF28  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD518 size=80
    let mut pc: u32 = 0x825AD518;
    'dispatch: loop {
        match pc {
            0x825AD518 => {
    //   block [0x825AD518..0x825AD568)
	// 825AD518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AD520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AD524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AD528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD530: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AD534: 4800018D  bl 0x825ad6c0
	ctx.lr = 0x825AD538;
	sub_825AD6C0(ctx, base);
	// 825AD538: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825AD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AD540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD544: 419A000C  beq cr6, 0x825ad550
	if ctx.cr[6].eq {
	pc = 0x825AD550; continue 'dispatch;
	}
	// 825AD548: 4BC6E7F1  bl 0x8221bd38
	ctx.lr = 0x825AD54C;
	sub_8221BD38(ctx, base);
	// 825AD54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AD550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AD554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AD558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AD55C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AD560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AD564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AD568 size=340
    let mut pc: u32 = 0x825AD568;
    'dispatch: loop {
        match pc {
            0x825AD568 => {
    //   block [0x825AD568..0x825AD6BC)
	// 825AD568: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD56C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825AD570: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825AD574: 38EB20B4  addi r7, r11, 0x20b4
	ctx.r[7].s64 = ctx.r[11].s64 + 8372;
	// 825AD578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AD57C: 38C80B7C  addi r6, r8, 0xb7c
	ctx.r[6].s64 = ctx.r[8].s64 + 2940;
	// 825AD580: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AD584: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 825AD588: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825AD58C: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825AD590: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825AD594: 38857088  addi r4, r5, 0x7088
	ctx.r[4].s64 = ctx.r[5].s64 + 28808;
	// 825AD598: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AD59C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825AD5A0: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD5A4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825AD5A8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825AD5AC: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825AD5B0: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825AD5B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD5B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5BC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD5C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD5C4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD5C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5CC: 4082FFE8  bne 0x825ad5b4
	if !ctx.cr[0].eq {
	pc = 0x825AD5B4; continue 'dispatch;
	}
	// 825AD5D0: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825AD5D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825AD5D8: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825AD5DC: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825AD5E0: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD5E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5E8: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD5EC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD5F0: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD5F4: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5F8: 4082FFE8  bne 0x825ad5e0
	if !ctx.cr[0].eq {
	pc = 0x825AD5E0; continue 'dispatch;
	}
	// 825AD5FC: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825AD600: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD604: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 825AD608: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825AD60C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD610: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD614: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD618: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD61C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD620: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD624: 4082FFE8  bne 0x825ad60c
	if !ctx.cr[0].eq {
	pc = 0x825AD60C; continue 'dispatch;
	}
	// 825AD628: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 825AD62C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825AD630: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 825AD634: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 825AD638: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD63C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD640: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD644: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD648: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD64C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD650: 4082FFE8  bne 0x825ad638
	if !ctx.cr[0].eq {
	pc = 0x825AD638; continue 'dispatch;
	}
	// 825AD654: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AD658: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD65C: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825AD660: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825AD664: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD66C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD670: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD674: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD678: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD67C: 4082FFE8  bne 0x825ad664
	if !ctx.cr[0].eq {
	pc = 0x825AD664; continue 'dispatch;
	}
	// 825AD680: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825AD684: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AD688: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825AD68C: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD690: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD694: 7CE02028  lwarx r7, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD698: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD69C: 7CE0212D  stwcx. r7, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD6A0: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD6A4: 4082FFE8  bne 0x825ad68c
	if !ctx.cr[0].eq {
	pc = 0x825AD68C; continue 'dispatch;
	}
	// 825AD6A8: 99630068  stb r11, 0x68(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 825AD6AC: 99630069  stb r11, 0x69(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 825AD6B0: 9963006A  stb r11, 0x6a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(106 as u32), ctx.r[11].u8 ) };
	// 825AD6B4: 9963006B  stb r11, 0x6b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(107 as u32), ctx.r[11].u8 ) };
	// 825AD6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD6C0 size=276
    let mut pc: u32 = 0x825AD6C0;
    'dispatch: loop {
        match pc {
            0x825AD6C0 => {
    //   block [0x825AD6C0..0x825AD7D4)
	// 825AD6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AD6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AD6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AD6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD6D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD6DC: 392B20B4  addi r9, r11, 0x20b4
	ctx.r[9].s64 = ctx.r[11].s64 + 8372;
	// 825AD6E0: 895F0068  lbz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AD6E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD6EC: 419A0008  beq cr6, 0x825ad6f4
	if ctx.cr[6].eq {
	pc = 0x825AD6F4; continue 'dispatch;
	}
	// 825AD6F0: 480003E1  bl 0x825adad0
	ctx.lr = 0x825AD6F4;
	sub_825ADAD0(ctx, base);
	// 825AD6F4: 897F006B  lbz r11, 0x6b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(107 as u32) ) } as u64;
	// 825AD6F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD6FC: 419A0010  beq cr6, 0x825ad70c
	if ctx.cr[6].eq {
	pc = 0x825AD70C; continue 'dispatch;
	}
	// 825AD700: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AD704: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 825AD708: 4BBED051  bl 0x8219a758
	ctx.lr = 0x825AD70C;
	sub_8219A758(ctx, base);
	// 825AD70C: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 825AD710: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD714: 4BC676C5  bl 0x82214dd8
	ctx.lr = 0x825AD718;
	sub_82214DD8(ctx, base);
	// 825AD718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD71C: 4BC0A3FD  bl 0x821b7b18
	ctx.lr = 0x825AD720;
	sub_821B7B18(ctx, base);
	// 825AD720: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 825AD724: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD728: 4BC676B1  bl 0x82214dd8
	ctx.lr = 0x825AD72C;
	sub_82214DD8(ctx, base);
	// 825AD72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD730: 4BC0A3E9  bl 0x821b7b18
	ctx.lr = 0x825AD734;
	sub_821B7B18(ctx, base);
	// 825AD734: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	// 825AD738: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD73C: 4BC6769D  bl 0x82214dd8
	ctx.lr = 0x825AD740;
	sub_82214DD8(ctx, base);
	// 825AD740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD744: 4BC0A3D5  bl 0x821b7b18
	ctx.lr = 0x825AD748;
	sub_821B7B18(ctx, base);
	// 825AD748: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 825AD74C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD750: 4BC67689  bl 0x82214dd8
	ctx.lr = 0x825AD754;
	sub_82214DD8(ctx, base);
	// 825AD754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD758: 4BC0A3C1  bl 0x821b7b18
	ctx.lr = 0x825AD75C;
	sub_821B7B18(ctx, base);
	// 825AD75C: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 825AD760: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD764: 4BC67675  bl 0x82214dd8
	ctx.lr = 0x825AD768;
	sub_82214DD8(ctx, base);
	// 825AD768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD76C: 4BC0A3AD  bl 0x821b7b18
	ctx.lr = 0x825AD770;
	sub_821B7B18(ctx, base);
	// 825AD770: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825AD774: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD778: 4BC67661  bl 0x82214dd8
	ctx.lr = 0x825AD77C;
	sub_82214DD8(ctx, base);
	// 825AD77C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD780: 4BC0A399  bl 0x821b7b18
	ctx.lr = 0x825AD784;
	sub_821B7B18(ctx, base);
	// 825AD784: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825AD788: 4BC0A391  bl 0x821b7b18
	ctx.lr = 0x825AD78C;
	sub_821B7B18(ctx, base);
	// 825AD78C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825AD790: 4BC0A389  bl 0x821b7b18
	ctx.lr = 0x825AD794;
	sub_821B7B18(ctx, base);
	// 825AD794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD798: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825AD79C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 825AD7A0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825AD7A4: 4BBE6695  bl 0x82193e38
	ctx.lr = 0x825AD7A8;
	sub_82193E38(ctx, base);
	// 825AD7A8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AD7AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AD7B0: 38E946D4  addi r7, r9, 0x46d4
	ctx.r[7].s64 = ctx.r[9].s64 + 18132;
	// 825AD7B4: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825AD7B8: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AD7BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AD7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AD7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AD7C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AD7CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AD7D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AD7D8 size=12
    let mut pc: u32 = 0x825AD7D8;
    'dispatch: loop {
        match pc {
            0x825AD7D8 => {
    //   block [0x825AD7D8..0x825AD7E4)
	// 825AD7D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AD7DC: 99630069  stb r11, 0x69(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 825AD7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD7E8 size=744
    let mut pc: u32 = 0x825AD7E8;
    'dispatch: loop {
        match pc {
            0x825AD7E8 => {
    //   block [0x825AD7E8..0x825ADAD0)
	// 825AD7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD7EC: 486FBC0D  bl 0x82ca93f8
	ctx.lr = 0x825AD7F0;
	sub_82CA93D0(ctx, base);
	// 825AD7F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD7F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825AD7F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AD7FC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825AD800: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 825AD804: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD808: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825AD80C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825AD810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD814: 419A001C  beq cr6, 0x825ad830
	if ctx.cr[6].eq {
	pc = 0x825AD830; continue 'dispatch;
	}
	// 825AD818: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD81C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD820: 419A000C  beq cr6, 0x825ad82c
	if ctx.cr[6].eq {
	pc = 0x825AD82C; continue 'dispatch;
	}
	// 825AD824: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AD828: 4800000C  b 0x825ad834
	pc = 0x825AD834; continue 'dispatch;
	// 825AD82C: 4BBE660D  bl 0x82193e38
	ctx.lr = 0x825AD830;
	sub_82193E38(ctx, base);
	// 825AD830: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825AD834: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AD838: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AD83C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AD840: 419A0018  beq cr6, 0x825ad858
	if ctx.cr[6].eq {
	pc = 0x825AD858; continue 'dispatch;
	}
	// 825AD844: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AD848: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AD84C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AD850: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD854: 409A0008  bne cr6, 0x825ad85c
	if !ctx.cr[6].eq {
	pc = 0x825AD85C; continue 'dispatch;
	}
	// 825AD858: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825AD85C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AD860: 38790008  addi r3, r25, 8
	ctx.r[3].s64 = ctx.r[25].s64 + 8;
	// 825AD864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD868: 419A0028  beq cr6, 0x825ad890
	if ctx.cr[6].eq {
	pc = 0x825AD890; continue 'dispatch;
	}
	// 825AD86C: 4BBC65CD  bl 0x82173e38
	ctx.lr = 0x825AD870;
	sub_82173E38(ctx, base);
	// 825AD870: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825AD874: 38E100BC  addi r7, r1, 0xbc
	ctx.r[7].s64 = ctx.r[1].s64 + 188;
	// 825AD878: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AD87C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AD880: 38990018  addi r4, r25, 0x18
	ctx.r[4].s64 = ctx.r[25].s64 + 24;
	// 825AD884: 38790020  addi r3, r25, 0x20
	ctx.r[3].s64 = ctx.r[25].s64 + 32;
	// 825AD888: 480013D1  bl 0x825aec58
	ctx.lr = 0x825AD88C;
	sub_825AEC58(ctx, base);
	// 825AD88C: 48000020  b 0x825ad8ac
	pc = 0x825AD8AC; continue 'dispatch;
	// 825AD890: 4BBC65A9  bl 0x82173e38
	ctx.lr = 0x825AD894;
	sub_82173E38(ctx, base);
	// 825AD894: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825AD898: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AD89C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AD8A0: 38990018  addi r4, r25, 0x18
	ctx.r[4].s64 = ctx.r[25].s64 + 24;
	// 825AD8A4: 38790020  addi r3, r25, 0x20
	ctx.r[3].s64 = ctx.r[25].s64 + 32;
	// 825AD8A8: 480014C9  bl 0x825aed70
	ctx.lr = 0x825AD8AC;
	sub_825AED70(ctx, base);
	// 825AD8AC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825AD8B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825AD8B4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD8B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD8BC: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AD8C0: 4BE9E0B9  bl 0x8244b978
	ctx.lr = 0x825AD8C4;
	sub_8244B978(ctx, base);
	// 825AD8C4: 8959006A  lbz r10, 0x6a(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(106 as u32) ) } as u64;
	// 825AD8C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD8CC: 419A01F8  beq cr6, 0x825adac4
	if ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825AD8D0: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD8D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD8D8: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD8DC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8E0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8E4: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825AD8E8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AD8F0: 409A000C  bne cr6, 0x825ad8fc
	if !ctx.cr[6].eq {
	pc = 0x825AD8FC; continue 'dispatch;
	}
	// 825AD8F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AD8F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825AD8FC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AD900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD904: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD908: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AD90C: 4E800421  bctrl
	ctx.lr = 0x825AD910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AD910: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AD914: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825AD918: 419A0018  beq cr6, 0x825ad930
	if ctx.cr[6].eq {
	pc = 0x825AD930; continue 'dispatch;
	}
	// 825AD91C: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 825AD920: 419A0010  beq cr6, 0x825ad930
	if ctx.cr[6].eq {
	pc = 0x825AD930; continue 'dispatch;
	}
	// 825AD924: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 825AD928: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825AD92C: 409A0008  bne cr6, 0x825ad934
	if !ctx.cr[6].eq {
	pc = 0x825AD934; continue 'dispatch;
	}
	// 825AD930: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AD934: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AD938: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AD93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD940: 419A001C  beq cr6, 0x825ad95c
	if ctx.cr[6].eq {
	pc = 0x825AD95C; continue 'dispatch;
	}
	// 825AD944: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD948: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825AD94C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD950: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD954: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD958: 4BD6AEA9  bl 0x82318800
	ctx.lr = 0x825AD95C;
	sub_82318800(ctx, base);
	// 825AD95C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825AD960: 4BC718F9  bl 0x8221f258
	ctx.lr = 0x825AD964;
	sub_8221F258(ctx, base);
	// 825AD964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AD96C: 419A0074  beq cr6, 0x825ad9e0
	if ctx.cr[6].eq {
	pc = 0x825AD9E0; continue 'dispatch;
	}
	// 825AD970: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825AD974: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825AD978: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 825AD97C: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 825AD980: 392BED9C  addi r9, r11, -0x1264
	ctx.r[9].s64 = ctx.r[11].s64 + -4708;
	// 825AD984: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 825AD988: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AD98C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 825AD990: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD994: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD99C: 4BFD1A8D  bl 0x8257f428
	ctx.lr = 0x825AD9A0;
	sub_8257F428(ctx, base);
	// 825AD9A0: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 825AD9A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9A8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AD9AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9B0: 4BFD1A79  bl 0x8257f428
	ctx.lr = 0x825AD9B4;
	sub_8257F428(ctx, base);
	// 825AD9B4: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 825AD9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9BC: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 825AD9C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9C4: 4BFD1A65  bl 0x8257f428
	ctx.lr = 0x825AD9C8;
	sub_8257F428(ctx, base);
	// 825AD9C8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825AD9CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9D4: 4BFD1A55  bl 0x8257f428
	ctx.lr = 0x825AD9D8;
	sub_8257F428(ctx, base);
	// 825AD9D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AD9DC: 48000008  b 0x825ad9e4
	pc = 0x825AD9E4; continue 'dispatch;
	// 825AD9E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825AD9E4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD9E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD9EC: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD9F0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD9F4: 4BD6AD25  bl 0x82318718
	ctx.lr = 0x825AD9F8;
	sub_82318718(ctx, base);
	// 825AD9F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825AD9FC: 419A00C8  beq cr6, 0x825adac4
	if ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825ADA00: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825ADA04: 409A0020  bne cr6, 0x825ada24
	if !ctx.cr[6].eq {
	pc = 0x825ADA24; continue 'dispatch;
	}
	// 825ADA08: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825ADA0C: 4BC7184D  bl 0x8221f258
	ctx.lr = 0x825ADA10;
	sub_8221F258(ctx, base);
	// 825ADA10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ADA14: 419A0098  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA18: 4BE27231  bl 0x823d4c48
	ctx.lr = 0x825ADA1C;
	sub_823D4C48(ctx, base);
	// 825ADA1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ADA20: 48000090  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
	// 825ADA24: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 825ADA28: 409A0038  bne cr6, 0x825ada60
	if !ctx.cr[6].eq {
	pc = 0x825ADA60; continue 'dispatch;
	}
	// 825ADA2C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825ADA30: 4BC71829  bl 0x8221f258
	ctx.lr = 0x825ADA34;
	sub_8221F258(ctx, base);
	// 825ADA34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADA38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825ADA3C: 419A0070  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA40: 4BE27209  bl 0x823d4c48
	ctx.lr = 0x825ADA44;
	sub_823D4C48(ctx, base);
	// 825ADA44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825ADA48: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 825ADA4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADA50: 394BECA0  addi r10, r11, -0x1360
	ctx.r[10].s64 = ctx.r[11].s64 + -4960;
	// 825ADA54: 9B5F0015  stb r26, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[26].u8 ) };
	// 825ADA58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825ADA5C: 48000054  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
	// 825ADA60: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 825ADA64: 409A0060  bne cr6, 0x825adac4
	if !ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825ADA68: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825ADA6C: 4BC717ED  bl 0x8221f258
	ctx.lr = 0x825ADA70;
	sub_8221F258(ctx, base);
	// 825ADA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADA74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825ADA78: 419A0034  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA7C: 4BE271CD  bl 0x823d4c48
	ctx.lr = 0x825ADA80;
	sub_823D4C48(ctx, base);
	// 825ADA80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825ADA84: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 825ADA88: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 825ADA8C: 392BECC4  addi r9, r11, -0x133c
	ctx.r[9].s64 = ctx.r[11].s64 + -4924;
	// 825ADA90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825ADA94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ADA98: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825ADA9C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825ADAA0: 4BFD1989  bl 0x8257f428
	ctx.lr = 0x825ADAA4;
	sub_8257F428(ctx, base);
	// 825ADAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADAA8: 48000008  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
	// 825ADAAC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825ADAB0: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADAB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADAB8: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825ADABC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADAC0: 4BD6AC59  bl 0x82318718
	ctx.lr = 0x825ADAC4;
	sub_82318718(ctx, base);
	// 825ADAC4: 9B190068  stb r24, 0x68(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(104 as u32), ctx.r[24].u8 ) };
	// 825ADAC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825ADACC: 486FB97C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ADAD0 size=176
    let mut pc: u32 = 0x825ADAD0;
    'dispatch: loop {
        match pc {
            0x825ADAD0 => {
    //   block [0x825ADAD0..0x825ADB80)
	// 825ADAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ADAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ADADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ADAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADAE8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADAEC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825ADAF0: 4BBECC69  bl 0x8219a758
	ctx.lr = 0x825ADAF4;
	sub_8219A758(ctx, base);
	// 825ADAF4: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 825ADAF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADAFC: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADB00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADB04: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825ADB08: 4BE9DF21  bl 0x8244ba28
	ctx.lr = 0x825ADB0C;
	sub_8244BA28(ctx, base);
	// 825ADB0C: 895F006A  lbz r10, 0x6a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(106 as u32) ) } as u64;
	// 825ADB10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADB14: 419A0060  beq cr6, 0x825adb74
	if ctx.cr[6].eq {
	pc = 0x825ADB74; continue 'dispatch;
	}
	// 825ADB18: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADB1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825ADB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADB24: 419A0010  beq cr6, 0x825adb34
	if ctx.cr[6].eq {
	pc = 0x825ADB34; continue 'dispatch;
	}
	// 825ADB28: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825ADB2C: 894A6A5E  lbz r10, 0x6a5e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(27230 as u32) ) } as u64;
	// 825ADB30: 48000008  b 0x825adb38
	pc = 0x825ADB38; continue 'dispatch;
	// 825ADB34: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825ADB38: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825ADB3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADB40: 419A0018  beq cr6, 0x825adb58
	if ctx.cr[6].eq {
	pc = 0x825ADB58; continue 'dispatch;
	}
	// 825ADB44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADB48: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 825ADB4C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825ADB50: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADB54: 4BD6ACAD  bl 0x82318800
	ctx.lr = 0x825ADB58;
	sub_82318800(ctx, base);
	// 825ADB58: 9BDF0068  stb r30, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u8 ) };
	// 825ADB5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ADB60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ADB64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ADB68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ADB6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ADB70: 4E800020  blr
	return;
	// 825ADB74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ADB78: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 825ADB7C: 4BFFFFE0  b 0x825adb5c
	pc = 0x825ADB5C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ADB80 size=472
    let mut pc: u32 = 0x825ADB80;
    'dispatch: loop {
        match pc {
            0x825ADB80 => {
    //   block [0x825ADB80..0x825ADD58)
	// 825ADB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADB84: 486FB885  bl 0x82ca9408
	ctx.lr = 0x825ADB88;
	sub_82CA93D0(ctx, base);
	// 825ADB88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADB8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825ADB90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ADB94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825ADB98: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825ADB9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADBA0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825ADBA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825ADBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADBAC: 419A001C  beq cr6, 0x825adbc8
	if ctx.cr[6].eq {
	pc = 0x825ADBC8; continue 'dispatch;
	}
	// 825ADBB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADBB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADBB8: 419A000C  beq cr6, 0x825adbc4
	if ctx.cr[6].eq {
	pc = 0x825ADBC4; continue 'dispatch;
	}
	// 825ADBBC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ADBC0: 4800000C  b 0x825adbcc
	pc = 0x825ADBCC; continue 'dispatch;
	// 825ADBC4: 4BBE6275  bl 0x82193e38
	ctx.lr = 0x825ADBC8;
	sub_82193E38(ctx, base);
	// 825ADBC8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825ADBCC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825ADBD0: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825ADBD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825ADBD8: 419A00F4  beq cr6, 0x825adccc
	if ctx.cr[6].eq {
	pc = 0x825ADCCC; continue 'dispatch;
	}
	// 825ADBDC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825ADBE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADBE4: 419A0024  beq cr6, 0x825adc08
	if ctx.cr[6].eq {
	pc = 0x825ADC08; continue 'dispatch;
	}
	// 825ADBE8: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 825ADBEC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825ADBF0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825ADBF4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825ADBF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADBFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADC00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADC04: 480000CC  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
	// 825ADC08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825ADC0C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ADC10: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825ADC14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825ADC18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825ADC1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ADC20: 40810054  ble 0x825adc74
	if !ctx.cr[0].gt {
	pc = 0x825ADC74; continue 'dispatch;
	}
	// 825ADC24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825ADC28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825ADC2C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825ADC30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADC34: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825ADC38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825ADC3C: 41980008  blt cr6, 0x825adc44
	if ctx.cr[6].lt {
	pc = 0x825ADC44; continue 'dispatch;
	}
	// 825ADC40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825ADC44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825ADC48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825ADC4C: 419A0014  beq cr6, 0x825adc60
	if ctx.cr[6].eq {
	pc = 0x825ADC60; continue 'dispatch;
	}
	// 825ADC50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825ADC54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825ADC58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825ADC5C: 4800000C  b 0x825adc68
	pc = 0x825ADC68; continue 'dispatch;
	// 825ADC60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825ADC64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825ADC68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ADC6C: 4199FFB8  bgt cr6, 0x825adc24
	if ctx.cr[6].gt {
	pc = 0x825ADC24; continue 'dispatch;
	}
	// 825ADC70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825ADC74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825ADC78: 419A0040  beq cr6, 0x825adcb8
	if ctx.cr[6].eq {
	pc = 0x825ADCB8; continue 'dispatch;
	}
	// 825ADC7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADC80: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825ADC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADC88: 41990008  bgt cr6, 0x825adc90
	if ctx.cr[6].gt {
	pc = 0x825ADC90; continue 'dispatch;
	}
	// 825ADC8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825ADC90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ADC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADC98: 409A0020  bne cr6, 0x825adcb8
	if !ctx.cr[6].eq {
	pc = 0x825ADCB8; continue 'dispatch;
	}
	// 825ADC9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825ADCA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825ADCA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ADCA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADCAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADCB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADCB4: 4800001C  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
	// 825ADCB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825ADCBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADCC0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADCC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADCC8: 48000008  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
	// 825ADCCC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825ADCD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ADCD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADCD8: 419A0024  beq cr6, 0x825adcfc
	if ctx.cr[6].eq {
	pc = 0x825ADCFC; continue 'dispatch;
	}
	// 825ADCDC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825ADCE0: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825ADCE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADCE8: 409A0068  bne cr6, 0x825add50
	if !ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADCEC: 897F002A  lbz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 825ADCF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADCF4: 419A0008  beq cr6, 0x825adcfc
	if ctx.cr[6].eq {
	pc = 0x825ADCFC; continue 'dispatch;
	}
	// 825ADCF8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825ADCFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ADD00: 894B6BE9  lbz r10, 0x6be9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27625 as u32) ) } as u64;
	// 825ADD04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADD08: 409A0048  bne cr6, 0x825add50
	if !ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADD0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADD10: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 825ADD14: 419A003C  beq cr6, 0x825add50
	if ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADD18: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 825ADD1C: C01D0008  lfs f0, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADD24: 419A0010  beq cr6, 0x825add34
	if ctx.cr[6].eq {
	pc = 0x825ADD34; continue 'dispatch;
	}
	// 825ADD28: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825ADD2C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825ADD30: 48000008  b 0x825add38
	pc = 0x825ADD38; continue 'dispatch;
	// 825ADD34: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825ADD38: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825ADD3C: 38DD0004  addi r6, r29, 4
	ctx.r[6].s64 = ctx.r[29].s64 + 4;
	// 825ADD40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825ADD44: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 825ADD48: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	// 825ADD4C: 4800112D  bl 0x825aee78
	ctx.lr = 0x825ADD50;
	sub_825AEE78(ctx, base);
	// 825ADD50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825ADD54: 486FB704  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ADD58 size=2584
    let mut pc: u32 = 0x825ADD58;
    'dispatch: loop {
        match pc {
            0x825ADD58 => {
    //   block [0x825ADD58..0x825ADFF8)
	// 825ADD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADD5C: 486FB69D  bl 0x82ca93f8
	ctx.lr = 0x825ADD60;
	sub_82CA93D0(ctx, base);
	// 825ADD60: 9421F700  stwu r1, -0x900(r1)
	ea = ctx.r[1].u32.wrapping_add(-2304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADD64: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ADD68: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825ADD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADD70: 894B6BE9  lbz r10, 0x6be9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27625 as u32) ) } as u64;
	// 825ADD74: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 825ADD78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADD7C: 419A04BC  beq cr6, 0x825ae238
	if ctx.cr[6].eq {
	pc = 0x825AE238; continue 'dispatch;
	}
	// 825ADD80: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 825ADD84: 409A005C  bne cr6, 0x825adde0
	if !ctx.cr[6].eq {
	pc = 0x825ADDE0; continue 'dispatch;
	}
	// 825ADD88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ADD8C: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADD90: 48451041  bl 0x829fedd0
	ctx.lr = 0x825ADD94;
	sub_829FEDD0(ctx, base);
	// 825ADD94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ADD98: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADD9C: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADDA0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825ADDA4: 4845102D  bl 0x829fedd0
	ctx.lr = 0x825ADDA8;
	sub_829FEDD0(ctx, base);
	// 825ADDA8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 825ADDAC: C1A10070  lfs f13, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ADDB0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825ADDB4: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825ADDB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ADDBC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825ADDC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ADDC4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADDC8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825ADDCC: 480010AD  bl 0x825aee78
	ctx.lr = 0x825ADDD0;
	sub_825AEE78(ctx, base);
	// 825ADDD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ADDD4: 995A0038  stb r10, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 825ADDD8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825ADDDC: 486FB66C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825ADDE0: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 825ADDE4: 409A005C  bne cr6, 0x825ade40
	if !ctx.cr[6].eq {
	pc = 0x825ADE40; continue 'dispatch;
	}
	// 825ADDE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ADDEC: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADDF0: 48450FE1  bl 0x829fedd0
	ctx.lr = 0x825ADDF4;
	sub_829FEDD0(ctx, base);
	// 825ADDF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ADDF8: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADDFC: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADE00: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825ADE04: 48450FCD  bl 0x829fedd0
	ctx.lr = 0x825ADE08;
	sub_829FEDD0(ctx, base);
	// 825ADE08: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825ADE0C: C1A10060  lfs f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ADE10: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825ADE14: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825ADE18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ADE1C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825ADE20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ADE24: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADE28: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825ADE2C: 4800104D  bl 0x825aee78
	ctx.lr = 0x825ADE30;
	sub_825AEE78(ctx, base);
	// 825ADE30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ADE34: 995A0038  stb r10, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 825ADE38: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825ADE3C: 486FB60C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825ADE40: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825ADE44: 409A0924  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825ADE48: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADE4C: 396BFFEF  addi r11, r11, -0x11
	ctx.r[11].s64 = ctx.r[11].s64 + -17;
	// 825ADE50: 2B0B0061  cmplwi cr6, r11, 0x61
	ctx.cr[6].compare_u32(ctx.r[11].u32, 97 as u32, &mut ctx.xer);
	// 825ADE54: 41990914  bgt cr6, 0x825ae768
	if ctx.cr[6].gt {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825ADE58: 3D80825B  lis r12, -0x7da5
	ctx.r[12].s64 = -2107965440;
	// 825ADE5C: 398CDE70  addi r12, r12, -0x2190
	ctx.r[12].s64 = ctx.r[12].s64 + -8592;
	// 825ADE60: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825ADE64: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825ADE68: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825ADE6C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825ADFF8; continue 'dispatch;
		},
		1 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		2 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		3 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		4 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		5 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		6 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		7 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		8 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		9 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		10 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		11 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		12 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		13 => {
	pc = 0x825AE088; continue 'dispatch;
		},
		14 => {
	pc = 0x825AE040; continue 'dispatch;
		},
		15 => {
	pc = 0x825AE0D0; continue 'dispatch;
		},
		16 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		17 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		18 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		19 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		20 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		21 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		22 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		23 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		24 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		25 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		26 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		27 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		28 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		29 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		30 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		31 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		32 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		33 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		34 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		35 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		36 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		37 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		38 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		39 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		40 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		41 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		42 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		43 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		44 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		45 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		46 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		47 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		48 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		49 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		50 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		51 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		52 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		53 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		54 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		55 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		56 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		57 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		58 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		59 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		60 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		61 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		62 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		63 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		64 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		65 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		66 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		67 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		68 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		69 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		70 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		71 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		72 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		73 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		74 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		75 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		76 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		77 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		78 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		79 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		80 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		81 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		82 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		83 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		84 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		85 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		86 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		87 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		88 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		89 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		90 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		91 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		92 => {
	pc = 0x825AE118; continue 'dispatch;
		},
		93 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		94 => {
	pc = 0x825AE1A8; continue 'dispatch;
		},
		95 => {
	pc = 0x825AE1F0; continue 'dispatch;
		},
		96 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		97 => {
	pc = 0x825AE160; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825ADE70: 825ADFF8  lwz r18, -0x2008(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8200 as u32) ) } as u64;
	// 825ADE74: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE78: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE7C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE80: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE84: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE88: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE8C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE90: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE94: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE98: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE9C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEA0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEA4: 825AE088  lwz r18, -0x1f78(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8056 as u32) ) } as u64;
	// 825ADEA8: 825AE040  lwz r18, -0x1fc0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8128 as u32) ) } as u64;
	// 825ADEAC: 825AE0D0  lwz r18, -0x1f30(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7984 as u32) ) } as u64;
	// 825ADEB0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEB4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEB8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEBC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADECC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEDC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEEC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEFC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF00: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF04: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF08: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF0C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF10: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF14: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF18: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF1C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF20: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF24: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF28: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF2C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF30: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF34: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF38: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF3C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF40: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF44: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF48: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF4C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF50: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF54: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF58: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF5C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF60: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF64: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF68: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF6C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF70: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF74: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF78: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF7C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF80: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF84: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF88: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF8C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF90: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF94: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF98: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF9C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFAC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFBC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFCC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFDC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFE0: 825AE118  lwz r18, -0x1ee8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7912 as u32) ) } as u64;
	// 825ADFE4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFE8: 825AE1A8  lwz r18, -0x1e58(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7768 as u32) ) } as u64;
	// 825ADFEC: 825AE1F0  lwz r18, -0x1e10(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7696 as u32) ) } as u64;
	// 825ADFF0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFF4: 825AE160  lwz r18, -0x1ea0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7840 as u32) ) } as u64;
            }
            0x825ADFF8 => {
    //   block [0x825ADFF8..0x825AE040)
	// 825ADFF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825ADFFC: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE000: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE004: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE008: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE00C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE010: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE014: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE018: C0094138  lfs f0, 0x4138(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE01C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE020: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE024: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE028: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE02C: 48000E4D  bl 0x825aee78
	ctx.lr = 0x825AE030;
	sub_825AEE78(ctx, base);
	// 825AE030: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE034: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE038: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE03C: 486FB40C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE040 => {
    //   block [0x825AE040..0x825AE088)
	// 825AE040: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE044: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE048: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE04C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE050: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE054: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE058: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE05C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE060: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE064: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE068: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE06C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE070: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE074: 48000E05  bl 0x825aee78
	ctx.lr = 0x825AE078;
	sub_825AEE78(ctx, base);
	// 825AE078: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE07C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE080: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE084: 486FB3C4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE088 => {
    //   block [0x825AE088..0x825AE0D0)
	// 825AE088: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE08C: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE090: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE094: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE098: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE09C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE0A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE0A4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE0A8: C009FFF4  lfs f0, -0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0AC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE0B0: C1A94138  lfs f13, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE0B4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE0B8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE0BC: 48000DBD  bl 0x825aee78
	ctx.lr = 0x825AE0C0;
	sub_825AEE78(ctx, base);
	// 825AE0C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE0C4: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE0C8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE0CC: 486FB37C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE0D0 => {
    //   block [0x825AE0D0..0x825AE118)
	// 825AE0D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE0D4: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE0D8: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE0DC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE0E0: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825AE0E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AE0E8: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE0F0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE0F4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE0F8: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0FC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE100: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE104: 48000D75  bl 0x825aee78
	ctx.lr = 0x825AE108;
	sub_825AEE78(ctx, base);
	// 825AE108: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE10C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE110: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE114: 486FB334  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE118 => {
    //   block [0x825AE118..0x825AE160)
	// 825AE118: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE11C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE120: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE124: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE128: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE12C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE130: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE134: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE138: C0094138  lfs f0, 0x4138(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE13C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE140: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE144: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE148: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE14C: 48000D2D  bl 0x825aee78
	ctx.lr = 0x825AE150;
	sub_825AEE78(ctx, base);
	// 825AE150: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE154: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE158: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE15C: 486FB2EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE160 => {
    //   block [0x825AE160..0x825AE1A8)
	// 825AE160: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE164: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE168: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE16C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE170: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE174: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE178: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE17C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE180: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE184: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE188: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE18C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE190: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE194: 48000CE5  bl 0x825aee78
	ctx.lr = 0x825AE198;
	sub_825AEE78(ctx, base);
	// 825AE198: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE19C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE1A0: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE1A4: 486FB2A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE1A8 => {
    //   block [0x825AE1A8..0x825AE1F0)
	// 825AE1A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE1AC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE1B0: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE1B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE1B8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE1BC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE1C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE1C4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE1C8: C009FFF4  lfs f0, -0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE1CC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE1D0: C1A94138  lfs f13, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE1D4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE1D8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE1DC: 48000C9D  bl 0x825aee78
	ctx.lr = 0x825AE1E0;
	sub_825AEE78(ctx, base);
	// 825AE1E0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE1E4: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE1E8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE1EC: 486FB25C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE1F0 => {
    //   block [0x825AE1F0..0x825AE768)
	// 825AE1F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE1F4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE1F8: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE1FC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE200: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825AE204: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AE208: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE20C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE210: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE214: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE218: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE21C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE220: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE224: 48000C55  bl 0x825aee78
	ctx.lr = 0x825AE228;
	sub_825AEE78(ctx, base);
	// 825AE228: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE22C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE230: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE234: 486FB214  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825AE238: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 825AE23C: 409A04B8  bne cr6, 0x825ae6f4
	if !ctx.cr[6].eq {
	pc = 0x825AE6F4; continue 'dispatch;
	}
	// 825AE240: 897A0008  lbz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE244: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 825AE248: 409A027C  bne cr6, 0x825ae4c4
	if !ctx.cr[6].eq {
	pc = 0x825AE4C4; continue 'dispatch;
	}
	// 825AE24C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825AE250: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE254: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE258: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE25C: 83AA009C  lwz r29, 0x9c(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AE264: 4BCB5FCD  bl 0x82264230
	ctx.lr = 0x825AE268;
	sub_82264230(ctx, base);
	// 825AE268: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AE26C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825AE270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE274: 419A0168  beq cr6, 0x825ae3dc
	if ctx.cr[6].eq {
	pc = 0x825AE3DC; continue 'dispatch;
	}
	// 825AE278: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE27C: 83DA0028  lwz r30, 0x28(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE280: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 825AE284: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825AE288: 5525DFFE  rlwinm r5, r9, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 825AE28C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AE290: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE294: 409A0028  bne cr6, 0x825ae2bc
	if !ctx.cr[6].eq {
	pc = 0x825AE2BC; continue 'dispatch;
	}
	// 825AE298: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE29C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AE2A0: 4BCB5F91  bl 0x82264230
	ctx.lr = 0x825AE2A4;
	sub_82264230(ctx, base);
	// 825AE2A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE2A8: 419A0014  beq cr6, 0x825ae2bc
	if ctx.cr[6].eq {
	pc = 0x825AE2BC; continue 'dispatch;
	}
	// 825AE2AC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE2B0: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 825AE2B4: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825AE2B8: 5525DFFE  rlwinm r5, r9, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 825AE2BC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825AE2C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE2C4: 419A0114  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE2C8: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 825AE2CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE2D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825AE2D4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE2D8: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	// 825AE2DC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE2E0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE2E4: 48000CE5  bl 0x825aefc8
	ctx.lr = 0x825AE2E8;
	sub_825AEFC8(ctx, base);
	// 825AE2E8: 813B6AB8  lwz r9, 0x6ab8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE2EC: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE2F0: 810B011C  lwz r8, 0x11c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE2F4: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 825AE2F8: 409A0010  bne cr6, 0x825ae308
	if !ctx.cr[6].eq {
	pc = 0x825AE308; continue 'dispatch;
	}
	// 825AE2FC: 38800047  li r4, 0x47
	ctx.r[4].s64 = 71;
	// 825AE300: 806B00A8  lwz r3, 0xa8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 825AE304: 4BEA2615  bl 0x82450918
	ctx.lr = 0x825AE308;
	sub_82450918(ctx, base);
	// 825AE308: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE30C: 815A0028  lwz r10, 0x28(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE310: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE314: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825AE318: 409A00C0  bne cr6, 0x825ae3d8
	if !ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE320: 480004C9  bl 0x825ae7e8
	ctx.lr = 0x825AE324;
	sub_825AE7E8(ctx, base);
	// 825AE324: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE32C: 419A00AC  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE330: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AE334: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE338: 4BC3A859  bl 0x821e8b90
	ctx.lr = 0x825AE33C;
	sub_821E8B90(ctx, base);
	// 825AE33C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE344: 409A0094  bne cr6, 0x825ae3d8
	if !ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE348: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE34C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE350: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE354: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825AE358: 409A0014  bne cr6, 0x825ae36c
	if !ctx.cr[6].eq {
	pc = 0x825AE36C; continue 'dispatch;
	}
	// 825AE35C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE360: 894B00DE  lbz r10, 0xde(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(222 as u32) ) } as u64;
	// 825AE364: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE368: 419A0070  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE36C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825AE370: 4BC70EE9  bl 0x8221f258
	ctx.lr = 0x825AE374;
	sub_8221F258(ctx, base);
	// 825AE374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE378: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AE37C: 419A002C  beq cr6, 0x825ae3a8
	if ctx.cr[6].eq {
	pc = 0x825AE3A8; continue 'dispatch;
	}
	// 825AE380: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE384: 4BCF0AF5  bl 0x8229ee78
	ctx.lr = 0x825AE388;
	sub_8229EE78(ctx, base);
	// 825AE388: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE38C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE390: 4BDBEC81  bl 0x8236d010
	ctx.lr = 0x825AE394;
	sub_8236D010(ctx, base);
	// 825AE394: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AE398: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AE39C: 392A5098  addi r9, r10, 0x5098
	ctx.r[9].s64 = ctx.r[10].s64 + 20632;
	// 825AE3A0: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AE3A4: 48000008  b 0x825ae3ac
	pc = 0x825AE3AC; continue 'dispatch;
	// 825AE3A8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE3AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825AE3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE3B4: 419A0014  beq cr6, 0x825ae3c8
	if ctx.cr[6].eq {
	pc = 0x825AE3C8; continue 'dispatch;
	}
	// 825AE3B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AE3BC: 48456905  bl 0x82a04cc0
	ctx.lr = 0x825AE3C0;
	sub_82A04CC0(ctx, base);
	// 825AE3C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE3C4: 4800000C  b 0x825ae3d0
	pc = 0x825AE3D0; continue 'dispatch;
	// 825AE3C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825AE3CC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825AE3D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE3D4: 4BDDB7AD  bl 0x82389b80
	ctx.lr = 0x825AE3D8;
	sub_82389B80(ctx, base);
	// 825AE3D8: 9B1A0038  stb r24, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[24].u8 ) };
	// 825AE3DC: 815B6AB8  lwz r10, 0x6ab8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE3E0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE3E4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE3E8: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825AE3EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE3F0: 419A0014  beq cr6, 0x825ae404
	if ctx.cr[6].eq {
	pc = 0x825AE404; continue 'dispatch;
	}
	// 825AE3F4: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 825AE3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE3FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE400: 409A0008  bne cr6, 0x825ae408
	if !ctx.cr[6].eq {
	pc = 0x825AE408; continue 'dispatch;
	}
	// 825AE404: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE410: 419A0358  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE414: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE418: 396B6474  addi r11, r11, 0x6474
	ctx.r[11].s64 = ctx.r[11].s64 + 25716;
	// 825AE41C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825AE420: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE424: 83EA008C  lwz r31, 0x8c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE428: 813F0064  lwz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AE42C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE430: 40990088  ble cr6, 0x825ae4b8
	if !ctx.cr[6].gt {
	pc = 0x825AE4B8; continue 'dispatch;
	}
	// 825AE434: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE438: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825AE43C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825AE440: 4E800421  bctrl
	ctx.lr = 0x825AE444;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AE444: B0610060  sth r3, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u16 ) };
	// 825AE448: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825AE44C: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 825AE450: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 825AE454: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825AE458: 9B010068  stb r24, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u8 ) };
	// 825AE45C: 486D9B85  bl 0x82c87fe0
	ctx.lr = 0x825AE460;
	sub_82C87FE0(ctx, base);
	// 825AE460: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AE464: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AE468: 39093D70  addi r8, r9, 0x3d70
	ctx.r[8].s64 = ctx.r[9].s64 + 15728;
	// 825AE46C: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 825AE470: 910100A0  stw r8, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 825AE474: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AE478: 486D9B29  bl 0x82c87fa0
	ctx.lr = 0x825AE47C;
	sub_82C87FA0(ctx, base);
	// 825AE47C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 825AE480: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AE484: 38C73C90  addi r6, r7, 0x3c90
	ctx.r[6].s64 = ctx.r[7].s64 + 15504;
	// 825AE488: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825AE48C: 90C10080  stw r6, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 825AE490: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AE494: 4BD5B6A5  bl 0x82309b38
	ctx.lr = 0x825AE498;
	sub_82309B38(ctx, base);
	// 825AE498: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825AE49C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825AE4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE4A4: 4BD86FD5  bl 0x82335478
	ctx.lr = 0x825AE4A8;
	sub_82335478(ctx, base);
	// 825AE4A8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825AE4AC: 485E89CD  bl 0x82b96e78
	ctx.lr = 0x825AE4B0;
	sub_82B96E78(ctx, base);
	// 825AE4B0: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825AE4B4: 485E89C5  bl 0x82b96e78
	ctx.lr = 0x825AE4B8;
	sub_82B96E78(ctx, base);
	// 825AE4B8: 9B1A0038  stb r24, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[24].u8 ) };
	// 825AE4BC: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE4C0: 486FAF88  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825AE4C4: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 825AE4C8: 409A02A0  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE4CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AE4D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE4D4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE4D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE4DC: 83CA009C  lwz r30, 0x9c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE4E4: 4BCB5D4D  bl 0x82264230
	ctx.lr = 0x825AE4E8;
	sub_82264230(ctx, base);
	// 825AE4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE4EC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825AE4F0: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AE4F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AE4F8: 419A0018  beq cr6, 0x825ae510
	if ctx.cr[6].eq {
	pc = 0x825AE510; continue 'dispatch;
	}
	// 825AE4FC: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE500: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE504: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825AE508: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE50C: 419A0008  beq cr6, 0x825ae514
	if ctx.cr[6].eq {
	pc = 0x825AE514; continue 'dispatch;
	}
	// 825AE510: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE514: 5565063E  clrlwi r5, r11, 0x18
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE518: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825AE51C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE520: 409A002C  bne cr6, 0x825ae54c
	if !ctx.cr[6].eq {
	pc = 0x825AE54C; continue 'dispatch;
	}
	// 825AE524: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE52C: 4BCB5D05  bl 0x82264230
	ctx.lr = 0x825AE530;
	sub_82264230(ctx, base);
	// 825AE530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE534: 419A0018  beq cr6, 0x825ae54c
	if ctx.cr[6].eq {
	pc = 0x825AE54C; continue 'dispatch;
	}
	// 825AE538: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE53C: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE540: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825AE544: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 825AE548: 5505DFFE  rlwinm r5, r8, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 825AE54C: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825AE550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE554: 419A0214  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE558: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825AE55C: 409A0014  bne cr6, 0x825ae570
	if !ctx.cr[6].eq {
	pc = 0x825AE570; continue 'dispatch;
	}
	// 825AE560: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE568: 4BCB5CC9  bl 0x82264230
	ctx.lr = 0x825AE56C;
	sub_82264230(ctx, base);
	// 825AE56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AE574: 419A01F4  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE578: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 825AE57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE580: 4BC3A611  bl 0x821e8b90
	ctx.lr = 0x825AE584;
	sub_821E8B90(ctx, base);
	// 825AE584: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE58C: 409A01DC  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE594: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 825AE598: 4BCF08E1  bl 0x8229ee78
	ctx.lr = 0x825AE59C;
	sub_8229EE78(ctx, base);
	// 825AE59C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE5A0: 419A0018  beq cr6, 0x825ae5b8
	if ctx.cr[6].eq {
	pc = 0x825AE5B8; continue 'dispatch;
	}
	// 825AE5A4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AE5A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AE5AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE5B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE5B4: 409A0008  bne cr6, 0x825ae5bc
	if !ctx.cr[6].eq {
	pc = 0x825AE5BC; continue 'dispatch;
	}
	// 825AE5B8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE5BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE5C4: 419A01A4  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE5CC: 4BCF08AD  bl 0x8229ee78
	ctx.lr = 0x825AE5D0;
	sub_8229EE78(ctx, base);
	// 825AE5D0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE5D4: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825AE5D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE5DC: 419A00F4  beq cr6, 0x825ae6d0
	if ctx.cr[6].eq {
	pc = 0x825AE6D0; continue 'dispatch;
	}
	// 825AE5E0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE5E8: 419A0024  beq cr6, 0x825ae60c
	if ctx.cr[6].eq {
	pc = 0x825AE60C; continue 'dispatch;
	}
	// 825AE5EC: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825AE5F0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE5F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AE5F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AE5FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE600: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE604: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE608: 480000CC  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
	// 825AE60C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE610: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AE614: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 825AE618: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AE61C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825AE620: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE624: 40810054  ble 0x825ae678
	if !ctx.cr[0].gt {
	pc = 0x825AE678; continue 'dispatch;
	}
	// 825AE628: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AE62C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AE630: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AE634: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE638: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825AE63C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825AE640: 41980008  blt cr6, 0x825ae648
	if ctx.cr[6].lt {
	pc = 0x825AE648; continue 'dispatch;
	}
	// 825AE644: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825AE648: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AE64C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AE650: 419A0014  beq cr6, 0x825ae664
	if ctx.cr[6].eq {
	pc = 0x825AE664; continue 'dispatch;
	}
	// 825AE654: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AE658: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AE65C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AE660: 4800000C  b 0x825ae66c
	pc = 0x825AE66C; continue 'dispatch;
	// 825AE664: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AE668: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AE66C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE670: 4199FFB8  bgt cr6, 0x825ae628
	if ctx.cr[6].gt {
	pc = 0x825AE628; continue 'dispatch;
	}
	// 825AE674: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825AE678: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AE67C: 419A0040  beq cr6, 0x825ae6bc
	if ctx.cr[6].eq {
	pc = 0x825AE6BC; continue 'dispatch;
	}
	// 825AE680: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE684: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825AE688: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE68C: 41990008  bgt cr6, 0x825ae694
	if ctx.cr[6].gt {
	pc = 0x825AE694; continue 'dispatch;
	}
	// 825AE690: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE69C: 409A0020  bne cr6, 0x825ae6bc
	if !ctx.cr[6].eq {
	pc = 0x825AE6BC; continue 'dispatch;
	}
	// 825AE6A0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AE6A4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825AE6A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AE6AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE6B0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE6B4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE6B8: 4800001C  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
	// 825AE6BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AE6C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE6C4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE6C8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE6CC: 48000008  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
	// 825AE6D0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825AE6D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE6DC: 419A008C  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE6E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE6E8: 4BE3B829  bl 0x823e9f10
	ctx.lr = 0x825AE6EC;
	sub_823E9F10(ctx, base);
	// 825AE6EC: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE6F0: 486FAD58  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 825AE6F4: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 825AE6F8: 409A0070  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE6FC: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 825AE700: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE704: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE708: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE70C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825AE710: 409A0058  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE714: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE718: 894B00DE  lbz r10, 0xde(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(222 as u32) ) } as u64;
	// 825AE71C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE720: 409A0048  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE724: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AE728: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825AE72C: 484506A5  bl 0x829fedd0
	ctx.lr = 0x825AE730;
	sub_829FEDD0(ctx, base);
	// 825AE730: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE734: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825AE738: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE73C: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE740: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE744: ED60603A  fmadds f11, f0, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 825AE748: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 825AE74C: 4099001C  ble cr6, 0x825ae768
	if !ctx.cr[6].gt {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE750: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE754: 38800047  li r4, 0x47
	ctx.r[4].s64 = 71;
	// 825AE758: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE75C: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 825AE760: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE764: 4BC06AFD  bl 0x821b5260
	ctx.lr = 0x825AE768;
	sub_821B5260(ctx, base);
            }
            0x825AE768 => {
    //   block [0x825AE768..0x825AE770)
	// 825AE768: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE76C: 486FACDC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AE770 size=24
    let mut pc: u32 = 0x825AE770;
    'dispatch: loop {
        match pc {
            0x825AE770 => {
    //   block [0x825AE770..0x825AE788)
	// 825AE770: 8963006A  lbz r11, 0x6a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(106 as u32) ) } as u64;
	// 825AE774: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 825AE778: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825AE77C: 552B077A  rlwinm r11, r9, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 825AE780: 386B0005  addi r3, r11, 5
	ctx.r[3].s64 = ctx.r[11].s64 + 5;
	// 825AE784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE788 size=96
    let mut pc: u32 = 0x825AE788;
    'dispatch: loop {
        match pc {
            0x825AE788 => {
    //   block [0x825AE788..0x825AE7E8)
	// 825AE788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE794: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE798: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AE79C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE7A4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE7A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE7AC: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE7B0: 4BCB5A81  bl 0x82264230
	ctx.lr = 0x825AE7B4;
	sub_82264230(ctx, base);
	// 825AE7B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE7B8: 419A001C  beq cr6, 0x825ae7d4
	if ctx.cr[6].eq {
	pc = 0x825AE7D4; continue 'dispatch;
	}
	// 825AE7BC: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 825AE7C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AE7C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AE7C8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE7CC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE7D0: 480007F9  bl 0x825aefc8
	ctx.lr = 0x825AE7D4;
	sub_825AEFC8(ctx, base);
	// 825AE7D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE7E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE7E8 size=436
    let mut pc: u32 = 0x825AE7E8;
    'dispatch: loop {
        match pc {
            0x825AE7E8 => {
    //   block [0x825AE7E8..0x825AE99C)
	// 825AE7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE7F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE7F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE7FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE800: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AE804: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE808: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825AE80C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825AE810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE814: 419A001C  beq cr6, 0x825ae830
	if ctx.cr[6].eq {
	pc = 0x825AE830; continue 'dispatch;
	}
	// 825AE818: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE81C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE820: 419A000C  beq cr6, 0x825ae82c
	if ctx.cr[6].eq {
	pc = 0x825AE82C; continue 'dispatch;
	}
	// 825AE824: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AE828: 4800000C  b 0x825ae834
	pc = 0x825AE834; continue 'dispatch;
	// 825AE82C: 4BBE560D  bl 0x82193e38
	ctx.lr = 0x825AE830;
	sub_82193E38(ctx, base);
	// 825AE830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825AE834: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE838: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 825AE83C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE840: 419A00F4  beq cr6, 0x825ae934
	if ctx.cr[6].eq {
	pc = 0x825AE934; continue 'dispatch;
	}
	// 825AE844: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE848: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE84C: 419A0024  beq cr6, 0x825ae870
	if ctx.cr[6].eq {
	pc = 0x825AE870; continue 'dispatch;
	}
	// 825AE850: 892A0031  lbz r9, 0x31(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 825AE854: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE858: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825AE85C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825AE860: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE864: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE868: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE86C: 480000CC  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
	// 825AE870: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE874: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AE878: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AE87C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AE880: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AE884: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE888: 40810054  ble 0x825ae8dc
	if !ctx.cr[0].gt {
	pc = 0x825AE8DC; continue 'dispatch;
	}
	// 825AE88C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AE890: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AE894: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AE898: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE89C: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825AE8A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AE8A4: 41980008  blt cr6, 0x825ae8ac
	if ctx.cr[6].lt {
	pc = 0x825AE8AC; continue 'dispatch;
	}
	// 825AE8A8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825AE8AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AE8B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AE8B4: 419A0014  beq cr6, 0x825ae8c8
	if ctx.cr[6].eq {
	pc = 0x825AE8C8; continue 'dispatch;
	}
	// 825AE8B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AE8BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AE8C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AE8C4: 4800000C  b 0x825ae8d0
	pc = 0x825AE8D0; continue 'dispatch;
	// 825AE8C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AE8CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AE8D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE8D4: 4199FFB8  bgt cr6, 0x825ae88c
	if ctx.cr[6].gt {
	pc = 0x825AE88C; continue 'dispatch;
	}
	// 825AE8D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AE8DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AE8E0: 419A0040  beq cr6, 0x825ae920
	if ctx.cr[6].eq {
	pc = 0x825AE920; continue 'dispatch;
	}
	// 825AE8E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE8E8: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825AE8EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE8F0: 41990008  bgt cr6, 0x825ae8f8
	if ctx.cr[6].gt {
	pc = 0x825AE8F8; continue 'dispatch;
	}
	// 825AE8F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825AE8F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE900: 409A0020  bne cr6, 0x825ae920
	if !ctx.cr[6].eq {
	pc = 0x825AE920; continue 'dispatch;
	}
	// 825AE904: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AE908: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AE90C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AE910: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE914: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE918: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE91C: 4800001C  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
	// 825AE920: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AE924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE928: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE92C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE930: 48000008  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
	// 825AE934: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825AE938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE940: 419A002C  beq cr6, 0x825ae96c
	if ctx.cr[6].eq {
	pc = 0x825AE96C; continue 'dispatch;
	}
	// 825AE944: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE94C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AE950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AE954: 4E800421  bctrl
	ctx.lr = 0x825AE958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AE958: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE95C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE960: 419A000C  beq cr6, 0x825ae96c
	if ctx.cr[6].eq {
	pc = 0x825AE96C; continue 'dispatch;
	}
	// 825AE964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AE968: 4800001C  b 0x825ae984
	pc = 0x825AE984; continue 'dispatch;
	// 825AE96C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE970: 4BCF0509  bl 0x8229ee78
	ctx.lr = 0x825AE974;
	sub_8229EE78(ctx, base);
	// 825AE974: 4804E5AD  bl 0x825fcf20
	ctx.lr = 0x825AE978;
	sub_825FCF20(ctx, base);
	// 825AE978: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE97C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825AE980: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825AE984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE9A0 size=384
    let mut pc: u32 = 0x825AE9A0;
    'dispatch: loop {
        match pc {
            0x825AE9A0 => {
    //   block [0x825AE9A0..0x825AEB20)
	// 825AE9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE9A4: 486FAA61  bl 0x82ca9404
	ctx.lr = 0x825AE9A8;
	sub_82CA93D0(ctx, base);
	// 825AE9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE9AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AE9B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AE9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE9B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825AE9BC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AE9C0: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AE9C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE9CC: 419A0148  beq cr6, 0x825aeb14
	if ctx.cr[6].eq {
	pc = 0x825AEB14; continue 'dispatch;
	}
	// 825AE9D0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE9D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AE9D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AE9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE9E0: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AE9E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE9E8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE9EC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825AE9F0: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825AE9F4: 4BBEC08D  bl 0x8219aa80
	ctx.lr = 0x825AE9F8;
	sub_8219AA80(ctx, base);
	// 825AE9F8: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE9FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA04: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA08: 4BC7A701  bl 0x82229108
	ctx.lr = 0x825AEA0C;
	sub_82229108(ctx, base);
	// 825AEA0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEA14: 419A0014  beq cr6, 0x825aea28
	if ctx.cr[6].eq {
	pc = 0x825AEA28; continue 'dispatch;
	}
	// 825AEA18: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEA1C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA24: 4BC7A6E5  bl 0x82229108
	ctx.lr = 0x825AEA28;
	sub_82229108(ctx, base);
	// 825AEA28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA2C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AEA30: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEA34: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEA38: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 825AEA3C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AEA40: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 825AEA44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEA48: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEA4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEA50: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825AEA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA58: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AEA5C: 4BBEBDE5  bl 0x8219a840
	ctx.lr = 0x825AEA60;
	sub_8219A840(ctx, base);
	// 825AEA60: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEA64: 409A0088  bne cr6, 0x825aeaec
	if !ctx.cr[6].eq {
	pc = 0x825AEAEC; continue 'dispatch;
	}
	// 825AEA68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AEA70: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 825AEA74: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEA78: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825AEA7C: 419A008C  beq cr6, 0x825aeb08
	if ctx.cr[6].eq {
	pc = 0x825AEB08; continue 'dispatch;
	}
	// 825AEA80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEA84: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 825AEA88: 409A0080  bne cr6, 0x825aeb08
	if !ctx.cr[6].eq {
	pc = 0x825AEB08; continue 'dispatch;
	}
	// 825AEA8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825AEA90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEA94: 388B9FCC  addi r4, r11, -0x6034
	ctx.r[4].s64 = ctx.r[11].s64 + -24628;
	// 825AEA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEA9C: 4BC7E435  bl 0x8222ced0
	ctx.lr = 0x825AEAA0;
	sub_8222CED0(ctx, base);
	// 825AEAA0: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 825AEAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEAA8: 4BC3DD51  bl 0x821ec7f8
	ctx.lr = 0x825AEAAC;
	sub_821EC7F8(ctx, base);
	// 825AEAAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AEAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEAB4: 409A0010  bne cr6, 0x825aeac4
	if !ctx.cr[6].eq {
	pc = 0x825AEAC4; continue 'dispatch;
	}
	// 825AEAB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825AEABC: 38ABFFDF  addi r5, r11, -0x21
	ctx.r[5].s64 = ctx.r[11].s64 + -33;
	// 825AEAC0: 48000008  b 0x825aeac8
	pc = 0x825AEAC8; continue 'dispatch;
	// 825AEAC4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEAC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AEACC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEAD0: 4BD0AD21  bl 0x822b97f0
	ctx.lr = 0x825AEAD4;
	sub_822B97F0(ctx, base);
	// 825AEAD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEAD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEADC: 4BBCC8BD  bl 0x8217b398
	ctx.lr = 0x825AEAE0;
	sub_8217B398(ctx, base);
	// 825AEAE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEAE4: 4BC09035  bl 0x821b7b18
	ctx.lr = 0x825AEAE8;
	sub_821B7B18(ctx, base);
	// 825AEAE8: 48000018  b 0x825aeb00
	pc = 0x825AEB00; continue 'dispatch;
	// 825AEAEC: 4864DD1D  bl 0x82bfc808
	ctx.lr = 0x825AEAF0;
	sub_82BFC808(ctx, base);
	// 825AEAF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEAF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEAFC: 4BC7E3D5  bl 0x8222ced0
	ctx.lr = 0x825AEB00;
	sub_8222CED0(ctx, base);
	// 825AEB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEB04: 4BC662D5  bl 0x82214dd8
	ctx.lr = 0x825AEB08;
	sub_82214DD8(ctx, base);
	// 825AEB08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AEB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB10: 4861D1F9  bl 0x82bcbd08
	ctx.lr = 0x825AEB14;
	sub_82BCBD08(ctx, base);
	// 825AEB14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEB18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEB1C: 486FA938  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEB20 size=308
    let mut pc: u32 = 0x825AEB20;
    'dispatch: loop {
        match pc {
            0x825AEB20 => {
    //   block [0x825AEB20..0x825AEC54)
	// 825AEB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEB24: 486FA8E1  bl 0x82ca9404
	ctx.lr = 0x825AEB28;
	sub_82CA93D0(ctx, base);
	// 825AEB28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEB2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEB30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEB34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825AEB38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEB40: 419A0108  beq cr6, 0x825aec48
	if ctx.cr[6].eq {
	pc = 0x825AEC48; continue 'dispatch;
	}
	// 825AEB44: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB48: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEB4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB54: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEB58: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AEB5C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEB60: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825AEB64: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825AEB68: 4BBEBF19  bl 0x8219aa80
	ctx.lr = 0x825AEB6C;
	sub_8219AA80(ctx, base);
	// 825AEB6C: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB70: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB78: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEB7C: 4BC7A58D  bl 0x82229108
	ctx.lr = 0x825AEB80;
	sub_82229108(ctx, base);
	// 825AEB80: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEB88: 419A0014  beq cr6, 0x825aeb9c
	if ctx.cr[6].eq {
	pc = 0x825AEB9C; continue 'dispatch;
	}
	// 825AEB8C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEB90: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB98: 4BC7A571  bl 0x82229108
	ctx.lr = 0x825AEB9C;
	sub_82229108(ctx, base);
	// 825AEB9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEBA0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AEBA4: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEBA8: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEBAC: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 825AEBB0: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825AEBB4: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 825AEBB8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AEBBC: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEBC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AEBC4: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825AEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEBCC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AEBD0: 4BBEBC71  bl 0x8219a840
	ctx.lr = 0x825AEBD4;
	sub_8219A840(ctx, base);
	// 825AEBD4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEBD8: 409A0048  bne cr6, 0x825aec20
	if !ctx.cr[6].eq {
	pc = 0x825AEC20; continue 'dispatch;
	}
	// 825AEBDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEBE0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AEBE4: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 825AEBE8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEBEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825AEBF0: 419A004C  beq cr6, 0x825aec3c
	if ctx.cr[6].eq {
	pc = 0x825AEC3C; continue 'dispatch;
	}
	// 825AEBF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEBF8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825AEBFC: 409A0040  bne cr6, 0x825aec3c
	if !ctx.cr[6].eq {
	pc = 0x825AEC3C; continue 'dispatch;
	}
	// 825AEC00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825AEC04: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEC08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AEC0C: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 825AEC10: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AEC14: 4BD53285  bl 0x82301e98
	ctx.lr = 0x825AEC18;
	sub_82301E98(ctx, base);
	// 825AEC18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AEC1C: 48000020  b 0x825aec3c
	pc = 0x825AEC3C; continue 'dispatch;
	// 825AEC20: 4864DBE9  bl 0x82bfc808
	ctx.lr = 0x825AEC24;
	sub_82BFC808(ctx, base);
	// 825AEC24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEC28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEC2C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEC30: 4BC7E2A1  bl 0x8222ced0
	ctx.lr = 0x825AEC34;
	sub_8222CED0(ctx, base);
	// 825AEC34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEC38: 4BC661A1  bl 0x82214dd8
	ctx.lr = 0x825AEC3C;
	sub_82214DD8(ctx, base);
	// 825AEC3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AEC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEC44: 4861D0C5  bl 0x82bcbd08
	ctx.lr = 0x825AEC48;
	sub_82BCBD08(ctx, base);
	// 825AEC48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEC4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEC50: 486FA804  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEC58 size=276
    let mut pc: u32 = 0x825AEC58;
    'dispatch: loop {
        match pc {
            0x825AEC58 => {
    //   block [0x825AEC58..0x825AED6C)
	// 825AEC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEC5C: 486FA7A5  bl 0x82ca9400
	ctx.lr = 0x825AEC60;
	sub_82CA93D0(ctx, base);
	// 825AEC60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEC64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEC68: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEC6C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AEC70: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825AEC74: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 825AEC78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEC80: 419A00E4  beq cr6, 0x825aed64
	if ctx.cr[6].eq {
	pc = 0x825AED64; continue 'dispatch;
	}
	// 825AEC84: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEC88: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEC8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEC94: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEC98: 4BBEBDE9  bl 0x8219aa80
	ctx.lr = 0x825AEC9C;
	sub_8219AA80(ctx, base);
	// 825AEC9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECA0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AECA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECA8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AECAC: 4BC7A45D  bl 0x82229108
	ctx.lr = 0x825AECB0;
	sub_82229108(ctx, base);
	// 825AECB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AECB8: 419A0014  beq cr6, 0x825aeccc
	if ctx.cr[6].eq {
	pc = 0x825AECCC; continue 'dispatch;
	}
	// 825AECBC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AECC0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AECC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECC8: 4BC7A441  bl 0x82229108
	ctx.lr = 0x825AECCC;
	sub_82229108(ctx, base);
	// 825AECCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECD0: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECD4: 4BDF42ED  bl 0x823a2fc0
	ctx.lr = 0x825AECD8;
	sub_823A2FC0(ctx, base);
	// 825AECD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECDC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECE0: 4BDF42E1  bl 0x823a2fc0
	ctx.lr = 0x825AECE4;
	sub_823A2FC0(ctx, base);
	// 825AECE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECE8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECEC: 4BDF42D5  bl 0x823a2fc0
	ctx.lr = 0x825AECF0;
	sub_823A2FC0(ctx, base);
	// 825AECF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AECF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AECF8: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AECFC: 394BFFD8  addi r10, r11, -0x28
	ctx.r[10].s64 = ctx.r[11].s64 + -40;
	// 825AED00: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AED04: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825AED08: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AED0C: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 825AED10: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 825AED14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AED18: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 825AED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AED20: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825AED24: 4BBEBB1D  bl 0x8219a840
	ctx.lr = 0x825AED28;
	sub_8219A840(ctx, base);
	// 825AED28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AED2C: 419A002C  beq cr6, 0x825aed58
	if ctx.cr[6].eq {
	pc = 0x825AED58; continue 'dispatch;
	}
	// 825AED30: 4864DAD9  bl 0x82bfc808
	ctx.lr = 0x825AED34;
	sub_82BFC808(ctx, base);
	// 825AED34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AED38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AED3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AED40: 4BC7E191  bl 0x8222ced0
	ctx.lr = 0x825AED44;
	sub_8222CED0(ctx, base);
	// 825AED44: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AED48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AED4C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AED50: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AED54: 4BC66085  bl 0x82214dd8
	ctx.lr = 0x825AED58;
	sub_82214DD8(ctx, base);
	// 825AED58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AED5C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AED60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AED64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AED68: 486FA6E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AED70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AED70 size=260
    let mut pc: u32 = 0x825AED70;
    'dispatch: loop {
        match pc {
            0x825AED70 => {
    //   block [0x825AED70..0x825AEE74)
	// 825AED70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AED74: 486FA691  bl 0x82ca9404
	ctx.lr = 0x825AED78;
	sub_82CA93D0(ctx, base);
	// 825AED78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AED7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AED80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AED84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AED88: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825AED8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AED90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AED94: 419A00D8  beq cr6, 0x825aee6c
	if ctx.cr[6].eq {
	pc = 0x825AEE6C; continue 'dispatch;
	}
	// 825AED98: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AED9C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEDA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDA8: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEDAC: 4BBEBCD5  bl 0x8219aa80
	ctx.lr = 0x825AEDB0;
	sub_8219AA80(ctx, base);
	// 825AEDB0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDB4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDBC: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEDC0: 4BC7A349  bl 0x82229108
	ctx.lr = 0x825AEDC4;
	sub_82229108(ctx, base);
	// 825AEDC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEDCC: 419A0014  beq cr6, 0x825aede0
	if ctx.cr[6].eq {
	pc = 0x825AEDE0; continue 'dispatch;
	}
	// 825AEDD0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEDD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDDC: 4BC7A32D  bl 0x82229108
	ctx.lr = 0x825AEDE0;
	sub_82229108(ctx, base);
	// 825AEDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDE4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDE8: 4BDF41D9  bl 0x823a2fc0
	ctx.lr = 0x825AEDEC;
	sub_823A2FC0(ctx, base);
	// 825AEDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDF0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDF4: 4BDF41CD  bl 0x823a2fc0
	ctx.lr = 0x825AEDF8;
	sub_823A2FC0(ctx, base);
	// 825AEDF8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEDFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AEE00: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEE04: 394BFFE0  addi r10, r11, -0x20
	ctx.r[10].s64 = ctx.r[11].s64 + -32;
	// 825AEE08: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AEE0C: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 825AEE10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEE14: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 825AEE18: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 825AEE1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEE20: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 825AEE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEE28: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825AEE2C: 4BBEBA15  bl 0x8219a840
	ctx.lr = 0x825AEE30;
	sub_8219A840(ctx, base);
	// 825AEE30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEE34: 419A002C  beq cr6, 0x825aee60
	if ctx.cr[6].eq {
	pc = 0x825AEE60; continue 'dispatch;
	}
	// 825AEE38: 4864D9D1  bl 0x82bfc808
	ctx.lr = 0x825AEE3C;
	sub_82BFC808(ctx, base);
	// 825AEE3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEE44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEE48: 4BC7E089  bl 0x8222ced0
	ctx.lr = 0x825AEE4C;
	sub_8222CED0(ctx, base);
	// 825AEE4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEE54: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEE58: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEE5C: 4BC65F7D  bl 0x82214dd8
	ctx.lr = 0x825AEE60;
	sub_82214DD8(ctx, base);
	// 825AEE60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEE64: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEE68: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEE6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEE70: 486FA5E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AEE78 size=336
    let mut pc: u32 = 0x825AEE78;
    'dispatch: loop {
        match pc {
            0x825AEE78 => {
    //   block [0x825AEE78..0x825AEFC8)
	// 825AEE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEE7C: 486FA585  bl 0x82ca9400
	ctx.lr = 0x825AEE80;
	sub_82CA93D0(ctx, base);
	// 825AEE80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEE84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEE88: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825AEE8C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825AEE90: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825AEE94: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825AEE98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEEA0: 419A0120  beq cr6, 0x825aefc0
	if ctx.cr[6].eq {
	pc = 0x825AEFC0; continue 'dispatch;
	}
	// 825AEEA4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEEA8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEEAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEB4: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEEB8: 4BBEBBC9  bl 0x8219aa80
	ctx.lr = 0x825AEEBC;
	sub_8219AA80(ctx, base);
	// 825AEEBC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEEC0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEC8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEECC: 4BC7A23D  bl 0x82229108
	ctx.lr = 0x825AEED0;
	sub_82229108(ctx, base);
	// 825AEED0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEED8: 419A0014  beq cr6, 0x825aeeec
	if ctx.cr[6].eq {
	pc = 0x825AEEEC; continue 'dispatch;
	}
	// 825AEEDC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEEE0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEE8: 4BC7A221  bl 0x82229108
	ctx.lr = 0x825AEEEC;
	sub_82229108(ctx, base);
	// 825AEEEC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEEF0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AEEF4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEEF8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AEEFC: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825AEF00: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AEF04: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEF08: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 825AEF0C: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AEF10: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825AEF14: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEF18: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825AEF1C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF20: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF28: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF2C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF30: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825AEF34: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF38: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF44: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF48: C15B0000  lfs f10, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825AEF4C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF50: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF58: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF5C: 394BFFD8  addi r10, r11, -0x28
	ctx.r[10].s64 = ctx.r[11].s64 + -40;
	// 825AEF60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF64: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825AEF68: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEF6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEF70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEF78: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AEF7C: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825AEF80: 4BBEB8C1  bl 0x8219a840
	ctx.lr = 0x825AEF84;
	sub_8219A840(ctx, base);
	// 825AEF84: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEF88: 419A002C  beq cr6, 0x825aefb4
	if ctx.cr[6].eq {
	pc = 0x825AEFB4; continue 'dispatch;
	}
	// 825AEF8C: 4864D87D  bl 0x82bfc808
	ctx.lr = 0x825AEF90;
	sub_82BFC808(ctx, base);
	// 825AEF90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEF94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEF98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEF9C: 4BC7DF35  bl 0x8222ced0
	ctx.lr = 0x825AEFA0;
	sub_8222CED0(ctx, base);
	// 825AEFA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEFA8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEFAC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEFB0: 4BC65E29  bl 0x82214dd8
	ctx.lr = 0x825AEFB4;
	sub_82214DD8(ctx, base);
	// 825AEFB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEFB8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEFBC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEFC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AEFC4: 486FA48C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AEFC8 size=280
    let mut pc: u32 = 0x825AEFC8;
    'dispatch: loop {
        match pc {
            0x825AEFC8 => {
    //   block [0x825AEFC8..0x825AF0E0)
	// 825AEFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEFCC: 486FA43D  bl 0x82ca9408
	ctx.lr = 0x825AEFD0;
	sub_82CA93D0(ctx, base);
	// 825AEFD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEFD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEFD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEFDC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AEFE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEFE8: 419A00F0  beq cr6, 0x825af0d8
	if ctx.cr[6].eq {
	pc = 0x825AF0D8; continue 'dispatch;
	}
	// 825AEFEC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEFF0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEFF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEFFC: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AF000: 4BBEBA81  bl 0x8219aa80
	ctx.lr = 0x825AF004;
	sub_8219AA80(ctx, base);
	// 825AF004: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF008: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AF00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF010: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF014: 4BC7A0F5  bl 0x82229108
	ctx.lr = 0x825AF018;
	sub_82229108(ctx, base);
	// 825AF018: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF020: 419A0014  beq cr6, 0x825af034
	if ctx.cr[6].eq {
	pc = 0x825AF034; continue 'dispatch;
	}
	// 825AF024: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AF028: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF030: 4BC7A0D9  bl 0x82229108
	ctx.lr = 0x825AF034;
	sub_82229108(ctx, base);
	// 825AF034: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF038: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AF03C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF040: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AF044: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825AF048: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AF04C: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AF050: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 825AF054: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF058: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825AF05C: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AF060: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825AF064: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AF068: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AF06C: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AF070: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF074: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AF078: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 825AF07C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF080: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825AF084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AF088: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF090: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825AF094: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AF098: 4BBEB7A9  bl 0x8219a840
	ctx.lr = 0x825AF09C;
	sub_8219A840(ctx, base);
	// 825AF09C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AF0A0: 419A002C  beq cr6, 0x825af0cc
	if ctx.cr[6].eq {
	pc = 0x825AF0CC; continue 'dispatch;
	}
	// 825AF0A4: 4864D765  bl 0x82bfc808
	ctx.lr = 0x825AF0A8;
	sub_82BFC808(ctx, base);
	// 825AF0A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AF0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF0B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF0B4: 4BC7DE1D  bl 0x8222ced0
	ctx.lr = 0x825AF0B8;
	sub_8222CED0(ctx, base);
	// 825AF0B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF0C0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AF0C4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF0C8: 4BC65D11  bl 0x82214dd8
	ctx.lr = 0x825AF0CC;
	sub_82214DD8(ctx, base);
	// 825AF0CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF0D0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AF0D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF0D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AF0DC: 486FA37C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AF0E0 size=8
    let mut pc: u32 = 0x825AF0E0;
    'dispatch: loop {
        match pc {
            0x825AF0E0 => {
    //   block [0x825AF0E0..0x825AF0E8)
	// 825AF0E0: 80630060  lwz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AF0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AF0E8 size=8
    let mut pc: u32 = 0x825AF0E8;
    'dispatch: loop {
        match pc {
            0x825AF0E8 => {
    //   block [0x825AF0E8..0x825AF0F0)
	// 825AF0E8: 806300A8  lwz r3, 0xa8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 825AF0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AF0F0 size=8
    let mut pc: u32 = 0x825AF0F0;
    'dispatch: loop {
        match pc {
            0x825AF0F0 => {
    //   block [0x825AF0F0..0x825AF0F8)
	// 825AF0F0: 806300AC  lwz r3, 0xac(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) } as u64;
	// 825AF0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF0F8 size=92
    let mut pc: u32 = 0x825AF0F8;
    'dispatch: loop {
        match pc {
            0x825AF0F8 => {
    //   block [0x825AF0F8..0x825AF154)
	// 825AF0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AF100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AF104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AF10C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 825AF110: 4BC08A09  bl 0x821b7b18
	ctx.lr = 0x825AF114;
	sub_821B7B18(ctx, base);
	// 825AF114: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 825AF118: 4BCEB739  bl 0x8229a850
	ctx.lr = 0x825AF11C;
	sub_8229A850(ctx, base);
	// 825AF11C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AF120: 397F0054  addi r11, r31, 0x54
	ctx.r[11].s64 = ctx.r[31].s64 + 84;
	// 825AF124: 409A0008  bne cr6, 0x825af12c
	if !ctx.cr[6].eq {
	pc = 0x825AF12C; continue 'dispatch;
	}
	// 825AF128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AF12C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 825AF130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF134: 392A04D4  addi r9, r10, 0x4d4
	ctx.r[9].s64 = ctx.r[10].s64 + 1236;
	// 825AF138: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AF13C: 4BBFD9F5  bl 0x821acb30
	ctx.lr = 0x825AF140;
	sub_821ACB30(ctx, base);
	// 825AF140: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AF144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AF148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AF14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AF150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF158 size=68
    let mut pc: u32 = 0x825AF158;
    'dispatch: loop {
        match pc {
            0x825AF158 => {
    //   block [0x825AF158..0x825AF19C)
	// 825AF158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AF160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AF164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AF168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AF170: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AF174: 4BF22D55  bl 0x824d1ec8
	ctx.lr = 0x825AF178;
	sub_824D1EC8(ctx, base);
	// 825AF178: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF180: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AF188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AF18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AF190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AF194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AF198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF1A0 size=1832
    let mut pc: u32 = 0x825AF1A0;
    'dispatch: loop {
        match pc {
            0x825AF1A0 => {
    //   block [0x825AF1A0..0x825AF8C8)
	// 825AF1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF1A4: 486FA269  bl 0x82ca940c
	ctx.lr = 0x825AF1A8;
	sub_82CA93D0(ctx, base);
	// 825AF1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF1AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AF1B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AF1B4: 3BAB50DC  addi r29, r11, 0x50dc
	ctx.r[29].s64 = ctx.r[11].s64 + 20700;
	// 825AF1B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF1C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF1C4: 4BC7DD0D  bl 0x8222ced0
	ctx.lr = 0x825AF1C8;
	sub_8222CED0(ctx, base);
	// 825AF1C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF1CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AF1D0: 480023F1  bl 0x825b15c0
	ctx.lr = 0x825AF1D4;
	sub_825B15C0(ctx, base);
	// 825AF1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF1D8: 4BC65C01  bl 0x82214dd8
	ctx.lr = 0x825AF1DC;
	sub_82214DD8(ctx, base);
	// 825AF1DC: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825AF1E0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AF1E4: 390AFEE0  addi r8, r10, -0x120
	ctx.r[8].s64 = ctx.r[10].s64 + -288;
	// 825AF1E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AF1EC: 388950E4  addi r4, r9, 0x50e4
	ctx.r[4].s64 = ctx.r[9].s64 + 20708;
	// 825AF1F0: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825AF1F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF1F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF1FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF200: 4BC7DCD1  bl 0x8222ced0
	ctx.lr = 0x825AF204;
	sub_8222CED0(ctx, base);
	// 825AF204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF208: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF210: 4BC7DCC1  bl 0x8222ced0
	ctx.lr = 0x825AF214;
	sub_8222CED0(ctx, base);
	// 825AF214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF218: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825AF21C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AF224: 480025E5  bl 0x825b1808
	ctx.lr = 0x825AF228;
	sub_825B1808(ctx, base);
	// 825AF228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF22C: 4BC65BAD  bl 0x82214dd8
	ctx.lr = 0x825AF230;
	sub_82214DD8(ctx, base);
	// 825AF230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF234: 4BC65BA5  bl 0x82214dd8
	ctx.lr = 0x825AF238;
	sub_82214DD8(ctx, base);
	// 825AF238: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825AF23C: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825AF240: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF244: 3867F0E0  addi r3, r7, -0xf20
	ctx.r[3].s64 = ctx.r[7].s64 + -3872;
	// 825AF248: 388650F0  addi r4, r6, 0x50f0
	ctx.r[4].s64 = ctx.r[6].s64 + 20720;
	// 825AF24C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF258: 4BC7DC79  bl 0x8222ced0
	ctx.lr = 0x825AF25C;
	sub_8222CED0(ctx, base);
	// 825AF25C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF264: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF268: 4BC7DC69  bl 0x8222ced0
	ctx.lr = 0x825AF26C;
	sub_8222CED0(ctx, base);
	// 825AF26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF270: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF274: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF278: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF27C: 4800360D  bl 0x825b2888
	ctx.lr = 0x825AF280;
	sub_825B2888(ctx, base);
	// 825AF280: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF284: 4BC65B55  bl 0x82214dd8
	ctx.lr = 0x825AF288;
	sub_82214DD8(ctx, base);
	// 825AF288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF28C: 4BC65B4D  bl 0x82214dd8
	ctx.lr = 0x825AF290;
	sub_82214DD8(ctx, base);
	// 825AF290: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF294: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF298: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF29C: 392BFF40  addi r9, r11, -0xc0
	ctx.r[9].s64 = ctx.r[11].s64 + -192;
	// 825AF2A0: 388A5100  addi r4, r10, 0x5100
	ctx.r[4].s64 = ctx.r[10].s64 + 20736;
	// 825AF2A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2A8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF2B0: 4BC7DC21  bl 0x8222ced0
	ctx.lr = 0x825AF2B4;
	sub_8222CED0(ctx, base);
	// 825AF2B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF2B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF2C0: 4BC7DC11  bl 0x8222ced0
	ctx.lr = 0x825AF2C4;
	sub_8222CED0(ctx, base);
	// 825AF2C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF2C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF2CC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF2D4: 48002745  bl 0x825b1a18
	ctx.lr = 0x825AF2D8;
	sub_825B1A18(ctx, base);
	// 825AF2D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF2DC: 4BC65AFD  bl 0x82214dd8
	ctx.lr = 0x825AF2E0;
	sub_82214DD8(ctx, base);
	// 825AF2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF2E4: 4BC65AF5  bl 0x82214dd8
	ctx.lr = 0x825AF2E8;
	sub_82214DD8(ctx, base);
	// 825AF2E8: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF2EC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF2F0: 38C80010  addi r6, r8, 0x10
	ctx.r[6].s64 = ctx.r[8].s64 + 16;
	// 825AF2F4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF2F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2FC: 38875118  addi r4, r7, 0x5118
	ctx.r[4].s64 = ctx.r[7].s64 + 20760;
	// 825AF300: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF308: 4BC7DBC9  bl 0x8222ced0
	ctx.lr = 0x825AF30C;
	sub_8222CED0(ctx, base);
	// 825AF30C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF310: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF318: 4BC7DBB9  bl 0x8222ced0
	ctx.lr = 0x825AF31C;
	sub_8222CED0(ctx, base);
	// 825AF31C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF320: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF324: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF328: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF32C: 480026ED  bl 0x825b1a18
	ctx.lr = 0x825AF330;
	sub_825B1A18(ctx, base);
	// 825AF330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF334: 4BC65AA5  bl 0x82214dd8
	ctx.lr = 0x825AF338;
	sub_82214DD8(ctx, base);
	// 825AF338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF33C: 4BC65A9D  bl 0x82214dd8
	ctx.lr = 0x825AF340;
	sub_82214DD8(ctx, base);
	// 825AF340: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF344: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF348: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF34C: 3865FFA8  addi r3, r5, -0x58
	ctx.r[3].s64 = ctx.r[5].s64 + -88;
	// 825AF350: 38845130  addi r4, r4, 0x5130
	ctx.r[4].s64 = ctx.r[4].s64 + 20784;
	// 825AF354: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF358: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF360: 4BC7DB71  bl 0x8222ced0
	ctx.lr = 0x825AF364;
	sub_8222CED0(ctx, base);
	// 825AF364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF368: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF36C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF370: 4BC7DB61  bl 0x8222ced0
	ctx.lr = 0x825AF374;
	sub_8222CED0(ctx, base);
	// 825AF374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF378: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF37C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF380: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF384: 48002695  bl 0x825b1a18
	ctx.lr = 0x825AF388;
	sub_825B1A18(ctx, base);
	// 825AF388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF38C: 4BC65A4D  bl 0x82214dd8
	ctx.lr = 0x825AF390;
	sub_82214DD8(ctx, base);
	// 825AF390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF394: 4BC65A45  bl 0x82214dd8
	ctx.lr = 0x825AF398;
	sub_82214DD8(ctx, base);
	// 825AF398: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF39C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF3A0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF3A4: 392BFEF8  addi r9, r11, -0x108
	ctx.r[9].s64 = ctx.r[11].s64 + -264;
	// 825AF3A8: 388A5144  addi r4, r10, 0x5144
	ctx.r[4].s64 = ctx.r[10].s64 + 20804;
	// 825AF3AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF3B0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF3B8: 4BC7DB19  bl 0x8222ced0
	ctx.lr = 0x825AF3BC;
	sub_8222CED0(ctx, base);
	// 825AF3BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF3C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF3C8: 4BC7DB09  bl 0x8222ced0
	ctx.lr = 0x825AF3CC;
	sub_8222CED0(ctx, base);
	// 825AF3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF3D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF3D4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF3D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF3DC: 4800284D  bl 0x825b1c28
	ctx.lr = 0x825AF3E0;
	sub_825B1C28(ctx, base);
	// 825AF3E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF3E4: 4BC659F5  bl 0x82214dd8
	ctx.lr = 0x825AF3E8;
	sub_82214DD8(ctx, base);
	// 825AF3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF3EC: 4BC659ED  bl 0x82214dd8
	ctx.lr = 0x825AF3F0;
	sub_82214DD8(ctx, base);
	// 825AF3F0: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF3F4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF3F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF3FC: 38C80078  addi r6, r8, 0x78
	ctx.r[6].s64 = ctx.r[8].s64 + 120;
	// 825AF400: 38875158  addi r4, r7, 0x5158
	ctx.r[4].s64 = ctx.r[7].s64 + 20824;
	// 825AF404: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF408: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF410: 4BC7DAC1  bl 0x8222ced0
	ctx.lr = 0x825AF414;
	sub_8222CED0(ctx, base);
	// 825AF414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF418: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF41C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF420: 4BC7DAB1  bl 0x8222ced0
	ctx.lr = 0x825AF424;
	sub_8222CED0(ctx, base);
	// 825AF424: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF42C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF430: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF434: 480025E5  bl 0x825b1a18
	ctx.lr = 0x825AF438;
	sub_825B1A18(ctx, base);
	// 825AF438: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF43C: 4BC6599D  bl 0x82214dd8
	ctx.lr = 0x825AF440;
	sub_82214DD8(ctx, base);
	// 825AF440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF444: 4BC65995  bl 0x82214dd8
	ctx.lr = 0x825AF448;
	sub_82214DD8(ctx, base);
	// 825AF448: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF44C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF450: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF454: 386500B0  addi r3, r5, 0xb0
	ctx.r[3].s64 = ctx.r[5].s64 + 176;
	// 825AF458: 38845168  addi r4, r4, 0x5168
	ctx.r[4].s64 = ctx.r[4].s64 + 20840;
	// 825AF45C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF460: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF468: 4BC7DA69  bl 0x8222ced0
	ctx.lr = 0x825AF46C;
	sub_8222CED0(ctx, base);
	// 825AF46C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF470: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF478: 4BC7DA59  bl 0x8222ced0
	ctx.lr = 0x825AF47C;
	sub_8222CED0(ctx, base);
	// 825AF47C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF480: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF484: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF488: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF48C: 480029AD  bl 0x825b1e38
	ctx.lr = 0x825AF490;
	sub_825B1E38(ctx, base);
	// 825AF490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF494: 4BC65945  bl 0x82214dd8
	ctx.lr = 0x825AF498;
	sub_82214DD8(ctx, base);
	// 825AF498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF49C: 4BC6593D  bl 0x82214dd8
	ctx.lr = 0x825AF4A0;
	sub_82214DD8(ctx, base);
	// 825AF4A0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF4A4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF4A8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF4AC: 392BFBF8  addi r9, r11, -0x408
	ctx.r[9].s64 = ctx.r[11].s64 + -1032;
	// 825AF4B0: 388A5180  addi r4, r10, 0x5180
	ctx.r[4].s64 = ctx.r[10].s64 + 20864;
	// 825AF4B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF4B8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF4C0: 4BC7DA11  bl 0x8222ced0
	ctx.lr = 0x825AF4C4;
	sub_8222CED0(ctx, base);
	// 825AF4C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF4C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF4CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF4D0: 4BC7DA01  bl 0x8222ced0
	ctx.lr = 0x825AF4D4;
	sub_8222CED0(ctx, base);
	// 825AF4D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF4D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF4DC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF4E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF4E4: 48002B65  bl 0x825b2048
	ctx.lr = 0x825AF4E8;
	sub_825B2048(ctx, base);
	// 825AF4E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF4EC: 4BC658ED  bl 0x82214dd8
	ctx.lr = 0x825AF4F0;
	sub_82214DD8(ctx, base);
	// 825AF4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF4F4: 4BC658E5  bl 0x82214dd8
	ctx.lr = 0x825AF4F8;
	sub_82214DD8(ctx, base);
	// 825AF4F8: 3D00822A  lis r8, -0x7dd6
	ctx.r[8].s64 = -2111176704;
	// 825AF4FC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF500: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF504: 38C8C620  addi r6, r8, -0x39e0
	ctx.r[6].s64 = ctx.r[8].s64 + -14816;
	// 825AF508: 38875194  addi r4, r7, 0x5194
	ctx.r[4].s64 = ctx.r[7].s64 + 20884;
	// 825AF50C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF510: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF518: 4BC7D9B9  bl 0x8222ced0
	ctx.lr = 0x825AF51C;
	sub_8222CED0(ctx, base);
	// 825AF51C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF520: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF528: 4BC7D9A9  bl 0x8222ced0
	ctx.lr = 0x825AF52C;
	sub_8222CED0(ctx, base);
	// 825AF52C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF530: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF534: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF53C: 48002D1D  bl 0x825b2258
	ctx.lr = 0x825AF540;
	sub_825B2258(ctx, base);
	// 825AF540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF544: 4BC65895  bl 0x82214dd8
	ctx.lr = 0x825AF548;
	sub_82214DD8(ctx, base);
	// 825AF548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF54C: 4BC6588D  bl 0x82214dd8
	ctx.lr = 0x825AF550;
	sub_82214DD8(ctx, base);
	// 825AF550: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF554: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF558: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF55C: 386500E8  addi r3, r5, 0xe8
	ctx.r[3].s64 = ctx.r[5].s64 + 232;
	// 825AF560: 388451AC  addi r4, r4, 0x51ac
	ctx.r[4].s64 = ctx.r[4].s64 + 20908;
	// 825AF564: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF568: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF570: 4BC7D961  bl 0x8222ced0
	ctx.lr = 0x825AF574;
	sub_8222CED0(ctx, base);
	// 825AF574: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF578: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF57C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF580: 4BC7D951  bl 0x8222ced0
	ctx.lr = 0x825AF584;
	sub_8222CED0(ctx, base);
	// 825AF584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF588: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF58C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF590: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF594: 48002CC5  bl 0x825b2258
	ctx.lr = 0x825AF598;
	sub_825B2258(ctx, base);
	// 825AF598: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF59C: 4BC6583D  bl 0x82214dd8
	ctx.lr = 0x825AF5A0;
	sub_82214DD8(ctx, base);
	// 825AF5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5A4: 4BC65835  bl 0x82214dd8
	ctx.lr = 0x825AF5A8;
	sub_82214DD8(ctx, base);
	// 825AF5A8: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF5AC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF5B0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF5B4: 392B0190  addi r9, r11, 0x190
	ctx.r[9].s64 = ctx.r[11].s64 + 400;
	// 825AF5B8: 388A51CC  addi r4, r10, 0x51cc
	ctx.r[4].s64 = ctx.r[10].s64 + 20940;
	// 825AF5BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF5C0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5C8: 4BC7D909  bl 0x8222ced0
	ctx.lr = 0x825AF5CC;
	sub_8222CED0(ctx, base);
	// 825AF5CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF5D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF5D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF5D8: 4BC7D8F9  bl 0x8222ced0
	ctx.lr = 0x825AF5DC;
	sub_8222CED0(ctx, base);
	// 825AF5DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF5E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF5E4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF5E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF5EC: 48002E7D  bl 0x825b2468
	ctx.lr = 0x825AF5F0;
	sub_825B2468(ctx, base);
	// 825AF5F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF5F4: 4BC657E5  bl 0x82214dd8
	ctx.lr = 0x825AF5F8;
	sub_82214DD8(ctx, base);
	// 825AF5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5FC: 4BC657DD  bl 0x82214dd8
	ctx.lr = 0x825AF600;
	sub_82214DD8(ctx, base);
	// 825AF600: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF604: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF608: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF60C: 38C80CD8  addi r6, r8, 0xcd8
	ctx.r[6].s64 = ctx.r[8].s64 + 3288;
	// 825AF610: 388751E8  addi r4, r7, 0x51e8
	ctx.r[4].s64 = ctx.r[7].s64 + 20968;
	// 825AF614: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF618: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF620: 4BC7D8B1  bl 0x8222ced0
	ctx.lr = 0x825AF624;
	sub_8222CED0(ctx, base);
	// 825AF624: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF628: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF630: 4BC7D8A1  bl 0x8222ced0
	ctx.lr = 0x825AF634;
	sub_8222CED0(ctx, base);
	// 825AF634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF638: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF63C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF640: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF644: 48003035  bl 0x825b2678
	ctx.lr = 0x825AF648;
	sub_825B2678(ctx, base);
	// 825AF648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF64C: 4BC6578D  bl 0x82214dd8
	ctx.lr = 0x825AF650;
	sub_82214DD8(ctx, base);
	// 825AF650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF654: 4BC65785  bl 0x82214dd8
	ctx.lr = 0x825AF658;
	sub_82214DD8(ctx, base);
	// 825AF658: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF65C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF660: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF664: 38650E00  addi r3, r5, 0xe00
	ctx.r[3].s64 = ctx.r[5].s64 + 3584;
	// 825AF668: 388451F8  addi r4, r4, 0x51f8
	ctx.r[4].s64 = ctx.r[4].s64 + 20984;
	// 825AF66C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF670: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF678: 4BC7D859  bl 0x8222ced0
	ctx.lr = 0x825AF67C;
	sub_8222CED0(ctx, base);
	// 825AF67C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF680: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF684: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF688: 4BC7D849  bl 0x8222ced0
	ctx.lr = 0x825AF68C;
	sub_8222CED0(ctx, base);
	// 825AF68C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF690: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF694: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF698: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF69C: 480031ED  bl 0x825b2888
	ctx.lr = 0x825AF6A0;
	sub_825B2888(ctx, base);
	// 825AF6A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6A4: 4BC65735  bl 0x82214dd8
	ctx.lr = 0x825AF6A8;
	sub_82214DD8(ctx, base);
	// 825AF6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF6AC: 4BC6572D  bl 0x82214dd8
	ctx.lr = 0x825AF6B0;
	sub_82214DD8(ctx, base);
	// 825AF6B0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF6B4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF6B8: 392B0DF8  addi r9, r11, 0xdf8
	ctx.r[9].s64 = ctx.r[11].s64 + 3576;
	// 825AF6BC: 388A5214  addi r4, r10, 0x5214
	ctx.r[4].s64 = ctx.r[10].s64 + 21012;
	// 825AF6C0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF6C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF6C8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF6D0: 4BC7D801  bl 0x8222ced0
	ctx.lr = 0x825AF6D4;
	sub_8222CED0(ctx, base);
	// 825AF6D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF6D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6E0: 4BC7D7F1  bl 0x8222ced0
	ctx.lr = 0x825AF6E4;
	sub_8222CED0(ctx, base);
	// 825AF6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF6E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF6EC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF6F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF6F4: 48003195  bl 0x825b2888
	ctx.lr = 0x825AF6F8;
	sub_825B2888(ctx, base);
	// 825AF6F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6FC: 4BC656DD  bl 0x82214dd8
	ctx.lr = 0x825AF700;
	sub_82214DD8(ctx, base);
	// 825AF700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF704: 4BC656D5  bl 0x82214dd8
	ctx.lr = 0x825AF708;
	sub_82214DD8(ctx, base);
	// 825AF708: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF70C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF710: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF714: 38C80E08  addi r6, r8, 0xe08
	ctx.r[6].s64 = ctx.r[8].s64 + 3592;
	// 825AF718: 38875230  addi r4, r7, 0x5230
	ctx.r[4].s64 = ctx.r[7].s64 + 21040;
	// 825AF71C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF720: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF728: 4BC7D7A9  bl 0x8222ced0
	ctx.lr = 0x825AF72C;
	sub_8222CED0(ctx, base);
	// 825AF72C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF730: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF734: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF738: 4BC7D799  bl 0x8222ced0
	ctx.lr = 0x825AF73C;
	sub_8222CED0(ctx, base);
	// 825AF73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF740: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF744: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF748: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF74C: 480024DD  bl 0x825b1c28
	ctx.lr = 0x825AF750;
	sub_825B1C28(ctx, base);
	// 825AF750: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF754: 4BC65685  bl 0x82214dd8
	ctx.lr = 0x825AF758;
	sub_82214DD8(ctx, base);
	// 825AF758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF75C: 4BC6567D  bl 0x82214dd8
	ctx.lr = 0x825AF760;
	sub_82214DD8(ctx, base);
	// 825AF760: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF764: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF768: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF76C: 3865F0E8  addi r3, r5, -0xf18
	ctx.r[3].s64 = ctx.r[5].s64 + -3864;
	// 825AF770: 38845240  addi r4, r4, 0x5240
	ctx.r[4].s64 = ctx.r[4].s64 + 21056;
	// 825AF774: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF778: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF780: 4BC7D751  bl 0x8222ced0
	ctx.lr = 0x825AF784;
	sub_8222CED0(ctx, base);
	// 825AF784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF788: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF78C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF790: 4BC7D741  bl 0x8222ced0
	ctx.lr = 0x825AF794;
	sub_8222CED0(ctx, base);
	// 825AF794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF798: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF79C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF7A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF7A4: 480030E5  bl 0x825b2888
	ctx.lr = 0x825AF7A8;
	sub_825B2888(ctx, base);
	// 825AF7A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF7AC: 4BC6562D  bl 0x82214dd8
	ctx.lr = 0x825AF7B0;
	sub_82214DD8(ctx, base);
	// 825AF7B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF7B4: 4BC65625  bl 0x82214dd8
	ctx.lr = 0x825AF7B8;
	sub_82214DD8(ctx, base);
	// 825AF7B8: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF7BC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF7C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF7C4: 392BF0F0  addi r9, r11, -0xf10
	ctx.r[9].s64 = ctx.r[11].s64 + -3856;
	// 825AF7C8: 388A5254  addi r4, r10, 0x5254
	ctx.r[4].s64 = ctx.r[10].s64 + 21076;
	// 825AF7CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF7D0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF7D8: 4BC7D6F9  bl 0x8222ced0
	ctx.lr = 0x825AF7DC;
	sub_8222CED0(ctx, base);
	// 825AF7DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF7E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF7E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF7E8: 4BC7D6E9  bl 0x8222ced0
	ctx.lr = 0x825AF7EC;
	sub_8222CED0(ctx, base);
	// 825AF7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF7F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF7F4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF7F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF7FC: 4800308D  bl 0x825b2888
	ctx.lr = 0x825AF800;
	sub_825B2888(ctx, base);
	// 825AF800: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF804: 4BC655D5  bl 0x82214dd8
	ctx.lr = 0x825AF808;
	sub_82214DD8(ctx, base);
	// 825AF808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF80C: 4BC655CD  bl 0x82214dd8
	ctx.lr = 0x825AF810;
	sub_82214DD8(ctx, base);
	// 825AF810: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF814: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF818: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF81C: 38C80E20  addi r6, r8, 0xe20
	ctx.r[6].s64 = ctx.r[8].s64 + 3616;
	// 825AF820: 38875268  addi r4, r7, 0x5268
	ctx.r[4].s64 = ctx.r[7].s64 + 21096;
	// 825AF824: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF828: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF830: 4BC7D6A1  bl 0x8222ced0
	ctx.lr = 0x825AF834;
	sub_8222CED0(ctx, base);
	// 825AF834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF838: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF83C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF840: 4BC7D691  bl 0x8222ced0
	ctx.lr = 0x825AF844;
	sub_8222CED0(ctx, base);
	// 825AF844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF848: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF84C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF850: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF854: 480023D5  bl 0x825b1c28
	ctx.lr = 0x825AF858;
	sub_825B1C28(ctx, base);
	// 825AF858: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF85C: 4BC6557D  bl 0x82214dd8
	ctx.lr = 0x825AF860;
	sub_82214DD8(ctx, base);
	// 825AF860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF864: 4BC65575  bl 0x82214dd8
	ctx.lr = 0x825AF868;
	sub_82214DD8(ctx, base);
	// 825AF868: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF86C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF870: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF874: 38650F58  addi r3, r5, 0xf58
	ctx.r[3].s64 = ctx.r[5].s64 + 3928;
	// 825AF878: 38845280  addi r4, r4, 0x5280
	ctx.r[4].s64 = ctx.r[4].s64 + 21120;
	// 825AF87C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF880: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF888: 4BC7D649  bl 0x8222ced0
	ctx.lr = 0x825AF88C;
	sub_8222CED0(ctx, base);
	// 825AF88C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF890: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF894: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF898: 4BC7D639  bl 0x8222ced0
	ctx.lr = 0x825AF89C;
	sub_8222CED0(ctx, base);
	// 825AF89C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF8A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF8A4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF8A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF8AC: 4800237D  bl 0x825b1c28
	ctx.lr = 0x825AF8B0;
	sub_825B1C28(ctx, base);
	// 825AF8B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF8B4: 4BC65525  bl 0x82214dd8
	ctx.lr = 0x825AF8B8;
	sub_82214DD8(ctx, base);
	// 825AF8B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF8BC: 4BC6551D  bl 0x82214dd8
	ctx.lr = 0x825AF8C0;
	sub_82214DD8(ctx, base);
	// 825AF8C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AF8C4: 486F9B98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF8C8 size=816
    let mut pc: u32 = 0x825AF8C8;
    'dispatch: loop {
        match pc {
            0x825AF8C8 => {
    //   block [0x825AF8C8..0x825AFBF8)
	// 825AF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF8CC: 486F9B39  bl 0x82ca9404
	ctx.lr = 0x825AF8D0;
	sub_82CA93D0(ctx, base);
	// 825AF8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF8D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825AF8D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AF8DC: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF8E0: 4BDDDBD9  bl 0x8238d4b8
	ctx.lr = 0x825AF8E4;
	sub_8238D4B8(ctx, base);
	// 825AF8E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF8E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825AF8EC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AF8F0: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825AF8F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AF8F8: 419A00F4  beq cr6, 0x825af9ec
	if ctx.cr[6].eq {
	pc = 0x825AF9EC; continue 'dispatch;
	}
	// 825AF8FC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AF900: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AF904: 419A0024  beq cr6, 0x825af928
	if ctx.cr[6].eq {
	pc = 0x825AF928; continue 'dispatch;
	}
	// 825AF908: 894A001F  lbz r10, 0x1f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 825AF90C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AF910: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AF914: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AF918: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF91C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF924: 480000D0  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
	// 825AF928: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AF92C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AF930: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825AF934: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AF938: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AF93C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AF940: 40810054  ble 0x825af994
	if !ctx.cr[0].gt {
	pc = 0x825AF994; continue 'dispatch;
	}
	// 825AF944: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AF948: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AF94C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AF950: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF954: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 825AF958: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AF95C: 41980008  blt cr6, 0x825af964
	if ctx.cr[6].lt {
	pc = 0x825AF964; continue 'dispatch;
	}
	// 825AF960: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825AF964: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AF968: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AF96C: 419A0014  beq cr6, 0x825af980
	if ctx.cr[6].eq {
	pc = 0x825AF980; continue 'dispatch;
	}
	// 825AF970: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AF974: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AF978: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AF97C: 4800000C  b 0x825af988
	pc = 0x825AF988; continue 'dispatch;
	// 825AF980: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AF984: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AF988: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AF98C: 4199FFB8  bgt cr6, 0x825af944
	if ctx.cr[6].gt {
	pc = 0x825AF944; continue 'dispatch;
	}
	// 825AF990: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AF994: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AF998: 419A0040  beq cr6, 0x825af9d8
	if ctx.cr[6].eq {
	pc = 0x825AF9D8; continue 'dispatch;
	}
	// 825AF99C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF9A0: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 825AF9A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9A8: 41990008  bgt cr6, 0x825af9b0
	if ctx.cr[6].gt {
	pc = 0x825AF9B0; continue 'dispatch;
	}
	// 825AF9AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825AF9B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AF9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF9B8: 409A0020  bne cr6, 0x825af9d8
	if !ctx.cr[6].eq {
	pc = 0x825AF9D8; continue 'dispatch;
	}
	// 825AF9BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AF9C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AF9C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AF9C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF9CC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF9D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9D4: 48000020  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
	// 825AF9D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AF9DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF9E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF9E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9E8: 4800000C  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
	// 825AF9EC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AF9F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825AF9F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AF9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF9FC: 419A0098  beq cr6, 0x825afa94
	if ctx.cr[6].eq {
	pc = 0x825AFA94; continue 'dispatch;
	}
	// 825AFA00: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825AFA04: 4BC6F855  bl 0x8221f258
	ctx.lr = 0x825AFA08;
	sub_8221F258(ctx, base);
	// 825AFA08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AFA0C: 419A001C  beq cr6, 0x825afa28
	if ctx.cr[6].eq {
	pc = 0x825AFA28; continue 'dispatch;
	}
	// 825AFA10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AFA14: 93830004  stw r28, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825AFA18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AFA1C: 394B0E0C  addi r10, r11, 0xe0c
	ctx.r[10].s64 = ctx.r[11].s64 + 3596;
	// 825AFA20: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825AFA24: 48000008  b 0x825afa2c
	pc = 0x825AFA2C; continue 'dispatch;
	// 825AFA28: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825AFA2C: 3BFB0048  addi r31, r27, 0x48
	ctx.r[31].s64 = ctx.r[27].s64 + 72;
	// 825AFA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFA34: 4BC080E5  bl 0x821b7b18
	ctx.lr = 0x825AFA38;
	sub_821B7B18(ctx, base);
	// 825AFA38: 93DB0048  stw r30, 0x48(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 825AFA3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AFA40: 419A0040  beq cr6, 0x825afa80
	if ctx.cr[6].eq {
	pc = 0x825AFA80; continue 'dispatch;
	}
	// 825AFA44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825AFA48: 4BC6F811  bl 0x8221f258
	ctx.lr = 0x825AFA4C;
	sub_8221F258(ctx, base);
	// 825AFA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AFA50: 419A0028  beq cr6, 0x825afa78
	if ctx.cr[6].eq {
	pc = 0x825AFA78; continue 'dispatch;
	}
	// 825AFA54: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFA58: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 825AFA5C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AFA60: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 825AFA64: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825AFA68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AFA6C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825AFA70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825AFA74: 48000008  b 0x825afa7c
	pc = 0x825AFA7C; continue 'dispatch;
	// 825AFA78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825AFA7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AFA80: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 825AFA84: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFA88: 38BB000C  addi r5, r27, 0xc
	ctx.r[5].s64 = ctx.r[27].s64 + 12;
	// 825AFA8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AFA90: 48015539  bl 0x825c4fc8
	ctx.lr = 0x825AFA94;
	sub_825C4FC8(ctx, base);
	// 825AFA94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFA98: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825AFA9C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AFAA0: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 825AFAA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AFAA8: 419A00E8  beq cr6, 0x825afb90
	if ctx.cr[6].eq {
	pc = 0x825AFB90; continue 'dispatch;
	}
	// 825AFAAC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFAB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFAB4: 419A0020  beq cr6, 0x825afad4
	if ctx.cr[6].eq {
	pc = 0x825AFAD4; continue 'dispatch;
	}
	// 825AFAB8: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825AFABC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFAC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AFAC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AFAC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFACC: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFAD0: 480000C4  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
	// 825AFAD4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFAD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFADC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825AFAE0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFAE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFAE8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFAEC: 40810054  ble 0x825afb40
	if !ctx.cr[0].gt {
	pc = 0x825AFB40; continue 'dispatch;
	}
	// 825AFAF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFAF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFAF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFAFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFB00: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825AFB04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFB08: 41980008  blt cr6, 0x825afb10
	if ctx.cr[6].lt {
	pc = 0x825AFB10; continue 'dispatch;
	}
	// 825AFB0C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825AFB10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFB14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFB18: 419A0014  beq cr6, 0x825afb2c
	if ctx.cr[6].eq {
	pc = 0x825AFB2C; continue 'dispatch;
	}
	// 825AFB1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFB20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFB24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFB28: 4800000C  b 0x825afb34
	pc = 0x825AFB34; continue 'dispatch;
	// 825AFB2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFB30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AFB34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFB38: 4199FFB8  bgt cr6, 0x825afaf0
	if ctx.cr[6].gt {
	pc = 0x825AFAF0; continue 'dispatch;
	}
	// 825AFB3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFB40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFB44: 419A003C  beq cr6, 0x825afb80
	if ctx.cr[6].eq {
	pc = 0x825AFB80; continue 'dispatch;
	}
	// 825AFB48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFB4C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825AFB50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB54: 41990008  bgt cr6, 0x825afb5c
	if ctx.cr[6].gt {
	pc = 0x825AFB5C; continue 'dispatch;
	}
	// 825AFB58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825AFB5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFB64: 409A001C  bne cr6, 0x825afb80
	if !ctx.cr[6].eq {
	pc = 0x825AFB80; continue 'dispatch;
	}
	// 825AFB68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFB6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFB70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFB74: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFB78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB7C: 48000018  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
	// 825AFB80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFB84: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFB88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB8C: 48000008  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
	// 825AFB90: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825AFB94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFB9C: 419A0054  beq cr6, 0x825afbf0
	if ctx.cr[6].eq {
	pc = 0x825AFBF0; continue 'dispatch;
	}
	// 825AFBA0: 38DB0010  addi r6, r27, 0x10
	ctx.r[6].s64 = ctx.r[27].s64 + 16;
	// 825AFBA4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825AFBA8: 389B0050  addi r4, r27, 0x50
	ctx.r[4].s64 = ctx.r[27].s64 + 80;
	// 825AFBAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFBB0: 4BFCDE29  bl 0x8257d9d8
	ctx.lr = 0x825AFBB4;
	sub_8257D9D8(ctx, base);
	// 825AFBB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825AFBB8: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBBC: 388BC254  addi r4, r11, -0x3dac
	ctx.r[4].s64 = ctx.r[11].s64 + -15788;
	// 825AFBC0: 4BC05949  bl 0x821b5508
	ctx.lr = 0x825AFBC4;
	sub_821B5508(ctx, base);
	// 825AFBC4: 907B0020  stw r3, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 825AFBC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 825AFBCC: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBD0: 388AC258  addi r4, r10, -0x3da8
	ctx.r[4].s64 = ctx.r[10].s64 + -15784;
	// 825AFBD4: 4BC05935  bl 0x821b5508
	ctx.lr = 0x825AFBD8;
	sub_821B5508(ctx, base);
	// 825AFBD8: 907B002C  stw r3, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 825AFBDC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 825AFBE0: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBE4: 3889C250  addi r4, r9, -0x3db0
	ctx.r[4].s64 = ctx.r[9].s64 + -15792;
	// 825AFBE8: 4BC05921  bl 0x821b5508
	ctx.lr = 0x825AFBEC;
	sub_821B5508(ctx, base);
	// 825AFBEC: 907B0038  stw r3, 0x38(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 825AFBF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AFBF4: 486F9860  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AFBF8 size=44
    let mut pc: u32 = 0x825AFBF8;
    'dispatch: loop {
        match pc {
            0x825AFBF8 => {
    //   block [0x825AFBF8..0x825AFC24)
	// 825AFBF8: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 825AFBFC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825AFC00: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 825AFC04: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 825AFC08: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFC0C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825AFC10: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825AFC14: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825AFC18: FD6C0024  fdiv f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 / ctx.f[0].f64;
	// 825AFC1C: FC205818  frsp f1, f11
	ctx.f[1].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825AFC20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AFC28 size=696
    let mut pc: u32 = 0x825AFC28;
    'dispatch: loop {
        match pc {
            0x825AFC28 => {
    //   block [0x825AFC28..0x825AFEE0)
	// 825AFC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFC2C: 486F97E1  bl 0x82ca940c
	ctx.lr = 0x825AFC30;
	sub_82CA93D0(ctx, base);
	// 825AFC30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFC34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AFC38: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825AFC3C: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFC40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFC44: 419A000C  beq cr6, 0x825afc50
	if ctx.cr[6].eq {
	pc = 0x825AFC50; continue 'dispatch;
	}
	// 825AFC48: 93DD0060  stw r30, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825AFC4C: 4800170D  bl 0x825b1358
	ctx.lr = 0x825AFC50;
	sub_825B1358(ctx, base);
	// 825AFC50: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AFC54: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFC58: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 825AFC5C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 825AFC60: 913D0074  stw r9, 0x74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 825AFC64: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AFC68: D01D0078  stfs f0, 0x78(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825AFC6C: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AFC70: 5507FFFE  rlwinm r7, r8, 0x1f, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825AFC74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFC78: 419A00F4  beq cr6, 0x825afd6c
	if ctx.cr[6].eq {
	pc = 0x825AFD6C; continue 'dispatch;
	}
	// 825AFC7C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFC80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFC84: 419A0024  beq cr6, 0x825afca8
	if ctx.cr[6].eq {
	pc = 0x825AFCA8; continue 'dispatch;
	}
	// 825AFC88: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 825AFC8C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFC90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AFC94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AFC98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFC9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFCA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFCA4: 480000CC  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
	// 825AFCA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFCAC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFCB0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825AFCB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFCB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFCBC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFCC0: 40810054  ble 0x825afd14
	if !ctx.cr[0].gt {
	pc = 0x825AFD14; continue 'dispatch;
	}
	// 825AFCC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFCC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFCCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFCD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFCD4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825AFCD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFCDC: 41980008  blt cr6, 0x825afce4
	if ctx.cr[6].lt {
	pc = 0x825AFCE4; continue 'dispatch;
	}
	// 825AFCE0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825AFCE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFCE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFCEC: 419A0014  beq cr6, 0x825afd00
	if ctx.cr[6].eq {
	pc = 0x825AFD00; continue 'dispatch;
	}
	// 825AFCF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFCF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFCF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFCFC: 4800000C  b 0x825afd08
	pc = 0x825AFD08; continue 'dispatch;
	// 825AFD00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFD04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AFD08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFD0C: 4199FFB8  bgt cr6, 0x825afcc4
	if ctx.cr[6].gt {
	pc = 0x825AFCC4; continue 'dispatch;
	}
	// 825AFD10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFD14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFD18: 419A0040  beq cr6, 0x825afd58
	if ctx.cr[6].eq {
	pc = 0x825AFD58; continue 'dispatch;
	}
	// 825AFD1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFD20: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825AFD24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD28: 41990008  bgt cr6, 0x825afd30
	if ctx.cr[6].gt {
	pc = 0x825AFD30; continue 'dispatch;
	}
	// 825AFD2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AFD30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFD38: 409A0020  bne cr6, 0x825afd58
	if !ctx.cr[6].eq {
	pc = 0x825AFD58; continue 'dispatch;
	}
	// 825AFD3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFD40: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFD44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFD48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFD50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD54: 4800001C  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
	// 825AFD58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFD5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFD64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD68: 48000008  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
	// 825AFD6C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AFD70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFD78: 419A001C  beq cr6, 0x825afd94
	if ctx.cr[6].eq {
	pc = 0x825AFD94; continue 'dispatch;
	}
	// 825AFD7C: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 825AFD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFD84: 4BE3A13D  bl 0x823e9ec0
	ctx.lr = 0x825AFD88;
	sub_823E9EC0(ctx, base);
	// 825AFD88: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AFD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFD90: 4BE39F01  bl 0x823e9c90
	ctx.lr = 0x825AFD94;
	sub_823E9C90(ctx, base);
	// 825AFD94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD98: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AFD9C: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 825AFDA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AFDA4: 419A00F4  beq cr6, 0x825afe98
	if ctx.cr[6].eq {
	pc = 0x825AFE98; continue 'dispatch;
	}
	// 825AFDA8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFDAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFDB0: 419A0024  beq cr6, 0x825afdd4
	if ctx.cr[6].eq {
	pc = 0x825AFDD4; continue 'dispatch;
	}
	// 825AFDB4: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AFDB8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFDBC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825AFDC0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825AFDC4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFDC8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFDCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFDD0: 480000D0  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
	// 825AFDD4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFDD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFDDC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825AFDE0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFDE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFDE8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFDEC: 40810054  ble 0x825afe40
	if !ctx.cr[0].gt {
	pc = 0x825AFE40; continue 'dispatch;
	}
	// 825AFDF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFDF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFDF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFDFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFE00: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AFE04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFE08: 41980008  blt cr6, 0x825afe10
	if ctx.cr[6].lt {
	pc = 0x825AFE10; continue 'dispatch;
	}
	// 825AFE0C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825AFE10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFE14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFE18: 419A0014  beq cr6, 0x825afe2c
	if ctx.cr[6].eq {
	pc = 0x825AFE2C; continue 'dispatch;
	}
	// 825AFE1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFE20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFE24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFE28: 4800000C  b 0x825afe34
	pc = 0x825AFE34; continue 'dispatch;
	// 825AFE2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFE30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825AFE34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFE38: 4199FFB8  bgt cr6, 0x825afdf0
	if ctx.cr[6].gt {
	pc = 0x825AFDF0; continue 'dispatch;
	}
	// 825AFE3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFE40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFE44: 419A0040  beq cr6, 0x825afe84
	if ctx.cr[6].eq {
	pc = 0x825AFE84; continue 'dispatch;
	}
	// 825AFE48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFE4C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AFE50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE54: 41990008  bgt cr6, 0x825afe5c
	if ctx.cr[6].gt {
	pc = 0x825AFE5C; continue 'dispatch;
	}
	// 825AFE58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AFE5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFE64: 409A0020  bne cr6, 0x825afe84
	if !ctx.cr[6].eq {
	pc = 0x825AFE84; continue 'dispatch;
	}
	// 825AFE68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFE6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFE70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFE74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFE78: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFE7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE80: 48000020  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
	// 825AFE84: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFE88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFE8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFE90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE94: 4800000C  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
	// 825AFE98: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AFE9C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AFEA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFEA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFEA8: 419A0028  beq cr6, 0x825afed0
	if ctx.cr[6].eq {
	pc = 0x825AFED0; continue 'dispatch;
	}
	// 825AFEAC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825AFEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFEB4: 4BC4F715  bl 0x821ff5c8
	ctx.lr = 0x825AFEB8;
	sub_821FF5C8(ctx, base);
	// 825AFEB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AFEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFEC0: 419A0010  beq cr6, 0x825afed0
	if ctx.cr[6].eq {
	pc = 0x825AFED0; continue 'dispatch;
	}
	// 825AFEC4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825AFEC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFECC: 4BE703D5  bl 0x824202a0
	ctx.lr = 0x825AFED0;
	sub_824202A0(ctx, base);
	// 825AFED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AFED4: 480009FD  bl 0x825b08d0
	ctx.lr = 0x825AFED8;
	sub_825B08D0(ctx, base);
	// 825AFED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AFEDC: 486F9580  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AFEE0 size=20
    let mut pc: u32 = 0x825AFEE0;
    'dispatch: loop {
        match pc {
            0x825AFEE0 => {
    //   block [0x825AFEE0..0x825AFEF4)
	// 825AFEE0: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFEE4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825AFEE8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825AFEEC: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 825AFEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFEF8 size=68
    let mut pc: u32 = 0x825AFEF8;
    'dispatch: loop {
        match pc {
            0x825AFEF8 => {
    //   block [0x825AFEF8..0x825AFF3C)
	// 825AFEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFF04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFF0C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFF10: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825AFF14: 419A000C  beq cr6, 0x825aff20
	if ctx.cr[6].eq {
	pc = 0x825AFF20; continue 'dispatch;
	}
	// 825AFF18: 909F0060  stw r4, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 825AFF1C: 4800143D  bl 0x825b1358
	ctx.lr = 0x825AFF20;
	sub_825B1358(ctx, base);
	// 825AFF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFF24: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFF40 size=100
    let mut pc: u32 = 0x825AFF40;
    'dispatch: loop {
        match pc {
            0x825AFF40 => {
    //   block [0x825AFF40..0x825AFFA4)
	// 825AFF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFF4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFF54: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFF58: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825AFF5C: 419A002C  beq cr6, 0x825aff88
	if ctx.cr[6].eq {
	pc = 0x825AFF88; continue 'dispatch;
	}
	// 825AFF60: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825AFF64: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AFF68: 480013F1  bl 0x825b1358
	ctx.lr = 0x825AFF6C;
	sub_825B1358(ctx, base);
	// 825AFF6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AFF70: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825AFF74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFF84: 4E800020  blr
	return;
	// 825AFF88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFF8C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFF90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFFA8 size=100
    let mut pc: u32 = 0x825AFFA8;
    'dispatch: loop {
        match pc {
            0x825AFFA8 => {
    //   block [0x825AFFA8..0x825B000C)
	// 825AFFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFFB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFFB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFFBC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFFC0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 825AFFC4: 419A002C  beq cr6, 0x825afff0
	if ctx.cr[6].eq {
	pc = 0x825AFFF0; continue 'dispatch;
	}
	// 825AFFC8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 825AFFCC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AFFD0: 48001389  bl 0x825b1358
	ctx.lr = 0x825AFFD4;
	sub_825B1358(ctx, base);
	// 825AFFD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AFFD8: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825AFFDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFFE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFFEC: 4E800020  blr
	return;
	// 825AFFF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFFF4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0010 size=100
    let mut pc: u32 = 0x825B0010;
    'dispatch: loop {
        match pc {
            0x825B0010 => {
    //   block [0x825B0010..0x825B0074)
	// 825B0010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B001C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B0024: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B0028: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825B002C: 419A002C  beq cr6, 0x825b0058
	if ctx.cr[6].eq {
	pc = 0x825B0058; continue 'dispatch;
	}
	// 825B0030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0034: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B0038: 48001321  bl 0x825b1358
	ctx.lr = 0x825B003C;
	sub_825B1358(ctx, base);
	// 825B003C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0040: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825B0044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B0048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B004C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0054: 4E800020  blr
	return;
	// 825B0058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B005C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B0060: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B0064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B006C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0078 size=52
    let mut pc: u32 = 0x825B0078;
    'dispatch: loop {
        match pc {
            0x825B0078 => {
    //   block [0x825B0078..0x825B00AC)
	// 825B0078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B007C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B0084: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B008C: 4BFFFB9D  bl 0x825afc28
	ctx.lr = 0x825B0090;
	sub_825AFC28(ctx, base);
	// 825B0090: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 825B0094: 48464CFD  bl 0x82a14d90
	ctx.lr = 0x825B0098;
	sub_82A14D90(ctx, base);
	// 825B0098: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B009C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B00A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B00A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B00A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B00B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B00B0 size=56
    let mut pc: u32 = 0x825B00B0;
    'dispatch: loop {
        match pc {
            0x825B00B0 => {
    //   block [0x825B00B0..0x825B00E8)
	// 825B00B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B00B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B00B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B00BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B00C0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B00C4: 4BCEC55D  bl 0x8229c620
	ctx.lr = 0x825B00C8;
	sub_8229C620(ctx, base);
	// 825B00C8: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 825B00CC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B00D0: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825B00D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B00D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B00DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B00E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B00E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B00E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B00E8 size=88
    let mut pc: u32 = 0x825B00E8;
    'dispatch: loop {
        match pc {
            0x825B00E8 => {
    //   block [0x825B00E8..0x825B0140)
	// 825B00E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B00EC: 8103006C  lwz r8, 0x6c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B00F0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825B00F4: 39230068  addi r9, r3, 0x68
	ctx.r[9].s64 = ctx.r[3].s64 + 104;
	// 825B00F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B00FC: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 825B0100: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825B0104: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0108: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B010C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0110: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825B0114: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 825B0118: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B011C: 7CA65050  subf r5, r6, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825B0120: 7CAAFE70  srawi r10, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 825B0124: 7D472838  and r7, r10, r5
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[5].u64;
	// 825B0128: 7CE72850  subf r7, r7, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 825B012C: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B0130: 419A0008  beq cr6, 0x825b0138
	if ctx.cr[6].eq {
	pc = 0x825B0138; continue 'dispatch;
	}
	// 825B0134: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0138: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B013C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0140 size=72
    let mut pc: u32 = 0x825B0140;
    'dispatch: loop {
        match pc {
            0x825B0140 => {
    //   block [0x825B0140..0x825B0188)
	// 825B0140: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0144: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0148: 409A0008  bne cr6, 0x825b0150
	if !ctx.cr[6].eq {
	pc = 0x825B0150; continue 'dispatch;
	}
	// 825B014C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0150: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B0154: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 825B0158: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825B015C: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B0160: 40990014  ble cr6, 0x825b0174
	if !ctx.cr[6].gt {
	pc = 0x825B0174; continue 'dispatch;
	}
	// 825B0164: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B0168: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B016C: 419A0008  beq cr6, 0x825b0174
	if ctx.cr[6].eq {
	pc = 0x825B0174; continue 'dispatch;
	}
	// 825B0170: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 825B0174: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0178: 409A0008  bne cr6, 0x825b0180
	if !ctx.cr[6].eq {
	pc = 0x825B0180; continue 'dispatch;
	}
	// 825B017C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0184: 4BFFFFA8  b 0x825b012c
	sub_825B00E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0188 size=4
    let mut pc: u32 = 0x825B0188;
    'dispatch: loop {
        match pc {
            0x825B0188 => {
    //   block [0x825B0188..0x825B018C)
	// 825B0188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0190 size=88
    let mut pc: u32 = 0x825B0190;
    'dispatch: loop {
        match pc {
            0x825B0190 => {
    //   block [0x825B0190..0x825B01E8)
	// 825B0190: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0194: 8103006C  lwz r8, 0x6c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B0198: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825B019C: 39230068  addi r9, r3, 0x68
	ctx.r[9].s64 = ctx.r[3].s64 + 104;
	// 825B01A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B01A4: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 825B01A8: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825B01AC: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B01B0: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B01B4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B01B8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825B01BC: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 825B01C0: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B01C4: 7CA65050  subf r5, r6, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825B01C8: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 825B01CC: 7C8A2838  and r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 & ctx.r[5].u64;
	// 825B01D0: 7CEA2850  subf r7, r10, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 825B01D4: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B01D8: 419A0008  beq cr6, 0x825b01e0
	if ctx.cr[6].eq {
	pc = 0x825B01E0; continue 'dispatch;
	}
	// 825B01DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B01E0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B01E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B01E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B01E8 size=60
    let mut pc: u32 = 0x825B01E8;
    'dispatch: loop {
        match pc {
            0x825B01E8 => {
    //   block [0x825B01E8..0x825B0224)
	// 825B01E8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B01EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B01F0: 409A0008  bne cr6, 0x825b01f8
	if !ctx.cr[6].eq {
	pc = 0x825B01F8; continue 'dispatch;
	}
	// 825B01F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B01F8: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B01FC: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 825B0200: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825B0204: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B0208: 40990008  ble cr6, 0x825b0210
	if !ctx.cr[6].gt {
	pc = 0x825B0210; continue 'dispatch;
	}
	// 825B020C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 825B0210: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0214: 409A0008  bne cr6, 0x825b021c
	if !ctx.cr[6].eq {
	pc = 0x825B021C; continue 'dispatch;
	}
	// 825B0218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B021C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0220: 4BFFFFB4  b 0x825b01d4
	sub_825B0190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0224(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0224 size=4
    let mut pc: u32 = 0x825B0224;
    'dispatch: loop {
        match pc {
            0x825B0224 => {
    //   block [0x825B0224..0x825B0228)
	// 825B0224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0228 size=672
    let mut pc: u32 = 0x825B0228;
    'dispatch: loop {
        match pc {
            0x825B0228 => {
    //   block [0x825B0228..0x825B04C8)
	// 825B0228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B022C: 486F91E1  bl 0x82ca940c
	ctx.lr = 0x825B0230;
	sub_82CA93D0(ctx, base);
	// 825B0230: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0234: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B0238: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B023C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0240: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0244: 409A027C  bne cr6, 0x825b04c0
	if !ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B0248: 897E001A  lbz r11, 0x1a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(26 as u32) ) } as u64;
	// 825B024C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0250: 419A0050  beq cr6, 0x825b02a0
	if ctx.cr[6].eq {
	pc = 0x825B02A0; continue 'dispatch;
	}
	// 825B0254: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 825B0258: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B025C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B0260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0264: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B0268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B026C: 4BC7CC65  bl 0x8222ced0
	ctx.lr = 0x825B0270;
	sub_8222CED0(ctx, base);
	// 825B0270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0274: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B0278: 4BBEC371  bl 0x8219c5e8
	ctx.lr = 0x825B027C;
	sub_8219C5E8(ctx, base);
	// 825B027C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B0280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0284: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0288: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B028C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0290: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B0294: 4BC64B45  bl 0x82214dd8
	ctx.lr = 0x825B0298;
	sub_82214DD8(ctx, base);
	// 825B0298: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B029C: 486F91C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 825B02A0: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 825B02A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B02A8: 409A0218  bne cr6, 0x825b04c0
	if !ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B02AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825B02B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B02B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B02B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B02BC: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B02C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B02C4: 4BC7CC0D  bl 0x8222ced0
	ctx.lr = 0x825B02C8;
	sub_8222CED0(ctx, base);
	// 825B02C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B02CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B02D0: 4BBEC319  bl 0x8219c5e8
	ctx.lr = 0x825B02D4;
	sub_8219C5E8(ctx, base);
	// 825B02D4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B02D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B02DC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B02E0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B02E4: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B02E8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B02EC: 4BC64AED  bl 0x82214dd8
	ctx.lr = 0x825B02F0;
	sub_82214DD8(ctx, base);
	// 825B02F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B02F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B02F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B02FC: 419A0038  beq cr6, 0x825b0334
	if ctx.cr[6].eq {
	pc = 0x825B0334; continue 'dispatch;
	}
	// 825B0300: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0308: 419A0080  beq cr6, 0x825b0388
	if ctx.cr[6].eq {
	pc = 0x825B0388; continue 'dispatch;
	}
	// 825B030C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0314: 419A0020  beq cr6, 0x825b0334
	if ctx.cr[6].eq {
	pc = 0x825B0334; continue 'dispatch;
	}
	// 825B0318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B031C: 4BBC3B1D  bl 0x82173e38
	ctx.lr = 0x825B0320;
	sub_82173E38(ctx, base);
	// 825B0320: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B0324: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B032C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0330: 409A0008  bne cr6, 0x825b0338
	if !ctx.cr[6].eq {
	pc = 0x825B0338; continue 'dispatch;
	}
	// 825B0334: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B0338: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B033C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0340: 419A0180  beq cr6, 0x825b04c0
	if ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B0344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0348: 4BBC3AF1  bl 0x82173e38
	ctx.lr = 0x825B034C;
	sub_82173E38(ctx, base);
	// 825B034C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0350: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 825B0354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0358: 419A0100  beq cr6, 0x825b0458
	if ctx.cr[6].eq {
	pc = 0x825B0458; continue 'dispatch;
	}
	// 825B035C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0364: 419A0030  beq cr6, 0x825b0394
	if ctx.cr[6].eq {
	pc = 0x825B0394; continue 'dispatch;
	}
	// 825B0368: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 825B036C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0370: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0374: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0378: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B037C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0380: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0384: 480000DC  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
	// 825B0388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B038C: 4BBE3AAD  bl 0x82193e38
	ctx.lr = 0x825B0390;
	sub_82193E38(ctx, base);
	// 825B0390: 4BFFFFA4  b 0x825b0334
	pc = 0x825B0334; continue 'dispatch;
	// 825B0394: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0398: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B039C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B03A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B03A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B03A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B03AC: 40810054  ble 0x825b0400
	if !ctx.cr[0].gt {
	pc = 0x825B0400; continue 'dispatch;
	}
	// 825B03B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B03B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B03B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B03BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B03C0: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825B03C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B03C8: 41980008  blt cr6, 0x825b03d0
	if ctx.cr[6].lt {
	pc = 0x825B03D0; continue 'dispatch;
	}
	// 825B03CC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825B03D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B03D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B03D8: 419A0014  beq cr6, 0x825b03ec
	if ctx.cr[6].eq {
	pc = 0x825B03EC; continue 'dispatch;
	}
	// 825B03DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B03E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B03E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B03E8: 4800000C  b 0x825b03f4
	pc = 0x825B03F4; continue 'dispatch;
	// 825B03EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B03F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825B03F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B03F8: 4199FFB8  bgt cr6, 0x825b03b0
	if ctx.cr[6].gt {
	pc = 0x825B03B0; continue 'dispatch;
	}
	// 825B03FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B0400: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B0404: 419A0040  beq cr6, 0x825b0444
	if ctx.cr[6].eq {
	pc = 0x825B0444; continue 'dispatch;
	}
	// 825B0408: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B040C: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825B0410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0414: 41990008  bgt cr6, 0x825b041c
	if ctx.cr[6].gt {
	pc = 0x825B041C; continue 'dispatch;
	}
	// 825B0418: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B041C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0424: 409A0020  bne cr6, 0x825b0444
	if !ctx.cr[6].eq {
	pc = 0x825B0444; continue 'dispatch;
	}
	// 825B0428: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B042C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B0430: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0438: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B043C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0440: 48000020  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
	// 825B0444: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0448: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B044C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0450: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0454: 4800000C  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
	// 825B0458: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B045C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B0460: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0468: 419A0058  beq cr6, 0x825b04c0
	if ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B046C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825B0470: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B0478: 48160C29  bl 0x827110a0
	ctx.lr = 0x825B047C;
	sub_827110A0(ctx, base);
	// 825B047C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B0480: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B0484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0488: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B048C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B0490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B0494: 4E800421  bctrl
	ctx.lr = 0x825B0498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B0498: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B049C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B04A0: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 825B04A4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B04A8: 4BBE3991  bl 0x82193e38
	ctx.lr = 0x825B04AC;
	sub_82193E38(ctx, base);
	// 825B04AC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825B04B0: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825B04B4: 4BC64925  bl 0x82214dd8
	ctx.lr = 0x825B04B8;
	sub_82214DD8(ctx, base);
	// 825B04B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B04BC: 4BBFC675  bl 0x821acb30
	ctx.lr = 0x825B04C0;
	sub_821ACB30(ctx, base);
	// 825B04C0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B04C4: 486F8F98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B04C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B04C8 size=316
    let mut pc: u32 = 0x825B04C8;
    'dispatch: loop {
        match pc {
            0x825B04C8 => {
    //   block [0x825B04C8..0x825B0604)
	// 825B04C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B04CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B04D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B04D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B04D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B04DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B04E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B04E4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B04E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B04EC: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B04F0: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B04F4: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825B04F8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825B04FC: 409A000C  bne cr6, 0x825b0508
	if !ctx.cr[6].eq {
	pc = 0x825B0508; continue 'dispatch;
	}
	// 825B0500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0504: 4BFFFD25  bl 0x825b0228
	ctx.lr = 0x825B0508;
	sub_825B0228(ctx, base);
	// 825B0508: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B050C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0510: 419A000C  beq cr6, 0x825b051c
	if ctx.cr[6].eq {
	pc = 0x825B051C; continue 'dispatch;
	}
	// 825B0514: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B0518: 409A0048  bne cr6, 0x825b0560
	if !ctx.cr[6].eq {
	pc = 0x825B0560; continue 'dispatch;
	}
	// 825B051C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 825B0520: 894BEAEB  lbz r10, -0x1515(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5397 as u32) ) } as u64;
	// 825B0524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0528: 409A0030  bne cr6, 0x825b0558
	if !ctx.cr[6].eq {
	pc = 0x825B0558; continue 'dispatch;
	}
	// 825B052C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B0530: 809EFFF8  lwz r4, -8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0534: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B0538: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B053C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B0540: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0544: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0548: 4BC82231  bl 0x82232778
	ctx.lr = 0x825B054C;
	sub_82232778(ctx, base);
	// 825B054C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0550: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0554: 409A000C  bne cr6, 0x825b0560
	if !ctx.cr[6].eq {
	pc = 0x825B0560; continue 'dispatch;
	}
	// 825B0558: 387EFFF4  addi r3, r30, -0xc
	ctx.r[3].s64 = ctx.r[30].s64 + -12;
	// 825B055C: 4BFFF6CD  bl 0x825afc28
	ctx.lr = 0x825B0560;
	sub_825AFC28(ctx, base);
	// 825B0560: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B0564: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 825B0568: 409A0054  bne cr6, 0x825b05bc
	if !ctx.cr[6].eq {
	pc = 0x825B05BC; continue 'dispatch;
	}
	// 825B056C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B0570: 3BFE005C  addi r31, r30, 0x5c
	ctx.r[31].s64 = ctx.r[30].s64 + 92;
	// 825B0574: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B0578: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B057C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B0580: 409A0008  bne cr6, 0x825b0588
	if !ctx.cr[6].eq {
	pc = 0x825B0588; continue 'dispatch;
	}
	// 825B0584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0588: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B058C: 419A0030  beq cr6, 0x825b05bc
	if ctx.cr[6].eq {
	pc = 0x825B05BC; continue 'dispatch;
	}
	// 825B0590: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0594: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B0598: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B059C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B05A0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B05A4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B05A8: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825B05AC: 4BC6B78D  bl 0x8221bd38
	ctx.lr = 0x825B05B0;
	sub_8221BD38(ctx, base);
	// 825B05B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B05B4: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 825B05B8: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825B05BC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B05C0: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B05C4: 813E0060  lwz r9, 0x60(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B05C8: 387E005C  addi r3, r30, 0x5c
	ctx.r[3].s64 = ctx.r[30].s64 + 92;
	// 825B05CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825B05D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825B05D4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B05D8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B05DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B05E0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B05E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B05E8: 480D35B9  bl 0x82683ba0
	ctx.lr = 0x825B05EC;
	sub_82683BA0(ctx, base);
	// 825B05EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B05F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B05F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B05F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B05FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0608 size=712
    let mut pc: u32 = 0x825B0608;
    'dispatch: loop {
        match pc {
            0x825B0608 => {
    //   block [0x825B0608..0x825B08D0)
	// 825B0608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B060C: 486F8E01  bl 0x82ca940c
	ctx.lr = 0x825B0610;
	sub_82CA93D0(ctx, base);
	// 825B0610: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0614: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B0618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B061C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B0620: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0624: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825B0628: 409A0010  bne cr6, 0x825b0638
	if !ctx.cr[6].eq {
	pc = 0x825B0638; continue 'dispatch;
	}
	// 825B062C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0634: 4BFFFBF5  bl 0x825b0228
	ctx.lr = 0x825B0638;
	sub_825B0228(ctx, base);
	// 825B0638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B063C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0640: 409A0288  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0644: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0648: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825B064C: 409A027C  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0650: 897E001A  lbz r11, 0x1a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(26 as u32) ) } as u64;
	// 825B0654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0658: 419A0050  beq cr6, 0x825b06a8
	if ctx.cr[6].eq {
	pc = 0x825B06A8; continue 'dispatch;
	}
	// 825B065C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 825B0660: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B0664: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B0668: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B066C: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B0670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0674: 4BC7C85D  bl 0x8222ced0
	ctx.lr = 0x825B0678;
	sub_8222CED0(ctx, base);
	// 825B0678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B067C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B0680: 4BBEBF69  bl 0x8219c5e8
	ctx.lr = 0x825B0684;
	sub_8219C5E8(ctx, base);
	// 825B0684: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B0688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B068C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0690: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B0694: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0698: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B069C: 4BC6473D  bl 0x82214dd8
	ctx.lr = 0x825B06A0;
	sub_82214DD8(ctx, base);
	// 825B06A0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B06A4: 486F8DB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 825B06A8: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 825B06AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B06B0: 409A0218  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B06B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B06B8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B06BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B06C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B06C4: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B06C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B06CC: 4BC7C805  bl 0x8222ced0
	ctx.lr = 0x825B06D0;
	sub_8222CED0(ctx, base);
	// 825B06D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B06D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B06D8: 4BBEBF11  bl 0x8219c5e8
	ctx.lr = 0x825B06DC;
	sub_8219C5E8(ctx, base);
	// 825B06DC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B06E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B06E4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B06E8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B06EC: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06F0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B06F4: 4BC646E5  bl 0x82214dd8
	ctx.lr = 0x825B06F8;
	sub_82214DD8(ctx, base);
	// 825B06F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B0700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0704: 419A0038  beq cr6, 0x825b073c
	if ctx.cr[6].eq {
	pc = 0x825B073C; continue 'dispatch;
	}
	// 825B0708: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B070C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0710: 419A0080  beq cr6, 0x825b0790
	if ctx.cr[6].eq {
	pc = 0x825B0790; continue 'dispatch;
	}
	// 825B0714: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B071C: 419A0020  beq cr6, 0x825b073c
	if ctx.cr[6].eq {
	pc = 0x825B073C; continue 'dispatch;
	}
	// 825B0720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0724: 4BBC3715  bl 0x82173e38
	ctx.lr = 0x825B0728;
	sub_82173E38(ctx, base);
	// 825B0728: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B072C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0734: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0738: 409A0008  bne cr6, 0x825b0740
	if !ctx.cr[6].eq {
	pc = 0x825B0740; continue 'dispatch;
	}
	// 825B073C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B0740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0748: 419A0180  beq cr6, 0x825b08c8
	if ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B074C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0750: 4BBC36E9  bl 0x82173e38
	ctx.lr = 0x825B0754;
	sub_82173E38(ctx, base);
	// 825B0754: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0758: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 825B075C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0760: 419A0100  beq cr6, 0x825b0860
	if ctx.cr[6].eq {
	pc = 0x825B0860; continue 'dispatch;
	}
	// 825B0764: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B076C: 419A0030  beq cr6, 0x825b079c
	if ctx.cr[6].eq {
	pc = 0x825B079C; continue 'dispatch;
	}
	// 825B0770: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 825B0774: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0778: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B077C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0780: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0784: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B078C: 480000DC  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
	// 825B0790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0794: 4BBE36A5  bl 0x82193e38
	ctx.lr = 0x825B0798;
	sub_82193E38(ctx, base);
	// 825B0798: 4BFFFFA4  b 0x825b073c
	pc = 0x825B073C; continue 'dispatch;
	// 825B079C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B07A0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B07A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B07A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B07AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B07B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B07B4: 40810054  ble 0x825b0808
	if !ctx.cr[0].gt {
	pc = 0x825B0808; continue 'dispatch;
	}
	// 825B07B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B07BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B07C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B07C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B07C8: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825B07CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B07D0: 41980008  blt cr6, 0x825b07d8
	if ctx.cr[6].lt {
	pc = 0x825B07D8; continue 'dispatch;
	}
	// 825B07D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825B07D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B07DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B07E0: 419A0014  beq cr6, 0x825b07f4
	if ctx.cr[6].eq {
	pc = 0x825B07F4; continue 'dispatch;
	}
	// 825B07E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B07E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B07EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B07F0: 4800000C  b 0x825b07fc
	pc = 0x825B07FC; continue 'dispatch;
	// 825B07F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B07F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825B07FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0800: 4199FFB8  bgt cr6, 0x825b07b8
	if ctx.cr[6].gt {
	pc = 0x825B07B8; continue 'dispatch;
	}
	// 825B0804: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B0808: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B080C: 419A0040  beq cr6, 0x825b084c
	if ctx.cr[6].eq {
	pc = 0x825B084C; continue 'dispatch;
	}
	// 825B0810: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0814: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825B0818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B081C: 41990008  bgt cr6, 0x825b0824
	if ctx.cr[6].gt {
	pc = 0x825B0824; continue 'dispatch;
	}
	// 825B0820: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B0824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B082C: 409A0020  bne cr6, 0x825b084c
	if !ctx.cr[6].eq {
	pc = 0x825B084C; continue 'dispatch;
	}
	// 825B0830: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B0834: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B0838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B083C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0840: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0848: 48000020  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
	// 825B084C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0854: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B085C: 4800000C  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
	// 825B0860: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B0864: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B0868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B086C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0870: 419A0058  beq cr6, 0x825b08c8
	if ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0874: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B0878: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B087C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B0880: 48160821  bl 0x827110a0
	ctx.lr = 0x825B0884;
	sub_827110A0(ctx, base);
	// 825B0884: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B0888: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B088C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B0894: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B0898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B089C: 4E800421  bctrl
	ctx.lr = 0x825B08A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B08A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B08A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B08A8: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 825B08AC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B08B0: 4BBE3589  bl 0x82193e38
	ctx.lr = 0x825B08B4;
	sub_82193E38(ctx, base);
	// 825B08B4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825B08B8: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825B08BC: 4BC6451D  bl 0x82214dd8
	ctx.lr = 0x825B08C0;
	sub_82214DD8(ctx, base);
	// 825B08C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B08C4: 4BBFC26D  bl 0x821acb30
	ctx.lr = 0x825B08C8;
	sub_821ACB30(ctx, base);
	// 825B08C8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B08CC: 486F8B90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B08D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B08D0 size=364
    let mut pc: u32 = 0x825B08D0;
    'dispatch: loop {
        match pc {
            0x825B08D0 => {
    //   block [0x825B08D0..0x825B0A3C)
	// 825B08D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B08D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B08D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B08DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B08E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B08E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B08E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B08EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B08F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B08F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B08F8: 995E007C  stb r10, 0x7c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[10].u8 ) };
	// 825B08FC: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B0900: 55285FFE  rlwinm r8, r9, 0xb, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x001FFFFFu64;
	// 825B0904: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0908: 419A00F4  beq cr6, 0x825b09fc
	if ctx.cr[6].eq {
	pc = 0x825B09FC; continue 'dispatch;
	}
	// 825B090C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0910: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0914: 419A0024  beq cr6, 0x825b0938
	if ctx.cr[6].eq {
	pc = 0x825B0938; continue 'dispatch;
	}
	// 825B0918: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 825B091C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0920: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B0924: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B0928: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B092C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B0930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0934: 480000CC  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
	// 825B0938: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B093C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0940: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B0944: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0948: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B094C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0950: 40810054  ble 0x825b09a4
	if !ctx.cr[0].gt {
	pc = 0x825B09A4; continue 'dispatch;
	}
	// 825B0954: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0958: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B095C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0960: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0964: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825B0968: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B096C: 41980008  blt cr6, 0x825b0974
	if ctx.cr[6].lt {
	pc = 0x825B0974; continue 'dispatch;
	}
	// 825B0970: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825B0974: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0978: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B097C: 419A0014  beq cr6, 0x825b0990
	if ctx.cr[6].eq {
	pc = 0x825B0990; continue 'dispatch;
	}
	// 825B0980: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0984: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0988: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B098C: 4800000C  b 0x825b0998
	pc = 0x825B0998; continue 'dispatch;
	// 825B0990: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B0994: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825B0998: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B099C: 4199FFB8  bgt cr6, 0x825b0954
	if ctx.cr[6].gt {
	pc = 0x825B0954; continue 'dispatch;
	}
	// 825B09A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B09A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B09A8: 419A0040  beq cr6, 0x825b09e8
	if ctx.cr[6].eq {
	pc = 0x825B09E8; continue 'dispatch;
	}
	// 825B09AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B09B0: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825B09B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09B8: 41990008  bgt cr6, 0x825b09c0
	if ctx.cr[6].gt {
	pc = 0x825B09C0; continue 'dispatch;
	}
	// 825B09BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B09C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B09C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B09C8: 409A0020  bne cr6, 0x825b09e8
	if !ctx.cr[6].eq {
	pc = 0x825B09E8; continue 'dispatch;
	}
	// 825B09CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B09D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B09D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B09D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B09DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B09E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09E4: 4800001C  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
	// 825B09E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B09EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B09F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B09F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09F8: 48000008  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
	// 825B09FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B0A00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A08: 419A001C  beq cr6, 0x825b0a24
	if ctx.cr[6].eq {
	pc = 0x825B0A24; continue 'dispatch;
	}
	// 825B0A0C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825B0A10: 4BC4EBB9  bl 0x821ff5c8
	ctx.lr = 0x825B0A14;
	sub_821FF5C8(ctx, base);
	// 825B0A14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A1C: 419A0008  beq cr6, 0x825b0a24
	if ctx.cr[6].eq {
	pc = 0x825B0A24; continue 'dispatch;
	}
	// 825B0A20: 9BFE007C  stb r31, 0x7c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[31].u8 ) };
	// 825B0A24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B0A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0A30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B0A34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0A40 size=212
    let mut pc: u32 = 0x825B0A40;
    'dispatch: loop {
        match pc {
            0x825B0A40 => {
    //   block [0x825B0A40..0x825B0B14)
	// 825B0A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0A48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B0A4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B0A50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0A54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B0A58: 480000C1  bl 0x825b0b18
	ctx.lr = 0x825B0A5C;
	sub_825B0B18(ctx, base);
	// 825B0A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B0A60: 419A0098  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0A64: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B0A68: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 825B0A6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0A70: 41980018  blt cr6, 0x825b0a88
	if ctx.cr[6].lt {
	pc = 0x825B0A88; continue 'dispatch;
	}
	// 825B0A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0A78: 4BCE7CC1  bl 0x82298738
	ctx.lr = 0x825B0A7C;
	sub_82298738(ctx, base);
	// 825B0A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B0A80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0A84: 409A0008  bne cr6, 0x825b0a8c
	if !ctx.cr[6].eq {
	pc = 0x825B0A8C; continue 'dispatch;
	}
	// 825B0A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0A8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A94: 419A0064  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0A9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0AA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B0AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0AA8: 4BD08F71  bl 0x822b9a18
	ctx.lr = 0x825B0AAC;
	sub_822B9A18(ctx, base);
	// 825B0AAC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0AB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0AB4: 419A0044  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B0ABC: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0AC0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825B0AC4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0ACC: 419A002C  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AD0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B0AD4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 825B0AD8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B0ADC: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B0AE0: 41820018  beq 0x825b0af8
	if ctx.cr[0].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AE4: 480D75E5  bl 0x826880c8
	ctx.lr = 0x825B0AE8;
	sub_826880C8(ctx, base);
	// 825B0AE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0AEC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0AF0: 480D47B9  bl 0x826852a8
	ctx.lr = 0x825B0AF4;
	sub_826852A8(ctx, base);
	// 825B0AF4: 48000008  b 0x825b0afc
	pc = 0x825B0AFC; continue 'dispatch;
	// 825B0AF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B0AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B0B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B0B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0B18 size=172
    let mut pc: u32 = 0x825B0B18;
    'dispatch: loop {
        match pc {
            0x825B0B18 => {
    //   block [0x825B0B18..0x825B0BC4)
	// 825B0B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0B1C: 486F88ED  bl 0x82ca9408
	ctx.lr = 0x825B0B20;
	sub_82CA93D0(ctx, base);
	// 825B0B20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0B24: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B0B28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B0B2C: 3BA30014  addi r29, r3, 0x14
	ctx.r[29].s64 = ctx.r[3].s64 + 20;
	// 825B0B30: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0B34: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B38: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B0B3C: 419A0008  beq cr6, 0x825b0b44
	if ctx.cr[6].eq {
	pc = 0x825B0B44; continue 'dispatch;
	}
	// 825B0B40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0B44: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B48: 419A0070  beq cr6, 0x825b0bb8
	if ctx.cr[6].eq {
	pc = 0x825B0BB8; continue 'dispatch;
	}
	// 825B0B4C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B54: 409A0008  bne cr6, 0x825b0b5c
	if !ctx.cr[6].eq {
	pc = 0x825B0B5C; continue 'dispatch;
	}
	// 825B0B58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0B5C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B0B60: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825B0B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0B68: 419A0020  beq cr6, 0x825b0b88
	if ctx.cr[6].eq {
	pc = 0x825B0B88; continue 'dispatch;
	}
	// 825B0B6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0B70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0B74: 419A000C  beq cr6, 0x825b0b80
	if ctx.cr[6].eq {
	pc = 0x825B0B80; continue 'dispatch;
	}
	// 825B0B78: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0B7C: 48000010  b 0x825b0b8c
	pc = 0x825B0B8C; continue 'dispatch;
	// 825B0B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0B84: 4BBE32B5  bl 0x82193e38
	ctx.lr = 0x825B0B88;
	sub_82193E38(ctx, base);
	// 825B0B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0B8C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B0B90: 419A001C  beq cr6, 0x825b0bac
	if ctx.cr[6].eq {
	pc = 0x825B0BAC; continue 'dispatch;
	}
	// 825B0B94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B98: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B9C: 409A0008  bne cr6, 0x825b0ba4
	if !ctx.cr[6].eq {
	pc = 0x825B0BA4; continue 'dispatch;
	}
	// 825B0BA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0BA4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0BA8: 4BFFFF8C  b 0x825b0b34
	pc = 0x825B0B34; continue 'dispatch;
	// 825B0BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0BB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B0BB4: 486F88A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 825B0BB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B0BBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B0BC0: 486F8898  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0BC8 size=268
    let mut pc: u32 = 0x825B0BC8;
    'dispatch: loop {
        match pc {
            0x825B0BC8 => {
    //   block [0x825B0BC8..0x825B0CD4)
	// 825B0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0BCC: 486F8839  bl 0x82ca9404
	ctx.lr = 0x825B0BD0;
	sub_82CA93D0(ctx, base);
	// 825B0BD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0BD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B0BD8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B0BDC: 3BA40014  addi r29, r4, 0x14
	ctx.r[29].s64 = ctx.r[4].s64 + 20;
	// 825B0BE0: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825B0BE4: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825B0BE8: 937C000C  stw r27, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 825B0BEC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B0BF0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0BF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0BF8: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B0BFC: 419A0008  beq cr6, 0x825b0c04
	if ctx.cr[6].eq {
	pc = 0x825B0C04; continue 'dispatch;
	}
	// 825B0C00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0C04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0C08: 419A00C0  beq cr6, 0x825b0cc8
	if ctx.cr[6].eq {
	pc = 0x825B0CC8; continue 'dispatch;
	}
	// 825B0C0C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0C10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0C14: 409A0008  bne cr6, 0x825b0c1c
	if !ctx.cr[6].eq {
	pc = 0x825B0C1C; continue 'dispatch;
	}
	// 825B0C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0C1C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B0C20: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825B0C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C28: 419A0030  beq cr6, 0x825b0c58
	if ctx.cr[6].eq {
	pc = 0x825B0C58; continue 'dispatch;
	}
	// 825B0C2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0C30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C34: 419A0054  beq cr6, 0x825b0c88
	if ctx.cr[6].eq {
	pc = 0x825B0C88; continue 'dispatch;
	}
	// 825B0C38: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C40: 419A0018  beq cr6, 0x825b0c58
	if ctx.cr[6].eq {
	pc = 0x825B0C58; continue 'dispatch;
	}
	// 825B0C44: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B0C48: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0C4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0C50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C54: 409A0008  bne cr6, 0x825b0c5c
	if !ctx.cr[6].eq {
	pc = 0x825B0C5C; continue 'dispatch;
	}
	// 825B0C58: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825B0C5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C64: 419A004C  beq cr6, 0x825b0cb0
	if ctx.cr[6].eq {
	pc = 0x825B0CB0; continue 'dispatch;
	}
	// 825B0C68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C70: 419A002C  beq cr6, 0x825b0c9c
	if ctx.cr[6].eq {
	pc = 0x825B0C9C; continue 'dispatch;
	}
	// 825B0C74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0C78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C7C: 419A0018  beq cr6, 0x825b0c94
	if ctx.cr[6].eq {
	pc = 0x825B0C94; continue 'dispatch;
	}
	// 825B0C80: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0C84: 4800001C  b 0x825b0ca0
	pc = 0x825B0CA0; continue 'dispatch;
	// 825B0C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0C8C: 4BBE31AD  bl 0x82193e38
	ctx.lr = 0x825B0C90;
	sub_82193E38(ctx, base);
	// 825B0C90: 4BFFFFC8  b 0x825b0c58
	pc = 0x825B0C58; continue 'dispatch;
	// 825B0C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0C98: 4BBE31A1  bl 0x82193e38
	ctx.lr = 0x825B0C9C;
	sub_82193E38(ctx, base);
	// 825B0C9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825B0CA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B0CA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0CA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B0CAC: 48598AA5  bl 0x82b49750
	ctx.lr = 0x825B0CB0;
	sub_82B49750(ctx, base);
	// 825B0CB0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0CB4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0CB8: 409A0008  bne cr6, 0x825b0cc0
	if !ctx.cr[6].eq {
	pc = 0x825B0CC0; continue 'dispatch;
	}
	// 825B0CBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 825B0CC0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0CC4: 4BFFFF30  b 0x825b0bf4
	pc = 0x825B0BF4; continue 'dispatch;
	// 825B0CC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B0CCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B0CD0: 486F8784  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0CD8 size=284
    let mut pc: u32 = 0x825B0CD8;
    'dispatch: loop {
        match pc {
            0x825B0CD8 => {
    //   block [0x825B0CD8..0x825B0DF4)
	// 825B0CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0CDC: 486F871D  bl 0x82ca93f8
	ctx.lr = 0x825B0CE0;
	sub_82CA93D0(ctx, base);
	// 825B0CE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0CE4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B0CE8: 54B8063E  clrlwi r24, r5, 0x18
	ctx.r[24].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825B0CEC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825B0CF0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B0CF4: 387A0090  addi r3, r26, 0x90
	ctx.r[3].s64 = ctx.r[26].s64 + 144;
	// 825B0CF8: 409A0008  bne cr6, 0x825b0d00
	if !ctx.cr[6].eq {
	pc = 0x825B0D00; continue 'dispatch;
	}
	// 825B0CFC: 387A0080  addi r3, r26, 0x80
	ctx.r[3].s64 = ctx.r[26].s64 + 128;
	// 825B0D00: 4BD69ED9  bl 0x8231abd8
	ctx.lr = 0x825B0D04;
	sub_8231ABD8(ctx, base);
	// 825B0D04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B0D08: 4BEA76B9  bl 0x824583c0
	ctx.lr = 0x825B0D0C;
	sub_824583C0(ctx, base);
	// 825B0D0C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B0D10: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 825B0D14: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 825B0D18: 419800D4  blt cr6, 0x825b0dec
	if ctx.cr[6].lt {
	pc = 0x825B0DEC; continue 'dispatch;
	}
	// 825B0D1C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B0D20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B0D24: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825B0D28: 3BCA7088  addi r30, r10, 0x7088
	ctx.r[30].s64 = ctx.r[10].s64 + 28808;
	// 825B0D2C: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 825B0D30: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B0D34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825B0D38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0D3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B0D40: 419A0054  beq cr6, 0x825b0d94
	if ctx.cr[6].eq {
	pc = 0x825B0D94; continue 'dispatch;
	}
	// 825B0D44: 48001D55  bl 0x825b2a98
	ctx.lr = 0x825B0D48;
	sub_825B2A98(ctx, base);
	// 825B0D48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B0D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0D50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0D54: 4BC7C17D  bl 0x8222ced0
	ctx.lr = 0x825B0D58;
	sub_8222CED0(ctx, base);
	// 825B0D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0D5C: 387A0090  addi r3, r26, 0x90
	ctx.r[3].s64 = ctx.r[26].s64 + 144;
	// 825B0D60: 4BBC44F9  bl 0x82175258
	ctx.lr = 0x825B0D64;
	sub_82175258(ctx, base);
	// 825B0D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0D68: 4BC15A01  bl 0x821c6768
	ctx.lr = 0x825B0D6C;
	sub_821C6768(ctx, base);
	// 825B0D6C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825B0D70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B0D74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0D78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B0D7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0D80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B0D84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0D88: 4082FFE8  bne 0x825b0d70
	if !ctx.cr[0].eq {
	pc = 0x825B0D70; continue 'dispatch;
	}
	// 825B0D8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B0D90: 48000050  b 0x825b0de0
	pc = 0x825B0DE0; continue 'dispatch;
	// 825B0D94: 48001D05  bl 0x825b2a98
	ctx.lr = 0x825B0D98;
	sub_825B2A98(ctx, base);
	// 825B0D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B0D9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B0DA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0DA4: 4BC7C12D  bl 0x8222ced0
	ctx.lr = 0x825B0DA8;
	sub_8222CED0(ctx, base);
	// 825B0DA8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825B0DAC: 387A0080  addi r3, r26, 0x80
	ctx.r[3].s64 = ctx.r[26].s64 + 128;
	// 825B0DB0: 4BBC44A9  bl 0x82175258
	ctx.lr = 0x825B0DB4;
	sub_82175258(ctx, base);
	// 825B0DB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B0DB8: 4BC159B1  bl 0x821c6768
	ctx.lr = 0x825B0DBC;
	sub_821C6768(ctx, base);
	// 825B0DBC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825B0DC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B0DC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0DC8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B0DCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0DD0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B0DD4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0DD8: 4082FFE8  bne 0x825b0dc0
	if !ctx.cr[0].eq {
	pc = 0x825B0DC0; continue 'dispatch;
	}
	// 825B0DDC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825B0DE0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B0DE4: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 825B0DE8: 4099FF48  ble cr6, 0x825b0d30
	if !ctx.cr[6].gt {
	pc = 0x825B0D30; continue 'dispatch;
	}
	// 825B0DEC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B0DF0: 486F8658  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0DF8 size=8
    let mut pc: u32 = 0x825B0DF8;
    'dispatch: loop {
        match pc {
            0x825B0DF8 => {
    //   block [0x825B0DF8..0x825B0E00)
	// 825B0DF8: 806300A0  lwz r3, 0xa0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 825B0DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E00 size=8
    let mut pc: u32 = 0x825B0E00;
    'dispatch: loop {
        match pc {
            0x825B0E00 => {
    //   block [0x825B0E00..0x825B0E08)
	// 825B0E00: 806300A4  lwz r3, 0xa4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 825B0E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E08 size=20
    let mut pc: u32 = 0x825B0E08;
    'dispatch: loop {
        match pc {
            0x825B0E08 => {
    //   block [0x825B0E08..0x825B0E1C)
	// 825B0E08: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0E0C: 908300A0  stw r4, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 825B0E10: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0E14: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825B0E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E20 size=12
    let mut pc: u32 = 0x825B0E20;
    'dispatch: loop {
        match pc {
            0x825B0E20 => {
    //   block [0x825B0E20..0x825B0E2C)
	// 825B0E20: 908300A8  stw r4, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[4].u32 ) };
	// 825B0E24: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825B0E28: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E2C size=68
    let mut pc: u32 = 0x825B0E2C;
    'dispatch: loop {
        match pc {
            0x825B0E2C => {
    //   block [0x825B0E2C..0x825B0E70)
	// 825B0E2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0E30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0E34: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0E38: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825B0E3C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0E40: 419A00F8  beq cr6, 0x825b0f38
	if ctx.cr[6].eq {
		sub_825B0F38(ctx, base);
		return;
	}
	// 825B0E44: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0E48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0E4C: 419A0024  beq cr6, 0x825b0e70
	if ctx.cr[6].eq {
		sub_825B0E70(ctx, base);
		return;
	}
	// 825B0E50: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 825B0E54: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0E58: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0E5C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0E60: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0E64: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0E68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0E6C: 480000D0  b 0x825b0f3c
	sub_825B0F38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E70 size=92
    let mut pc: u32 = 0x825B0E70;
    'dispatch: loop {
        match pc {
            0x825B0E70 => {
    //   block [0x825B0E70..0x825B0ECC)
	// 825B0E70: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0E74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B0E78: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0E7C: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 825B0E80: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0E84: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 825B0E88: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0E8C: 40810054  ble 0x825b0ee0
	if !ctx.cr[0].gt {
		sub_825B0ECC(ctx, base);
		return;
	}
	// 825B0E90: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0E94: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B0E98: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0E9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0EA0: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 825B0EA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B0EA8: 41980008  blt cr6, 0x825b0eb0
	if ctx.cr[6].lt {
	pc = 0x825B0EB0; continue 'dispatch;
	}
	// 825B0EAC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825B0EB0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0EB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0EB8: 419A0014  beq cr6, 0x825b0ecc
	if ctx.cr[6].eq {
		sub_825B0ECC(ctx, base);
		return;
	}
	// 825B0EBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0EC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0EC8: 4800000C  b 0x825b0ed4
	sub_825B0ECC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0ECC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0ECC size=88
    let mut pc: u32 = 0x825B0ECC;
    'dispatch: loop {
        match pc {
            0x825B0ECC => {
    //   block [0x825B0ECC..0x825B0F24)
	// 825B0ECC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B0ED0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825B0ED4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0ED8: 4199FFB8  bgt cr6, 0x825b0e90
	if ctx.cr[6].gt {
		sub_825B0E70(ctx, base);
		return;
	}
	// 825B0EDC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 825B0EE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B0EE4: 419A0040  beq cr6, 0x825b0f24
	if ctx.cr[6].eq {
		sub_825B0F24(ctx, base);
		return;
	}
	// 825B0EE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0EEC: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 825B0EF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0EF4: 41990008  bgt cr6, 0x825b0efc
	if ctx.cr[6].gt {
	pc = 0x825B0EFC; continue 'dispatch;
	}
	// 825B0EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0EFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0F04: 409A0020  bne cr6, 0x825b0f24
	if !ctx.cr[6].eq {
		sub_825B0F24(ctx, base);
		return;
	}
	// 825B0F08: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0F0C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825B0F10: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B0F14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0F1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0F20: 4800001C  b 0x825b0f3c
	sub_825B0F38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F24 size=20
    let mut pc: u32 = 0x825B0F24;
    'dispatch: loop {
        match pc {
            0x825B0F24 => {
    //   block [0x825B0F24..0x825B0F38)
	// 825B0F24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0F28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F2C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0F34: 48000008  b 0x825b0f3c
	sub_825B0F38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F38 size=16
    let mut pc: u32 = 0x825B0F38;
    'dispatch: loop {
        match pc {
            0x825B0F38 => {
    //   block [0x825B0F38..0x825B0F48)
	// 825B0F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0F3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0F44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F48 size=16
    let mut pc: u32 = 0x825B0F48;
    'dispatch: loop {
        match pc {
            0x825B0F48 => {
    //   block [0x825B0F48..0x825B0F58)
	// 825B0F48: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0F4C: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0F50: 916A0110  stw r11, 0x110(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825B0F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F58 size=12
    let mut pc: u32 = 0x825B0F58;
    'dispatch: loop {
        match pc {
            0x825B0F58 => {
    //   block [0x825B0F58..0x825B0F64)
	// 825B0F58: 908300AC  stw r4, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 825B0F5C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825B0F60: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F64 size=68
    let mut pc: u32 = 0x825B0F64;
    'dispatch: loop {
        match pc {
            0x825B0F64 => {
    //   block [0x825B0F64..0x825B0FA8)
	// 825B0F64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0F6C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0F70: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825B0F74: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0F78: 419A00F8  beq cr6, 0x825b1070
	if ctx.cr[6].eq {
		sub_825B1070(ctx, base);
		return;
	}
	// 825B0F7C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0F80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0F84: 419A0024  beq cr6, 0x825b0fa8
	if ctx.cr[6].eq {
		sub_825B0FA8(ctx, base);
		return;
	}
	// 825B0F88: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 825B0F8C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0F90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0F94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0F98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0FA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0FA4: 480000D0  b 0x825b1074
	sub_825B1070(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0FA8 size=92
    let mut pc: u32 = 0x825B0FA8;
    'dispatch: loop {
        match pc {
            0x825B0FA8 => {
    //   block [0x825B0FA8..0x825B1004)
	// 825B0FA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0FAC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B0FB0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0FB4: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 825B0FB8: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0FBC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 825B0FC0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0FC4: 40810054  ble 0x825b1018
	if !ctx.cr[0].gt {
		sub_825B1004(ctx, base);
		return;
	}
	// 825B0FC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0FCC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B0FD0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0FD4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0FD8: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 825B0FDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B0FE0: 41980008  blt cr6, 0x825b0fe8
	if ctx.cr[6].lt {
	pc = 0x825B0FE8; continue 'dispatch;
	}
	// 825B0FE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825B0FE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0FEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0FF0: 419A0014  beq cr6, 0x825b1004
	if ctx.cr[6].eq {
		sub_825B1004(ctx, base);
		return;
	}
	// 825B0FF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0FFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B1000: 4800000C  b 0x825b100c
	sub_825B1004(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


